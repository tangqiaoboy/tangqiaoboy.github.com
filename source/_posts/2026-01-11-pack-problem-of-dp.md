---
title: 背包问题
date: 2026-01-11 22:41:29
tags: cspj
---

## 引言

背包问题是动态规划中的经典问题，也是 GESP 六级必考的知识点。其原理虽然需要花一些时间，但大多数孩子都能掌握，但是到了具体的题目时，因为背包问题变化较多，就不那么容易写出代码来。

本文将试图把背包问题的各种考法都列举出来，帮助大家巩固练习。

## 背包问题

背包问题之所以叫这个名字，是因为其背景故事是：往一个容量有限的背包里面，放入一些物品。每个物品有不同的体积大小，所以会占用相应的背包的容量。物品不能被分割，所以要么整个放入背包中，要么不放入。我们需要找出放入背包的价值最大的方案。

举一个简单的例子，背包容量是 10L：
 - 物品 1：体积 7 L，价值 8
 - 物品 2：体积 5 L，价值 5
 - 物品 3：体积 4 L，价值 4

虽然物品 1 的价值最大，价值/体积(即单位体积的价值)也最大，但是因为放入物品 1 之后，剩余的空间 3L 无法再放入别的物品而浪费掉了。就不如不放物品 1，而放入物品 2 和物品 3 带来的总价值大。

由此我们也能看出，背包问题不能用简单的贪心来解决，而需要用动态规划。

## 解题思路

背包问题的转移方程可以被优化为一维，但为了方便理解，我们先看没有优化的版本。我们定义：
 - 每个元素的体积为 `a[i]`，价值为 `v[i]`。
 - `dp[i][j]` 表示用前 i 个物品，放入容量为 j 的背包时，所能达到的最大价值

那对于第 i 个物品，如果我们已经知道了前面的结果，那么我们有两种选择：
 - 不放入 第 i 个物品，这样 `dp[i][j] = dp[i-1][j]`
 - 放入 第 i 个物品，这样 `dp[i][j] = dp[i-1][j-a[i]] + v[i]`
 
而以上就是状态转移方程，我们在上面两种情况下取最优的情况：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i]] + v[i])` 。

另外我们需要考虑一下初始化的情况，即 `dp[0][1~n]` 应该怎么赋值。因为前 0 个物品什么都没选，那么价值肯定都是 0，所以让它们都等于 0 即可。

将以上逻辑写成代码如下：

```c++
memset(dp, 0, sizeof dp);
for (int i = 1; i <= 3; ++i)
    for (int j = 1; j <= 10; ++j) {
        dp[i][j] = dp[i-1][j];
        if (j-a[i]>=0)
            dp[i][j] = max(dp[i][j], dp[i-1][j-a[i]] + v[i]);
    }
```

在这段代码中，为了保证 `j-a[i]` 的值为正，加了一个 if 来检查，保证没有下标越界的代码。如果下标越界，有可能会读取到随机值，也可能读取到非法地址，造成运行异常（Runtime Error）。

我们再用刚刚的例子来做一下表格演示：背包容量是 10L。
 - 物品 1：体积 7 L，价值 8
 - 物品 2：体积 5 L，价值 5
 - 物品 3：体积 4 L，价值 4

经过转移方程的计算，最终，我们可以填出下面这个二维表格，表格中的每一项都计算出来了用前 i 个物品，体积为 j 时的最优化方案。这也是符合动态规划的最优子结构的特征。

{% img /images/pack-dp.jpg %}

## 01 背包

所谓的 01 背包，就是指物品的数量只有 1 个，只有选与不选两种方案。刚刚的例子就是一个 01 背包的例子。

我们发现 dp[i][j] 只与两个值相关 dp[i-1][j] 和 dp[i-1][j-a[i]]，这样的二维数组利用的效率很低。所以，我们就想到，能不能把第 i 维省略掉，这样可以节省存储空间（但没有节省运算时间）。

压缩后的代码如下：

```c++
memset(dp, 0, sizeof dp);
for (int i = 1; i <= 3; ++i)
    for (int j = 10; j >= a[i]; --j) {
        dp[j] = max(dp[j], dp[j-a[i]] + v[i]);
    }
```

我们注意到，j 的循环方式从正序变成了逆序。之所以要这么操作，读者可以用表格的方式，把正着循环的结果填一下就能明白。

如果 j 不是倒着循环，在一轮 j 的循环过程中，dp[j] 的值会在修改后，再一次被访问到，这样就会使得一个物品实际上已经计算了放入的价值，又被重复计算第二次。

## 完全背包

一个物品被多次重复放入和重复计算价值，其实是我们在完全背包问题中需要的效果。所以，刚刚的代码，如果我们把 j 正序循环，就是完全背包的代码，如下所示：

```c++
memset(dp, 0, sizeof dp);
for (int i = 1; i <= 3; ++i)
    for (int j = a[i]; j <= 10; ++j) {
        dp[j] = max(dp[j], dp[j-a[i]] + v[i]);
    }
```

但是为了方便理解，我们还是把完全背包的非压维代码也一并看一下：

```c++
memset(dp, 0, sizeof dp);
for (int i = 1; i <= 3; ++i)
    for (int j = 1; j <= 10; ++j) {
        dp[i][j] = dp[i-1][j];
        if (j-a[i]>=0) {
            dp[i][j] = max(dp[i][j], dp[i-1][j-a[i]] + v[i]);
            dp[i][j] = max(dp[i][j], dp[i][j-a[i]] + v[i]);
        }
    }
```

因为 `dp[i][j-a[i]] >= dp[i-1][j-a[i]]`，所以以上代码可以省略成：

```c++
memset(dp, 0, sizeof dp);
for (int i = 1; i <= 3; ++i)
    for (int j = 1; j <= 10; ++j) {
        dp[i][j] = dp[i-1][j];
        if (j-a[i]>=0) {
            dp[i][j] = max(dp[i][j], dp[i][j-a[i]] + v[i]);
        }
    }
```

我们可以记住这个写法，因为后面有一些题因为各种情况可能无法压维，就会需要这种写法。

我们还是用刚刚的例子来填写二维表格，背包容量是 10L。物品数量改为无限。
 - 物品 1：体积 7 L，价值 8
 - 物品 2：体积 5 L，价值 5
 - 物品 3：体积 4 L，价值 4

以下是填写出来的值：

{% img /images/pack-dp-2.jpg %}

题目变为完全背包后，答案变了，最优方案变成了放入两个物品 2，得到最大价值 10。

## 多重背包

## 