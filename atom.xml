<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐巧的博客</title>
  
  <subtitle>记录下自己学习的点滴</subtitle>
  <link href="https://blog.devtang.com/atom.xml" rel="self"/>
  
  <link href="https://blog.devtang.com/"/>
  <updated>2025-02-09T15:08:31.242Z</updated>
  <id>https://blog.devtang.com/</id>
  
  <author>
    <name>唐巧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSPJ 教学思考：并查集</title>
    <link href="https://blog.devtang.com/2025/02/09/teaching-notes-of-union-query-set/"/>
    <id>https://blog.devtang.com/2025/02/09/teaching-notes-of-union-query-set/</id>
    <published>2025-02-09T13:20:27.000Z</published>
    <updated>2025-02-09T15:08:31.242Z</updated>
    
    <content type="html"><![CDATA[<p>并查集在引入之前，需要先教会学生集合的概念。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是数学中的一个基本概念，它是由一些确定的、彼此不同的对象所组成的整体。集合有两个特点：</p><ul><li>集合中的元素是互不相同的。</li><li>集合中的元素没有顺序之分。比如集合 {1, 2, 3} 和 {3, 2, 1} 是同一个集合。</li></ul><p>生活中的集合有很多，比如：班级，家庭成员，朋友等等。所以，学生还是比较容易理解的。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li><li>合并（Merge）：合并两个元素所属集合（合并对应的树）</li></ul><p>在教学并查集的时候，画示意图可以很好地让学生理解并查集的操作。</p><h3 id="并查集的初始化"><a href="#并查集的初始化" class="headerlink" title="并查集的初始化"></a>并查集的初始化</h3><p>我们用数组来表示并查集，用数组的值表示当前结点的父亲。如下图所示：</p><img src="/images/uqs-1.jpg" class=""><p>所以，初始化的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[MAXN], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集的查询操作"><a href="#并查集的查询操作" class="headerlink" title="并查集的查询操作"></a>并查集的查询操作</h3><p>并查集在查询时，从初始结点开始，判断自己是不是根结点。根结点的特征是自己是自己的父亲。如果自己不是根结点，则继续递归往上找。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这儿，也顺便引入路径压缩的优化，告诉学生在返回值的时候，如果更新结点，就可以把下图中的长路径“拍扁”，使得下次查询的时候速度更快。</p><img src="/images/uqs-2.jpg" class=""><p>那么如何更新呢？只需要在上面的代码基础上做一点点改动，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]); <span class="comment">// 在返回值之前，更新结点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以简化成一行：<code>return p[a]==a ? a : (p[a] = find(p[a]));</code>。但是教学的时候，还是展开让学生理解清楚后，再提供简化的写法比较好。</p><h3 id="并查集的合并操作"><a href="#并查集的合并操作" class="headerlink" title="并查集的合并操作"></a>并查集的合并操作</h3><img src="/images/uqs-3.jpg" class=""><p>合并的时候，像上图那样，我们把一个结点的根结点的父亲，指向另外一个根结点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以简化成一行：<code>p[find(a)]=find(b);</code>。但是教学的时候，还是展开让学生理解清楚后，再提供简化的写法比较好。</p><h3 id="判断并查集中集合的个数"><a href="#判断并查集中集合的个数" class="headerlink" title="判断并查集中集合的个数"></a>判断并查集中集合的个数</h3><p>因为有一个根结点，就代表有一个集合，所以我们可以数根结点的个数来得到集合的个数。</p><p>根结点的特点是：它的父结点就是自己。相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集的练习题"><a href="#并查集的练习题" class="headerlink" title="并查集的练习题"></a>并查集的练习题</h2><p>完成以上的基础教学，就可以练习了。并查集的考查主要就是两个：</p><ul><li>判断两点是否联通</li><li>计算连通块（集合）的个数</li></ul><p>以下是基础的练习题目。</p><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚</a></td><td>基础题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a></td><td>基础题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1892">P1892 团伙</a></td><td>提高题，需要用反集</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3144">P3144 Closing the Farm S</a></td><td>USACO 16 OPEN</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1197">P1197 星球大战</a></td><td>JSOI 2008</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2024">P2024 食物链</a></td><td>NOI 2001</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1196">P1196 银河英雄传说</a></td><td>NOI 2002</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="反集"><a href="#反集" class="headerlink" title="反集"></a>反集</h2><p>当题目中引入了敌人关系，并且定义：“敌人的敌人是朋友”的时候，就可以用反集来求解了。</p><p>反集专门用于表示敌对关系，并且敌人的敌人是朋友。反集的思路是再构造一个集合（称之为反集），然后将“敌人”关系通过原集和反集表示出来。</p><p>我们看个例子：</p><p>比如假设有 3 个元素，1, 2, 3。我们称他们的反集元素分别为 <code>1&#39;</code> , <code>2&#39;</code>,  <code>3&#39;</code>; 分别表示 1, 2, 3 的敌人。</p><p>这个时候，如果 1 和 2 是敌人，则：</p><ul><li>因为 <code>1&#39;</code> 也是 1 的敌人, 所以 <code>1&#39;</code> 和 2 是朋友</li><li>因为 <code>2&#39;</code> 也是 2 的敌人, 所以 <code>2&#39;</code> 也是 1 的朋友</li></ul><p>结果表示如下：</p><img src="/images/uqs-4.jpg" class=""><p>这个时候，如果 2 和 3 是敌人，则</p><ul><li>2 和 3&#96; 是朋友</li><li>3 和 2&#96; 是朋友</li></ul><p>结果表示如下：</p><img src="/images/uqs-5.jpg" class=""><p>我们可以看到，在这种操作下，1 和 3 自然就在一个集合中了（成为朋友了）。</p><p>以上逻辑在并查集中如何实现呢？我们将并查集的下标扩展一倍，用 <code>n+1</code> ~ <code>2n</code> 来表示反集元素。其中，元素 a 的反集是 a+n。 </p><p>这个时候，如果 a 与 b 是敌人，则需要在并查集中做如下操作：</p><ul><li>因为 a 与 b 是敌人，所以 a 与 b+n 就是朋友，需要 <code>merge(a, b+n)</code>;</li><li>因为 a 与 b 是敌人，所以 b 与 a+n 就是朋友，需要 <code>merge(b, a+n)</code>;</li></ul><p><a href="https://www.luogu.com.cn/problem/P1892">P1892 团伙</a> 是反集的典型例题，可以拿此题练习。</p><p>需要特别注意的是，因为此题需要判断集合数量，所以需要让 <code>1~n</code> 的元素当根结点，涉及合并操作的时候，不要让 <code>1~n</code> 的元素当反集元素的孩子。关健代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> fb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="comment">// b 有可能是反集，所以始终让 fb 在合并的时候当子结点</span></span><br><span class="line">    p[fb] = fa; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1892">P1892 团伙</a> 的完整参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">2010</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> fb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="comment">// b 有可能是反集，所以始终让 fb 在合并的时候当子结点</span></span><br><span class="line">    p[fb] = fa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2010</span>; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, ch, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">merge</span>(a, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">merge</span>(a, b+n);</span><br><span class="line">            <span class="built_in">merge</span>(b, a+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="练习题参考代码"><a href="#练习题参考代码" class="headerlink" title="练习题参考代码"></a>练习题参考代码</h2><h3 id="P1551-亲戚"><a href="#P1551-亲戚" class="headerlink" title="P1551 亲戚"></a>P1551 亲戚</h3><p>标准的并查集，没有陷阱。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> p[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5010</span>; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">merge</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1536-村村通"><a href="#P1536-村村通" class="headerlink" title="P1536 村村通"></a>P1536 村村通</h3><p>用并查集操作，然后数一下一共有多少个不同的集合，答案就是 <code>集合数-1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">1010</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">merge</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (pa == i) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>并查集还有更多的优化，比如在合并的时候，把高度小的树往高度大的树上合并，以尽可能减少树的高度，这样可以使得未来查询的时候效率更高。因为大多时候用不上，所以这些知识可以放在课后阅读中让学生自行掌握。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">https://oi-wiki.org/ds/dsu/</a></li><li><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></li><li><a href="https://oj.youyue.info/fs/storage?target=RFa/1nCebcqlz7_l1hL8tESDa.pdf&expire=1739031007409&secret=cfb465cf9abed5a203ea3c85a5718f03">反集</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;并查集在引入之前，需要先教会学生集合的概念。&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;集合是数学中的一个基本概念，它是由一些确定的、彼此不同的对象所组成的整体。集合有</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：二分查找</title>
    <link href="https://blog.devtang.com/2025/01/25/teaching-notes-of-binary-search/"/>
    <id>https://blog.devtang.com/2025/01/25/teaching-notes-of-binary-search/</id>
    <published>2025-01-25T14:19:44.000Z</published>
    <updated>2025-02-07T13:29:46.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二分查找的基础逻辑很简单：我们小时候都玩过猜数字游戏，心里想一个数字（ 数字范围是 1-100），让对方猜，如果没猜对，就只告诉对方猜大了还是小了，看看最快几次能猜到。</p><p>这个游戏的最佳策略就是二分。先猜 50，如果大了，就猜 25。这样最多 7 次就可以猜到答案。</p><h2 id="基础模版"><a href="#基础模版" class="headerlink" title="基础模版"></a>基础模版</h2><p>对于猜数字这个游戏来说，二分的模版最简单的就是如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="type">int</span> left, right, mid, ans;</span><br><span class="line">left = <span class="number">1</span>;</span><br><span class="line">right = n;</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (v[mid] &gt; a) &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[mid] &lt; a) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = mid;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码需要注意的有以下几点：</p><ul><li>查徇范围是 <code>[left, right]</code>，即 left 和 right 都是闭区间。</li><li>循环条件是<code>left &lt;= right</code>，即当 <code>left == right</code>时，还需要进行一次测试。</li><li><code>mid = left + (right-left) / 2</code>其实等价于 <code>mid = (left + right) / 2</code>只是后者可能超界，用前者可以避免。</li></ul><p>这种思路其实比较简单，写起来基本上不会犯错。但是，如果有多个目标值时，我们可能要多次更新 <code>ans</code> 变量。</p><p><a href="https://www.luogu.com.cn/problem/P2249">P2249 查找</a>就是一道例题，此题需要找到目标值第一次出现的位置，如果用上面的模版，我们需要多次更新 <code>ans</code>，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n, m, a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> left, right, mid, ans;</span><br><span class="line">        left = <span class="number">1</span>;</span><br><span class="line">        right = n;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v[mid] &gt; a) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[mid] &lt; a) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到，则比较 ans 的值，更新它</span></span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">-1</span> || ans &gt; mid) ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一种模版"><a href="#另一种模版" class="headerlink" title="另一种模版"></a>另一种模版</h2><p>除了刚刚的模版外，我们还可以用另外一种写法来写二分：我们用 <code>[l,r)</code>来表示目标查找区间，注意这里是左闭右开的区间。然后，我们不停地尝试缩小这个区间：</p><ul><li>情况 1：当目标值比 mid 值大的时候，新区间在 <code>[mid+1, r)</code></li><li>情况 2：当目标值比 mid 值小的时候，新区间在 <code>[l, mid)</code></li><li>情况 3：当目标值与 mid 值相等的时候，因为我们要找最小值，所以新区间在 <code>[l, mid)</code>。</li></ul><p>以上的情况 2 和情况 3 是可以合并的。结果就是只需要写一个 if 就可以了，核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有同学可能会问：如果只有一个值相等，并且在 mid 位置，那以上做法不是把结果就跳出区间了？其实这种情况下，l 的值会一步步右移，最后的循环结束的结果会是 <code>[mid,mid)</code>。所以我们还是可以从循环结束的 l 值中读到目标值。</p><p>对于这种写法，我们的二分判断会少很多，只需要最后判断一下 l 的值是否是目标值，即可知道是否查找成功。</p><p>以下是参考代码（从以前的 32 行缩短为 24 行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n, m, a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> l, r, mid;</span><br><span class="line">        l = <span class="number">1</span>; r = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; n+<span class="number">1</span> &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果记不清楚，就分开写：</p><ul><li>如果猜对了但要找最小值，就更新 r</li><li>如果 mid 大了，则答案在 mid 左侧，就更新 r</li><li>如果 mid 小了，则答案在 mid 右侧，就更新 l</li></ul><p>另外，以上这种代码其实是不停在<code>[l,mid)</code> 和 <code>[mid+1, r)</code>之间做选择，所以：</p><ul><li><code>l</code> 只会更新成 <code>mid+1</code></li><li><code>r</code> 只会更新成 <code>mid</code></li></ul><p>最后答案如果有，则在 <code>l</code> 位置，当然 <code>l</code> 位置也可能不是答案：</p><ul><li>如果目标极小，没找到，则 <code>l</code> 位置为查找的范围最左侧下标</li><li>如果目标极大，没找到，则 <code>l</code> 位置为最初的 r 的位置（那个位置是最后一个元素的下一个位置，直接读取会数组越界）</li></ul><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><p>其实上面那个写法就是 C++ STL 里面的 <code>lower_bound</code> 函数，所以我们可以直接用 <code>lower_bound</code> 函数来实现 <a href="https://www.luogu.com.cn/problem/P2249">P2249 题</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n, m, a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">lower_bound</span>(v+<span class="number">1</span>, v+n+<span class="number">1</span>, a) - v;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; n+<span class="number">1</span> &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>lower_bound</code> 在 <code>[first,last)</code> 中的前闭后开区间进行二分查找，返回大于或等于目标值的第一个元素位置。如果所有元素都小于目标值，则返回 last 的位置。</p><p>这种函数行为初看很奇怪，因为它：</p><ul><li>当找到目标值时，它返回达找到的值的第一个位置</li><li>当没有目标值时，它返回第一个大于目标值的位置</li><li>当所有元素都小于目标值时，它返回 last 的位置</li></ul><p>这实际上就是它的内部实现所致（可以理解为这种写法的side effect），它内部实现就是我们刚刚提到的写法，所以才会这么返回目标值。</p><p>如果我们想把查找结果转换成数组下标，只需要让它减去数组首地址即可，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx = <span class="built_in">lower_bound</span>(v, v+n, a) - v;</span><br></pre></td></tr></table></figure><h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h2><p>除了 <code>lower_bound</code> 函数之外，C++还提供了 <code>upper_bound</code> 函数。<code>lower_bound</code> 在 <code>[first, last)</code> 中的前闭后开区间进行二分查找，返回第一个比目标值大的位置。如果没找到，则返回 last 的位置。</p><p><code>upper_bound</code> 的内部实现逻辑是：</p><ul><li><strong>如果猜对了但要找最大值，就更新 l</strong></li><li>如果 mid 大了，则答案在 mid 左侧，就更新 r</li><li>如果 mid 小了，则答案在 mid 右侧，就更新 l</li></ul><p>为了方便对比，我把 <code>lower_bound</code> 的逻辑再写一下：</p><ul><li><strong>如果猜对了但要找最小值，就更新 r</strong></li><li>如果 mid 大了，则答案在 mid 左侧，就更新 r</li><li>如果 mid 小了，则答案在 mid 右侧，就更新 l</li></ul><p>你看出来了吗？只是第一个更新的逻辑不一样。所以，其实两者的代码很像，我自己分别写了二者的一个实现，大家可以对比看一下，实际上二者实现部分只差了一个字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果目标值等于或者小于 mid，则 r = m</span></span><br><span class="line"><span class="comment">// 如果目标值大于 mid，则 l = m+1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    l = <span class="number">0</span>; r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; v[m]) l = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 mid 值小于等于目标，就 l=m+1</span></span><br><span class="line"><span class="comment">// 如果 mid 值大于目标，就 r=m</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    l = <span class="number">0</span>; r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= v[m]) l = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们 <code>upper_bound</code> 考虑几种情况：</p><ul><li>如果目标值极小，那么一直就更新 r，结果返回的就是首地址，为正确值。</li><li>如果目标值极大，那么一直就更新 l，结果返回的就是 last。</li></ul><p>所以 <code>upper_bound</code> 如果没找到，会返回 last。</p><p>我们再看 <code>lower_bound</code></p><ul><li>如果目标值极小，那么一直就更新 r，结果返回的就是首地址，为第一个大于目标值的地址。</li><li>如果目标值极大，那么一直就更新 l，结果返回的就是 last。</li></ul><p>所以，其实这两个函数在没找到目标值的情况下，都有可能返回首地址或末地址的。只是对于 <code>upper_bound</code> 函数来说，首地址是有意义的。</p><p>而 <code>lower_bound</code> 函数返回的首地址怎么说呢？有点像 side effect。很少有需求是求这个地址，所以很多时候要特殊处理一下，就像我们刚刚例题里面又判断了一下一样(如下所示)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &lt; n+<span class="number">1</span> &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>二分不但能用于查找数值，还可以用来暴力尝试答案。因为即便是 0-20 亿这么大的范围的猜数字游戏，也只需要 30 多次就可以猜到，所以如果某个问题可以像猜大小一样，每次获得答案是大了还是小了，就可以用二分的办法来“二分答案”。</p><p>对于二分答案一类的题目，最常见的题目描述特征是求某某值的<strong>最大值最小</strong>，或者<strong>最小值最大</strong>。这个特征可以作为我们选择二分解题的小提示。我们在练习题目 <a href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a> 和 <a href="https://www.luogu.com.cn/problem/P1182">P1182 数列分段 Section II</a> 中就可以看到这种提示。</p><h2 id="教学和练习题目"><a href="#教学和练习题目" class="headerlink" title="教学和练习题目"></a>教学和练习题目</h2><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2249">P2249 查找</a></td><td>可用 lower_bound 函数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对</a></td><td>也可使用 STL map</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1873">P1873 砍树</a></td><td>二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3853">P3853 路标设置</a></td><td>天津省选，二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1678">P1678 烦恼的高考志愿</a></td><td>二分查找，可用 upper_bound 函数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2440">P2440 木材加工</a></td><td>二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a></td><td>二分答案，NOIP2015 提高组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1182">P1182 数列分段 Section II</a></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="P3853-路标设置"><a href="#P3853-路标设置" class="headerlink" title="P3853 路标设置"></a>P3853 路标设置</h3><p>二分答案+判定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L, N, K;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]-v[i<span class="number">-1</span>] &gt; mid)&#123;</span><br><span class="line">            ans += (v[i]-v[i<span class="number">-1</span>]<span class="number">-1</span>)/mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=K)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;L, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left, right, mid, ans = INT_MAX;</span><br><span class="line">    left = <span class="number">1</span>;</span><br><span class="line">    right = L;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找。</span></span><br><span class="line"><span class="comment"> * 用 upper_bound 找到第一个大的位置 idx，然后取 idx 和 idx - 1, 分别试一下。</span></span><br><span class="line"><span class="comment"> * idx 可能是 0 或者末尾（idx == m），要特殊处理一下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n, vm[<span class="number">100010</span>], a;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, vm+i);</span><br><span class="line">    <span class="built_in">sort</span>(vm, vm+m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">upper_bound</span>(vm, vm+m, a)-vm;</span><br><span class="line">        <span class="keyword">if</span> (idx != m) diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(vm[idx]-a));</span><br><span class="line">        <span class="keyword">if</span> (idx - <span class="number">1</span> &gt;=<span class="number">0</span> ) diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(vm[idx<span class="number">-1</span>]-a));</span><br><span class="line">        ans += diff;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i]/mid;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = (<span class="type">int</span>)<span class="number">1e8</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h3><p>二分答案：用 mid 去试跳，如果间距小于 mid，则去掉那个石头，如果去掉个数超过 k 个，则失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ed, n, k;</span><br><span class="line"><span class="type">int</span> v[<span class="number">50010</span>];</span><br><span class="line"><span class="comment">// 用 mid 去试跳，如果间距小于 mid，则去掉那个石头，如果去掉个数超过 k 个，则失败。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> dis = v[i] - v[i<span class="number">-1</span>] + diff;</span><br><span class="line">        <span class="keyword">if</span> (dis &lt; mid) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            diff = dis;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            diff = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;ed, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">    v[n+<span class="number">1</span>] = ed; <span class="comment">// 终点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = ed;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mid);</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1182-数列分段-Section-II"><a href="#P1182-数列分段-Section-II" class="headerlink" title="P1182 数列分段 Section II"></a>P1182 数列分段 Section II</h3><p>二分答案。对目标答案每 mid 分一段，如果分出来的段数 &lt;&#x3D; m 即为真。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, v[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">        <span class="keyword">if</span> (v[i] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            cnt = <span class="number">0</span>; </span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">0</span>) tot++;</span><br><span class="line">    <span class="keyword">if</span> (tot &lt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, mid);</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="教学思考"><a href="#教学思考" class="headerlink" title="教学思考"></a>教学思考</h2><p>因为<code>lower_bound</code> 和 <code>upper_bound</code>的写法相比传统写法还是有点复杂，在教学中还是适合用最初的那个易懂的版本。易懂的版本虽然执行起来多几次判断，但是在比赛中这一点多的时间并不影响整体的时间复杂度，所以不会因此扣分。同时，简单易于理解的代码，在学习和解题时，也更加不容易犯错。</p><p>待学生理解基础二分的写法后，再把系统的实现拿出来，作为增强的补充练习题目。这么补充练习并不是要学生一定掌握，而是借由实现系统的函数，学会在比赛中调用 C++ 的 <code>lower_bound</code> 和 <code>upper_bound</code> 库函数，这样可以加速解题的速度。</p><p>二分答案的思路很好理解，但是实际写起来还是很容易晕，所以需要多加练习。另外利用题目特征来获得提示，帮助自己快速解题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>lower_bound</code> 和 <code>upper_bound</code> 都是极简二分查找的 C++ 内部实现。</li><li>因为它们都有 side effect，所以在查找目标不存在时，均可能返回首地址和末地址（取决于目标是极小还是极大）。<ul><li>因为以上的 side effect，所以我们给 <code>lower_bound</code> 赋予了额外的功能：返回第一个大于或等于目标值的位置；如果不存在返回 last。</li><li><code>upper_bound</code> 在目标值极小的时候，返回首地址（正好符合要求）；在目标值极大的时候，返回 last。</li></ul></li><li>因为 <code>lower_bound</code> 有可能返回的不是目标值，所以最后要判断一下。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;二分查找的基础逻辑很简单：我们小时候都玩过猜数字游戏，心里想一个数字（ 数字范围是 1-100），让对方猜，如果没猜对，就只告诉对方猜大了还</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：动态规划</title>
    <link href="https://blog.devtang.com/2025/01/05/teaching-notes-of-dp/"/>
    <id>https://blog.devtang.com/2025/01/05/teaching-notes-of-dp/</id>
    <published>2025-01-05T10:03:48.000Z</published>
    <updated>2025-01-20T14:49:51.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>动态规划是 CSPJ 拉分的关键知识点。</p><p>之所以这样，是因为动态规划不像 DFS、BFS、二分那样有固定的模版格式。学生要在动态规划问题上融汇贯通，需要花费大量的练习，也需要足够的聪明。</p><p>笔者自己在高中阶段，也是在动态规划问题上困扰许久。我自己的学习经验是：动态规划还是需要多练，练够 100 道题目，才能够熟悉动态规划的各种变型。之后在比赛中看到新的题目，才会有点似曾相识的感觉，进一步思考出状态转移方程。</p><p>所以，我打算写 100 道动态规划方程的题解，希望有志攻破此难关的学生和家长一起加油！</p><h1 id="动态规划解题的核心问题"><a href="#动态规划解题的核心问题" class="headerlink" title="动态规划解题的核心问题"></a>动态规划解题的核心问题</h1><p>虽然动态规划没有模版可以套，但是动态规划有三个核心问题：</p><ul><li>状态的定义</li><li>状态转移方程</li><li>初始状态的设置</li></ul><p>一般思考动态规划就是思考以上三个问题，这三个问题解决了，动态规划的程序也可以写出来了。</p><h1 id="教学题目"><a href="#教学题目" class="headerlink" title="教学题目"></a>教学题目</h1><p>推荐的教学题目如下：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2842">P2842 纸币问题 1</a></td><td>基础 DP，记忆化搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a></td><td>基础 DP，记忆化搜索 【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2840">P2840 纸币问题 2</a></td><td>基础 DP</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2834">P2834 纸币问题 3</a></td><td>基础 DP，有多处可优化的点</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a></td><td>NOIP2005 普及组第三题。01 背包问题。【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药</a></td><td>完全背包问题。【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2196">P2196 挖地雷</a></td><td>NOIP1996 提高组第三题。涉及输出路径技巧。</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1434">P1434 滑雪</a></td><td>上海市省队选拔 2002</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a></td><td>最大子段和。【经典 DP】</td></tr><tr><td></td><td></td></tr></tbody></table><p>适合的作业：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a></td><td>记忆化搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2871">P2871 Charm Bracelet S</a></td><td>USACO 07 DEC，01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日</a></td><td>01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1002">P1002 过河卒</a></td><td>NOIP2002 普及组，记忆化搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1049">P1049 装箱问题</a></td><td>NOIP2001 普及组，01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1064">P1064 金明的预算方案</a></td><td>01 背包变型，NOIP2006 提高组第二题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1077">P1077 摆花</a></td><td>NOIP2012 普及组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a></td><td>与摆花一题类似</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2392">P2392 考前临时抱佛脚</a></td><td>01 背包变型</td></tr></tbody></table><h1 id="例题代码"><a href="#例题代码" class="headerlink" title="例题代码"></a>例题代码</h1><h2 id="P2842-纸币问题-1"><a href="#P2842-纸币问题-1" class="headerlink" title="P2842 纸币问题 1"></a>P2842 纸币问题 1</h2><p>此题可以带着孩子一步步推导和演进。具体步骤如下。</p><p>先引导孩子用最暴力的 DFS 的方式来做此题，建立基础的解题框架，虽然会超时，但是也帮助我们后面引导孩子学会记忆化搜索。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS，超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pt&gt;=v[i]) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, <span class="built_in">dfs</span>(pt-v[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">dfs</span>(w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的代码，通过分析，发现大部分的超时是因为有重复的计算过程。以下是一个以 10,5,1 为例的示意：</p><img src="/images/dp-1.jpg" class=""><p>所以，我们可以将重复计算的过程保存下来，以后再次需要计算的时候，直接读取保存的结果即可。在此思想下，我们只需要在上面改动三行，即可将超时的程序改为通过。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS，记忆化搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">10010</span>]; <span class="comment">// 改动 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r[pt] != <span class="number">0</span>) <span class="keyword">return</span> r[pt]; <span class="comment">// 改动 2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pt&gt;=v[i]) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, <span class="built_in">dfs</span>(pt-v[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (r[pt]=ret); <span class="comment">// 改动 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">dfs</span>(w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了以上两段代码的尝试，我们能够发现：</p><ul><li>dfs(pt) 只与 dfs( 0 ~ pt-1) 有关,与 dfs(pt+1~w)无关。</li><li>如果我们知道了 dfs(0~pt)，就可以推出 dfs(pt+1)</li></ul><p>那么，我们就可以思考，如果我们用 dp[i] 来表示钱币总额为 i 的结果数。那么，dp[i] 的计算过程（即：状态转移方程）为：<code>dp[i] = min( dp[i-v[j]] )+1</code>，其中<code>j=0~N</code>。</p><p>这样，我们就可以引导学生写出第一个动态规划程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i] = min( dp[i-v[j]] )  + 1 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>], dp[<span class="number">11000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=w ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-v[j]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-v[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1216-数字三角形"><a href="#P1216-数字三角形" class="headerlink" title="P1216 数字三角形"></a>P1216 数字三角形</h2><p><a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a>同样可以用记忆化搜索引入。先写记忆化搜索的代码有助于我们理解动态规划的状态转移方程。</p><p>搜索的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS，记忆化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> r[x][y];</span><br><span class="line">    <span class="keyword">if</span> (x == n<span class="number">-1</span>) <span class="keyword">return</span> </span><br><span class="line">        r[x][y] = v[x][y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> </span><br><span class="line">        r[x][y] = v[x][y]+<span class="built_in">max</span>(<span class="built_in">dfs</span>(x+<span class="number">1</span>,y), <span class="built_in">dfs</span>(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由搜索代码可知，每一个位置的最价结果由它下面两个结点的最价结果构成。于是，我们可以构造出状态转移方程：<code>dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1])</code></p><p>另外，我们可以引导学生：上层的依赖于下层的数据，那应该怎么推导呢？让学生想到用倒着 for 循环的方式来从下往上推导。</p><p>最后，我们再引导学生构建一下初始值。由此，我们建立起动态规划解题的三个核心问题：</p><ul><li>状态的定义</li><li>状态转移方程</li><li>初始状态的设置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划：</span></span><br><span class="line"><span class="comment"> * dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        dp[n<span class="number">-1</span>][j] = v[n<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            dp[i][j] = v[i][j] + <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P2840-纸币问题-2"><a href="#P2840-纸币问题-2" class="headerlink" title="P2840 纸币问题 2"></a>P2840 纸币问题 2</h2><p>状态转移方程为：<code>dp[i] = sum(dp[i- v[j]]), j = 0~N</code>，结果需要每次模 1000000007。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w ; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= v[j]) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i-v[j]])%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2834-纸币问题-3"><a href="#P2834-纸币问题-3" class="headerlink" title="P2834 纸币问题 3"></a>P2834 纸币问题 3</h2><p>此题不能像之前的题目那样，用金钱数为阶段。因为此题是计算的组合数，所以 1,5 和 5,1 是一种答案。如果以金钱数为阶段，就无法方便将这种重复计算的排除掉。</p><p>那么，以什么为阶段，可以保证每个阶段可以基于过去的阶段推导出来？可以用不同的钱币种类为阶段！</p><p>接下来就是思考这种情况下的状态转移方程。可以得出，状态转移方程如下：</p><ul><li><code>dp[i][j]</code> 表示用前 i 种钱币组成金额 j 的组合数</li><li><code>dp[i][j] = dp[i-1][j-v[i]] + dp[i-1][j - v[i]*2] + …. dp[i-1][j-v[i]*n]; (j &gt;= v[i]*n)</code></li><li>初始状态：<code>dp[1][0] = 1; dp[1][v[1]] = 1; dp[1][v[1]*2] = 1;</code></li></ul><p>参考程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">1010</span>][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">// dp[0][0] = 1; dp[0][v[0]] = 1;dp[0][v[0]*2] = 1;….</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1</span>;</span><br><span class="line">        cnt += v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j - cnt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i][j]+dp[i<span class="number">-1</span>][j-cnt]) % MOD;</span><br><span class="line">                cnt += v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n<span class="number">-1</span>][w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有另外一种状态转移方程，把阶段分为没有用过 a，和至少用过一张 a。</p><p>这样的话，状态转移方程优化为：<code>dp[i][j] = dp[i-1][j] + dp[i][j-v[i]]</code></p><p>这样，代码的复杂度进一步降低，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">1010</span>][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1</span>;</span><br><span class="line">        cnt += v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-v[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j]+dp[i][j-v[i]])% MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n<span class="number">-1</span>][w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还可以进一步简化，因为 dp[i] 那一层算完之后 dp[i-1] 层就没有用了。有没有可能我们将 dp[i]层和 dp[i-1]都合并在一起呢？</p><p>答案是可以的。我们可以将关键代码进一步简化如下，把 dp 改成一个一维数组。状态转移方程变为了:<code>dp[j] = dp[j] + dp[j-v[i]]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= w) &#123;</span><br><span class="line">        dp[cnt] = <span class="number">1</span>;</span><br><span class="line">        cnt += v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-v[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = (dp[j]+dp[j-v[i]]) % MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j]; <span class="comment">//此行可以删除，但为了教学示意保留</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h2><p><a href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a>这题是经典的 01 背包问题。为了方便教学，我们还是从最简单的动态规划思路开始推导。</p><p>我们把每个草药是一个阶段，这样：</p><ul><li><code>dp[i][j]</code> 表示前 i 个草药，花费 j 时间可以得到的最大价值</li><li>状态转移方程为：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]])</code></li></ul><p>这样写出来的参考程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">dp[i][j] 表示前 i 个草药，花费 j 时间可以得到的最大价值</span></span><br><span class="line"><span class="comment">dp[i][j] = max(dp[i-1][j], dp[i-1][j-t[i]] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, M;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>], v[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;T, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, t+i, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下标从 1 开始，这样不用考虑 i-1 越界了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= T; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - t[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j - t[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[M][T]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上一题一样，通过分析，我们发现 dp[i][j] 中的 i 一层可以优化掉，变成只有 dp[j]。</p><p>这样，状态转移方程被优化成：<code>dp[j]=max(dp[j],dp[j-t[i]]+v[i])</code>。</p><p>但是，因为每一个草药只能用一次，如果我们正着循环 j 的话，会出现多次使用第 i 个草药的情况。所以，我们倒着进行递推，就可以避免这种情况。</p><p>最终实现的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">dp[j] 花费 j 时间可以得到的最大价值</span></span><br><span class="line"><span class="comment">dp[j] = max(dp[j], dp[j-t[i]])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, M;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>], v[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;T, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, t+i, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = T; j &gt;= t[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - t[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[T]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2196-挖地雷"><a href="#P2196-挖地雷" class="headerlink" title="P2196 挖地雷"></a>P2196 挖地雷</h2><p><a href="https://www.luogu.com.cn/problem/P2196">P2196 挖地雷</a> 是 NOIP1996 提高组第三题。这道题的解法有点类似于<a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a>。</p><p>但是，这道题更难的是：它需要我们输出路径。</p><p>我们先说状态转移方程：</p><ul><li>dp[i] 表示第 i 个地窖能够挖到的最多地雷数。</li><li>w[i] 表示第 i 个地窖的地雷数。</li><li>转移方程：<code>dp[i] = max(dp[i+1~N]中能够与 dp[i] 连通的地窖) + w[i]</code> 与 <code>dp[i] = w[i]</code>中的较大者。</li></ul><p>我们再说说如何输出路径。因为计算之后 dp 数组中保存了每个结点能够挖的最大地雷数。所以，我们从答案 dp[ans]开始，找哪一个地窖与当前相连，同时值又等于 dp[ans] - w[ans],则表示那个地窖是下一个点。</p><p>参数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i&gt;=<span class="number">1</span>; --i) &#123;</span><br><span class="line">        dp[i] = w[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][j]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[ans] &lt; dp[i]) ans = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = dp[ans];</span><br><span class="line">    <span class="type">int</span> idx = ans;</span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, idx);</span><br><span class="line">        cnt -= w[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx + <span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[idx][i] &amp;&amp; cnt == dp[i]) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, dp[ans]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1434-滑雪"><a href="#P1434-滑雪" class="headerlink" title="P1434 滑雪"></a>P1434 滑雪</h2><p>这道题的麻烦点是如何定义状态转移的阶段，因为没有明显的阶段。</p><p>可以考虑的办法是：将点按高度排序，这样从高度低的点开始，往高的点做状态转移。</p><p>所以：</p><ul><li>定义：dp[i][j] 表示从 (i,j) 这个位置开始滑的最长坡。</li><li>转移方程：<ul><li><code>dp[x][y] = max(dp[x&#39;][y&#39;])+1</code></li><li><code>dp[x&#39;][y&#39;]</code> 为上下左右相邻并且高度更低的点</li></ul></li><li>初始化：无</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, h;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _h) &#123;</span><br><span class="line">        x = _x; y = _y; h = _h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node a, Node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.h &lt; b.h;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r, &amp;c);</span><br><span class="line">    v.<span class="built_in">reserve</span>(r*c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tu[i][j]);</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(i, j, tu[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r*c; ++i) &#123;</span><br><span class="line">        Node node = v[i];</span><br><span class="line">        <span class="type">int</span> x = node.x;</span><br><span class="line">        <span class="type">int</span> y = node.y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> tox = x + movex[j];</span><br><span class="line">        <span class="type">int</span> toy = y + movey[j];</span><br><span class="line">        <span class="keyword">if</span> (tox &gt;=<span class="number">0</span> &amp;&amp; tox &lt;r &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;c &amp;&amp;</span><br><span class="line">        node.h &gt; tu[tox][toy]) &#123;</span><br><span class="line">        dp[x][y] = <span class="built_in">max</span>(dp[x][y], dp[tox][toy]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[x][y] += <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[x][y]);</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dp[%d][%d]=%d\n&quot;</span>, x, y, dp[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题更容易想到的写法还是记忆化搜索：对每一个点作为开始点进行一次 DFS，同时在进行递归调用的时候，如果当前点处理过，则返回上次的结果。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS, 记忆化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> rem[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rem[x][y] != <span class="number">0</span>) <span class="keyword">return</span> rem[x][y];</span><br><span class="line">    <span class="type">int</span> mm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tox = x + movex[i];</span><br><span class="line">        <span class="type">int</span> toy = y + movey[i];</span><br><span class="line">        <span class="keyword">if</span> (tox &gt;=<span class="number">0</span> &amp;&amp; tox &lt;r &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;c &amp;&amp;</span><br><span class="line">        tu[x][y] &gt; tu[tox][toy]) &#123;</span><br><span class="line">            mm = <span class="built_in">max</span>(mm, <span class="built_in">dfs</span>(tox, toy));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (rem[x][y] = mm + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tu[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1115-最大子段和"><a href="#P1115-最大子段和" class="headerlink" title="P1115 最大子段和"></a>P1115 最大子段和</h2><p><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a> 是最经典的一类动态规划问题。思路如下：</p><ul><li>dp[i] 表示包含 i 这个数，并且以 i 结尾的最大子段和。</li><li>状态转移方程：<ul><li>如果 dp[i-1] 为负数，那么 <code>dp[i] = v[i]</code></li><li>如果 dp[i-1] 为正数，那么 <code>dp[i] = dp[i-1]+v[i]</code></li></ul></li></ul><p>因为 dp[i] 在转移方程上只与 dp[i-1]相关，所以它最终结构上被可以被化简成类似贪心的策略，即：</p><ul><li>用一个变量记录当前的累加值，如果当前累加值为负数，则重新计算。</li><li>在累加过程中随时判断，记录最大的累加值为最终答案。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">200100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h1><h2 id="P4017-最大食物链计数"><a href="#P4017-最大食物链计数" class="headerlink" title="P4017 最大食物链计数"></a>P4017 最大食物链计数</h2><p><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a>最佳的做法是做记忆化的搜索。</p><p>记录下出度为 0 的结点，从这些结点开始去寻找，把各种可能的路径加总。同时在 DFS 的时候，记录下搜索的结果。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记忆化搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 80112002</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line"><span class="type">int</span> r[<span class="number">5010</span>], out[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[a] != <span class="number">-1</span>) <span class="keyword">return</span> r[a];</span><br><span class="line">    <span class="comment">// 如果是头部，算一种情况</span></span><br><span class="line">    <span class="keyword">if</span> (v[a].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> (r[a]=<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不是头部，则求和</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[a].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cnt = (cnt + <span class="built_in">dfs</span>(v[a][i])) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[a] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    v.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        v[a].<span class="built_in">push_back</span>(b); <span class="comment">// a 被 b 吃</span></span><br><span class="line">        out[b]++; <span class="comment">// b 的出度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果 i 出度为 0，就表示只能被吃，为底部</span></span><br><span class="line">        <span class="keyword">if</span> (out[i] == <span class="number">0</span>) &#123; </span><br><span class="line">            ans += <span class="built_in">dfs</span>(i);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2871-Charm-Bracelet-S"><a href="#P2871-Charm-Bracelet-S" class="headerlink" title="P2871 Charm Bracelet S"></a>P2871 Charm Bracelet S</h2><p><a href="https://www.luogu.com.cn/problem/P2871">P2871 Charm Bracelet S</a> 是最最标准的 01 背包问题。可以作为基础练习。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[<span class="number">3500</span>], v[<span class="number">3500</span>], dp[<span class="number">14000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, w+i, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=w[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1802-5-倍经验日"><a href="#P1802-5-倍经验日" class="headerlink" title="P1802 5 倍经验日"></a>P1802 5 倍经验日</h2><p>经典的 01 背包问题：</p><ul><li>dp[i] 表示 i 容量可以获得的最大的经验值增量。</li><li>w[i] 表示第 i 个药的数量。</li><li>t[i] 表示第 i 个药贡献的经验值增量。</li></ul><p>状态转移方程：<code>dp[j] = max(dp[j], dp[j-w[i]]+t[i])</code>。</p><p>需要注意答案最大超过了 int，需要用 long long。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>], w[<span class="number">1010</span>], t[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> base = <span class="number">0</span>, n, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        base += a;</span><br><span class="line">        t[i] = b-a;</span><br><span class="line">        w[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=x; j&gt;=<span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-w[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i]]+t[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大结果为 5*1e9，需要用 long long</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">5LL</span>*(dp[x] + base));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1002-过河卒"><a href="#P1002-过河卒" class="headerlink" title="P1002 过河卒"></a>P1002 过河卒</h2><p><a href="https://www.luogu.com.cn/problem/P1002">P1002 过河卒</a>此题是标准的记忆化搜索。有两个陷阱：</p><ul><li>马所在的位置也不能走。</li><li>long long。</li></ul><p>相关代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记忆化搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bx, by, hx, hy;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> r[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">block</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="built_in">abs</span>(x-hx)*<span class="built_in">abs</span>(y-hy);</span><br><span class="line">    <span class="keyword">return</span> (v == <span class="number">2</span> || x==hx &amp;&amp; y == hy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;bx || y&gt;by) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == bx &amp;&amp; y == by) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r[x][y]!=<span class="number">-1</span>) <span class="keyword">return</span> r[x][y];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">block</span>(x,y)) <span class="keyword">return</span> r[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">dfs</span>(x+<span class="number">1</span>,y) + <span class="built_in">dfs</span>(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r[x][y] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">    cin &gt;&gt; bx &gt;&gt; by &gt;&gt; hx &gt;&gt; hy;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1064-金明的预算方案"><a href="#P1064-金明的预算方案" class="headerlink" title="P1064 金明的预算方案"></a>P1064 金明的预算方案</h2><p><a href="https://www.luogu.com.cn/problem/P1064">P1064 金明的预算方案</a> 是一道 01 背包的变型题。题目增加了附件的概念，初看起来没法下手，但是题目增加了一个限制条件：附件最多只有 2 个。</p><p>所以，我们可以将 01 背包的“选或不选”两种情况扩充成以下 5 种情况：</p><ul><li>不选</li><li>选主件，不选附件</li><li>选主件 + 附件 1</li><li>选主件 + 附件 2</li><li>选主件 + 附件 1 + 附件 2</li></ul><p>然后就可以用 01 背包来实现该动态规划了。我们把每种物品的费用当作背包的体积，把每种物品的<code>价格*权重</code>当作价值。</p><p>转移方程是：<code>dp[i]=max(dp[i], 5 种物品选择情况)</code>，每种选择情况下，<code>dp[i]=max(dp[i], dp[i-该选择下的花费]+该选择下的收益) </code>。</p><p>另外，需要注意，输入数据的编号可能不按顺序提供，有以下这种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100 3</span><br><span class="line">1000 5 3</span><br><span class="line">10 5 3</span><br><span class="line">50 2 0</span><br></pre></td></tr></table></figure><p>以下是参考程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;Node&gt; va;</span><br><span class="line">vector&lt;vector&lt;Node&gt; &gt; vb;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">40000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateDP</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i-m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i-m] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    va.<span class="built_in">resize</span>(m);</span><br><span class="line">    vb.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        Node node;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;node.m, &amp;node.w, &amp;node.t);</span><br><span class="line">        node.w = node.w*node.m; </span><br><span class="line">        va[i] = node;</span><br><span class="line">        <span class="keyword">if</span> (node.t != <span class="number">0</span>) &#123;</span><br><span class="line">            vb[node.t - <span class="number">1</span>].<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="comment">// 只处理主件，附件与主体一并处理</span></span><br><span class="line">        <span class="keyword">if</span> (va[i].t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// 选主件，不选附件</span></span><br><span class="line">                <span class="built_in">updateDP</span>(j, va[i].m,va[i].w);</span><br><span class="line">                <span class="comment">// 选主件+附件 1</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">0</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">0</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j, money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选主件+附件 2</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">1</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">1</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j , money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选主件+附件 1+附件 2</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">0</span>].m + vb[i][<span class="number">1</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">0</span>].w + vb[i][<span class="number">1</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j, money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1077-摆花"><a href="#P1077-摆花" class="headerlink" title="P1077 摆花"></a>P1077 摆花</h2><p><a href="https://www.luogu.com.cn/problem/P1077">P1077 摆花</a> 一题是 NOIP2012 普及组的第三题。</p><ul><li><code>dp[i][j]</code> 表示前 i 种花，摆在前 j 个位置上的种数。</li></ul><p>状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] 不放第 i 种花</span><br><span class="line">         + dp[i-1][j-1] 放 1 个第 i 种花</span><br><span class="line">         + dp[i-1][j-2] 放 2 个第 i 种花</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>这道题的难点：没有想到 <code>dp[0][0]=1</code>。因为后面推导的时候，<br><code>dp[i-1][j-k]</code> 中 <code>j==k</code> 的时候，也是一种可能的情况，要统计进来。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= a[i]; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-k];</span><br><span class="line">                    dp[i][j] %= <span class="number">1000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1164-小A点菜"><a href="#P1164-小A点菜" class="headerlink" title="P1164 小A点菜"></a>P1164 小A点菜</h2><p><a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a>一题阶段比较明显。每一道菜点不点是一个明显阶段。所以：</p><ul><li><code>dp[i][j]</code>表示前 i 道菜，用 j 的价格，能够点的方案数</li></ul><p>对于每道菜，有点或不点两种方案，所以：</p><ul><li>转移方程：<code>dp[i][j] = dp[i-1][j]+dp[i-1][j-a[i]]</code></li></ul><p>由于 i 阶段只与 i-1 阶段相关，所以可以把阶段压缩掉，只留一维。最后压缩后的方案是：</p><ul><li><code>dp[j]</code> 表示用 j 的价格可以点到的点的种数</li><li>初始条件 <code>dp[0] = 1</code>，因为这样才可以把后面的结果递推出来</li><li><code>dp[j] = dp[j] + dp[j-a[i]]</code></li></ul><p>因为和 01 背包类似的原因，压缩后需要倒着用 for 循环，否则每道菜就用了不止一次了。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=a[i]; --j) &#123;</span><br><span class="line">            dp[j] += dp[j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2392-考前临时抱佛脚"><a href="#P2392-考前临时抱佛脚" class="headerlink" title="P2392 考前临时抱佛脚"></a>P2392 考前临时抱佛脚</h2><p><a href="https://www.luogu.com.cn/problem/P2392">P2392 考前临时抱佛脚</a> 此题可以用动态规划，也可以用搜索，因为每科只有最多 20 个题目，所以搜索空间最大是 2^20 等于约 100 万。</p><p>以下是搜索的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>], v[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> ans, tot, ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsAns</span><span class="params">(<span class="type">int</span> pt, <span class="type">int</span> n, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">max</span>(cnt, tot-cnt);</span><br><span class="line">        ret = <span class="built_in">min</span>(ret, tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfsAns</span>(pt+<span class="number">1</span>, n, cnt);</span><br><span class="line">    <span class="built_in">dfsAns</span>(pt+<span class="number">1</span>, n, cnt+v[pt]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, s, s+<span class="number">1</span>, s+<span class="number">2</span>, s+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+j);</span><br><span class="line">            tot += v[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ret = tot;</span><br><span class="line">        <span class="built_in">dfsAns</span>(<span class="number">0</span>, s[i], <span class="number">0</span>);</span><br><span class="line">        ans += ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用动态规划解题时，此题可以把每次复习看作一次 01 背包的选择。每道题的价值和成本相同。背包的目标是尽可能接近 sum&#x2F;2，因为sum 最大值为 <code>20*60 = 1200</code>，所以背包大小最大是 600。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">610</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpAns</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=v[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">max</span>(dp[m], cnt - dp[m]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, s, s+<span class="number">1</span>, s+<span class="number">2</span>, s+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+j);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">dpAns</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;动态规划是 CSPJ 拉分的关键知识点。&lt;/p&gt;
&lt;p&gt;之所以这样，是因为动态规划不像 DFS、BFS、二分那样有固定的模版格式。学生要在动</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：贪心算法</title>
    <link href="https://blog.devtang.com/2025/01/05/cspj-notes-of-greedy-algorithm/"/>
    <id>https://blog.devtang.com/2025/01/05/cspj-notes-of-greedy-algorithm/</id>
    <published>2025-01-05T02:28:04.000Z</published>
    <updated>2025-01-05T06:22:58.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>贪心算法讲起来容易，就是问题求解的每一步，都用一个局部最佳的策略，如果能够证明局部最佳的策略最终能够保证全局最佳，则可以用贪心算法。</p><p>在实际 CSPJ 比赛中，我们不用严谨的求解和证明，只需要尝试做一些反例，如果反例中找不到问题，就可以先用贪心求解。毕竟比赛中时间的权重因素比较高。</p><p>在教学中，我们先通过简单的题目让学生理解贪心的概念。之后就可以逐步增加难度，让学生意识到，写出贪心可能容易，但是想到贪心这种解法在比赛中并不那么显而易见。</p><p>贪心通常伴随着排序，所以对 STL 的 <code>sort</code> 以及 <code>priority_queue</code> 的熟练应用也是快速解决贪心题目的必备基础，在学习相关题目的时候，可以重点加强巩固相关知识点。</p><h2 id="2、sort-函数"><a href="#2、sort-函数" class="headerlink" title="2、sort 函数"></a>2、sort 函数</h2><p>sort 函数内部使用快速排序实现，时间复杂度为 <code>O(N*log(N))</code>。对于数据规模为 10 万左右的题目，出题人有可能是希望你用这个时间复杂度来解题的，所以可以留意一下是否需要排序。</p><p>对于普通类型，STL 自带了 <code>greater&lt;T&gt;</code>和<code>less&lt;T&gt;</code> 两个比较器，以下是相关代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sort</span>(v, v+n, greater&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure><p>sort 函数通常和自定义的结构体排序搭配使用，以下是相关代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (Person a, Person b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person v[<span class="number">1100</span>];</span><br><span class="line"><span class="comment">// 使用时直接用 sort</span></span><br><span class="line"><span class="built_in">sort</span>(v, v+n);</span><br></pre></td></tr></table></figure><h2 id="3、教学题目"><a href="#3、教学题目" class="headerlink" title="3、教学题目"></a>3、教学题目</h2><p>推荐的教学题目如下：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2240">P2240 部分背包问题</a></td><td>较简单的一道贪心题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1223">P1223 排队接水</a></td><td>贪心进阶</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1803">P1803 凌乱的yyy</a></td><td>贪心进阶</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P5019">P5019 铺设道路</a></td><td>NOIP2018 提高组真题</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="4、例题代码"><a href="#4、例题代码" class="headerlink" title="4、例题代码"></a>4、例题代码</h2><h3 id="P2240-部分背包问题"><a href="#P2240-部分背包问题" class="headerlink" title="P2240 部分背包问题"></a>P2240 部分背包问题</h3><p><a href="https://www.luogu.com.cn/problem/P2240">P2240 部分背包问题</a> 是较简单的一道贪心题。唯一的陷阱是，学过动态规划的同学可能误以为这个是背包问题。但是在教学中，贪心算法的学习比动态规划更早，所以不会有这个误解。</p><p>此题的解题思路是：将金币按单位重量的价值排序，如果能放则放；放不了，则分割放部分。</p><p>我们定义了一个结构体，结构体中的 <code>double p</code>用于保存单位重量的价值。在排序的时候，按 p 的大小来由大到小排序。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Gold</span> &#123;</span><br><span class="line"><span class="type">int</span> w, v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Gold a, Gold b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.p &gt; b.p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line">Gold v[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i].w, &amp;v[i].v);</span><br><span class="line">v[i].p = v[i].v*<span class="number">1.0</span> / v[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v, v+n);</span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (t&gt;=v[i].w) &#123;</span><br><span class="line">ans += v[i].v;</span><br><span class="line">t -= v[i].w;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans += v[i].p * t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1223-排队接水"><a href="#P1223-排队接水" class="headerlink" title="P1223 排队接水"></a>P1223 排队接水</h3><p><a href="https://www.luogu.com.cn/problem/P1223">P1223 排队接水</a> 此题的难度是需要推导出贪心的策略。具体推导过程如下：</p><img src="/images/greedy-1.jpg" class=""><p>由以上推导，我们只需要将打水时间按从小到大排序，然后加总时间即可。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Person a, Person b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Person v[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">v[i].idx = i+<span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; v[i].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v, v+n);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i].idx);</span><br><span class="line">cnt += v[i].v * (n-i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%.2f\n&quot;</span>, cnt*<span class="number">1.0</span>/n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1803-凌乱的yyy"><a href="#P1803-凌乱的yyy" class="headerlink" title="P1803 凌乱的yyy"></a>P1803 凌乱的yyy</h3><p>此题有两种贪心的思路，分别是：</p><ul><li>按开始时间排序贪心</li><li>按结束时间排序贪心</li></ul><h4 id="按开始时间排序贪心"><a href="#按开始时间排序贪心" class="headerlink" title="按开始时间排序贪心"></a>按开始时间排序贪心</h4><p>此贪心的方法如下：</p><ul><li><p>左端点排序（小的在前），左端点相同的，按右端点排序(小的在前）</p></li><li><p>比较当前区间和下一区间，如果下一区间与当前区间没有相交，则由于我们是按左端点排序的，后面的都不会相交，直接选择当前区间；否则这两个区间显然必须抛弃一个，由于我们是按左端点排序的，后面的区间左端点都是大于它们的，因此这两个的左端点已经没有意义了，为了留出更多的空间，留下右端点靠左的那一个即可。</p></li></ul><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按开始时间排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Line a, Line b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.left != b.left) <span class="keyword">return</span> a.left &lt; b.left;</span><br><span class="line"><span class="keyword">return</span> a.right &lt; b.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line">Line v[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i].left, &amp;v[i].right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v, v+n);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> border = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i].left &gt;= border) &#123;</span><br><span class="line">ans++;</span><br><span class="line">border = v[i].right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">border = <span class="built_in">min</span>(border, v[i].right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按结束时间排序贪心"><a href="#按结束时间排序贪心" class="headerlink" title="按结束时间排序贪心"></a>按结束时间排序贪心</h4><p>此贪心的方法如下：</p><ul><li>右端点排序（小的在前），右端点相同的，按左端点排序(大的在前）</li></ul><p>这种贪心的思路是：对于每一个结束时间，如果能排（开始时间在上一个结束时间之后），就尽量安排。如果不能排，则尝试下一个结束时间。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按结束时间排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Line a, Line b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.right != b.right) <span class="keyword">return</span> a.right &lt; b.right;</span><br><span class="line"><span class="keyword">return</span> a.left &lt; b.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line">Line v[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i].left, &amp;v[i].right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v, v+n);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> border = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (border &lt;= v[i].left) &#123;</span><br><span class="line">ans++;</span><br><span class="line">border = v[i].right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5019-铺设道路"><a href="#P5019-铺设道路" class="headerlink" title="P5019 铺设道路"></a>P5019 铺设道路</h3><p><a href="https://www.luogu.com.cn/problem/P5019">P5019 铺设道路</a>是 NOIP2018 提高组真题。之所以作为提高组题目，是因为很难想到这种贪心策略，不过一旦想清楚，写起来是很简单的。</p><p>贪心策略是：</p><ul><li>第一个坑直接填满</li><li>从第二坑开始，考虑能不能被左边顺带给填上。</li><li>如果第二个坑比第一个坑小，肯定就顺带填上了。不需要任何成本。</li><li>如果第二个坑比第一个坑大，那么就只能顺带填一部分，多出来的差额，需要额外的填补。</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">&#125;</span><br><span class="line">ans = v[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i]&gt;v[i<span class="number">-1</span>]) &#123;</span><br><span class="line">ans += v[i] - v[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h2&gt;&lt;p&gt;贪心算法讲起来容易，就是问题求解的每一步，都用一个局部最佳的策略，如果能够证明局部最佳的策略最终能够保证全局最佳，则可以用贪</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>2024 年个人总结</title>
    <link href="https://blog.devtang.com/2025/01/01/2024-summary/"/>
    <id>https://blog.devtang.com/2025/01/01/2024-summary/</id>
    <published>2025-01-01T02:41:17.000Z</published>
    <updated>2025-02-14T12:15:05.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工作"><a href="#一、工作" class="headerlink" title="一、工作"></a>一、工作</h2><h3 id="财务视角"><a href="#财务视角" class="headerlink" title="财务视角"></a>财务视角</h3><p>2024 年从财务视角，业务整体有不小的进步。</p><p>23 年虽然业务增长不错，但是整体有将将近千万的亏损，而 24 年整体的赢利是上千万的。所以业务整体健康度更高。当然，因为我们严卡利润率，我们的营收规模在 2024 年基本上没有什么增长，还是在 2 个亿左右。希望 2025 年有所增长。</p><p>海外业务在收缩为一人之后，也有不小的起色。我们在韩国还是找到了一条基于 coupang 全拖管的立足之地，可以基于这个基本盘开始做增长。虽然小，但是不至于每个月担心巨大的亏损，所以能睡得着觉。</p><h3 id="产品视角"><a href="#产品视角" class="headerlink" title="产品视角"></a>产品视角</h3><p>分产品来说，2024 年我们没有交付什么成功的新产品。虽然我们在年初上线了英语闪卡机，下半年上线了斑马拼音机 G2，但是这两款产品都没能上规模。不管是达人还是直播间，这两款产品都运营得比较艰难。</p><!--我对英语闪卡机的归因是：同质化竞品较多，差异化不足。市面上同质化的产品通常定价在 80 左右，我们的定价是 299，还是远超它们。另外，我们虽然主打的是纯英语的闪卡机，但是这种差异化，不足以支撑这么高的定价。我对斑马拼音机 G2 的归因是：插卡形式差异化虽然足够，但是体验的提升不可直观察觉，只有真正使用后才可能体会到，这使得高昂的成本并没有转化成产品销售时的竞争力。另外，拼音机的上线时间有点晚，接近秋季开学了，很多家长反馈说已经买过了，对我们的销量也有不小的影响。思维机在 2024 年上线了以下题卡： - S0 级别的题卡（1 季度），有效推动了思维机向 2-3 岁人群的渗透。这部分的成交占比接近 40%。我们也发现一个现象：越是低龄孩子的家长，越喜欢这种没有屏幕的学习产品。 - 故宫主题题卡（2 季度）。故宫主题题卡较为失败。一是上线时间晚，错过了暑期高峰。二是成本高于预期，比较难做赠品。 - 鲨鱼宝宝题卡（3 季度）。鲨鱼宝宝题卡在自播间成为主要的选购组套。 - 音乐主题题卡（4 季度）。音乐主题题卡本想尝试与思维机单独售卖，结果发现没有渠道愿意主推。### 团队视角产品团队在推品方面还是面临不小挑战，团队提创新方案的能力还需要培养。营销团队逐步在完成我的 -1 层级搭建，桔子和丹丹都有一点点进步。--><h3 id="斑马童书"><a href="#斑马童书" class="headerlink" title="斑马童书"></a>斑马童书</h3><p>年底还有一个大的变化，就是我开始负责斑马童书。</p><p>童书是一个市场比玩教具小，同时竞争更加激烈的品类。但是对我来说，能够学习一个新的品类的玩法，也是一种成长，所以我还是很愿意投入精力在里面，看看能不能深耕出一些结果。</p><h2 id="二、读书和写作"><a href="#二、读书和写作" class="headerlink" title="二、读书和写作"></a>二、读书和写作</h2><p>24 年一共读了 10 本书，以下是读书笔记：</p><ul><li><a href="/2024/12/22/xiaomi-development-notes/">极致性价比 - 读《小米创业思考》</a></li><li><a href="/2024/11/17/wave-coming/">颠覆技术的发展 - 读《浪潮将至》</a></li><li><a href="/2024/10/27/notes-from-duan-yong-ping/">本分 - 读《段永平投资回答录》</a></li><li><a href="/2024/09/17/talking-with-xibei/">西贝创始人贾国龙的成与败 - 读《折腾不止》</a></li><li><a href="/2024/06/23/pricing-strategy/">要利润的定价 - 读《定价制胜》</a></li><li><a href="/2024/06/29/history-of-1870-2010/">读《蹒跚前行 1870～2010 经济史》</a></li><li><a href="/2024/05/15/ever-living-fire/">人单合一 - 读《永恒的活火》</a></li><li><a href="/2024/03/26/marketing-management-book-summary/">如何卖货 - 读《营销管理》</a></li><li><a href="/2024/02/17/xiaomasong-notes-2/">小马宋的营销总结(2) - 读《卖货真相》</a></li><li><a href="/2024/02/09/xiaomasong-notes-1/">小马宋的营销总结(1) - 读《营销笔记》</a></li></ul><p>写作方面，整理了以下文章：</p><ul><li><a href="/2024/01/29/target-mapping-situations/">《上下同欲的几种情况》</a>, 我思考清楚了与上级下级的关系，写了此文。</li><li><a href="/2024/03/08/thinking-about-private-group/">《关于私域的思考》</a>，因为工作涉及私域售卖，总结了私域的特点。</li><li><a href="/2024/09/01/living-selling-101/">《如何在抖音直播卖货》</a>，一篇科普文章。</li><li><a href="/2024/09/06/problem-solving-structure/">《第一性原理思考：解决问题的通用框架》</a> ，该文章是我今年在公众号的爆文，7 万阅读量。该文以及该文的 <a href="/2024/09/19/thinking-pattens/">《续篇》</a> 对我梳理自己的工作也有不小的帮助。</li></ul><p>今年还写了一篇涉及农夫山泉的文章<a href="/2024/03/19/talk-about-nongfu-spring/">《替农夫山泉说句话》</a>，整个过程对我的帮助也很大，让我理解了情绪的力量。虽然当时争议很大，但事后看来，我的观点是对的，这也让我很开心。</p><h2 id="三、爱好"><a href="#三、爱好" class="headerlink" title="三、爱好"></a>三、爱好</h2><p>今年开始系统性将 CSPJ 培训作为自己的爱好，我打算把这作为自己退休后的生活内容。因为目标在 20 年之后，所以我也开始慢慢总结自己在信息学竞赛上的经验，共分享了以下几篇文章：</p><ul><li><a href="/2024/09/17/cspj-introduction/">五分钟弄懂 CSP-J</a></li><li><a href="/2024/11/07/teach-notes-of-for-loop/">CSPJ 教学思考：for 循环</a></li><li><a href="/2024/12/15/bfs-teaching-notes/">CSPJ 教学思考：宽度优先搜索</a></li></ul><p>除了爱好外，今年还做了一些事情来悦己：</p><ul><li>买了一台极米 Z7X 高亮版投影仪，在床上看投屏的感受很好。</li><li>买了一台 M3 的 MacBook Air，在家用电脑的幸福感直线上升。</li><li>买了一部荣耀 Magic V3 折叠屏。在工作中看文档效率，以及读书的体验提升明显。</li><li>买了一台 Insta 360 拇指相机。发现拍的时候很爽，但剪辑视频累死人。</li><li>双 11 给家里的猫买了自动喂食器和自动喂水器。再也不用每天惦记着毛孩子的吃喝问题了。不过喂食器买完有点后悔，应该买带摄像头的，这样就可以知道有没有吃完。</li></ul><p>今年也买了一些软件：</p><ul><li>Sublime Text，花了 99 美元。平时写博客和 CSPJ 代码都用它。</li><li>Longshot，花了大概 100 RMB。可以支持长截图。</li><li>Bartender 5，MacBook 的刘海屏下，没这个显示不了太多状态栏的东西。</li></ul><h2 id="四、理财"><a href="#四、理财" class="headerlink" title="四、理财"></a>四、理财</h2><p>今年理财在贯彻自己年初目标上执行得还可以。</p><ul><li><p>年初定下来的定投目标，执行比较顺利。513500 算是一个很不错的 QDII 标的，唯一的缺点就是综合管理费是 0.91% </p></li><li><p>年初还想在合适的时候赎回指数增强产品，这个也在年底做了。之前持有了三年的金锝和九坤的 500 指数增强，发现不同的产品增强的成绩差很多，能差 10% 以上。</p></li><li><p>赎回了元盛 CTA。元盛给我的理解是：它能够在经济上行和下行的时候，都能捕捉到套利机会。但是元盛近两年的收益都是负的，我无法理解为什么这两年都没有机会。和管理团队的沟通机会也不是很好，所以赎回了。</p></li></ul><p>今年整体港股和 A 股都有不错的收益。A 股整体有 19.05% 的收益。</p><img src="/images/2024-profit-a.jpg" class=""><p>港股里面：</p><ul><li>腾讯 417，+11%</li><li>恒生高股息 23.9，+4%</li><li>波司登 3.88，+18%</li><li>海底捞 15.9，+27%</li><li>伟易达 52.8，-2.9%</li></ul><p>今年在理财上也有更多的思考和成长。比如：</p><ul><li>不懂不碰。以前是没那么遵守的，今年会更加严格。我也因此卖出了茅台。</li><li>再平衡。以前没有严格做，在建平上吃了大亏，建平曾经有 100% 的收益，那个时候没有做再平衡，心理上贪多，还是自己能力不够，今年开始认真做这个事情。</li></ul><h2 id="五、24-年的目标回顾"><a href="#五、24-年的目标回顾" class="headerlink" title="五、24 年的目标回顾"></a>五、24 年的目标回顾</h2><ul><li>工作：<ul><li>销售：搭建好销售团队，带好团队的核心成员。培养有共同价值观和长久共事意愿的同事。这一点有一些进展，团队成员今年有一些流动，我觉得是好的。</li><li>产品：推进硬件产品的创新尝试。今年没什么有效的落地，不算很好。</li></ul></li><li>理财：<ul><li>定投少量标普 500，建立初始仓位。今年做得不错。</li><li>在合适的时候减少 A 股的指数增强仓位。今年做得不错。</li></ul></li><li>个人：<ul><li>读 6 本书。完成了，最后读了 9 本。</li><li>很久没出国了，想抽空去一趟加拿大。没能完成。</li><li>每月游泳一次。完成了。</li><li>积极乐观。今年马马虎虎吧。</li></ul></li></ul><h2 id="六、25-年的目标"><a href="#六、25-年的目标" class="headerlink" title="六、25 年的目标"></a>六、25 年的目标</h2><ul><li>工作：硬件稳中有增，童书赢亏打正。带好童书业务。</li><li>理财：做好配置，找到能拿 10 年的标的，并能坚定持有。</li><li>个人：读 6 本书。CSPJ 教学继续累进。</li></ul><h2 id="七、个人-Milestone"><a href="#七、个人-Milestone" class="headerlink" title="七、个人 Milestone"></a>七、个人 Milestone</h2><ul><li>硬件业务利润过千万</li><li>开始负责童书售卖业务</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工作&quot;&gt;&lt;a href=&quot;#一、工作&quot; class=&quot;headerlink&quot; title=&quot;一、工作&quot;&gt;&lt;/a&gt;一、工作&lt;/h2&gt;&lt;h3 id=&quot;财务视角&quot;&gt;&lt;a href=&quot;#财务视角&quot; class=&quot;headerlink&quot; title=&quot;财务视角&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="anniversary" scheme="https://blog.devtang.com/tags/anniversary/"/>
    
  </entry>
  
  <entry>
    <title>极致性价比 - 读《小米创业思考》</title>
    <link href="https://blog.devtang.com/2024/12/22/xiaomi-development-notes/"/>
    <id>https://blog.devtang.com/2024/12/22/xiaomi-development-notes/</id>
    <published>2024-12-22T14:37:53.000Z</published>
    <updated>2024-12-24T01:15:11.530Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/xiaomi-thinking.jpg" class=""><p>其实我以前一直不理解雷军。</p><p>原因一是我在猿辅导工作，我们做的产品都是追求创新和高品质。因为成本不低，所以我们的产品定价不那么便宜。像我们公司的学练机、月子中心、咖啡、月龄盒，以及我负责的斑马玩教具，说实话定价在行业都是比较高的。</p><p>原因二是我比较欣赏的人，不管是公司内部的同事，还是公司外部的一些人，都对 “性价比” 这个词表现出不喜欢。这种不喜欢主要是站在商业角度，这种模式做起来太辛苦，太容易失败。</p><p>原因三是我自己曾负责过一款基于微信传播的英语学习产品。在这个产品失败前，我们尝试过极致的低价，但是最后并没有带来同等回报的增长，所以我知道，低价并不好做。</p><p>最近读了根据雷军口述整理出来的《小米创业思考》，终于有那么一点点理解雷军要做什么了。</p><p>以下是一些感悟。</p><h2 id="雷军的-“极致性价比”-逻辑"><a href="#雷军的-“极致性价比”-逻辑" class="headerlink" title="雷军的 “极致性价比” 逻辑"></a>雷军的 “极致性价比” 逻辑</h2><p>雷军的 “极致性价比” 的想法来自 Costco，他在采访中说，一个在中国国内卖几千块钱的新秀丽的行李箱，在 Costco 只需要几百块钱。同时，雷军是一个有比较多社会责任感的企业家，他希望在互联网时代，大家可以用厚道的价格买到极致体验的东西，于是，小米成了他这个理想的实践地。</p><p>企业的存在，首先是因为有社会价值，即用户需求。首先因为用户需要某种服务，才会有相应的企业存在。在用户需求的基础下，企业才会有自己的经营使命和战略，战略应该围绕着自己的社会价值，去更好地满足自己的社会价值，这样的企业才能活得更久。</p><p>小米运用 “极致性价比” 逻辑，选择了一个极度差异化的经营模式，这种模式下：</p><ul><li>小米的产品具备独特的价值：性价比高。</li><li>小米的产品总成本领先：因为量大。</li><li>小米的竞争对手难以模仿。因为这种模式太难生存了。</li></ul><p>所以，小米其实是选了一条几乎没有人，也几乎没有人走成功的路。</p><p>所以，了解完小米的逻辑之后，我理解了雷军。其实常见的经营模式雷军都知道，也都理解，但是雷军就是想走一条不一样的路。同时他也认为这条路虽然难，但是对于开创者的回报巨大。</p><h2 id="小米如何完成-“不可能三角”"><a href="#小米如何完成-“不可能三角”" class="headerlink" title="小米如何完成 “不可能三角”"></a>小米如何完成 “不可能三角”</h2><p>小米这种模式，需要同时做到三点：产品好、价格低，以及要有合理的利润（也就是股东回报），雷军称之为 “不可能三角”。那他是如何完成的呢？</p><ul><li><p>产品好。雷军要求团队只做高端和创新的产品，即便是做充电宝，也是将原本用在笔记本电脑上的铝外壳做到了充电宝中。除了产品好外，小米在打造新品时，首先考量的第一要素是，产品是否具备“明天属性”。“明天属性”是指代表先进趋势的体验，而且这种体验是用户一旦用过就不想放手的。比如用户一旦用了智能手机，就再也不想用非智能手机了。</p></li><li><p>价格低。雷军相信厚道的定价会带来规模效应，所以，他的很多产品是贴着成本价来定的。首款小米手机，成本 2000 块，他就定价 1999。这充分诠释了他对于价格的理解。</p></li><li><p>合理利润。这么低的价格还能有利润吗？只有向制造环节要规模效应和生产效率，同时向流通环节要效率。</p></li></ul><p>在合理利润这个点上，雷军做了很多事情。比如在制造环节：</p><ul><li>他们投资机械臂算法的公司，希望将机械臂的价格打下来，这样就可以在生产中尽可能使用机械臂。</li><li>他们将生产线做改造，将不同产线的差异装配点模块化，使得换线成本显著降低。</li></ul><p>在向流程环节要效率这个点上，雷军遇到了很大的挑战，没有线下的渠道愿意与他合作。于是在初期，他只能和自己的售后合作伙伴来合作开店，最终把线下渠道的成本压到了 10% 左右。而传统的渠道，成本是 20% 左右。</p><p>但是，即使到了现在，小米在合理利润这个点上，也没有完全通过市场检验。在手机端，小米因为有大量应用市场广告和 App 预装等服务性收费，才使得他有足够的利润。但是在硬件端，不是每款硬件都可以靠服务收费的，比如大部分小米生态链产品就不太需要服务，小米还需要在未来回答这些问题。</p><h2 id="小米如何做第一辆车"><a href="#小米如何做第一辆车" class="headerlink" title="小米如何做第一辆车"></a>小米如何做第一辆车</h2><p>小米切入造车行业，刚开始下属的提案有很多创新。雷军觉得不好，他觉得大公司做新业务的三个大坑：认知错位、惯性思维、偶像包袱。总觉得自己牛逼，做新业务要干件大事，但是自己在新领域很可能就是一个小学生，有很多该交的学费都还没交。</p><p>所以，雷军要求团队 “先确保做一款好车，一款能够与当下同级所有产品比拼的好车，在确保这个目标的基础上，再考虑颠覆的部分。” </p><p>当目标变成 “一款好车” 时，颠覆不颠覆就不那么重要了，什么东西好拿过来借鉴就好了。于是，小米的第一款车显得很熟悉，很多保时捷上的设计被借鉴来了，大家也被一款好的设计所吸引。</p><p>虽然入局晚了几年，但小米汽车还是获得了一个梦幻开局。</p><h2 id="终局思维"><a href="#终局思维" class="headerlink" title="终局思维"></a>终局思维</h2><p>雷军在书中提到了消费电子行业的规律：当 15-20 年后行业进入成熟期，全球前 5 的品牌必将手握 80% 以上的份额。也就是说，只有最终进入全球行业前 5，做到年出货 1000 万台以上才有意义。</p><p>雷军在进入这个行业的最初，就想好了 20 年后的终局。这种终局思维才让他能够做长期主义的事情，包括投入三电等基础能力的研发，包括为造车留够足够的资金，也包括他自己的 All in 行为。</p><h2 id="小米曾经犯的错误"><a href="#小米曾经犯的错误" class="headerlink" title="小米曾经犯的错误"></a>小米曾经犯的错误</h2><p>芒格说：如果你知道自己可能死在哪里，就永远不要去那个地方。雷军在书中提了很多小米犯的错误，这些错误让我记忆犹新。以下是一些记录：</p><h3 id="性价比应该作用在用户价值上"><a href="#性价比应该作用在用户价值上" class="headerlink" title="性价比应该作用在用户价值上"></a>性价比应该作用在用户价值上</h3><p>小米早期连 SIM 卡的卡针都要用 10 倍于同行的材质和工艺，这事后来被雷军叫停了。雷军认为，所有的产品体验成本，应该用在用户价值上，如果用户用不到，就是自嗨。SIM 卡的卡针大部分用户只会用一次，这个卡针上就没必要用 10 倍于同行的成本。</p><p>在消费品行业，一些产品包装也会有同样的问题。如果消费者收到的产品过度包装，消费者就会认为 “羊毛出在羊身上”，这反倒是一种浪费。</p><h3 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h3><p>雷军认为，自己在红米品牌上犯了错，以及之前用了很多 X 米的生态链品牌都是不对的，这些品牌模糊了小米品牌。所以，后来红米改名成为了 Redmi。</p><p>小米品牌，最终只用在了非常核心的产品上，包括：手机、电视、路由、音箱、笔记本电脑，以及后来做的汽车。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/xiaomi-thinking.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;其实我以前一直不理解雷军。&lt;/p&gt;
&lt;p&gt;原因一是我在猿辅导工作，我们做的产品都是追求创新和高品质。因为成本不低，所以我们的产品定价不那么便宜。像我们公司的学练机、月子中心、</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：宽度优先搜索</title>
    <link href="https://blog.devtang.com/2024/12/15/bfs-teaching-notes/"/>
    <id>https://blog.devtang.com/2024/12/15/bfs-teaching-notes/</id>
    <published>2024-12-15T08:54:30.000Z</published>
    <updated>2024-12-22T09:06:13.290Z</updated>
    
    <content type="html"><![CDATA[<p>在学习完数据结构队列(queue)后，就可以让学生学习宽度优先搜索了。</p><p>宽度优先搜索（BFS）的形式相对固定，但是写起来代码偏长，学生在学习的时候，老是容易忘掉一些环节，所以需要加强练习。</p><h1 id="1、模版记忆"><a href="#1、模版记忆" class="headerlink" title="1、模版记忆"></a>1、模版记忆</h1><p>我整理了一个 BFS 的模版，每次教学前让孩子复述这个环节，通过这种方式来强化模版的记忆，帮助学生掌握这个算法。</p><p>模版如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">queue&lt; ? &gt; q;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>( ? );</span><br><span class="line">标记 ? 已经处理</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">? = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(各种情况) &#123;</span><br><span class="line">  <span class="keyword">if</span> (可入队) &#123;</span><br><span class="line">q.<span class="built_in">push</span>( ? )</span><br><span class="line">标记 ? 已经处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、关于结构体的使用"><a href="#2、关于结构体的使用" class="headerlink" title="2、关于结构体的使用"></a>2、关于结构体的使用</h1><p>在教学宽度优先搜索的初期，其实并不需要将入队的数据整合成结构体。这样反而会让代码变得更复杂。可以直接将需要入队的数据成组地 push 和 pop，这样就实现了简易的类似结构体的效果。</p><h1 id="3、教学题目"><a href="#3、教学题目" class="headerlink" title="3、教学题目"></a>3、教学题目</h1><p>推荐的教学题目如下：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/B3625">B3625 迷宫寻路</a></td><td>新手入门，没有陷阱，学习方向数组写法</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历</a></td><td>需要求步数，需要写 8 个方向</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1135">P1135 奇怪的电梯</a></td><td>BFS 不仅仅可以是在地图上，也可以是另外的搜索形式</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1162">P1162 填涂颜色</a></td><td>学习标记技巧：将地图往外扩一圈 0 ，减少标记难度</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1825">P1825 Corn Maze S</a></td><td>变种的地图，可以传送</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1451">P1451 求细胞数量</a></td><td>多次的 BFS 标记</td></tr></tbody></table><p>推荐更多练习的题目如下，可作为<strong>基础训练</strong>之用：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1746">P1746 离开中山路</a></td><td>比较标准的练习，无坑</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1506">P1506 拯救oibh总部</a></td><td>强化<a href="https://www.luogu.com.cn/problem/P1162">P1162 填涂颜色</a> 中学到的标记技巧</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1331">P1331 海战</a></td><td>多次 BFS 标记的同时，如何判断标记物是矩行</td></tr></tbody></table><p>以下题目难度更高一些，可以作为<strong>强化训练</strong>之用：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1141">P1141 01迷宫</a></td><td>数据量很大，需要提前保存查询结果</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2802">P2802 回家</a></td><td>状态变为走过时的血量有没有变高</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8604">P8604 危险系数</a></td><td>[蓝桥杯 2013 国 C]题目，用 BFS 暴力尝试</td></tr><tr><td><a href="https://atcoder.jp/contests/abc384/tasks/abc384_e">Takahashi is Slime 2</a></td><td>变种的 BFS，需要用优先队列</td></tr></tbody></table><h1 id="4、例题代码"><a href="#4、例题代码" class="headerlink" title="4、例题代码"></a>4、例题代码</h1><p>以下是详细的例题代码说明。</p><h2 id="B3625-迷宫寻路"><a href="#B3625-迷宫寻路" class="headerlink" title="B3625 迷宫寻路"></a>B3625 迷宫寻路</h2><p><a href="https://www.luogu.com.cn/problem/B3625">B3625 迷宫寻路</a> 是一道非常基础的宽度优先搜索，只需要输出 YES 或者 NO，对输出的要求也较小，适合拿来入门教学。</p><p>在本例题中，我们也要开始教会学生定义 movex、movey 数组，后续在迷宫一类的宽度搜索题目中，这种技巧非常见。movex、movey 的快速定义技巧是：movex 和 movey 的结构交替，每一组都是一个 1 和一个 0，同时变换 1 的正负号。记住这样的技巧就可以快速定义出这两个数组。代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>本例还需要一个数组标记是否走过，我们使用 flag 数组。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B3625 迷宫寻路，宽度优先搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">110</span>][<span class="number">110</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> tox, toy;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(x); q.<span class="built_in">push</span>(y);</span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (x == n<span class="number">-1</span> &amp;&amp; y == m<span class="number">-1</span>) &#123;</span><br><span class="line">result = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">tox = x + movex[i];</span><br><span class="line">toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;= <span class="number">0</span> &amp;&amp; tox &lt;n &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;m</span><br><span class="line">&amp;&amp; tu[tox][toy] == <span class="string">&#x27;.&#x27;</span> </span><br><span class="line">&amp;&amp; flag[tox][toy]== <span class="literal">false</span>) &#123;</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(tox); q.<span class="built_in">push</span>(toy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; tu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迷宫寻路加强：求步数"><a href="#迷宫寻路加强：求步数" class="headerlink" title="迷宫寻路加强：求步数"></a>迷宫寻路加强：求步数</h2><p>有了上面的代码，我们可以在题目上做变动，比如把输出的要求改为：<br><strong>如果能到达，则输出到达终点的最短步数</strong> ，引导学生思考，现有的代码要做怎样的改造，才能实现新的要求。</p><p>于是，我们讨论得出，需要将”步数”引入到代码中，于是，原来的代码增加了两处修改：</p><ul><li>每次入队的时候，将当前位置到达的步数也入队</li><li>如果到达终点，记录下来当时的步数</li></ul><p>改动的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B3625 迷宫寻路，宽度优先搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">110</span>][<span class="number">110</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> tox, toy, step;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(x); q.<span class="built_in">push</span>(y); </span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 改动 1</span></span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">step = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();  <span class="comment">// 改动 2</span></span><br><span class="line"><span class="keyword">if</span> (x == n<span class="number">-1</span> &amp;&amp; y == m<span class="number">-1</span>) &#123;</span><br><span class="line">result = <span class="literal">true</span>;</span><br><span class="line">ans = step;  <span class="comment">// 改动 3</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">tox = x + movex[i];</span><br><span class="line">toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;= <span class="number">0</span> &amp;&amp; tox &lt;n &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;m</span><br><span class="line">&amp;&amp; tu[tox][toy] == <span class="string">&#x27;.&#x27;</span> </span><br><span class="line">&amp;&amp; flag[tox][toy]== <span class="literal">false</span>) &#123;</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(tox); q.<span class="built_in">push</span>(toy); </span><br><span class="line">q.<span class="built_in">push</span>(step+<span class="number">1</span>);  <span class="comment">// 改动 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result) cout &lt;&lt; <span class="string">&quot;Yes, step = &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; tu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迷宫寻路加强：求路径"><a href="#迷宫寻路加强：求路径" class="headerlink" title="迷宫寻路加强：求路径"></a>迷宫寻路加强：求路径</h2><p>当我们需要输出路径的时候，我们需要做两件事情：</p><p>1、把 BFS 经过的数据全部保存下来。这个时候我们就不能用队列了，只能用 vector，然后另外用一个变量 idx 来记录处理过的元素下标。于是，判断是否处理完的条件变成了如下的形式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (idx != q.<span class="built_in">size</span>())</span><br></pre></td></tr></table></figure><p>2、我们需要对每个元素中增加一个 <code>parent</code> 变量，记录它是来自哪一个下标。这样就可以把整个路径串起来。如下的形式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, step, parent;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _step, <span class="type">int</span> _parent) &#123;</span><br><span class="line">x = _x; y = _y; step = _step; parent=_parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终，整体的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * B3625 迷宫寻路，宽度优先搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">110</span>][<span class="number">110</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, step, parent;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _step, <span class="type">int</span> _parent) &#123;</span><br><span class="line">x = _x; y = _y; step = _step; parent=_parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> tox, toy, step;</span><br><span class="line">vector&lt;Node&gt; q;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(x, y, <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (idx != q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">Node node = q[idx];</span><br><span class="line"><span class="keyword">if</span> (node.x == n<span class="number">-1</span> &amp;&amp; node.y == m<span class="number">-1</span>) &#123;</span><br><span class="line">result = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">stack&lt;Node&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(node);</span><br><span class="line"><span class="keyword">while</span> (node.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">node = q[node.parent];</span><br><span class="line">s.<span class="built_in">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">node = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) -&gt;\n&quot;</span>, node.x+<span class="number">1</span>, node.y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">tox = node.x + movex[i];</span><br><span class="line">toy = node.y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;= <span class="number">0</span> &amp;&amp; tox &lt;n &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;m</span><br><span class="line">&amp;&amp; tu[tox][toy] == <span class="string">&#x27;.&#x27;</span> </span><br><span class="line">&amp;&amp; flag[tox][toy]== <span class="literal">false</span>) &#123;</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(tox, toy, step+<span class="number">1</span>, idx));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!result) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; tu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">.##.#</span></span><br><span class="line"><span class="comment">.#...</span></span><br><span class="line"><span class="comment">...#.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1443-马的遍历"><a href="#P1443-马的遍历" class="headerlink" title="P1443 马的遍历"></a>P1443 马的遍历</h2><p>有了迷宫寻路的变种练习基础，我们就可以正式练习用 BFS 来求最近的步数一类的题目了。这其中比较适合的题目是： <a href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历</a>。</p><p>《马的遍历》一题要求我们把所有位置的最近距离都求出来，我们可以用一个数组来保存结果。</p><p>同时，马可以跳 8 个方向，有了之前的建 movex, movey 的经验，我们知道，每组数是 1 与 2 的各种组合。于是可以快速写出来这两个方向数组。</p><p>具体写法是：</p><ul><li>先写 x 数组，把所有的负数写出来，再写所有的正数。</li><li>考虑到每个数会有正负两个 y 与此搭档，所以每个数我们写两遍。这样就写出来了 <code>-2,-2,-1,-1,1,1,2,2</code></li><li>然后我们对着 movex 写 movey，凡是对应的 movex 是 2 的，我们就写 1，凡是 movex 是 1的，我们就写 2，同样的我们需要写正数和负数两遍。</li><li>写完后两个数组的字符串也应该是刚好一样的，可以帮我们作为一个检查手段。</li></ul><p>具体如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br></pre></td></tr></table></figure><p>完整的《马的遍历》的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1443 马的遍历, 宽度优先搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坐标是从 1,1 开始算的</span></span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">410</span>][<span class="number">410</span>];</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">410</span>][<span class="number">410</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x); q.<span class="built_in">push</span>(y); q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">tu[x][y] = <span class="number">0</span>;</span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> step = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox&gt;=<span class="number">1</span> &amp;&amp; tox&lt;=n &amp;&amp; toy&gt;=<span class="number">1</span> &amp;&amp; toy&lt;=m &amp;&amp;</span><br><span class="line">!flag[tox][toy])&#123;</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(tox); q.<span class="built_in">push</span>(toy); q.<span class="built_in">push</span>(step+<span class="number">1</span>);</span><br><span class="line">tu[tox][toy] = step+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(tu, <span class="number">-1</span>, <span class="built_in">sizeof</span>(tu));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">bfs</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j&lt;=m; ++j) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tu[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题还有一个小的教学点，就是用 memset 来初始化值为 -1。可以顺便教学 memset 可以初使化的值，告诉学生不是每种值都可以用 memset 来初始化。</p><h2 id="P1135-奇怪的电梯"><a href="#P1135-奇怪的电梯" class="headerlink" title="P1135 奇怪的电梯"></a>P1135 奇怪的电梯</h2><p><a href="https://www.luogu.com.cn/problem/P1135">P1135 奇怪的电梯</a> 一题的意义在于，用非地图的形式来教学 BFS，让学生知道 BFS 不仅仅可以是在地图上。</p><p>但从实现来说，此题的难度相对较小。此题的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1135 奇怪的电梯</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 宽度优先搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, A, B;</span><br><span class="line"><span class="type">int</span> jump[<span class="number">210</span>];</span><br><span class="line"><span class="type">char</span> flag[<span class="number">210</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node node, up, down;</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A == B) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">node.v = A;</span><br><span class="line">node.step = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(node);</span><br><span class="line">flag[node.v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">up = down = node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">up.v += jump[node.v];</span><br><span class="line">down.v -= jump[node.v];</span><br><span class="line">up.step = down.step = node.step + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (up.v &lt;= N &amp;&amp; flag[up.v] == <span class="number">0</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(up);</span><br><span class="line">flag[up.v] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (down.v &gt;=<span class="number">1</span> &amp;&amp; flag[down.v] ==<span class="number">0</span> ) &#123;</span><br><span class="line">q.<span class="built_in">push</span>( down );</span><br><span class="line">flag[down.v] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (up.v == B || down.v == B) &#123;</span><br><span class="line">ans = node.step + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;A, &amp;B);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, jump+i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1162-填涂颜色"><a href="#P1162-填涂颜色" class="headerlink" title="P1162 填涂颜色"></a>P1162 填涂颜色</h2><p><a href="https://www.luogu.com.cn/problem/P1162">P1162 填涂颜色</a> 可以用来学习地图标记的一个技巧：将地图往外扩一圈 0 ，减少标记难度。实际在写的时候，只需要从下标 1 开始读数据即可。</p><p>此题的参考代码如下，代码的最后用注释带了一个测试用例。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1162 填涂颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">40</span>][<span class="number">40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">40</span>][<span class="number">40</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x+movex[i];</span><br><span class="line"><span class="type">int</span> toy = y+movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox&gt;=<span class="number">0</span> &amp;&amp; tox&lt;=n+<span class="number">1</span> &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;=n+<span class="number">1</span></span><br><span class="line">&amp;&amp; tu[tox][toy] == <span class="number">0</span> &amp;&amp; flag[tox][toy]==<span class="literal">false</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(tox);</span><br><span class="line">q.<span class="built_in">push</span>(toy);</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=n; ++j) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tu[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == <span class="number">0</span> &amp;&amp; flag[i][j] == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tu[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">0 0 1 1 1 1</span></span><br><span class="line"><span class="comment">0 1 1 0 1 0</span></span><br><span class="line"><span class="comment">1 1 0 0 1 1</span></span><br><span class="line"><span class="comment">0 1 0 0 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1506-拯救oibh总部"><a href="#P1506-拯救oibh总部" class="headerlink" title="P1506 拯救oibh总部"></a>P1506 拯救oibh总部</h2><p><a href="https://www.luogu.com.cn/problem/P1506">P1506 拯救oibh总部</a> 强化上一题学到的技巧。</p><p>同时我们此题学习用 memset 将 char 数组统一设置成字符’0’：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(tu, <span class="string">&#x27;0&#x27;</span>, <span class="built_in">sizeof</span>(tu));</span><br></pre></td></tr></table></figure><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1506 拯救oibh总部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">510</span>][<span class="number">510</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">510</span>][<span class="number">510</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">flag[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox&gt;=<span class="number">0</span> &amp;&amp; tox &lt;=n+<span class="number">1</span> &amp;&amp;</span><br><span class="line">toy&gt;=<span class="number">0</span> &amp;&amp; toy &lt;=m+<span class="number">1</span> &amp;&amp;</span><br><span class="line">tu[tox][toy] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; </span><br><span class="line">flag[tox][toy] == <span class="literal">false</span>) &#123;</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(tox);</span><br><span class="line">q.<span class="built_in">push</span>(toy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(tu, <span class="string">&#x27;0&#x27;</span>, <span class="built_in">sizeof</span>(tu));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="type">char</span> ss[<span class="number">510</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">tu[i][j] = ss[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; flag[i][j]==<span class="literal">false</span>) </span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1825-Corn-Maze-S"><a href="#P1825-Corn-Maze-S" class="headerlink" title="P1825 Corn Maze S"></a>P1825 Corn Maze S</h2><p><a href="https://www.luogu.com.cn/problem/P1825">P1825 Corn Maze S</a> 增加了“地图传送”这种新的玩法，使得 BFS 代码写起来会更加复杂一点。</p><p>像这种更复杂的 BFS，我们就可以引入结构体，来让代码更整洁一点。结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">Node</span>() &#123;x=y=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y) &#123;x = _x; y=_y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在 BFS 的过程中，我们还需要记录步数，所以我们用 STL 的 pair 来存储队列元素。借此题，我们完成了 pair 的教学。</p><p>pair 的关键用法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">queue&lt;pair&lt;Node, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">pair&lt;Node, <span class="type">int</span>&gt; one = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Node a = one.first;</span><br><span class="line"><span class="type">int</span> step = one.second;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1825 [USACO11OPEN] Corn Maze S</span></span><br><span class="line"><span class="comment"> * 宽度优先搜索</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 遇到传送的时候，把位置更新到另一个传送点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">310</span>][<span class="number">310</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">310</span>][<span class="number">310</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">Node</span>() &#123;x=y=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y) &#123;x = _x; y=_y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node st;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Node a, Node b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">getNode</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == ch) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Node</span>(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">getOtherNode</span><span class="params">(<span class="type">char</span> ch, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == i &amp;&amp; y == j) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == ch) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Node</span>(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(Node a)</span> </span>&#123;</span><br><span class="line">queue&lt;pair&lt;Node, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a, <span class="number">0</span>));</span><br><span class="line">flag[a.x][a.y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">pair&lt;Node, <span class="type">int</span>&gt; one = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">a = one.first;</span><br><span class="line"><span class="type">int</span> step = one.second;</span><br><span class="line"><span class="type">char</span> ch = tu[a.x][a.y];</span><br><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">a = <span class="built_in">getOtherNode</span>(ch, a.x, a.y);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = a.x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = a.y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox&gt;=<span class="number">0</span> &amp;&amp; tox&lt;N &amp;&amp; toy&gt;=<span class="number">0</span> &amp;&amp; toy&lt;M &amp;&amp;</span><br><span class="line">tu[tox][toy] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; !flag[tox][toy]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(tox, toy), step+<span class="number">1</span>));</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tu[i]);</span><br><span class="line">&#125;</span><br><span class="line">Node st = <span class="built_in">getNode</span>(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>(st));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1451-求细胞数量"><a href="#P1451-求细胞数量" class="headerlink" title="P1451 求细胞数量"></a>P1451 求细胞数量</h2><p><a href="https://www.luogu.com.cn/problem/P1451">P1451 求细胞数量</a> 是一道非常基础的 BFS 题目。此题需要多次调用 BFS，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1451 求细胞数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">110</span>][<span class="number">110</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;= <span class="number">0</span> &amp;&amp; tox &lt; n &amp;&amp;</span><br><span class="line">toy &gt;= <span class="number">0</span> &amp;&amp; toy &lt; m &amp;&amp; </span><br><span class="line">tu[tox][toy]!=<span class="string">&#x27;0&#x27;</span> &amp;&amp;</span><br><span class="line">flag[tox][toy]==<span class="literal">false</span>) &#123;</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(tox);</span><br><span class="line">q.<span class="built_in">push</span>(toy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tu[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; flag[i][j] == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">bfs</span>(i, j);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1331-海战"><a href="#P1331-海战" class="headerlink" title="P1331 海战"></a>P1331 海战</h2><p><a href="https://www.luogu.com.cn/problem/P1331">P1331 海战</a> 一题的标记矩形的形式比较难想到，我个人用的是另外一个判断方法：看看所填充的坐标最小和最大值计算出来的矩形面积与标记的数量是否刚好匹配。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宽度优先搜索。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 先用 floodfill 把每组船支标记。标记的时候，记录：</span></span><br><span class="line"><span class="comment"> *  - 最小 minx, miny 和最大 maxx, maxy</span></span><br><span class="line"><span class="comment"> * 然后判断是否标记的船只数量是否是正方形：</span></span><br><span class="line"><span class="comment"> *  - cnt == (maxx-minx+1)*(maxy-miny+1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> R, C;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">1100</span>][<span class="number">1100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">1100</span>][<span class="number">1100</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> shipCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mark</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> minx, miny, maxx, maxy;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">minx = maxx = x;</span><br><span class="line">miny = maxy = y;</span><br><span class="line">flag[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">ans++;</span><br><span class="line">minx = <span class="built_in">min</span>(minx, x);</span><br><span class="line">miny = <span class="built_in">min</span>(miny, y);</span><br><span class="line">maxx = <span class="built_in">max</span>(maxx, x);</span><br><span class="line">maxy = <span class="built_in">max</span>(maxy, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;=<span class="number">0</span> &amp;&amp; tox &lt; R &amp;&amp; toy&gt;=<span class="number">0</span> &amp;&amp; toy&lt;C</span><br><span class="line">&amp;&amp; tu[tox][toy] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; !flag[tox][toy]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(tox);</span><br><span class="line">q.<span class="built_in">push</span>(toy);</span><br><span class="line">flag[tox][toy] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt = (maxx-minx+<span class="number">1</span>)*(maxy-miny+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ans == cnt) &#123;</span><br><span class="line">shipCnt++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;R, &amp;C);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tu[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; flag[i][j] == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">mark</span>(i, j)) &#123;</span><br><span class="line">shipCnt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="built_in">process</span>();</span><br><span class="line"><span class="keyword">if</span> (shipCnt == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Bad placement.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;There are %d ships.\n&quot;</span>, shipCnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 8</span></span><br><span class="line"><span class="comment">.....#.#</span></span><br><span class="line"><span class="comment">##.....#</span></span><br><span class="line"><span class="comment">##.....#</span></span><br><span class="line"><span class="comment">.......#</span></span><br><span class="line"><span class="comment">##.....#</span></span><br><span class="line"><span class="comment">#..#...#</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1141-01迷宫"><a href="#P1141-01迷宫" class="headerlink" title="P1141 01迷宫"></a>P1141 01迷宫</h2><p><a href="https://www.luogu.com.cn/problem/P1141">P1141 01迷宫</a> 这道题的难度在于，我们需要 BFS  之后，把结果全部保存下来，之后每次查询的时候把答案直接输出就可以了。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此题 m 的量很大，所以要提前算出答案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> flag[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> debug=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">convert</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mark</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">cnt++;</span><br><span class="line">flag[x][y] = v;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">x = a.first;</span><br><span class="line">y = a.second;</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">convert</span>(tu[x][y]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;=<span class="number">0</span> &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; tox &lt;n &amp;&amp; toy&lt;n </span><br><span class="line">&amp;&amp;tu[tox][toy]==ch</span><br><span class="line">&amp;&amp;flag[tox][toy]==<span class="number">-1</span>) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tox, toy));</span><br><span class="line">cnt++;</span><br><span class="line">flag[tox][toy] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">flag[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[i][j] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 标记 idx </span></span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">mark</span>(i, j, idx);</span><br><span class="line"><span class="comment">// 把标为 idx 的个数放到 ans 数组中</span></span><br><span class="line">ans.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tu[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">process</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="type">int</span> idx = flag[x<span class="number">-1</span>][y<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[idx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1746-离开中山路"><a href="#P1746-离开中山路" class="headerlink" title="P1746 离开中山路"></a>P1746 离开中山路</h2><p><a href="https://www.luogu.com.cn/problem/P1746">P1746 离开中山路</a>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1746 离开中山路</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">1100</span>][<span class="number">1100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> flag[<span class="number">1100</span>][<span class="number">1100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> fx, fy, tx, ty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(x); q.<span class="built_in">push</span>(y); q.<span class="built_in">push</span>(step);</span><br><span class="line">flag[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">y = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">step = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (x == tx<span class="number">-1</span> &amp;&amp; y == ty<span class="number">-1</span>) <span class="keyword">return</span> step;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = x+movex[i];</span><br><span class="line"><span class="type">int</span> toy = y+movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;= <span class="number">0</span> &amp;&amp; tox &lt;n &amp;&amp;</span><br><span class="line">toy &gt;= <span class="number">0</span> &amp;&amp; toy &lt;n &amp;&amp;</span><br><span class="line">tu[tox][toy]==<span class="string">&#x27;0&#x27;</span> &amp;&amp;</span><br><span class="line">flag[tox][toy]==<span class="number">0</span>) &#123;</span><br><span class="line">flag[tox][toy] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(tox); q.<span class="built_in">push</span>(toy); q.<span class="built_in">push</span>(step+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tu[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;fx, &amp;fy, &amp;tx, &amp;ty);</span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">bfs</span>(fx<span class="number">-1</span>, fy<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P2802-回家"><a href="#P2802-回家" class="headerlink" title="P2802 回家"></a>P2802 回家</h2><p><a href="https://www.luogu.com.cn/problem/P2802">P2802 回家</a>一题的解题技巧是：将 flag 数组用于保存走上去时的最大血量。如果走上去最大血量可以更高，也是可以再次走的。</p><p>另外，当只剩 1 格血时，下一步不管走到哪儿都是死，所以就不用扩展了。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P2802 回家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">char</span> flag[<span class="number">15</span>][<span class="number">15</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> sx, sy, tx, ty;</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, s, t;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _s, <span class="type">int</span> <span class="type">_t</span>) &#123;</span><br><span class="line">x = _x; y=_y; s=_s; t=<span class="type">_t</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">Node</span>(x, y, <span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line">flag[x][y] = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">Node node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (node.x == tx &amp;&amp; node.y == ty) &#123;</span><br><span class="line"><span class="keyword">return</span> node.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没到终点，只剩 1 点血，怎么都死</span></span><br><span class="line"><span class="keyword">if</span> (node.t == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> tox = node.x + movex[i];</span><br><span class="line"><span class="type">int</span> toy = node.y + movey[i];</span><br><span class="line"><span class="keyword">if</span> (tox &gt;= <span class="number">0</span> &amp;&amp; tox &lt; n &amp;&amp;</span><br><span class="line">toy &gt;= <span class="number">0</span> &amp;&amp; toy &lt; m &amp;&amp; </span><br><span class="line">tu[tox][toy] != <span class="number">0</span> &amp;&amp;</span><br><span class="line">flag[tox][toy] &lt; node.t - <span class="number">1</span>) &#123;</span><br><span class="line">flag[tox][toy] = node.t <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> life = node.t - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tu[tox][toy] == <span class="number">4</span>) &#123;</span><br><span class="line">life = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">Node</span>(tox, toy, node.s+<span class="number">1</span>, life));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tu[i][j]);</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == <span class="number">2</span>) &#123; sx = i; sy = j; &#125;</span><br><span class="line"><span class="keyword">if</span> (tu[i][j] == <span class="number">3</span>) &#123; tx = i; ty = j; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">bfs</span>(sx, sy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习完数据结构队列(queue)后，就可以让学生学习宽度优先搜索了。&lt;/p&gt;
&lt;p&gt;宽度优先搜索（BFS）的形式相对固定，但是写起来代码偏长，学生在学习的时候，老是容易忘掉一些环节，所以需要加强练习。&lt;/p&gt;
&lt;h1 id=&quot;1、模版记忆&quot;&gt;&lt;a href=&quot;#1、模版记</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>将 stdc++.h 加到 Macbook M1/M2/M3 编译环境中</title>
    <link href="https://blog.devtang.com/2024/12/01/add-stdc-to-macbook-m1/"/>
    <id>https://blog.devtang.com/2024/12/01/add-stdc-to-macbook-m1/</id>
    <published>2024-12-01T03:29:19.000Z</published>
    <updated>2024-12-01T03:48:08.803Z</updated>
    
    <content type="html"><![CDATA[<p>查了好多资料，大多是不能 work 的。感谢这个视频教程：<a href="https://www.youtube.com/watch?v=LmR8sRcqbq0">https://www.youtube.com/watch?v=LmR8sRcqbq0</a>，最终帮我完成了需求。</p><p>以下是步骤概述：</p><p>1、在命令行执行：<code>echo | g++ -v -x c++ -E -</code>，我的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; echo | g++ -v -x c++ -E -</span><br><span class="line">Apple clang version 16.0.0 (clang-1600.0.26.3)</span><br><span class="line">Target: arm64-apple-darwin23.6.0</span><br><span class="line">Thread model: posix</span><br><span class="line">// 此处省略若干行</span><br><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/16/include</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks (framework directory)</span><br><span class="line">End of search list.</span><br><span class="line"># 1 &quot;&lt;stdin&gt;&quot;</span><br><span class="line"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class="line"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class="line"># 439 &quot;&lt;built-in&gt;&quot; 3</span><br><span class="line"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class="line"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class="line"># 1 &quot;&lt;stdin&gt;&quot; 2</span><br></pre></td></tr></table></figure><p>2、在上一步的结果中，寻找 <code>include &lt;...&gt; search starts here</code> 那一行，在那一行后面有提供 5 个路径，找到中间那个路径，按住 cmd 点击，可以用鼠标打开那个路径。如下图：</p><img src="/images/command_echo.jpg" class=""><p>3、找开之后，在那个路径新建名为 <code>bits</code> 的文件夹。</p><p>4、进入 <code>bits</code>文件夹，随便粘贴一个头文件进去，然后改名为 <code>stdc++.h</code>，修改文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// C++ includes used for precompiling -*- C++ -*-</span><br><span class="line"></span><br><span class="line">// Copyright (C) 2003-2014 Free Software Foundation, Inc.</span><br><span class="line">//</span><br><span class="line">// This file is part of the GNU ISO C++ Library.  This library is free</span><br><span class="line">// software; you can redistribute it and/or modify it under the</span><br><span class="line">// terms of the GNU General Public License as published by the</span><br><span class="line">// Free Software Foundation; either version 3, or (at your option)</span><br><span class="line">// any later version.</span><br><span class="line"></span><br><span class="line">// This library is distributed in the hope that it will be useful,</span><br><span class="line">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="line">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="line">// GNU General Public License for more details.</span><br><span class="line"></span><br><span class="line">// Under Section 7 of GPL version 3, you are granted additional</span><br><span class="line">// permissions described in the GCC Runtime Library Exception, version</span><br><span class="line">// 3.1, as published by the Free Software Foundation.</span><br><span class="line"></span><br><span class="line">// You should have received a copy of the GNU General Public License and</span><br><span class="line">// a copy of the GCC Runtime Library Exception along with this program;</span><br><span class="line">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span><br><span class="line">// &lt;http://www.gnu.org/licenses/&gt;.</span><br><span class="line"></span><br><span class="line">/** @file stdc++.h</span><br><span class="line"> *  This is an implementation file for a precompiled header.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 17.4.1.2 Headers</span><br><span class="line"></span><br><span class="line">// C</span><br><span class="line">#ifndef _GLIBCXX_NO_ASSERT</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#endif</span><br><span class="line">#include &lt;cctype&gt;</span><br><span class="line">#include &lt;cerrno&gt;</span><br><span class="line">#include &lt;cfloat&gt;</span><br><span class="line">#include &lt;ciso646&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;clocale&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;csetjmp&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;cstdarg&gt;</span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line"></span><br><span class="line">#if __cplusplus &gt;= 201103L</span><br><span class="line">#include &lt;ccomplex&gt;</span><br><span class="line">#include &lt;cfenv&gt;</span><br><span class="line">#include &lt;cinttypes&gt;</span><br><span class="line">#include &lt;cstdbool&gt;</span><br><span class="line">#include &lt;cstdint&gt;</span><br><span class="line">#include &lt;ctgmath&gt;</span><br><span class="line">#include &lt;cwchar&gt;</span><br><span class="line">#include &lt;cwctype&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// C++</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">#include &lt;complex&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;ios&gt;</span><br><span class="line">#include &lt;iosfwd&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;istream&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;locale&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;new&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;ostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;streambuf&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;valarray&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#if __cplusplus &gt;= 201103L</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line">#include &lt;ratio&gt;</span><br><span class="line">#include &lt;regex&gt;</span><br><span class="line">#include &lt;scoped_allocator&gt;</span><br><span class="line">#include &lt;system_error&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;tuple&gt;</span><br><span class="line">#include &lt;typeindex&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成以上步骤，搞定！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查了好多资料，大多是不能 work 的。感谢这个视频教程：&lt;a href=&quot;https://www.youtube.com/watch?v=LmR8sRcqbq0&quot;&gt;https://www.youtube.com/watch?v=LmR8sRcqbq0&lt;/a&gt;，最终帮我完成</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>颠覆技术的发展 - 读《浪潮将至》</title>
    <link href="https://blog.devtang.com/2024/11/17/wave-coming/"/>
    <id>https://blog.devtang.com/2024/11/17/wave-coming/</id>
    <published>2024-11-17T14:56:13.000Z</published>
    <updated>2024-12-01T15:00:54.053Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/coming-wave.jpg" class=""><p>最近看了 DeepMind 联合创始人和微软人工智能 CEO 苏莱曼的 《浪潮将至》。</p><p>该书主要介绍了未来极大可能改变世界的三个技术领域，分别是人工智能、合成生物学、量子技术。</p><p>以下是一些读书感悟。</p><h2 id="颠覆技术的对抗非对称性"><a href="#颠覆技术的对抗非对称性" class="headerlink" title="颠覆技术的对抗非对称性"></a>颠覆技术的对抗非对称性</h2><p>对抗非对称性指：拥有颠覆技术的一方可以用极小的力量对抗过去不可能对抗的力量。</p><p>这可以类比为在冷兵器时代拥有机关枪的一个人就可以对抗一整个敌人军队。</p><p>核武器的对抗也具备非对称性。拥有核武器的一方对非核国家也具备碾压性的优势。当然，后面全球努力在限制这种能力，以免被恐怖组织拥有带来全球的灭顶之灾。</p><p>人工智能的非对称性体现在对很多方面：<strong>拥有超级人工智能的组织的生产力可以是千倍于传统生产力。</strong></p><p>书中列举了 DeepMind 公司在预测蛋白质结构上的突破，在这个技术出现之前，人类的蛋白质结构数据库中只有大概 20 万个蛋白质结构。DeepMind 公司一次性上传了 2 亿个新的蛋白质结构，几乎覆盖了所有已知的蛋白质。2 亿 vs 20 万，就是一个 1000 倍的对抗优势。</p><p>马斯克的擎天柱人形机器人如果成功大规模量产，也可能将全球制造业格局重塑。现在制造业主要还是集中于人力成本低廉的国家（例如中国，东南亚，墨西哥），到时候不需要吃饭和休息的机器的成本可能是人类的 百分之一。</p><p>现在看起来，<strong>人工智能似乎可以改变所有行业，唯一不可能替代的是人类亲自服务和沟通带来的某些情绪价值。</strong></p><h2 id="颠覆技术的普及性"><a href="#颠覆技术的普及性" class="headerlink" title="颠覆技术的普及性"></a>颠覆技术的普及性</h2><p>不同于核武器技术，这些颠覆性技术的获取难度非常低。现在非常多的大模型技术公司的代码和模型都是开源的，普通人可以方便地从网上获取到相关资源。GitHub 平台上已经有 1.9 亿个代码库，其中大部分都是开源的。</p><p>现在全球顶尖的研究成果论文也可以从网上免费下载。特别是预印本网站，它加速了全球获取论文的方便程度。arXiv 上已经收录了超过 200 万篇论文。</p><p>对于生物技术来说，可打印定制 DNA 链的 DNA 合成器的购买只需要几万美元，而且该机器小巧便捷。下图是我在微信公众号搜到的一款 DNA 合成器，重量为 60 公斤，尺寸为 1&#x2F;8 立方米，比一个家用洗衣机还小。</p><img src="/images/coming-wave-2.jpg" class=""><p>作者打了一个比方：一个邪恶的恐怖组织只需要在网上下单，就可以拥有制造出新型病原体的能力。这些病原体可以被设计成规避人类的已知对策，以无症状的方式传播，具备对抗治疗的能力。</p><p>所以，<strong>未来一个人很可能“具备杀死 10 亿人的能力”，所需的仅仅是一个动机。</strong></p><p>“绝命毒师”如果出现在那个时代，会有这样的动机吗？</p><h2 id="颠覆技术的监管难度"><a href="#颠覆技术的监管难度" class="headerlink" title="颠覆技术的监管难度"></a>颠覆技术的监管难度</h2><p>颠覆技术不像原子弹那样明显让人意识到危险，所以大众还没有对监管产生紧迫感。</p><p>作者曾经在谷歌成立了一个人工智能伦理委员会。但是最终因为委员会里面有几个人曾经发表过反对跨性别的言论，于是大家的争论变成了要求这几个人从委员会辞职。</p><p>政治正确比人工智能的伦理更重要，于是这个委员会就解散了。</p><p>顺便说一下，几年前我听说谷歌所有项目成立的时候，都需要考虑这个项目组成员有没有黑人，有没有女人，是不是政治正确的。</p><p>颠覆技术的监管连政治正确都克服不了，更别说国际社会之间的各种利益鸿沟了。</p><h2 id="未来畅想：如何减小影响"><a href="#未来畅想：如何减小影响" class="headerlink" title="未来畅想：如何减小影响"></a>未来畅想：如何减小影响</h2><p>颠覆技术在未来如果把工作替代了，会产生怎样的动荡？200 年前的工业革命可以给我们一些参考。</p><p>1807 年，由于工资被消减，6000 名英国织布工人发起抗议示威。1811 年，破坏者袭击了当地的工厂，摧毁了 63 台纺织机。</p><p>颠覆技术如果让大量普通民众失业，很显然是非常危险的。我们应该在推进技术进步的同时，考虑到对现有工人的就业影响，以尽量温和的方式来推进变革。</p><p>我曾经想过如何减小自动驾驶技术对滴滴司机的就业影响。我的方法如下：</p><ul><li>同价。通过税收调节，保证自动驾驶车和有人驾驶车同价。自动驾驶车收重税，税收用于安置被影响的司机。</li><li>控量。通过颁发牌照，慢慢减少有人驾驶车。</li><li>转移岗位。把司机转岗培训成无人驾驶车的看护员，做一些清洁保障保养等工作。</li></ul><p>通过以上办法，慢慢把滴滴司机都安置好了，再减少税收，让自动驾驶慢慢赢得市场。</p><p>以上假想只是针对自动驾驶技术，但如果颠覆技术一次性颠覆了大部分行业，其应对方案会变得更难。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>《浪潮将至》介绍了颠覆技术（人工智能、合成生物学、量子技术）的对抗非对称性，知识普及性，和监管的难度。</p><p>未来如何发展，我们拭目以待。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/coming-wave.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;最近看了 DeepMind 联合创始人和微软人工智能 CEO 苏莱曼的 《浪潮将至》。&lt;/p&gt;
&lt;p&gt;该书主要介绍了未来极大可能改变世界的三个技术领域，分别是人工智能、合成生物学、量</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>如何控制孩子的电脑使用</title>
    <link href="https://blog.devtang.com/2024/11/08/time-control-of-cspj-learning/"/>
    <id>https://blog.devtang.com/2024/11/08/time-control-of-cspj-learning/</id>
    <published>2024-11-08T01:09:08.000Z</published>
    <updated>2024-11-08T01:35:43.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景和问题"><a href="#背景和问题" class="headerlink" title="背景和问题"></a>背景和问题</h2><p>小学生在学习编程的时候，我们必然需要使用电脑上机练习。但是，电脑上也充满了各种“诱惑”：</p><ul><li>打开网页无处不在的游戏广告，很多游戏还是网页游戏</li><li>应用市场里各种各样的游戏</li><li>小红书，B 站等各种各样的网站也充满吸引力</li></ul><p> 那我们如何保证孩子能够在上机的时候一直专心练习编程呢？难道得一直在旁边盯着吗？</p><p> 为此，我做了一些功课，分享给大家。</p><h2 id="解决方案（Windows-平台）"><a href="#解决方案（Windows-平台）" class="headerlink" title="解决方案（Windows 平台）"></a>解决方案（Windows 平台）</h2><p>微软的 Windows 操作系统中有一个家长控制功能。通过该功能家长可以限制小朋友对计算机功能的使用，以及规定和限制使用 Windows 的某些功能。</p><p>例如: 限制孩子的账户只能使用某个应用程序、游戏等。</p><p>使用 Windows 的家长控制功能可以在不安装其它软件的情况下，控制孩子使用Windows的绝大部分应用和功能。</p><p>具体操作方式如下。</p><h3 id="1、为孩子创建一个单独账号"><a href="#1、为孩子创建一个单独账号" class="headerlink" title="1、为孩子创建一个单独账号"></a>1、为孩子创建一个单独账号</h3><ul><li>按下键盘上的“Windows”键+“I”键打开设置→点击“账户”</li><li>点击左侧的“账户&#x2F;家庭和其他用户”，并“添加账户”</li><li>在弹出的窗口中点击“为孩子创建一个”，按步骤创建新的Microsoft账户</li><li>用新建的账户登录，在“概述”里面的隐私设置里打开“共享我的活动”，如下图</li></ul><img src="/images/time-control-1.jpg" class=""><h3 id="2、在线管理家庭设置"><a href="#2、在线管理家庭设置" class="headerlink" title="2、在线管理家庭设置"></a>2、在线管理家庭设置</h3><ul><li>用家长账户重新登录电脑</li><li>再次按下“Windows”键+“I”键打开设置→点击“账户”</li><li>点击左侧的“账户&#x2F;家庭和其他用户”</li><li>点击“在线管理家庭设置或删除账户”打开管理链接</li></ul><p>在管理链接中就可以管理孩子的时间了。</p><h2 id="解决方案（Mac-平台）"><a href="#解决方案（Mac-平台）" class="headerlink" title="解决方案（Mac 平台）"></a>解决方案（Mac 平台）</h2><ul><li>1、为孩子单独注册一个 Apple ID。</li><li>Mac 平台的家庭共享功能可以将孩子加入到一个家庭中。</li><li>可以在家庭共享中进入到孩子的帐户，查看孩子的屏幕使用时间，以及限制一些功能的使用。如下图：</li></ul><img src="/images/time-control-2.jpg" class=""><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景和问题&quot;&gt;&lt;a href=&quot;#背景和问题&quot; class=&quot;headerlink&quot; title=&quot;背景和问题&quot;&gt;&lt;/a&gt;背景和问题&lt;/h2&gt;&lt;p&gt;小学生在学习编程的时候，我们必然需要使用电脑上机练习。但是，电脑上也充满了各种“诱惑”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：for 循环</title>
    <link href="https://blog.devtang.com/2024/11/07/teach-notes-of-for-loop/"/>
    <id>https://blog.devtang.com/2024/11/07/teach-notes-of-for-loop/</id>
    <published>2024-11-07T01:13:43.000Z</published>
    <updated>2024-12-01T13:51:10.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景和问题"><a href="#背景和问题" class="headerlink" title="背景和问题"></a>背景和问题</h2><p>小学生在学习编程的时候，像变量，赋值，输入，输出，分支这些逻辑相对容易理解。因为这与人类真实世界的很多行为相似，所以学生会很容易吸收。具体来说：</p><ul><li>变量其实就是我们平时取的“名字”或者“外号”，用于指代一种特定物品。</li><li>赋值相当于为这种特定物品指定一种属性值，像是苹果的重量，价格一样。</li><li>输入和输出在很多电子产品中都有接触，孩子现在很小就接触手机，非常容易理解键盘就是一种输入，屏幕显示就是一种输出。</li><li>分支就是我们自然语言中的“如果…就”，非常容易类比。</li></ul><p>但是，for 循环由于其很难与现实世界“类比”，所以成为小学生学习编程的第一个障碍。</p><p>如何理解 for 循环，并且灵活运用 for 循环，成为一个教学难点。</p><h2 id="教学思考"><a href="#教学思考" class="headerlink" title="教学思考"></a>教学思考</h2><p>我在教学 for 循环的时候发现，如果我们用尽量渐进式的方式，让孩子刚开始接触到的 for 循环与现实世界数学中的数列一一对应。然后，再一步一步拔高难度，随着难度提高，最终 for 循环可以实现求解“非波拉切数列”以及“小数点后 10000 位”这类已经高度变型的题目。</p><p>因为每一步的难度提升梯度很小，所以学生虽然找不到现实世界类比，但终于还是比较容易理解整个渐进变化的过程。</p><p>这就类似于我们学立体几何前先学平面几何，学平面几何前先学点线面一样。从微小的简单事物开始，我们最终可以创造整个世界。</p><p>以下是我对 for 循环的具体教学拆解。</p><h2 id="教学拆解"><a href="#教学拆解" class="headerlink" title="教学拆解"></a>教学拆解</h2><h3 id="1、用-for-循环输出数列"><a href="#1、用-for-循环输出数列" class="headerlink" title="1、用 for 循环输出数列"></a>1、用 for 循环输出数列</h3><p>输出从 1-N 的等差数列是使用 for 循环最基础形式。我们先用这个引入，让孩子先初步了解 for 循环的三段形式。</p><p>for 循环的三段式其实对初学者来说还是有点绕，借此环节把 for 的基本格式熟悉。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、用-for-循环输出-1-N-的和"><a href="#2、用-for-循环输出-1-N-的和" class="headerlink" title="2、用 for 循环输出 1-N 的和"></a>2、用 for 循环输出 1-N 的和</h3><p>累加器的写法对于初学者来说是一个小障碍，但是累加器与 for 循环的结合使用在之后的变化很常见，所以我们在这个阶段把累加器引入，帮助孩子建立累加器的使用习惯。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>注：对于不习惯 +&#x3D; 的学生，也可以刚开始用 <code>sum = sum + i</code>来教学，减少学生的陌生感。</p><p>此题对应的线上练习是：<a href="https://ybt.ssoier.cn/problem_show.php?pid=2016">《2016：【例4.1】for循环求和》</a></p><p>此题也可以进一步变化为：分别求奇数和、偶数和。让学生学会在 for 里面嵌入 if 表达式。</p><ul><li>奇偶数之和线上练习：<a href="https://ybt.ssoier.cn/problem_show.php?pid=2018">《2018：【例4.3】输出奇偶数之和》</a></li><li>奇数求和的线上练习：<a href="https://ybt.ssoier.cn/problem_show.php?pid=1065">《1065：奇数求和》</a></li></ul><h3 id="3、用-for-循环输出-1-N-的和的平均值"><a href="#3、用-for-循环输出-1-N-的和的平均值" class="headerlink" title="3、用 for 循环输出 1-N 的和的平均值"></a>3、用 for 循环输出 1-N 的和的平均值</h3><p>平均值的计算涉及整除的概念，需要在除之前将被除数转化为小数，同时需要用 iomanip 头文件中的函数来控制输出格式，这一编程技巧正好在这一步引入，让学生逐步熟悉对输出的控制。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="comment">// 此处省略若干行</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">double</span>(sum)/n &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>此题对应的线上练习是：<a href="https://ybt.ssoier.cn/problem_show.php?pid=1060">《1060：均值》</a></p><h3 id="4、输入-N，接着输入-N-个数求和"><a href="#4、输入-N，接着输入-N-个数求和" class="headerlink" title="4、输入 N，接着输入 N 个数求和"></a>4、输入 N，接着输入 N 个数求和</h3><p>大部分学生以为 for 循环是 for 循环，输入是输入，却不知道for 循环里面也可以写输入。通过此题，学生可以更多了解 for 循环的用处：用来批量输入。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, a;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">sum += a;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>相关练习：</p><ul><li><a href="https://ybt.ssoier.cn/problem_show.php?pid=1060">《1060：均值》</a></li><li><a href="https://ybt.ssoier.cn/problem_show.php?pid=1061">《1061：求整数的和与均值》</a></li></ul><h3 id="5、输入-N-个数，求能整除-4-的个数"><a href="#5、输入-N-个数，求能整除-4-的个数" class="headerlink" title="5、输入 N 个数，求能整除 4 的个数"></a>5、输入 N 个数，求能整除 4 的个数</h3><p>与上一题类似，我们在这里引入 if 条件，让学生了解，for 循环里面可以放前面学过的分支结构。</p><p>另外，本题的累加器变形为“计数”。让学生对计数的操作产生基本的认知。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, a;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="6、输入-N-个数，统计值为-1、5-的个数"><a href="#6、输入-N-个数，统计值为-1、5-的个数" class="headerlink" title="6、输入 N 个数，统计值为 1、5 的个数"></a>6、输入 N 个数，统计值为 1、5 的个数</h3><p>我们在上一题的基础上增加难度，让累加器可以是多个。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt1 = <span class="number">0</span>, cnt5 = <span class="number">0</span>, a;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) cnt1++;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">5</span>) cnt5++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cnt5 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>相关练习：</p><ul><li><a href="https://ybt.ssoier.cn/problem_show.php?pid=1067">《1067：整数的个数》</a></li><li><a href="https://ybt.ssoier.cn/problem_show.php?pid=1068">《1068：与指定数字相同的数的个数》</a></li></ul><h3 id="7、输入-N-个数，求-N-个数的乘积"><a href="#7、输入-N-个数，求-N-个数的乘积" class="headerlink" title="7、输入 N 个数，求 N 个数的乘积"></a>7、输入 N 个数，求 N 个数的乘积</h3><p>我们学会了在 for 循环中累加，计数，那更多的变化就是求乘积了。在求乘积的时候，这个累积的变量值要从 1 开始。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mul = <span class="number">1</span>, a;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">mul = mul * a;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mul &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>此题对应的线上练习是：<a href="https://ybt.ssoier.cn/problem_show.php?pid=2019">《2019：【例4.4】求阶乘》</a></p><h3 id="8、输入-N-和-M，求-M-的-N-次方"><a href="#8、输入-N-和-M，求-M-的-N-次方" class="headerlink" title="8、输入 N 和 M，求 M 的 N 次方"></a>8、输入 N 和 M，求 M 的 N 次方</h3><p>次方是乘积的另一种变化。线上的练习题是：<a href="https://ybt.ssoier.cn/problem_show.php?pid=1069">《1069：乘方计算》</a></p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mul = <span class="number">1</span>, m, n;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">mul = mul * m;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mul &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>M 的 N 次方还有两种难度的加强，分别是：</p><ul><li>让学生考虑数据范围，用 long long 代替 int</li><li>在数据范围超过 long long 时，取结果的末尾 5 位数</li></ul><h3 id="8、输入-N-个数，让你对这-N-个数做更复杂的操作"><a href="#8、输入-N-个数，让你对这-N-个数做更复杂的操作" class="headerlink" title="8、输入 N 个数，让你对这 N 个数做更复杂的操作"></a>8、输入 N 个数，让你对这 N 个数做更复杂的操作</h3><p><a href="https://ybt.ssoier.cn/problem_show.php?pid=1075">《1075：药房管理》</a>一题就展示了一种更复杂的 for 循环。</p><p>原来我们不但可以累加，计数，求积，还可以做减法。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= a)&#123;</span><br><span class="line">        m = m-a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = b+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="9、求第-N-个斐波那契数"><a href="#9、求第-N-个斐波那契数" class="headerlink" title="9、求第 N 个斐波那契数"></a>9、求第 N 个斐波那契数</h3><p><a href="https://ybt.ssoier.cn/problem_show.php?pid=1071">《1071：菲波那契数》</a> 要求求第 K 个斐波那契数。</p><p>我们在这个 for 循环中实现了递推算法。递推是一个对新手来说很“神奇”的计算机算法，对于初学者来说，斐波那契数是最佳的一个学习例题，因为代码可以非常短。容易理解递推的核心思想。</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>, b=<span class="number">1</span>, c=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        c = b+a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、有一个数-N，满足-N-N-1-N-2-N-3-1680-请问-N-的值是几"><a href="#10、有一个数-N，满足-N-N-1-N-2-N-3-1680-请问-N-的值是几" class="headerlink" title="10、有一个数 N，满足 N*(N+1)*(N+2)*(N+3) = 1680 请问 N 的值是几"></a>10、有一个数 N，满足 <code>N*(N+1)*(N+2)*(N+3) = 1680</code> 请问 N 的值是几</h3><p>暴力枚举的基础代码也是 for 循环，我们用一个最简单的题目来引入枚举的思想。</p><p>示例代码：略。</p><h3 id="11、for-的嵌套：金字塔"><a href="#11、for-的嵌套：金字塔" class="headerlink" title="11、for 的嵌套：金字塔"></a>11、for 的嵌套：金字塔</h3><p>我们可以让学生试图输出一个二维的图形，比如输入 N，输出 N 层的金字塔。</p><p>金字塔的形状可以是这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure><p>也可以是这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   *</span><br><span class="line">  **</span><br><span class="line"> ***</span><br><span class="line">****</span><br></pre></td></tr></table></figure><p>也可以是这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   *</span><br><span class="line">  ***</span><br><span class="line"> *****</span><br><span class="line">*******</span><br></pre></td></tr></table></figure><p>借此让学生锻炼模拟的能力。</p><p>此题对应的线上练习是：<a href="https://ybt.ssoier.cn/problem_show.php?pid=2027">《2027：【例4.13】三角形》</a></p><h3 id="12、for-的嵌套：矩形"><a href="#12、for-的嵌套：矩形" class="headerlink" title="12、for 的嵌套：矩形"></a>12、for 的嵌套：矩形</h3><p>输入矩形的宽高，输出下面的形状。借此更一步强化学生模拟的能力。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line">*   *</span><br><span class="line">*   *</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>此题对应的线上练习是：<a href="https://ybt.ssoier.cn/problem_show.php?pid=1097">《1097：画矩形》</a></p><h3 id="13、for-的逆序"><a href="#13、for-的逆序" class="headerlink" title="13、for 的逆序"></a>13、for 的逆序</h3><p>for 循环中的三段，除了正向的写，也可以逆向的写。所以，我们可以让学生尝试把 1-N 倒着输出。</p><p>类似的，也可以提醒 for 的第三段<code>i++</code>其实也可以改成 <code>i+=2</code>之类的形式，实现各种跳着输出的情况。</p><h2 id="教学实操"><a href="#教学实操" class="headerlink" title="教学实操"></a>教学实操</h2><h3 id="单人教学"><a href="#单人教学" class="headerlink" title="单人教学"></a>单人教学</h3><p>在实操中，我们可以用一块白板进行代码的演示，然后不断擦写相关的关键代码，保留基础的 for 框架。这样方便学生观察到其中的变化与不变。</p><p>在没有白板的时候，也可以用电脑中的 IDE 或 PPT 来进行演示。</p><p>对于每一步的问题，可以让学生来应答。通过应答的过程，观察学生对此类问题的掌握情况，有选择的加速进度或者放慢进度，保证学生对知识的吸收到位。</p><h3 id="多人教学"><a href="#多人教学" class="headerlink" title="多人教学"></a>多人教学</h3><p>在多人教学的时候，可以让大家在纸上写下自己的答案，然后待大家都完成或大部分完成后，随机选择一位学生给其他人讲解，通过互助的方式，既锻炼了学生的表达，又强化了学生对知识的理解。</p><p>对于未完成的同学，可以让他反向提问，其他人帮忙解答。老师在这个过程中只需要监督整个过程，保证知识传递是正确的即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景和问题&quot;&gt;&lt;a href=&quot;#背景和问题&quot; class=&quot;headerlink&quot; title=&quot;背景和问题&quot;&gt;&lt;/a&gt;背景和问题&lt;/h2&gt;&lt;p&gt;小学生在学习编程的时候，像变量，赋值，输入，输出，分支这些逻辑相对容易理解。因为这与人类真实世界的很多行为相似，所以</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>本分 - 读《段永平投资回答录》</title>
    <link href="https://blog.devtang.com/2024/10/27/notes-from-duan-yong-ping/"/>
    <id>https://blog.devtang.com/2024/10/27/notes-from-duan-yong-ping/</id>
    <published>2024-10-27T03:50:04.000Z</published>
    <updated>2024-12-01T15:08:26.878Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了《段永平投资回答录》，分为商业逻辑篇和投资逻辑篇。一些感受深的点记录一下。</p><h2 id="不为清单"><a href="#不为清单" class="headerlink" title="不为清单"></a>不为清单</h2><p>段永平说：我们之所以成为我们，很多时候不是因为我们做了什么，而是因为我们不做什么。</p><p>查理芒格说：如果知道我会死在哪里，我将永远不会去那里。</p><p>两个人的观点很相似，就是用“不做&#x2F;不去”的方式来限制自己的行为。为此，段永平为自己的企业经营制定了“不为清单”（Stop doing list）。这些不为清单确实帮助企业经营划清了一些原则和边界。</p><p>在段永平的不为清单里：</p><ul><li>有一些是关于企业文化价值观的，比如：不攻击竞争对手、不拖付货款。</li><li>有一些是关于企业安全经营边界的，比如：不赊账、不代工、不借钱。</li><li>有一些是关于企业发展原则的，比如：不做不擅长的事情、不做没有差异化的产品。</li></ul><p>不为清单在企业管理上具备很强的高效性。因为如果是要为清单，那么这个清单可能很长，也可能很模糊，最终大家一来记不住，二来不知道执行到什么程度。但不为清单就简单很多，遇到相似的事情，不做就可以了。</p><p>附上段永平的不为清单，如下：</p><blockquote><ul><li>专注。不做不擅长的事情。</li><li>不借钱。不负债就不会倒闭。</li><li>没有销售部。不讨价还价。</li><li>不赊账。</li><li>不拖付货款。</li><li>不晚发工资。</li><li>不做不诚信的事情。</li><li>不攻击竞争对手。</li><li>不打价格战。</li><li>不谈性价比。</li><li>不做没有差异化的产品。</li><li>不弯道超车，关注自己的进步，面对客观的事物发展和成长的规律。</li><li>不收购</li><li>不多元化</li><li>不关注市占率，不关注销量排名</li><li>不盲目扩张</li><li>不赚快钱</li><li>不虚夸产品</li></ul></blockquote><h2 id="价值投资的逻辑"><a href="#价值投资的逻辑" class="headerlink" title="价值投资的逻辑"></a>价值投资的逻辑</h2><p>段永平在书中帮我再次梳理了价值投资的逻辑，段永平说：</p><blockquote><p>买股票就是买公司，买公司就是买其未来的现金流折现。</p></blockquote><p>说说我个人的理解：买股票就是买公司，指的是用“长期拥有一家公司的心态来考量自己的买入交易”。怎么样才是“长期拥有”的心态呢，比如问自己：</p><ul><li>如果这家公司退市了，你会不会紧张</li><li>如果这家公司停牌 10 年不能交易了，你会不会接受</li><li>如果这家公司股价跌了，你会不会开心（因为你可以继续买入）</li></ul><p>有人说，退市了我怎么卖掉？但是，如果你是用拥有公司的心态在买股票，首先就不应该考虑短期买卖，也不应该用着急需要用的短期资金。</p><p>有人说，股价跌了我持仓亏损怎么办？但是，如果这家企业的内在价值（即：未来现金流）是没有变化的，那么它未来会持续给你贡献高的收益回报，股价长期而言也会在内在价值基线上下波动。所以这反而是一个好的买入机会。</p><p>所以，价值投资将股票的买卖转变为了三个方面的考量：</p><ul><li>1、公司好不好</li><li>2、企业文化和管理层</li><li>3、价格是否划算（有安全边际）</li></ul><p>总结下来就是：好业务、好管理、好价格。</p><h3 id="公司好不好"><a href="#公司好不好" class="headerlink" title="公司好不好"></a>公司好不好</h3><p>对于公司好不好的考查方式有很多，比如毛利率，经营壁垒，增长率等等，但段永平用他与巴菲特午餐时，巴菲特的回答总结道：最重要的是商业模式。</p><p>什么是商业模式呢？我理解为这家公司的“天赋”，即：环境变化也很难被改变的东西。不同的商业模式决定了一些公司会很辛苦才能活下来，另一些公司很轻松就可以活下来。举个例子：</p><p>斑马玩教具做的是 2-6 岁孩子的教育硬件，因为一款硬件的使用寿命大概有 3 年左右，所以，同一款产品几乎不会有复购的。但是我们看苹果手机，同样是 3 年左右的使用寿命，但是因为用户在生命期内可能每 3 年就买一次苹果手机，加上苹果手机的软硬件生态使得用户很难把它换掉，对于一个 20 岁的用户来说，他一辈子可能会用掉几十部苹果手机（3 年换一次）。这个从复购上来讲，就是一个很好的商业模式。</p><p>但是苹果手机与可口可乐比，商业模式就又会差一些。因为苹果手机需要不停迭代产品，否则就还是可能被淘汰。但是可口可乐并不需要改产品，它可以 100 年不改产品，甚至改产品对它是有害的。从产品迭代角度，可口可乐就比苹果手机要更优秀一些。</p><p>可口可乐与茅台酒比，商业模式就又会差一些。因为同样是卖水，茅台卖不掉的酒会随着年份升值，而可口可乐卖不掉的水会过期，只能倒掉。</p><p>所以，商业模式决定了公司的经营难度，商业模式好的公司，CEO 和管理层只要不犯错，公司大概率就不会有问题。</p><h3 id="企业文化和管理层"><a href="#企业文化和管理层" class="headerlink" title="企业文化和管理层"></a>企业文化和管理层</h3><p>除了商业模式外，一家好的公司还应该有优秀的产品和市场团队。我个人认为：</p><ul><li>好的产品应该消费者导向，满足用户的真实需求；尽可能做减法，不做功能的堆叠；以体验优先，而不是以成本优先。</li><li>好的市场活动应该保持克制和理性，不放大功能、不夸大承诺、不投机营销。营销的时候尽量以产品卖点为主，不讲赠品，优惠这些。</li></ul><p>另外，公司有没有长期经营的价值导向，类似于段永平提到的不为清单。在这种文化下，管理层是否贯彻落地了相关的价值导向，而不是说一套做一套。</p><p>除了以上之外，站在股东角度，还需要看管理层是否有回报股东的意愿。这一点在 A 股上特别需要注意。</p><h3 id="价格是否划算（有安全边际）"><a href="#价格是否划算（有安全边际）" class="headerlink" title="价格是否划算（有安全边际）"></a>价格是否划算（有安全边际）</h3><p>如果前两点通过了，那么就到了第 3 点：当前的价格是否划算。</p><p>因为我们没有哪一个人能 100% 预测对未来，所以对于企业的经营风险，也是有可能出现黑天鹅事件的。当出现这类事件后，我们的安全边际就给了我们一些安全垫。另外，虽然买股票是一个长期投资行为，但我们多年以后，还是可能会有卖出的需求，有了安全边际，在卖出的时候股价偏离真实价值的可能性就会更低一些。</p><h2 id="长期主义的毛估估"><a href="#长期主义的毛估估" class="headerlink" title="长期主义的毛估估"></a>长期主义的毛估估</h2><p>段永平的价值投资特点还在于长期主义的毛估估，用定性的评估代替定量的计算。他说：</p><blockquote><p>我觉得所谓未来现金流的定性分析比定量分析要重要的多，用公式的人往往会陷于细节而忽略整体。</p></blockquote><p>当年段永平投资网易，就是看到游戏行业的巨大，认为网易很可能估计涨到百亿。这种长期主义的感性评估，使得段永平不必特别计算回报的年限和当前的财务水平，只需要足够多的耐心就可以收获到百倍以上的回报。</p><p>长期主义的毛估估，这种做法很容易找到当下被低估的成长型企业。而且看准之后收获是十倍百倍的，所以很值得学习。网易就是一个案例。</p><p>用长期主义的毛估估，也可以敢于对当下偏贵的股票下手，因为长期主义来看，当前贵的股票其实长期看起来并不贵。段永平对苹果公司的投资就是一个案例。</p><p>巴菲特曾经说过：“当时喜诗糖果如果再贵 500 万美元，他就不会买了，现在看起来真是太愚蠢了”。这也是同样的道理。</p><p>但是困难点就在于能够看这么远不容易，需要对某个行业有较深刻的认识，才能够拿得住股票，穿越股价的波动，不被外界影响。所以段永平说，他花两年才能看懂一家企业。</p><h3 id="快速折现法"><a href="#快速折现法" class="headerlink" title="快速折现法"></a>快速折现法</h3><p>我基于段永平的毛估估思想，想了一个快速折现的方法，仅用于那种营收相对稳定的公司计算现金流折现。</p><p>具体方法是：我们假设这家公司每年的利润是 100 元，在未来 10 年内不会有大的利润差异。快速的毛估估以 7% 的现金流折现算，因为 72 法则，所以大概 10 年后的现金 100 块，在现在就只值 50 块了。于是，我们可以用简单的等差数列求和（其实不是等差数例）来估算 10 年的现金流总和：<code>sum = (50 + 100) * 10 / 2 = 750</code>。</p><p>这与用等比数列求和公式<code>sum = a1*(1-q^n)/(1-q), q=1/1.06</code>计算出来的和 780 相差无几(误差 5% 以内）。</p><h2 id="对股价波动的理解"><a href="#对股价波动的理解" class="headerlink" title="对股价波动的理解"></a>对股价波动的理解</h2><blockquote><p>市场短期看是投票器，长期看是称重机。—-格雷厄姆。</p></blockquote><p>短期的股价是由供求（买卖量）决定的，长期股价是由价值决定的。因为股价如果偏离价值太多，最终会被各种行为纠正。这种纠正包括：财报数据、回购、分红、甚至私有化。</p><p>总之，纠正股价偏离行为的底层支持是价值背后的现金流。关于这个，段永平举了一个具体的例子：假如市场就是不喜欢网易，网易股价一直在几千万市值，然后如果网易一年能够赚 20 亿美金，这个时候，网易的赢利能力一定能够让股价回归。</p><h2 id="企业价值-Enterprise-value"><a href="#企业价值-Enterprise-value" class="headerlink" title="企业价值 Enterprise value"></a>企业价值 Enterprise value</h2><p>相对于 PE，段永平提出了 EE 的概念，第一个 E 指的是企业价值 Enterprise value。具体来说，<code>企业价值 = 市值 + 负债 - 现金</code>。段永平希望用这种方式把企业的债务也算到你拥有这家企业付出的潜在成本。当然，企业的现金就是你拥有它的直接收益，所以减掉。</p><p>整个概念还是建立在“买股票就是买公司”基础逻辑下。因为如果你买下一家公司，理论上这家公司的债务也被你买下了，所以这部分的成本不能不看。</p><h2 id="如何能拿住百倍的增长"><a href="#如何能拿住百倍的增长" class="headerlink" title="如何能拿住百倍的增长"></a>如何能拿住百倍的增长</h2><p>段永平分享了他如何拿住网易，收获了超过 100 倍的回报的。</p><blockquote><p>能够拿得住最主要原因还是对公司及其业务的了解，还有就是平常心，不要去想买入的成本，把焦点放在能理解的未来现金流上。</p></blockquote><p>在不断 review 自己拥有的公司的赢利能力的时候，如果逻辑没有变，就可以持续持有。</p><h2 id="投资用闲钱，晚上能睡觉"><a href="#投资用闲钱，晚上能睡觉" class="headerlink" title="投资用闲钱，晚上能睡觉"></a>投资用闲钱，晚上能睡觉</h2><p>段永平强调了投资要用闲钱，这样万一亏了，也不会影响生活质量。</p><p>另外，买入的资产不管怎么波动，都需要晚上能睡得着觉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这本书其实不那么正式，都是段永平在雪球上的发贴，但是质量挺高的，现在很难得有经营成功的企业家写书传道，所以能通过他的贴子学到东西还是挺值的。另外，段永平的很多观点很难一下子理解，还是值得多读一读，常读常新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近读了《段永平投资回答录》，分为商业逻辑篇和投资逻辑篇。一些感受深的点记录一下。&lt;/p&gt;
&lt;h2 id=&quot;不为清单&quot;&gt;&lt;a href=&quot;#不为清单&quot; class=&quot;headerlink&quot; title=&quot;不为清单&quot;&gt;&lt;/a&gt;不为清单&lt;/h2&gt;&lt;p&gt;段永平说：我们之所以成为我</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>在 VS Code 中使用 cin 输入数据</title>
    <link href="https://blog.devtang.com/2024/09/27/use-cin-in-vscode/"/>
    <id>https://blog.devtang.com/2024/09/27/use-cin-in-vscode/</id>
    <published>2024-09-27T14:18:03.000Z</published>
    <updated>2024-11-07T01:14:43.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>默认在 VS Code 中，我们无法使用 cin 输入数据。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>步骤如下：</p><ul><li>安装 <code>Code Runner</code> 插件</li><li>按 <code>command + ,</code>进入设置页面，输入 <code>Run in Terminal</code></li><li>勾选上 <code>Whether to run code in Integrated Terminal.</code></li></ul><p>如下图所示：</p><img src="/images/code-runner.jpg" class="">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;默认在 VS Code 中，我们无法使用 cin 输入数据。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>第一性原理思考：解决问题的通用框架(续)</title>
    <link href="https://blog.devtang.com/2024/09/19/thinking-pattens/"/>
    <id>https://blog.devtang.com/2024/09/19/thinking-pattens/</id>
    <published>2024-09-19T04:59:03.000Z</published>
    <updated>2024-09-21T13:51:33.138Z</updated>
    
    <content type="html"><![CDATA[<p>我在<a href="/2024/09/06/problem-solving-structure/">《第一性原理思考：解决问题的通用框架》</a>介绍了一种思考解决问题的通用框架。其中的第 3 步：信息判断是制定解决方案的核心步骤，但我在原文中讲得比较笼统，这次再展开详细介绍一下。</p><p>信息判断有很多种方式和方法，我想先重点介绍几种我认为比较有用的判断方式，最后再介绍一些常见的信息判断的误区。</p><h2 id="28-原理"><a href="#28-原理" class="headerlink" title="28 原理"></a>28 原理</h2><img src="/images/28-principle.jpg" class=""><p>我们在框架的第 1 步信息收集中，已经将问题相关的各种因素收集得比较全面。这个时候我们会发现，信息通常会非常丰富。而且，通常正面和反面的信息都有，这个时候信息判断决策就会比较困难。这个时候，我就需要用 28 原理，来找到最最核心的因素。</p><p>大自然其实就告诉了我们这个原理。在自然界，如果影响一个事情的因素有 10 个，那么这 10 个因素每个刚好权重占比 10%，是从来没有的现象。大部分时候，大自然的事物呈正态分布，核心的 20% 的因素对结果产生了 80% 的影响。</p><p>举几个真实的案例。</p><h3 id="案例一：优化内容"><a href="#案例一：优化内容" class="headerlink" title="案例一：优化内容"></a>案例一：优化内容</h3><p>我在负责小猿搜题的时候，我们想优化题目解析的呈现。该工作最极致的优化做法，就是请老师为每一道题目录制一个 5 分钟左右的视频讲解。但是，我们有 2 亿道题目，如果全部优化一遍，我们的成本巨大，这个想法将变得不可执行。</p><p>在讨论方案的时候，我们想到这个问题或许符合 28 原理，于是我们将学生的搜索结果进行统计。结果发现，80% 的搜索结果落在了大概 500 万道题目上。于是，2 亿的工作量一下子缩减了 97.5%，我们只需要做不到 5% 的工作，就可以将题目呈现体验提升 80%。</p><h3 id="案例二：优化硬件产品"><a href="#案例二：优化硬件产品" class="headerlink" title="案例二：优化硬件产品"></a>案例二：优化硬件产品</h3><p>利用 28 原理做产品决策的“减法”也同样很有效果，特别是硬件产品。对于硬件产品来说，每一项功能的生产成本与功能的使用频率不成正比。核心的功能占到了 80% 以上的使用时间，但核心功能的成本占比通常不到 80%，这个时候，聚焦提升核心功能体验，减少非核心功能的开发，都是对 28 原理的应用。</p><h3 id="案例三：填报志愿"><a href="#案例三：填报志愿" class="headerlink" title="案例三：填报志愿"></a>案例三：填报志愿</h3><p>我高考完面临填报志愿选专业，我自己喜欢计算机专业，但是呢，我的分数不够上 985 学校里面计算机专业较强的大学。于是我的决策因素就有很多，要不要换专业，如果不换选哪个学校的计算机专业。这方面的考量因素很多，比如：</p><ul><li>地域。我应该选哪个城市？</li><li>学校。我应该选哪个学校？</li><li>专业排名。这个学校的计算机专业排名是多少？</li><li>竞争激烈度。其他人会抢这个专业吗？我的胜算是多大？</li><li>就业难度。这个专业方向好就业吗？</li><li>就业薪资。就业薪资是多少？</li><li>兴趣。我对哪些专业有兴趣？</li><li>风险。落榜的风险。</li></ul><p>最后我花了很长时间，首先决定还是以兴趣做为第一导向，选择了计算机专业。然后优先挑选了北京的学校，因为我觉得北京离互联网行业近，可以有比较多的机会实习。最终我选择了北师大的计算机系，虽然这个专业在院校排名里面较为靠后。</p><p>在我的逻辑里面，“兴趣”就是占据 80% 权重的因素。因为有兴趣，才有可能付出比别人多，做得比别人好。相比兴趣，别的因素都不那么重要。事实证明，我的决策还是对的。我对计算机的兴趣帮助我在学习和工作中都保持了较高的投入度，进而获得了比较大的正面回报。我也在研究生阶段获得了 在 IBM 和网易的实习机会。当然，我的运气也不错，赶上了互联网行业的红利期。</p><h2 id="谬误推导"><a href="#谬误推导" class="headerlink" title="谬误推导"></a>谬误推导</h2><img src="/images/if-right.jpg" class=""><p>“谬误推导”这个词是我生造的，因为我还没有找到合适的词语用于描述这种思维方式。</p><p>谬误推导是指：假设某个观点是真理，然后按照原本的逻辑推导演绎，现实世界应该会是什么样。如果推出一个与现实世界相反的结论，就说明之前的观点有误。</p><p>我有两次明显体会到谬误推导的实际用处，分享给大家。</p><h3 id="案例一：民宿是不是一个好生意"><a href="#案例一：民宿是不是一个好生意" class="headerlink" title="案例一：民宿是不是一个好生意"></a>案例一：民宿是不是一个好生意</h3><p>有一年的春节，我在京郊租了一个大院子，想体验一下退休之后的田院生活。过去之后，我发现京郊有很多人把自己的宅基地改造成这种居住体验良好的民宿，然后出租获利。然后我就很好奇这是不是一个好生意，加上当时我们有“租一个院子没事去过周末”的想法，所以我们把那个村待出租的院子都考查了一番，也问了一下价格。</p><p>最后我花了一些时间，结论是：这不是一个好的生意。里面涉及的原因有很多，但我主要测算了一下财务回报模型，发现这个事情回报率太低。另外居住的新鲜感过去之后，因为远离城市会有各种不便，整体体验也不算太好。</p><p>当我把自己的逻辑分享给 gcz 的时候，他直接用了“谬误推导”来判断，他说：<strong>如果这个事情成立，那么民宿就应该产生规模化的品牌，但现在显然没有，说明这个事情不靠谱。</strong></p><p>我当时惊了，我想：这不符合“第一性原理”呀！看事情不应该从本源去思考吗？但是我又一想，“谬误推导”还是很有价值的，因为：</p><ul><li>“谬误推导”很快，我们在工作中的很多事情权重不高，深入研究一个事情的本质原因性价比太低。</li><li>“谬误推导”还是为第一性原理思考提供了快速的反面证据。如果要推翻这个“谬误推导”，我们容易找到那个核心问题。</li></ul><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>段永平分享过一个在步步高的案例。当时步步高每年的广告费用很大，有高管提出：我们的广告费用这么高，不如我们自己做广告公司。因为这样，我们首先不愁客户，我们自己就是自己的客户。然后别的东西我们可以学，我们也可以招成熟广告公司的人，我们很努力，假以时日，我们肯定可以做得比较优秀。</p><p>段永平用“谬误推导”拒绝了这个提议，他说：我不知道这里面有什么逻辑问题，但是我知道我们肯定做不成。因为：<strong>如果这个假设成立的话，世界上最大的广告公司应该是”可口可乐广告公司”和“宝洁广告公司”。但显然并不是，所以我们做广告公司这件事情一定不成立。</strong></p><h2 id="终局思维"><a href="#终局思维" class="headerlink" title="终局思维"></a>终局思维</h2><img src="/images/long-term.jpg" class=""><p>终局思维是把一个事情的发展看长远，从而忽略掉短期因素的影响。人们天然对身边刚刚发生的事情赋予巨大的权重，而把过去很久发生的事情赋予较低的权重，但这个是不对的。终局思维可以帮助我们看到影响事情发展的核心因素。</p><p>终局思维可以帮助我们做难而正确的事情。有一些事情决策成本巨大，比如：猿辅导要投入力量做 AI 研究院，这方面的工作非常费钱，而且短期可能看不到产出。但是如果我们用终局思维想：未来的教育产品是否需要 AI 赋能？答案就会更容易一些。</p><p>又比如，一些错误决策已经做了，有一些沉没成本已经投入了，是立即纠正，还是慢慢收缩调整？如果站在终局思维，那么就应该尽快调整，因为如果未来是要调整的，那么每提前一天都是减少更一步的损失。所以段永平说：<strong>「发现错误立即改正，不管付出多大的代价，都是最小的代价；不改正错误，将付出更大的代价」。</strong></p><p>用终局思维看待每一次失败，失败也显得不那么重要了。如果失败没有导致个人信心丧失，反而激发出更强的斗志，同时我们又从失败中吸取了教训，那么失败是个人迈向成功的必经之路。</p><p>再说两个案例。</p><h3 id="案例一：直播带货"><a href="#案例一：直播带货" class="headerlink" title="案例一：直播带货"></a>案例一：直播带货</h3><p>拿直播带货来说，每一次直播带货事故都会对达人品牌产生不利影响，虽然短期的影响可能不大，但是这反映出达人团队的品质把控上的能力问题。长期来看，必将影响消费者在达人直播间购物的心智。所以这么来看，如果不有效解决带货品质问题，小杨哥直播间长期很难存活。</p><p>长期来看，如果直播带货的规模巨大，势必对人们的生活产生重大影响，规范直播带货中的各种宣传用语是必然的。在这个过程中，没有做好准备的达人都会被时代抛弃。</p><h3 id="案例二：挑选领导-下属-伙伴"><a href="#案例二：挑选领导-下属-伙伴" class="headerlink" title="案例二：挑选领导&#x2F;下属&#x2F;伙伴"></a>案例二：挑选领导&#x2F;下属&#x2F;伙伴</h3><p>终局思维可以用来挑选下属、上级和合作伙伴。如果你有一个合作伙伴，每次都出会一些问题，虽然没有出大事，但是长期来看，它必将影响你的生意，早日换掉他就是一个明智的选择。公司内的上下级共事也一样可以用终局思维，如果做不到上下同欲，下属必然在未来会遭遇误解，那么与其这样，不如用脚投票，离开他不欣赏的上级。</p><!-- 没想到怎么与决策联系，感觉更像是一种心理调整## 底限思维思考一些坚难决策的时候，把决策的最差情况考虑进来，看看自己能不能接受，如果最差的情况自己也能接受，那么就可以放心了。比如：刚刚说的上下同欲很重要，如果你对老板不欣赏，想离职。最差的情况会怎么样？你如果能接受这个最差情况，那么就可以考虑执行你的想法。如果你接受不了，那就想别的方案。--><h2 id="批评观点的-4-种角度"><a href="#批评观点的-4-种角度" class="headerlink" title="批评观点的 4 种角度"></a>批评观点的 4 种角度</h2><p>这是我从<a href="/2016/01/17/how-to-read-a-book-summary/">《如何阅读一本书》</a>中学到的方法，作者认为，批评别人的观点只能有 4 种：</p><ul><li>证明观点的知识不足。</li><li>证明观点的知识错误。</li><li>证明观点不合逻辑。</li><li>证明观点的分析与理由是不完整的。</li></ul><p>如果你不能用相关证据显示作者是知识不足、知识有误，或不合逻辑，你就不能反对他。</p><p>很多人面对一些结论的时候，表现出强烈的反对，但是如果你发现他不能按以上标准来反对的话，就说明他并不真正在反对，只是「不喜欢」这个结论，而这只是在表达一种情绪或者偏见。我们应该尽量避免陷入情绪中，或者至少应该在陷入情绪中时，知道自己当前只是在发泄，而不是在讨论问题。</p><p>我们在下结论的时候，也可以用这 4 点去检查一下，自己有没有知识不⾜、知识错误、不合逻辑等问题。</p><h2 id="信息判断的误区"><a href="#信息判断的误区" class="headerlink" title="信息判断的误区"></a>信息判断的误区</h2><p>再说说一些信息判断的误区。</p><h3 id="误区一：把相关性当因果"><a href="#误区一：把相关性当因果" class="headerlink" title="误区一：把相关性当因果"></a>误区一：把相关性当因果</h3><p>很多人把相关性归纳到因果上面。驳倒这个误区最有趣的论述就是：医院是死亡率最高的地方，所以我们应该远离医院。</p><p>作为练习，请思考下面的论述有什么问题：</p><blockquote><p>统计显示，⼤部分喜欢吸烟的⼈肺癌发病率⽐不吸烟的⼈⾼ 10 倍，所以吸咽导致肺癌。</p></blockquote><p>｜<br>｜<br>｜<br>｜<br>｜<br>｜请想一想再往下翻答案<br>｜<br>｜<br>｜<br>｜<br>｜<br>｜</p><p>答案：喜欢吸烟与肺癌只能通过上面的统计证明相关，但是不能推导出因果关系。著名的统计学家 Fisher 就喜欢吸烟，他举了一个反驳的例子：有没有可能有一种基因，带有这种基因的人会喜欢吸烟，同时，这种基因会导致肺癌发病率高。这样，不管这类人抽不抽烟，他们因为带有这种基因，所以都会有较高肺癌发病率。</p><p>关于这个误区，<a href="https://www.youtube.com/watch?app=desktop&v=f7LPJihhD1s">这里</a>还有更多的资料（需要梯子）。</p><h3 id="误区二：从众心理"><a href="#误区二：从众心理" class="headerlink" title="误区二：从众心理"></a>误区二：从众心理</h3><img src="/images/follow-others.jpg" class=""><p>从众效应由美国社会心理学家阿施提出，是一种普遍存在的社会心理和行为，从众心理通常是由于个体受到集体的隐形或者显性的压力，而改变自己的目标，最终选择和多数人一致的意见或行为。</p><p>从众心态在广告学中最佳的应用案例，就是讲自己的产品「销量第一」。当然，咱们不能撒谎，得真的是销量第一的时候才能讲「销量第一」。斑马思维机去年卖了 30 多万台，远远超过第 2 名，我们就找咨询公司做了一下市场调研，宣布自己销量第一。我们公司兄弟部门的产品小猿学练机，也讲自己「销量第一」。</p><p>但是，销量第一的产品就一定最好吗？其实不见得。当年的手机霸主洛基亚，也是曾经的销量第一，不也被苹果超过了。所以，从逻辑上讲，「销量第一」与产品体验第一，只能说具有一定的相关性，无法产生因果推导。</p><p>但是，大家都有从众的心态。「销量第一」就是告诉你，别人都选择了我，你是跟随大众，还是与众不同？大部分人都会选择从众。</p><p>当然，购物决策对个体的影响不大，选择「销量第一」的产品大多数时候也没毛病。但是，当我们在面临重大问题做决策的时候，从众可不一定是一个好的选择。</p><p>很多系统对从众选择会有天然的抑制，比如：</p><ul><li>股票市场，如果大家都跟着舆论买同一支股票，那么股票的价格就会高于其内在价值，造成投资的亏损。</li><li>如果大家高考都报一个专业，这个专业的录取分数就会巨高。</li><li>如果今年苹果非常贵，大家都选择种苹果，那么几年后苹果就会烂大街。“阳光玫瑰”就是一个真实的例子。</li></ul><p>所以，做重大决策的时候，问问自己为什么？如果答案是：因为别人也这样，那就有点危险。</p><h3 id="误区三：现状即是真理"><a href="#误区三：现状即是真理" class="headerlink" title="误区三：现状即是真理"></a>误区三：现状即是真理</h3><img src="/images/reality-is-truth.jpg" class=""><p>现实的一些情况，原因可能很复杂，所以不能把现状做简单归因。</p><p>比如：一个企业家把公司做上市了，挣了上百亿的利润，他就一定很会经营吗？不一定。他也可能做了假账，他也可能吃到了时代的红利，比如恒大。</p><p>比如：中医到底有没有效果？简单认为它在中国存在了上千年就能当证据吗，肯定不能。放血疗法在西医还流行了上千年呢，咱们怎么不认为它有效？那应该怎么证明中医有效？</p><p>比如：有个理财经理给你推荐某个产品，说它过去 5 年年化收益超过 10%。潜台词是说：未来也会这样。那过去的业绩一定能推导出未来的业绩吗？不一定吧。</p><p>对自己的现状分析也很重要，一些人获得了一些成功就很骄傲，觉得自己很厉害，做什么都可以成功。但是成功到底是因为自己的实力还是时代给的机会，如果不能理性分析，就很可能在未来栽跟头。</p><h3 id="误区四：情绪"><a href="#误区四：情绪" class="headerlink" title="误区四：情绪"></a>误区四：情绪</h3><img src="/images/emotions.jpg" class=""><p>情绪是做决策巨大的敌人。股票市场就是贪婪情绪和恐惧情绪的集结地，稍不注意你就被情绪统治了行为，追涨杀跌。</p><p>基于情绪做信息判断和行为有利于情绪在当下的释放，但是相关的后果我们不一能在未来能够承受。所以，更加理智的办法是把情绪的处理和信息的判断分开。</p><p>情绪的问题可以用适当的方式来排解和宣泄。信息判断和决策的问题，还是交给理性。</p><p>另外，我们也需要识别他人的情绪，将他人的情绪与事实分开接收。现在网络上的一些观点，都带有强烈的情绪，我们需要有足够的智慧去分辨它们。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了信息判断的几种框架思维，包括：28 原理、谬误推导、终局思维等。也介绍了一些思维误区，包括：把相关性当因果、从众心理、现状即是真理、情绪等。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我在&lt;a href=&quot;/2024/09/06/problem-solving-structure/&quot;&gt;《第一性原理思考：解决问题的通用框架》&lt;/a&gt;介绍了一种思考解决问题的通用框架。其中的第 3 步：信息判断是制定解决方案的核心步骤，但我在原文中讲得比较笼统，这次再展开详细</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>五分钟弄懂 CSP-J</title>
    <link href="https://blog.devtang.com/2024/09/17/cspj-introduction/"/>
    <id>https://blog.devtang.com/2024/09/17/cspj-introduction/</id>
    <published>2024-09-17T13:51:36.000Z</published>
    <updated>2024-11-07T01:14:31.624Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文约 1500 字，阅读需用时 5 分钟。</p></blockquote><h2 id="什么是-CSP-J"><a href="#什么是-CSP-J" class="headerlink" title="什么是 CSP-J"></a>什么是 CSP-J</h2><p>CSP（Certified Software Professional）全称是中国计算机学会（CCF）主办的“软件能力认证”，它是中国计算机学会为了提高计算机软件人才的专业水平而设立的一项专业技能认证。CSP 认证分为两个级别：CSP-J（Junior，入门级）和CSP-S（Senior，提高级）。</p><p>因为该认证主要用于选拔 NOIP 选手，所以认证的报名通道仅向各中小学的计算机老师开放。</p><p>比赛在每年的 9 月开学之后进行，比赛分为两轮。第一轮为笔试，第二轮为上机。第一轮通过之后，才能参加第二轮。2023 年 CSP-J 第一轮的通过分数线为 63 分。</p><p>比赛报名的官方网站为 <a href="https://www.noi.cn/">https://www.noi.cn/</a>，<a href="https://www.noi.cn/xw/2024-07-16/827939.shtml">这里</a>有官方关于 CSP-J 的更多介绍。</p><h2 id="信息学相关比赛的分类"><a href="#信息学相关比赛的分类" class="headerlink" title="信息学相关比赛的分类"></a>信息学相关比赛的分类</h2><p>参加信息学比赛，按打怪升级的过程，可以是从 GESP 考级开始。GESP 每 3 个月就有一次考级，可以及时检验学习成果。平均 3 个月就可以完成一个级别的知识学习，在学习初期，正反馈的频率还比较高。</p><p>以下是各个比赛面向的人群和获奖难度。</p><table><thead><tr><th>比赛名</th><th>面向人群</th><th>获奖难度</th></tr></thead><tbody><tr><td>GESP</td><td>小学生+初中生</td><td>共 8 级。GESP 7 级 80 分或 8 级 60 分，可<a href="https://gesp.ccf.org.cn/101/1002/10144.html">跳过 CSP 第一轮</a></td></tr><tr><td>CSP-J</td><td>小学生+初中生</td><td>各省约前 20% 可拿省一等奖</td></tr><tr><td>CSP-S</td><td>高中生</td><td>各省约前 20% 可拿省一等奖</td></tr><tr><td>NOIP</td><td>高中生</td><td>各省约前 20% 可拿省一等奖</td></tr><tr><td>NOI</td><td>高中生</td><td>2024 年总获奖率为 85%，前 50 可获金奖</td></tr><tr><td>IOI</td><td>高中生</td><td>代表中国参加全球的比赛</td></tr></tbody></table><p>大部分小学生和初中生的目标是 CSP-J，获得一等奖可以被各大重点高中点招。</p><p>大部分高中孩子的目标可能在 NOIP 的一等奖，因为有了这个奖项，就可以被保送或者自主招生降分录取，高考的压力会小很多。我当年就是有 NOIP 的奖项，获得了北师大的自主招生参考资格（当时全国只有 50 个资格），然后考试通过了北师大的自主招生。</p><h2 id="CSP-J-的获奖难度"><a href="#CSP-J-的获奖难度" class="headerlink" title="CSP-J 的获奖难度"></a>CSP-J 的获奖难度</h2><p>我做了一个《北京 CSP-J 近五年比赛情况》表，如下：</p><img src="/images/cspj-1.jpg" class=""><p>从中可以看到：</p><ul><li>初赛报名人数逐年增长，每年增长都在 10% 以上。22 年和 23 年分别增长了62% 和39%</li><li>第一轮初赛的通过率逐年下降，每年最少下降 2pp，23 年通过率为 24%</li><li>复赛获奖率非常高，即便是最低的 2023 年，也有71% 的孩子在复赛中获奖</li></ul><p>虽然报名人数在增加，但好消息是：复赛中一等奖的获奖人数是基本按照复赛人数来计算的，得奖比例约为 20%，所以参赛人数越多，一等奖的名额就越多。</p><h2 id="几年级可以拿到-CSP-J-一等奖"><a href="#几年级可以拿到-CSP-J-一等奖" class="headerlink" title="几年级可以拿到 CSP-J 一等奖"></a>几年级可以拿到 CSP-J 一等奖</h2><p>获得 CSP-J 一等奖的年级分布如下，绝大多数（74%）的孩子都是在初二或者初三，才能获得 CSP-J 一等奖。</p><img src="/images/cspj-2.jpg" class=""><p>但是，也有少量的优秀小学生（约6%），可以在小学阶段就拿到 CSP-J 一等奖，这样的学生在 2022 年有 146 人。</p><img src="/images/cspj-3.jpg" class=""><h2 id="CSP-J-的备赛准备"><a href="#CSP-J-的备赛准备" class="headerlink" title="CSP-J 的备赛准备"></a>CSP-J 的备赛准备</h2><p>CSP-J 的最佳备赛年龄是 4 年级的上学期。因为，CSP-J 的比赛在每年的 9 月份，如果从 4 年级上学期开始备赛，那么就可以有整整两年来准备。但如果从 5 年级开始备赛，那么备赛时间就只有 1 年了。</p><p>是 4 年级不是 3 年级或更早的原因是：孩子在 4 年级的智力水平发育程度相对比较容易接受 C++ 这种比较抽象的编程语言。更早的年龄还是以兴趣培养为主较好，编程语言也可以选择 Scratch 或者 Python。但到了 4 年级，就应该学 C++ 了。</p><p>因为 C++ 语言是官方比赛语言，所以准备的时候应该直接从 C++开始，否则后期还涉及语言的切换，会浪费更多的备赛时间。</p><p>CSP-J 的备赛分为如下 3 个阶段，总共约 600 小时（240 小时上课，360 小时练习）：</p><ul><li>C++ 语言学习。约 24 课时。</li><li>数据结构。约 24 课时。</li><li>算法。约 192 课时。</li></ul><p>总课时约 240 小时，再加 360 小时以上的练习。</p><p>一般孩子如果从 4 年级开始，每周上 2 小时的课，完成作业 3 小时，那么就需要 120 周，差不多两年的时间还差一点。如果暑假再补一些时间进去，就刚刚够学习时长。</p><p>以上是冲着全国只有 146 人达成的“小学生阶段拿一等奖”为目标的训练方式。如果目标不那么激进，按大部分学生的学习进度，在初二获奖一等奖。那么准备时间就多了 1 倍，有 6 年级和初一整整两年。而且中间可以多次参赛，积累比赛经验。这样获奖的可能性就大大增加了。</p><p>所以，理性一点的目标是：</p><ul><li>小学 4 年级开始准备</li><li>小学 6 年级能够进入复赛</li><li>初中 1 年级保二等奖，争一等奖</li><li>初中 2 年级争一等奖</li><li>初中 3 年级参加 CSP-S</li><li>高中 1 年级争 CSP-S 和 NOIP 二等奖</li><li>高中 2 年级争 CSP-S 和 NOIP 一等奖</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>我也在指导一个北京的五年级孩子学习编程，准备 CSP-J，现在学习完 40 课时（约 5 个月时间），已经通过了 GESP 2 级。欢迎同行和家长联系我一起交流，我的微信：tangqiaoboy 。</p><img src="/images/cspj-4.jpg" class=""><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文约 1500 字，阅读需用时 5 分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是-CSP-J&quot;&gt;&lt;a href=&quot;#什么是-CSP-J&quot; class=&quot;headerlink&quot; title=&quot;什么是 CSP-J&quot;&gt;&lt;/a&gt;什么</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>西贝创始人贾国龙的成与败 - 读《折腾不止》</title>
    <link href="https://blog.devtang.com/2024/09/17/talking-with-xibei/"/>
    <id>https://blog.devtang.com/2024/09/17/talking-with-xibei/</id>
    <published>2024-09-17T06:01:11.000Z</published>
    <updated>2024-09-17T10:38:33.529Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/talk-with-xibei-book-cover.jpg" class=""><p>最近读完了李翔写的《折腾不止 - 西贝创始人贾国龙的成败与蓝图》，有一些感悟，记录一下。</p><h2 id="市场规模"><a href="#市场规模" class="headerlink" title="市场规模"></a>市场规模</h2><p>餐饮行业整个市场的规模非常大，中国大概有 5 万亿的市场规模。但是基本上都是很小规模的店。</p><p>从规模化角度看，现在中国最大的中餐品牌是海底捞，营收大概有 400 亿，剩下的公司都没有过百亿。几十亿营收的公司有：九毛九（旗下有太二酸菜鱼），营收 40 亿；呷哺呷哺，营收 40 亿。</p><p>西贝也属于几十亿营收这个梯队，23 年营收 62 亿。</p><p>餐饮行业的市场规模看起来是可以 “抗通胀的”，我想到的原因是：</p><ul><li>餐饮行业的人力成本是重要的一部分支出，人力工资每年在增长。</li><li>原材料成本会通胀。</li></ul><p>我也简单查了中国统计局数据，过去 10 年中国餐饮行业的市场规模一直在增长。其中：</p><ul><li>2014 年餐饮收入达 29000 亿元</li><li>2017 年餐饮收入达 39100 亿元</li><li>2023 年餐饮收入达 <a href="https://www.stats.gov.cn/sj/zxfb/202401/t20240116_1946619.html">52890 亿元</a></li></ul><p>所以，餐饮行业从规模上看，是一个挺好的行业。只是能够一直坚持做好的企业不多。比如以前很火的小肥羊、俏江南，现在就已经销声匿迹。</p><p>贾国龙把西贝的成功，主要还是归因于战略选择的成功和时代机遇。其中核心的战略选择环节是：进北京、边缘开大店、进商场、全国开店。时代红利是指赶上了商业综合体的红利，很多商场给的租金比较低。</p><p>但是西贝能够持续稳定经营，还是来源于自身独特的定位（小店、小贵、儿童友好），以及对菜品品质的把控。</p><h2 id="定位的讨论"><a href="#定位的讨论" class="headerlink" title="定位的讨论"></a>定位的讨论</h2><p>贾国龙认为：定位理论虽然对，但是国内把它教条化了。好象除了它对，其他都错。定位理论是“小山头理论”，他们认为这是企业的唯一选择。但企业还可以做草原、做大海，为什么非得做小山头呢？</p><p>这让我想起来小米，小米用这个品牌做手机、做智能家居、也做汽车。看起来现在发展得还行。我相信雷军肯定是读过《定位》的，有一次别人问他为什么，他说小米想做“人车家全生态”，只有都用小米这个品牌，用户才能接受这样的定位。</p><p>美团也是一个案例。美团现在不停讲美好生活，大家慢慢就把美团与生活服务关联上，这样美团买药，外卖，团购，用美团这个品牌都不违和。</p><p>我认为这种“大草原”的品牌，最大的风险还是某一方面的产品投入不够，从而把整个集团的品牌损害了。记得我大学的时候是联想的无脑粉，于是第一款 MP3 买了一款联想的产品，当时其实比别的牌子要贵，但是我觉得联想这个品牌我信得过。后来我发现，这个 MP3 的产品力其实很一般，所以我的心智就变成了：“联想这家公司做 PC 还行，做别的不太行”。所以，如果不是战略选择，就不要轻易用集团品牌。</p><p>书中提到贾国龙做新的餐饮店，君智战略咨询的董事长谢伟山建议用新品牌贾国龙也采纳了。因为新品牌做失败了，大家不会因此对西贝有什么联想。</p><p>不止只是贾国龙，华与华的老板华杉也在批判定位理论（下图）。华杉认为：独特的销售主张（USP）比定位更重要。而定位理论的几个逻辑都有问题，华杉认为：</p><ul><li>定位理论说：顾客导向的时代已经过去，竞争导向的时代来临。但其实我们现在大部分成功的公司，还是因为服务好了顾客才成功，而不是因为把竞争对手打败才成功。</li><li>定位理论要求有足够强的营销资源，但是实际上很多产品的市场规模和利润都无法支撑足够多的营销资源。</li></ul><img src="/images/talk-with-xibei-1.jpg" class=""><p>所以，关于“定位”，贾国龙说得很好：“没有对错，需要具体情况具体分析”。所以，这本书让我对定位理论「去魅」了。</p><h2 id="定价的讨论"><a href="#定价的讨论" class="headerlink" title="定价的讨论"></a>定价的讨论</h2><p>贾国龙提到顾问孟庆祥给他的三个启发，分别是：</p><ul><li>产品要匹配营销</li><li>应该要投入研发，增加产品竞争力</li><li>有竞争力的产品，才有定价权</li></ul><p>我很认同以上观点。小贵的产品，才有竞争力。因为小贵才能支持研发和营销的成本。</p><p>斑马的硬件产品也一直秉承这样的理念。我们的斑马思维机、斑马拼音机等产品都是属于同行中较贵的产品。但是，这并不代表我们有着暴利。我们只是把创新的成本、产品品质的成本都放到了定价中，以便维护斑马一直以来给用户的高品质的感受。</p><h2 id="海底捞的竞争力来自于淘汰"><a href="#海底捞的竞争力来自于淘汰" class="headerlink" title="海底捞的竞争力来自于淘汰"></a>海底捞的竞争力来自于淘汰</h2><p>海底捞对业务在最后 10% 的人淘汰。海底捞因为是一个个的单店模型，所以很容易横向比较。每一个层级岗位的干部，都有相对明确的业绩产出，这个时候，如果业绩产出不行，从结果上就比较好判断。</p><p>末位淘汰也给了海底捞其他干部一定程度上的危机感，避免大公司懒散的文化。</p><h2 id="一些不好的感受"><a href="#一些不好的感受" class="headerlink" title="一些不好的感受"></a>一些不好的感受</h2><p>贾国龙的一些话也给了我不太好的感受。</p><p><strong>第一个：他喜欢下指标。</strong> 比如他说中国堡一年要开 365 家店，KPI 是很容易让人走偏的管理方式。又比如说，XXX 年要上市，要做到 XXX 亿。但他也有一个对这个不好习惯的“补丁”，就是会朝令夕改。比如第二次访谈的时候，他就表示贾国龙中国堡开了 50 家就暂停了，因为发现很多问题需要解决。</p><p>有了这个补丁，大家会对他说话的权威性降权，难怪他有一个高管说，对他唯一的不满就是老变。</p><p><strong>第二个：贾国龙把“做大做强”作为经营的最顶层目标。</strong>他为了达成这个目标，选择了更容易规模化的快餐方向，选择了学习麦当劳。在中国堡这个产品上，也有着极强的麦当劳的影子。</p><p>虽然贾国龙也知道产品为王，懂得 MVP 来验证产品需求。贾国龙也懂得风险控制，一直用合适比例的利润来做这类的探索。但是，我始终认为，“消费者导向”（用户需求）才是驱动企业增长的最顶层原因。</p><p>在“做大做强”的目标下去寻找用户需求，不知道会不会更加短视，更加急功近利，又或者是提高风险，都是未知数，所以我不太喜欢。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>贾国龙作为西贝的 100% 控股的股东、老板、创始人。一个在餐饮行业深耕 30 多年的创业者。有着异于同行的各种优秀品质。他热爱学习，懂得餐饮的经营管理，又有着强烈的成长和创新动机。</p><p>在西贝核心业务每年贡献几个亿利润的情况下，他不停地创新和成长，我从他身上看到了一个企业家对自身成就的不懈追求。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/talk-with-xibei-book-cover.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;最近读完了李翔写的《折腾不止 - 西贝创始人贾国龙的成败与蓝图》，有一些感悟，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;市场规模&quot;&gt;&lt;a href=&quot;#市场规</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>第一性原理思考：解决问题的通用框架</title>
    <link href="https://blog.devtang.com/2024/09/06/problem-solving-structure/"/>
    <id>https://blog.devtang.com/2024/09/06/problem-solving-structure/</id>
    <published>2024-09-05T19:47:11.000Z</published>
    <updated>2024-10-27T03:28:56.463Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/problem-solve-1.jpg" class=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>马斯克运用第一性原理成功创立了 SolarCity、特斯拉、SpaceX。我们在生活和工作中，也会涉及很多需要解决的未知问题。大多数时候我们都听从于「长辈经验」，这种决策方式大多数时候是对的，但是对于创新工作或者重要决策却可能是一个灾难。</p><p>我结合自己的工作实践，总结出一个基于第一性原理的思考框架，希望可以帮助大家重建问题分析的通用框架。</p><p>我应用这个通用框架解决以下各种工作上的问题：</p><ul><li>如何提升 iOS 开发水平</li><li>如何优化直播间销量</li><li>如何在韩国卖斑马思维机</li></ul><p>作为案例，我也教大家用这个框架解决以下生活问题：</p><ul><li>减肥没效果怎么办</li><li>如何找到男&#x2F;女朋友</li></ul><p>希望对你有帮助。</p><h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p>这个框架把解决问题分成 4 步：</p><ul><li>信息收集</li><li>信息建模</li><li>信息判断</li><li>策略迭代</li></ul><p>我们拿一个生活中的问题来举例：<strong>“有个朋友减肥一直没效果，想让你帮忙分析一下”</strong>。</p><img src="/images/problem-solve-2.jpg" class=""><h2 id="第-1-步：信息收集"><a href="#第-1-步：信息收集" class="headerlink" title="第 1 步：信息收集"></a>第 1 步：信息收集</h2><p>当你的朋友给你说减肥没效果的时候，你不要着急给他下诊断出解决方案，不着急说：你一定是缺少运动，或者说一定是吃太多。因为在“减肥没效果”这件事情上的原因可能有成千上万种，你得先找到原因，才能对诊下药。所以，你应该先收集信息。</p><img src="/images/problem-solve-3.jpg" class=""><p>在收集信息上，得做两个大类的信息收集：</p><ul><li>1、收集经验数据</li><li>2、收集原始数据</li></ul><h3 id="收集经验数据"><a href="#收集经验数据" class="headerlink" title="收集经验数据"></a>收集经验数据</h3><p>什么是经验数据？经验数据就是人们在这件事情上已经形成的方法总结。拿减肥来说，不管是小红书还是 B 站，还是微信公众号，上面已经有很多人分享减肥这件事情的经验，有成功的总结，也有常见的失败，这些都是宝贵的经验数据，你应该先收集下来。</p><p>还有哪儿有经验数据？专门的减肥书籍，应该可以找到很多。身边的减肥成功的朋友、健身房的身材管理教练，也是可以去咨询收集信息的重要来源。</p><p>对于减肥来说，以上的信息收集渠道可能就够了。对于一个通用的问题，可供寻找的经验数据源有以下这些供参考：</p><ul><li>查阅类：搜索引擎、ChatGPT、国家统计局资料、专门书籍、知网数据库、行为研究报告</li><li>走访类：专家访谈、用户访谈、实地走访。</li></ul><img src="/images/problem-solve-4.jpg" class=""><p>对于一个你完全不了解的领域，可以用 What-else 研究法。以研究 iOS 开发为例：</p><ul><li>(what) 什么是 iOS 开发？然后你可能通过查找资料发现这是一种移动开发技术。</li><li>(else) 还有哪些是移动开发。你可能找到 Android开发，Windows Mobile 开发等。</li><li>(what) Android 是什么？然后你可能查到这是 Google 出的移动开发技术。</li><li>(else) Google 家还出了哪些开发语言？然后你可能查到 Flutter。</li></ul><p>应用 What-else 研究法，你可以快速扩展自己在该领域的知识点，从而慢慢把知识点连成线，形成经验数据的图谱。</p><h3 id="收集原始数据"><a href="#收集原始数据" class="headerlink" title="收集原始数据"></a>收集原始数据</h3><img src="/images/problem-solve-5.jpg" class=""><p>原始数据是指现场的、未经加工和解释的数据。马斯克在思考如何造火箭的时候，查阅制造火箭的基础原料成本，就是在收集原始数据。这为他进一步利用第一性原理，推测出火箭的制造成本有大幅下降空间提供了基础信息。</p><p>还是说回减肥这个案例，对于这个减肥没效果的朋友，最重要的原始数据是什么呢？</p><p>有人说是他自己是怎么减肥的，这只说对了一半。如果你只是听他讲他是怎么减肥的，那就不是“原始数据“。因为这里面已经有了你的这个朋友的主观判断在里面。这件事情的原始数据应该是你的朋友每天的日常的生活现场和减肥的现场。你应该全程跟着这个朋友，记录下这个现场，这才是最最原始的，未经加工的数据。</p><img src="/images/problem-solve-6.jpg" class=""><p>我很喜欢一个美剧叫豪斯医生（Doctor House），主人公豪斯医生就从来不相信病人的口述，而是像个侦探一样，从各种现场的细节来判断真相，最终找到真实的病因，对诊下药。我想他一定是和我一样明白原始数据重要性的😁。</p><h2 id="第-2-步：信息建模"><a href="#第-2-步：信息建模" class="headerlink" title="第 2 步：信息建模"></a>第 2 步：信息建模</h2><p>有了第 1 步的信息收集工作，我们对问题已经有了足够多的了解，接下来就可以开始第 2 步的信息建模工作了。</p><img src="/images/problem-solve-7.jpg" class=""><p>信息建模的工作分为 3 步，分别是：</p><ul><li>1、拆解问题</li><li>2、找到问题的核心数据指标</li><li>3、数字化&#x2F;自动化地收集核心数据</li></ul><p>拿减肥来说，如果你基于收集到的信息，发现你的朋友主要是运动太少，那么你就可以把减肥问题拆解成「控制摄入」和「提高代谢」两个角度。</p><p>但不同的情况下，拆解问题的角度应该不一样。如果你的朋友是因为心情抑郁暴饮暴食，那么问题就应该围绕心理健康展开拆解。如果你的朋友是因为肥胖症，那么又应该从这个病症的专业治疗角度，展开拆解。</p><p>再举一个例子：iOS 开发水平应该如何提高的？我的拆解是：输入和输出两个角度。</p><ul><li>输入方面：我们可以拆解成阅读博客，阅读图书，看相关的视频，听相关的分享，参加相关的会议，找同事请教等。</li><li>输出方面：我们可以拆解成写总结的文章，代码练习，分享等。<ul><li>代码练习又可以分成：工作上的代码优化、面试题目代码的练习、开源项目的参与等。</li></ul></li></ul><p>我之前也是基于上面的拆解，坚持写了好多年的技术分享，最终出版了《iOS 开发进阶》。</p><p>拆解完问题之后，我们需要将拆解完的指标量化。</p><ul><li>拿减肥的案例来说，我们就应该收集每日摄入的卡路里和身体的代谢率指标。</li><li>拿 iOS 提高的案例来说，我们就应该量化输入和输出的周度、月度、年度目标。</li></ul><p>有了量化的指标，如果我们能够将其数字化记录到系统中，甚至自动化收集它就更好了。</p><ul><li>拿减肥的案例来说，我们用一个软件记录每天的卡路里摄入和代谢率，就很好。</li><li>拿 iOS 提高的案例来说，我们用统计工具记录自己代码练习量，就很好。</li></ul><p>【练习】假如我们的问题是：如何找到男&#x2F;女朋友呢？如果你的信息收集发现，问题主要出在自己太害羞，应该如何拆解问题和量化指标？</p><h2 id="第-3-步：信息判断"><a href="#第-3-步：信息判断" class="headerlink" title="第 3 步：信息判断"></a>第 3 步：信息判断</h2><p>执行完第 1 步和第 2 步，你还不能解决问题，因为前面只是帮你分析了数据，找到了关健的一些指标，具体怎么做并没有解决。</p><p>所以，在第 3 步，你需要根据前面的信息，做判断和决策，制定自己解决问题的「执行方案」。</p><ul><li>拿减肥的案例来说，你需要制定每日控制卡路里摄入和代谢率的具体方法。</li><li>拿 iOS 提高的案例来说，你需要制定输入和输出的具体每日任务目标，以及做合理的时间规划等。</li></ul><img src="/images/problem-solve-8.jpg" class=""><p>如果我们在面对一些创新性的问题，因为可供参考借鉴的案例不多，在制定执行方案的时候，应该尽可能打开思路，用第一性原理去思考。比如：别人造电动车没有电池就放弃了，马斯克的执行方案却是用 7000 多节松下的 18650 电池拼成一个大电池包。</p><h2 id="第-4-步：策略迭代"><a href="#第-4-步：策略迭代" class="headerlink" title="第 4 步：策略迭代"></a>第 4 步：策略迭代</h2><p>你的执行方案不一定靠谱，当你发现过一段时间，关键数据指标并没有变好的时候，就说明你应该停下来思考一下了。在这一步应用 PDCA 环，可以很好地帮助你优化自己的方案。</p><img src="/images/problem-solve-9.jpg" class=""><p>PDCA 包括：</p><ul><li>策略制定（Plan）</li><li>策略实施（Do）</li><li>检查过程，保障策略能够实施到位（Check）</li><li>获得策略数据反馈，调整（Act&#x2F;Adjust）</li></ul><p>有关键数据做指导，你做的任何调整都能带来正反馈（指标变好）或者负反馈（指标变差），这样你很快就能从中总结经验，对问题有更加深入的理解，从而优化自己的执行方案。</p><h2 id="本框架的局限"><a href="#本框架的局限" class="headerlink" title="本框架的局限"></a>本框架的局限</h2><img src="/images/problem-solve-10.jpg" class=""><p>本框架有三个局限：</p><ul><li>只适合解决有原始数据的问题</li><li>只能保证策略尽可能对，不能保证执行到位</li><li>个体的思考和判断是解决问题的核心</li></ul><p>所以，没有银弹，本框架只能帮你尽可能接近真相，真正要解决问题还是得靠你自己的思考、判断和执行。</p><p>以上。更多内容请看：<a href="/2024/09/19/thinking-pattens/">《第一性原理思考：解决问题的通用框架(续)》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/problem-solve-1.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;马斯克运用第一性原理成功创立了 Sola</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何在抖音直播卖货</title>
    <link href="https://blog.devtang.com/2024/09/01/living-selling-101/"/>
    <id>https://blog.devtang.com/2024/09/01/living-selling-101/</id>
    <published>2024-09-01T06:52:02.000Z</published>
    <updated>2024-09-01T14:25:52.578Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/living-head.jpg" class=""><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着抖音日活破 8 亿，短视频和直播已深入我们每一个人的生活。其中，直播电商作为抖音商业化重要的一环，成为很多品牌销售工作的重点。</p><p>我之前写过一篇科普<a href="/2019/08/25/ad-101/">效果广告</a>的文章，帮助很多非广告行业从业者理解效果广告，很多人很喜欢。于是，我想接着这个主题，分享一下抖音直播卖货的基础，如果你没有从事过相关工作，本文可以让你对直播电商有一个基础认知。</p><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p>直播卖货的核心流程分成两步。</p><ul><li>第 1 步：在信息流中投放你的种草短视频素材（或直播间画面），引导用户点进你的直播间。</li><li>第 2 步：在直播间中，完成产品的介绍、答疑，并引导用户下单。</li></ul><p>我们接下来会拆开这两个环节分开介绍。</p><h2 id="短视频素材"><a href="#短视频素材" class="headerlink" title="短视频素材"></a>短视频素材</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们日常在抖音上刷短视频，大概刷 10 条左右，就会出现一条是广告商投放的种草短视频。这个短视频会在右侧有一个直播的效果（如下图），短视频中的口播也会引导你进去直播间。</p><img src="/images/living-video-entry.jpg" class=""><p>除了种草短视频外，广告商也可能将直播画面投放到你的信息流中，引导你进去直播间（如下图）。</p><img src="/images/living-video-entry2.jpg" class=""><h3 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h3><p>对于一个种草短视频来说，平台会评价很多核心的过程指标，最主要的包括：</p><ul><li>点击进直播间的转化率</li><li>进入直播间后，访问商品的转化率</li><li>支付的转化率</li></ul><p>下图是一个案例，呈现出了某个电商直播间的转化漏斗。</p><img src="/images/living-process.jpg" class=""><p>除了以上指标外，我们评价一个种草短视频的好坏，还有一些过程指标，包括：</p><ul><li>5 秒完播率。</li><li>用户点击成本。</li></ul><p>【5 秒完播率】：指用户看完了这个视频前 5 秒的比例。在短视频信息流中，用户很没有耐心，如果不能在前 5 秒抓住用户的注意力，用户手指轻轻上滑，就会把你的视频滑走。而每一次广告的曝光都是要收费的，所以，尽可能提高前 5 秒的完播率，就可以提升进入直播间的点击率。</p><p>【用户点击成本】：通常每一个商品，都有适合自己的点击成本（具体的成本通常是经验数据）。如果点击成本太低，那么：</p><ul><li>短视频可能过于有欺骗性，这会使得直播间的成交转化率相对下降，所以得不尝失。</li><li>用户也可能不精准，比如都是一些好奇心强，但是成交意愿弱的用户。</li></ul><h3 id="种草短视频的类型"><a href="#种草短视频的类型" class="headerlink" title="种草短视频的类型"></a>种草短视频的类型</h3><p>在我们所处的教育行业，一般种草短视频有以下几种类型：</p><ul><li>身临其境 真实感受。例如：“最近我家孩子…”</li><li>附加身份 激发认同。例如：“作为一个海淀妈妈…”</li><li>消费观念 透传实惠。例如：“不到一顿饭的钱…”</li><li>第一人称 情节发展。例如：“直接产品使用视频…”</li><li>软蹭热点 放大痛点。例如：“最近 xxx 新闻大家都看到了…”</li><li>制造噱头 营造稀缺。例如：“不好意思，活动即将结束了…”</li></ul><p>要做好这些短视频，有一些基础的要求：</p><ul><li>需要符合平台和相关的法规。比如不能虚假宣传，不能恶意制造焦虑，不能诋毁竞争对手。</li><li>风格要多样。比如同样的口播文案，在车里拍可能就比在办公室拍效果好很多。但如果大家都在车里拍，你出一个在飞机上拍，效果可能又不一样。总之，风格不要雷同，不然前 5 秒的完播率会很差。</li></ul><p>除了风格尽可能多样外，我个人认为，一个好的种草短视频还是应该尽量讲产品，把产品的核心卖点讲清楚，即便用户当下不买，那么他也会对产品有一个较为清晰的了解，这对品牌来说，可以积累长期的势能。</p><h3 id="利润模型"><a href="#利润模型" class="headerlink" title="利润模型"></a>利润模型</h3><p>如果你了解广告系统，你应该能够理解。每一个种草短视频都是基于 ECPM 进行竞价，本质上你需要尽可能提高自己的广告转化效率，否则你就无法给出市场公允的一个千次展示成本。</p><p>在抖音平台上，千次展示成本大概在 50 - 200 元之间。我们假设你的平均千次展示成本是 100 元，视频点击率是 10%，直播间的支付转化率是 10%，客单价是 100。那么:</p><ul><li>1000 次展示（成本 100 元），能够给你带来：<code>1000 * 10% = 100</code> 次点击。</li><li>100 次点击能够带来 <code>100 * 10% = 10</code> 次成交转化。</li><li>10 次转化能够带来 <code>10 * 100 = 1000</code> 的收入。</li></ul><p>如果你的商品成本是 50 元，那么你每花 100 元广告费，就有 1000 元的收入，扣除 500 元的商品成本和 100 元的广告费，就还有 400 元的利润。</p><p>这就是一个极简的直播利润模型，后面我们会继续完善它。</p><h2 id="直播间"><a href="#直播间" class="headerlink" title="直播间"></a>直播间</h2><p>说完短视频素材，我们再说说直播间。</p><h3 id="循环是直播带货的基本形式"><a href="#循环是直播带货的基本形式" class="headerlink" title="循环是直播带货的基本形式"></a>循环是直播带货的基本形式</h3><p>直播间最基本的功能，就是面对不断进入直播间的用户，完成从产品讲解到引导下单的整个流程。由于每个用户在直播间的停留时间并不长（通常为 1-5 分钟），所以我们需要在非常短的时间内完成从产品讲解到引导下单的过程。而直播间，其实就是在不断循环这个过程。</p><p>我们来看看前一段时间很火的李一舟的直播间是怎么卖人工智能课的（下图）：</p><img src="/images/living-process-example.jpg" class=""><p>李一舟为什么要讲这么简洁？因为如果你随便看一个直播间的在线人数，你就会发现，每一分钟，都有超过 20% 的人离开，又会有超过 20% 的人新进入直播间。下图是一个案例，在该案例中，实时在线只有 22 人，但是每分钟进出直播间的人数分别达到了 18 人和 15 人。</p><img src="/images/living-process-uv-stream.jpg" class=""><p>假如你在线下经营一个“超级卖场”，每 1 分钟会进来 1000 人，同时上 1 分钟进来的 1000 人会离开，你应该怎么办？如果你需要 3 分钟才能讲清楚你的产品，那么不好意思，前面进来的人等不到你讲完就走了，后面进来的人，因为只听到你讲的后一半，不知道你在讲什么。</p><p>你只能抓住这仅有的 1 分钟时间，迅速完成需求挖掘，产品介绍，引导下单的过程。从这个角度看，李一舟的直播话术还挺高效的。但是，李一舟不应该撒谎，“仅有 10 个名额”这个说法对用户是一种欺骗，其实有更好的处理方式。</p><h3 id="流量是直播的生命之源"><a href="#流量是直播的生命之源" class="headerlink" title="流量是直播的生命之源"></a>流量是直播的生命之源</h3><p>直播间的主播讲得不管多么好，没有观众也不行。流量在很多别的平台就是付费广告，但是在抖音，还有一大部分是“自然流量”。下图是某个直播间的流量图，可以看到，它有将近一半的自然流量，这部分流量是不需要给抖音付费的。</p><img src="/images/living-source-type.jpg" class=""><p>那么如何获得自然流量呢？自然流量其实是抖音给直播间的奖励，当抖音的算法认为当前的直播间具备下面任一一个优点的时候，算法就会给与奖励。</p><ul><li>优点一：这个直播间看起来很有趣。</li><li>优点二：这个直播间看起来很挣钱。</li></ul><p>我们先说优点一。抖音算法认为，优质的内容应该分发给更多人。所以，如果抖音算法觉得你的直播间很有趣，被很多人喜欢，那么就会把你的直播间分发给更多人。</p><p>什么样的行为代表有趣呢？关注、互动、点赞、评论、停留。</p><p>所以，大家有没有看过这样的直播间行为：</p><ul><li>某直播间，主播不停在说，新进直播间的朋友们，麻烦给我点个关注，送个粉丝灯牌。</li><li>某直播间，发福袋。领福袋的要求是关注+发一条指定语言的评论。</li></ul><p>下图是小猿学练机的直播间福袋，就是一个典型的用福袋增加关注、互动、停留的例子。</p><img src="/images/living-process-gift.jpg" class=""><p>我们再说说优点二：这个直播间看起来很挣钱。为了衡量挣钱的能力，抖音有一个叫做 GPM 的指标。GPM 指：平均每一千个观众下单的总金额，常用来衡量直播间卖货能力。</p><p>举个例子，如果直播间每进来 1000 个用户，就有 100 个用户下单，客单价是 200，那么你的 GPM 就是 <code>100 * 200 = 20000</code>。</p><p>我们知道，抖音对所有平台的交易都有抽佣的，抽佣常见的比例是 2% - 5%。所以，你的 GPM 越高，抖音得到的抽佣也就越多。如果你的 GPM 是 20000，抽佣比例是 5%，那么每 1000 个用户平台可以得到抽佣 <code>20000*5% = 1000</code> 元。</p><p>这样，当平台的广告流量有富余的时候，算法就会把流量给那些 GPM 高的直播间作为奖励。平台本身也会得到更多的佣金。</p><h2 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h2><p>我们在最初的时候提到了一个极简的成本模型：</p><blockquote><p>如果你的商品成本是 50 元，那么你每花 100 元广告费，就有 1000 元的收入，扣除 500 元的商品成本和 100 元的广告费，就还有 400 元的利润。</p></blockquote><p>其实，实际核算下来，你还需要付出以下的成本。</p><h3 id="退货成本"><a href="#退货成本" class="headerlink" title="退货成本"></a>退货成本</h3><p>商品都会有一定的退货率，当退货发生的时候，虽然你收回了商品，但是平台不会退还你已经付出的广告费的。所以，还是刚刚那个模型下，如果你的退货率是 30%，那么你的收入变成了 700，商品成本变成了 350，广告费 100，你的利润下降到了<br><code>700 - 350 - 100 = 250</code> 元。</p><h3 id="平台佣金"><a href="#平台佣金" class="headerlink" title="平台佣金"></a>平台佣金</h3><p>平台通常会抽取 5% 的交易佣金。所以，刚刚那个模型还需要减掉 <code>700*5%=35</code> 元。利润下降到了 215 元。</p><h3 id="运营人员成本"><a href="#运营人员成本" class="headerlink" title="运营人员成本"></a>运营人员成本</h3><p>直播间的主播和场控，运营都是要发工资的。根据城市不同，主播的工资为 100&#x2F;小时 - 300&#x2F;小时 不等。场控的工资约为 50 元&#x2F;小时。下图是在成都的某个直播间在微信群上发的招聘的信息。</p><img src="/images/living-people-price.jpg" class=""><p>所以，如果刚刚那个 1000 的销售额是在 0.5 小时达成的业绩，主播+场控的小时工资为 200 元。那么，你还需要付出 <code>200*0.5=100</code> 元的成本。利润下降到了 115 元。</p><h3 id="GMV-提点"><a href="#GMV-提点" class="headerlink" title="GMV 提点"></a>GMV 提点</h3><p>如果我们直播代运营公司，我们通常还需要支持 5% - 10% 的 GMV 提点。在本例中，如果我们支付 5% 的提点，则成本为 <code>700*0.05=35</code> 元。利润下降到 80 元。</p><h3 id="税"><a href="#税" class="headerlink" title="税"></a>税</h3><p>如果我们售卖的是实物商品，我们需要支付 13% 的增值税。增值税只需要交“增值”的部分，我们的售价与成本的差价是 350 元，所以我们需要交 <code>350*13%=45.5</code> 元的税。利润下降到 34.5 元。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>其它成本还包括：</p><ul><li>短视频素材的制作成本。通常情况下，一个直播间每月需要制作 40 - 80 条左右的短视频，平均每条素材的制作成本约为 500 元，月成本为 2-4 万元。</li><li>投放提点。如果我们找第三方代投公司帮我们投放，我们通常需要支付 <code>3% - 5%</code> 的投放提点。在本例中，我们需要支持 3-5 元。如果我们不找第三方代投公司，则需要招聘投放人员，成本可能更高。</li><li>运费险。</li><li>客服成本，提供售前和售后支持。</li></ul><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><ul><li>抖音直播卖货的核心工作是短视频素材的制作和直播间的转化。</li><li>一个看起来很挣钱的直播间，在计算上退货、投流成本、商品成本、运营成本、第三方提点、税收、客服成本后，其实利润就微乎其微了。</li></ul><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/living-head.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;随着抖音日活破 8 亿，短视频和直播已深入我们每</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>读《蹒跚前行 1870～2010 经济史》</title>
    <link href="https://blog.devtang.com/2024/06/29/history-of-1870-2010/"/>
    <id>https://blog.devtang.com/2024/06/29/history-of-1870-2010/</id>
    <published>2024-06-29T15:03:29.000Z</published>
    <updated>2025-01-02T15:06:35.465Z</updated>
    
    <content type="html"><![CDATA[<p>本书的作者德龙教授是经济史学家，加州伯克利分校经济学教授，曾担任克林顿政府财政部副助理部长。</p><p>这本书以历史发展的时间线，介绍全球经济发展的过程。战争（包括一战和二战）、通胀、通缩、黄金发展期伴随着这 100 多年的历史进程，读完让人感叹发展的不易，就如本书书名：蹒跚前行。</p><p>以下是一些笔记。</p><h2 id="1、关于通胀"><a href="#1、关于通胀" class="headerlink" title="1、关于通胀"></a>1、关于通胀</h2><p>通胀类似于一种税收和财富调节手段。它将财富从拥有现金的人手里转移到了拥有非现金财富的手里。</p><p>如果你是借款人，因为借款人是用贬值后的货币还款，而贷款人不得不接受已经贬值的货币。所以通胀对于欠债方是利好的。</p><p>政府发行的货币最好是和 GDP 的增长匹配。如果政府因为各种原因印制了更多货币来满足一些特定需求的时候，就会推动通胀。</p><p>通胀是一个零和博弈。受益者和损失者的损益完全匹配。</p><h2 id="2、失业率对社会的影响"><a href="#2、失业率对社会的影响" class="headerlink" title="2、失业率对社会的影响"></a>2、失业率对社会的影响</h2><p>书中介绍了大萧条时期，就业环境如何给大家带来了巨大的伤害。乔治·奥威尔的描述是：<strong>“让我害怕并震惊的事情是，看到许多人因为失业而感到羞愧。”</strong></p><p>在一个合理的社会中，每个人应该能够通过劳动自食其力。这让社会处于一个体面的状态。如果社会和经济制度让大量民众失去工作，那么一方面给个体会带来巨大的心理打击，另一方面也会给社会带来不稳定因素。</p><h2 id="3、日本的终身雇佣制"><a href="#3、日本的终身雇佣制" class="headerlink" title="3、日本的终身雇佣制"></a>3、日本的终身雇佣制</h2><p>日本的终身雇佣制来源于 20 世纪上半叶。当时日本的制造业很依赖未婚年轻女性，但是这一劳动队伍缺乏经验，同时流失率高。为了平衡流失率，日本慢慢发展出了终身雇佣制。</p><p>同时，1930 年，日本通过放弃金本位和对外扩张，避免了欧洲传过来的大萧条，从而让企业无需解雇员工，强化了终身雇佣制的文化。</p><h2 id="4、二战德国为什么会失败"><a href="#4、二战德国为什么会失败" class="headerlink" title="4、二战德国为什么会失败"></a>4、二战德国为什么会失败</h2><p>二战核心打的是经济战，虽然德国战术很强，但是从经济产出看，在 1944 年， 盟军的生产效率与德日对比为 150:24。即：德国和日本每生产出 1 架飞机，对方可以生产 6 架。</p><h2 id="5、社会主义国家选择企业国有化的理由"><a href="#5、社会主义国家选择企业国有化的理由" class="headerlink" title="5、社会主义国家选择企业国有化的理由"></a>5、社会主义国家选择企业国有化的理由</h2><p>作者提供了 3 个主要原因：</p><ul><li>担心垄断。领导人认为垄断企业会对社会公众进行剥削，除非国有化。</li><li>担心腐败。垄断企业可能直接收买负责监管的机构。</li><li>马克思主义信仰。认为资本市场具备剥削性质，只有公有制才能避免这种剥削。</li></ul><p>以上理由多少可以用来理解我们的社会。</p><h2 id="6、安全资产短缺问题"><a href="#6、安全资产短缺问题" class="headerlink" title="6、安全资产短缺问题"></a>6、安全资产短缺问题</h2><p>当经济危机发生的时候，大家会抛售之前被认为安全的资产。这个时候就会出现安全资产短缺的问题。这个时候怎么办呢？</p><p>作者介绍了白芝浩-明斯基策略：<strong>为应对安全资产短缺现象，政府的最优选择是立即基于平时被视为优质资产的抵押品提供充足的贷款，但收取惩罚性利率。</strong></p><p>提供充足贷款意味着创造足够多的安全资产，使供应不再短缺。收取惩罚性利率则意味着防范投机性金融机构利用这种混乱局面来渔利。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本书的作者德龙教授是经济史学家，加州伯克利分校经济学教授，曾担任克林顿政府财政部副助理部长。&lt;/p&gt;
&lt;p&gt;这本书以历史发展的时间线，介绍全球经济发展的过程。战争（包括一战和二战）、通胀、通缩、黄金发展期伴随着这 100 多年的历史进程，读完让人感叹发展的不易，就如本书书名</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>要利润的定价 - 读《定价制胜》</title>
    <link href="https://blog.devtang.com/2024/06/23/pricing-strategy/"/>
    <id>https://blog.devtang.com/2024/06/23/pricing-strategy/</id>
    <published>2024-06-23T14:32:48.000Z</published>
    <updated>2024-09-01T14:36:39.869Z</updated>
    
    <content type="html"><![CDATA[<p>最近读完了一本叫《定价制胜》的新书，作者是赫尔曼·西蒙。该作者创办了一家咨询公司，在全球提供定价咨询服务。截止 2021 西蒙咨询年营业额 5 亿美元，拥有员工 1700 人。</p><p>以下是我的读书心得。</p><h2 id="一、德国铁路的定价咨询"><a href="#一、德国铁路的定价咨询" class="headerlink" title="一、德国铁路的定价咨询"></a>一、德国铁路的定价咨询</h2><p>作者接到了德国铁路公司的咨询需求。当时的困境是：铁路的票价高于自己开车的油费，当时铁路每公里的费用约为 0.16 美元，但是开车的每公里费用约为 0.1 美元。所以，大部分人从经济角度选择开车出行。</p><p>西蒙的解决方案是将火车出行的成本拆分为固定成本和可变成本两部分。西蒙让铁路公司推出 BahnCard 50 优惠卡，售价为 140 美元一年，拥有优惠卡的用户可以以 5 折购买车票。</p><p>这样，每公里火车的可变成本变成了 0.08 美元，低于开车出行的 0.1 美元。最终，该优惠卡每年卖出 400 多万张。</p><p>该方案类似于京东 PLUS，天猫 VIP88。用一次性的付费将用户之后每次的购买成本降低，带动用户更多消费。</p><h2 id="二、凡勃伦效应"><a href="#二、凡勃伦效应" class="headerlink" title="二、凡勃伦效应"></a>二、凡勃伦效应</h2><p>美国经济学和社会学家凡勃伦在他的著作《有闲阶级论》中揭示了价格是身份和社会威望的标志，为消费者提供了社会心理层面的效用。这又被称为“凡勃伦效应”。</p><p>具备这类特征的一些奢侈品，在一定范围内，会出现价格越高销量越好的情况。这样的案例有很多，比如爱马仕的包，保时捷，以及一些高档手表，茅台酒等。</p><p>对于这类商品，找准自己的需求曲线，不要定价过低才可能有比较好的销量和利润。</p><h2 id="三、品质效应"><a href="#三、品质效应" class="headerlink" title="三、品质效应"></a>三、品质效应</h2><p>大部分消费者都认为：便宜无好货家，一分钱一分货。所以，较高的价格以及与其匹配的品质，可以给到消费者安全感。</p><p>研究表明，像鼻用喷雾，连裤袜，墨水和电子产品的价格提高时，它们的销量也会提高。</p><p>书中举了一家电动剃须刀的例子，这家市场跟随者为了使产品价格更接近市场领导品牌博朗（Braun），大幅提升了售价，其产品的销量在短时间内增加了 4 倍。新的价格打消了消费者对其质量的担忧，同时对于博朗，其仍然具备足够的价格吸引力。这就是所谓的价格甜蜜点。</p><p>我认为教育产品其实也是具备这样的品质效应。因为教育产品价格背后的产品品质和服务比较复杂和专业，消费者通常不太能做到比较客观的比较，这种情况下，价格高的产品在品质也过硬的情况下，长期也是最舒服的。</p><h2 id="四、定价应该支撑企业利润"><a href="#四、定价应该支撑企业利润" class="headerlink" title="四、定价应该支撑企业利润"></a>四、定价应该支撑企业利润</h2><p>作者用一个具体的例子展示了价格折扣与利润的关系。</p><p>我们假设一个硬件产品价格为 10 元，销量为 100 万件，销售额为 1000 万。其中成本为 800 万，利润为 200 万。</p><p>现在，我们假设销量不变，我们将价格打 9 折，用 9 元的价格销售。这个时候，我们的利润会下降 50%，只有 100 万了。</p><p>如下图所示：</p><img src="/images/price-strategy-2.jpg" class=""><p>有人可能会说：降价会带来销量的上涨。好的，那么销量需要上涨多少才能与之前的利润持平呢？答案是销量上涨一倍。</p><p>10% 的优惠基本上是不可能带来 100% 的销量上涨的，所以最终带来的就是利润的损失。</p><p>以上还没有考虑竞争对手跟进降价的情况。如果竞争对手也跟进降价 10%，那么大家的销量应该基本保持不变。</p><p>** 结论：9 折的销售会带来利润的大幅度损失，同时销量的上涨很难弥补这部分。 **</p><p>同时，我们可以做另外一个假设：如果我们涨价 10%，那会怎么样？结论是：如果销量没有下滑超过 3 成，涨价就可以提供更多的利润。</p><p>所以，在面对困境的时候，涨价比降价更安全。</p><h2 id="五、盈亏平衡分析"><a href="#五、盈亏平衡分析" class="headerlink" title="五、盈亏平衡分析"></a>五、盈亏平衡分析</h2><p>对于一个商品，它的成本包括固定成本（销售人员工资等）以及可变成本（生产成本，营销费用），于是我们可以得出以下公式：</p><p><code>盈亏平衡销量 = 固定成本 / （价格-可变成本）</code></p><p>假如，我们的固定成本是 300 万，定价 100 块钱，可变成本是 60。那么，我们需要卖出 300 万&#x2F;40 &#x3D; 7.5 万件商品才能回本。</p><p>如果我们把价格降到 80，那么销量需要翻倍才能盈亏平衡，如果我们把价格涨到 120，那么只需要卖出 5 万件就能盈亏平衡。</p><h2 id="六、价格弹性"><a href="#六、价格弹性" class="headerlink" title="六、价格弹性"></a>六、价格弹性</h2><p>价格弹性是指销量变化与价格变化的关系。</p><p>价格弹性为 2 表示销量变化百分比是价格变化百分比的 2 倍。也就是说，1% 的价格下降将带来 2% 的销量增长。相反地，1% 的价格提升将会造成 2% 的销量下跌。</p><p>根据西蒙咨询对数万种商品的分析，价格弹性通常在 1.3-3 之间浮动，中等浮动大约在 2。</p><p>所以，我们可以借助这个工具估算价格变化带来的销量变化。如果价格弹性为 2，那么 9 折优惠对应的销量提升就是 20% 。</p><p>利用价格弹性规则和历史上同类产品的参数经验，我们就可以模拟分析各种定价对于销量的影响了。当然，这个假设还是建立在需求曲线是线性的情况下。真实的情况应该更加复杂。</p><h2 id="七、危机中的利润"><a href="#七、危机中的利润" class="headerlink" title="七、危机中的利润"></a>七、危机中的利润</h2><p>在进行定价讨论的时候，西蒙咨询公司通常会让企业出一套选择题：</p><ul><li>选项 A：价格下降 5%，销量保持不变</li><li>选项 B：销量下降 5%，价格保持不变</li></ul><p>大部分企业都会选择 A。但因为全球企业的平均净利润率约为 6%，其中中国的企业平均净利润率为 5.2%，所以选择 A 意味着利润率从 5.2% 下降到基本上无利润的境地（也可以理解为利润率下降 100%）。</p><img src="/images/price-strategy-1.jpg" class=""><p>所以，当企业陷入困境，降价是一种危险的操作，因为降价有可能让企业陷入亏损。相对来说，减产的危害小很多。</p><h2 id="八、一些小结"><a href="#八、一些小结" class="headerlink" title="八、一些小结"></a>八、一些小结</h2><p>巴菲特说：评估一家企业价值最重要的因素是其定价权。</p><p>西蒙说：好的价格方案需要创造价值，量化价值以及传递价值。最后，也是最重要的一点，避免价格战。</p><p>孙正义在投资 wework 失败之后说：你的梦想最好是有利可图的。</p><p>我的老板常圳说：没有哪个公司是因为盈利倒闭的。</p><p>我认为：</p><ul><li>制定价格和营销策略的时候，首先应该关注利润，然后才是规模；</li><li>营销中应该重点为消费者传递产品的价值信息而不是优惠信息；</li><li>为团队传递利润为先的价值导向；</li></ul><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近读完了一本叫《定价制胜》的新书，作者是赫尔曼·西蒙。该作者创办了一家咨询公司，在全球提供定价咨询服务。截止 2021 西蒙咨询年营业额 5 亿美元，拥有员工 1700 人。&lt;/p&gt;
&lt;p&gt;以下是我的读书心得。&lt;/p&gt;
&lt;h2 id=&quot;一、德国铁路的定价咨询&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
</feed>
