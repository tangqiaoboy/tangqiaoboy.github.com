<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐巧的博客</title>
  
  <subtitle>记录下自己学习的点滴</subtitle>
  <link href="https://blog.devtang.com/atom.xml" rel="self"/>
  
  <link href="https://blog.devtang.com/"/>
  <updated>2025-10-21T00:41:49.196Z</updated>
  <id>https://blog.devtang.com/</id>
  
  <author>
    <name>唐巧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解 MCP -读《这就是 MCP》</title>
    <link href="https://blog.devtang.com/2025/10/21/mcp-introduction/"/>
    <id>https://blog.devtang.com/2025/10/21/mcp-introduction/</id>
    <published>2025-10-21T00:36:13.000Z</published>
    <updated>2025-10-21T00:41:49.196Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/mcp-book.jpg" class=""><h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>最近读完了一本讲解 MCP 实现原理的书：<a href="https://book.douban.com/subject/37441660/">《这就是 MCP》</a>，它帮助我更好地理解了 MCP，以下是一些笔记。</p><h2 id="二、什么是-MCP"><a href="#二、什么是-MCP" class="headerlink" title="二、什么是 MCP"></a>二、什么是 MCP</h2><p>MCP 的全称是 Model Context Protocol，之所以叫这个名字，是因为它可以成为大模型调用外部工具的协议，让大模型能够补充自己的上下文（即 Context）。</p><p>在没有 MCP 之前，每个大模型都在为自己扩展调用外部工具的能力，最常见的能力就是调用搜索引擎。但是这就会造成一个麻烦：每个大模型都需要自己开发一遍调用工具（重复造轮子），而且由于协议不开放，第三方开发者无法为大模型提供更多工具。</p><p>在有了 MCP 之后，整个开发流程变成了：</p><ul><li>大模型都适配 MCP 协议</li><li>各种工具都适配 MCP 协议</li></ul><p>这样，一个新的工具出来，立刻可以为所有大模型可用，而一个新的大模型也可以立刻调用市面上公开的 MCP（下图）。</p><img src="/images/mcp-book-1.jpg" class=""><p>有人把这个比作 <strong>“AI 时代的 HTTP 协议”</strong>，我是比较认同的。</p><h2 id="三、MCP-的实现细节"><a href="#三、MCP-的实现细节" class="headerlink" title="三、MCP 的实现细节"></a>三、MCP 的实现细节</h2><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1 角色"></a>3.1 角色</h3><p>不同于 HTTP协议的浏览器 &#x2F; 服务器（B&#x2F;S）架构，MCP 的协议多了一个 “主机” 的角色，一共包含三个角色，分别是：主机，客户端，服务器。</p><p>主机：创建和管理多个客户端。负责鉴权相关工作。负责多个客户端内容的聚合，</p><p>客户端：一个客户端是一个进程，负责与对应的 MCP 服务器交互数据，管理会话的状态。</p><p>服务器：为客户端提供服务。可以部署成本地服务或远程服务。</p><h3 id="3-2-协议"><a href="#3-2-协议" class="headerlink" title="3.2 协议"></a>3.2 协议</h3><p>MCP 使用 JSON-RPC 作为客户端与服务器通信的基础。</p><p>当服务器部署在本地的时候，它允许客户端用 stdio 的方式来传输 JSON 编码的数据。</p><p>当服务器部署在远程的时候，它使用 HTTP 来传输 JSON。</p><p>鉴权方面， 基于 stdio 传输实现的服务器直接从环境变量中读取授权凭证，而基于 HTTP 协议的服务器，基于 OAuth 2.1 实现授权。</p><h2 id="四、如何开发-MCP"><a href="#四、如何开发-MCP" class="headerlink" title="四、如何开发 MCP"></a>四、如何开发 MCP</h2><p>开发 SDK：MCP 支持任意语言开发 MCP 服务器，我们可以使用官方提供的 SDK 快速生成代码框架。</p><p>调试工具：官方提供的调试工具名为 MCP Inspector，用它连接对应 MCP 之后就可以在面板中调试功能。</p><p>发布 MCP：我们可以把开发好的服务发布到 MCP 市场上面供开发者检索到。</p><p>MCP 市场。市面上比较有名的市场包括：</p><ul><li>Anthropic 官方的 <a href="https://github.com/modelcontextprotocol/servers">MCP Servers 仓库</a></li><li><a href="https://smithery.ai/">Smithery</a></li><li><a href="https://glama.ai/">Glama</a></li></ul><h2 id="五、MCP-的问题"><a href="#五、MCP-的问题" class="headerlink" title="五、MCP 的问题"></a>五、MCP 的问题</h2><p>MCP 发布才一年时间，所以还有很多细节未来需要完善，包括：</p><ul><li>协议对多模态内容支持不够友好</li><li>鉴权机制不完善，很多 MCP 服务还未支持 25 年 3 月引入的 OAuth 鉴权协议</li><li>安全防护能力弱。攻击者可以构造恶意的 MCP 服务来诱导用户执行恶意命令，从而实现信息窃取，执行恶意命令等攻击。</li></ul><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/mcp-book.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;一、序言&quot;&gt;&lt;a href=&quot;#一、序言&quot; class=&quot;headerlink&quot; title=&quot;一、序言&quot;&gt;&lt;/a&gt;一、序言&lt;/h2&gt;&lt;p&gt;最近读完了一本讲解 MCP 实现原理的</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>斑马思维机的详细调研</title>
    <link href="https://blog.devtang.com/2025/10/09/zebra-logic-introduction/"/>
    <id>https://blog.devtang.com/2025/10/09/zebra-logic-introduction/</id>
    <published>2025-10-09T09:39:07.000Z</published>
    <updated>2025-11-02T14:53:05.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文档创建于 2025.3，最后更新于 2025.10</p></blockquote><h2 id="一、产品介绍"><a href="#一、产品介绍" class="headerlink" title="一、产品介绍"></a>一、产品介绍</h2><img src="/images/zebra-logic.jpg" class=""><p>斑马思维机是针对 2-8 岁儿童的全科启蒙学习机。由在线教育集团“猿辅导”旗下的斑马品牌在 2022 年 11 月<a href="https://tech.cnr.cn/techph/20221102/t20221102_526049239.shtml" title="斑马思维机 G1 发布时间">推向市场</a>，并在 2023 年 8 月升级为<a href="https://www.sohu.com/a/708327102_104421" title="斑马思维机 G2 发布时间">二代产品</a>：斑马思维机 G2。</p><p>它包含语文、思维、英语、音乐等学科内容，通过纸质的题卡结合点触交互的形式，让孩子在不同情景主题场景下互动，通过互动答题的形式，完成内容的教学。插卡自动出题，孩子通过点触答题。答对有鼓励，答错会有提醒，孩子可以自主完成从插卡到答题的整个过程。</p><p>相比别的早教学习机，斑马思维机的核心特点是没有传统的屏幕。它用纸质题卡来完成学习交互，在完成学习的同时可以有效保护低幼孩子的眼睛，防止过早接触电子屏幕产生沉迷。</p><p>产品上线后累计销量突破 100 万台，2023 年和 2024 年连续两年<a href="https://www.pingwest.com/a/295205" title="销量第一报道">全国销量第一</a>。</p><p>斑马思维机主要具备如下产品优势：</p><h3 id="1、专业教研"><a href="#1、专业教研" class="headerlink" title="1、专业教研"></a>1、专业教研</h3><p>团队邀请了三位行业专家共同参与内容研发，分别是：</p><ul><li>曹立宏教授：中国传媒大学的脑科学专家。</li><li>刘嘉教授：清华大学心理学专家。同时也是“最强大脑”节目的科学总顾问。</li><li>蔡可教授：首都师范大学教育学专家。同时也是语文新课标的制定者。</li></ul><img src="/images/zebra-logic-professior.jpg" class=""><p>在以上专家参与的同时，斑马结合自己斑马 AI 学产品的 3000 万用户的 100 亿次线上作答数据，为题卡的编制提供大数据支撑。</p><img src="/images/zebra-logic-big-data.jpg" class=""><p>斑马思维机题卡构建了科学合理的分级进阶体系，分设 S0、S1、S2、S3 4 个难度级别。这种设置充分考虑了 2-8 岁儿童不同阶段的认知水平和思维发展能力。题卡难度逐阶递增、螺旋上升，能够循序渐进地开发儿童大脑潜能。</p><h3 id="2、纸屏护眼"><a href="#2、纸屏护眼" class="headerlink" title="2、纸屏护眼"></a>2、纸屏护眼</h3><p>不同于传统有屏幕的学习机，斑马思维机通过插卡+点触的方式来学习，可以有效减少孩子接触电子屏幕的时间，防止孩子过早接触屏幕，影响视力。</p><p>每张题卡上都有丰富的主题元素，帮助孩子建立起学习的兴趣。</p><p>每张纸质题卡都用了食品级白卡和大豆油墨印刷，保证对孩子安全。</p><h3 id="3、全科启蒙"><a href="#3、全科启蒙" class="headerlink" title="3、全科启蒙"></a>3、全科启蒙</h3><p>斑马思维机的题卡包含语文、思维、英语三大核心题卡，相关的内容体系分为 S0、S1、S2、S3 4 个难度级别，且难度分级科学合理，充分满足不同年龄段孩子的学习需求。其中：</p><table><thead><tr><th>级别</th><th>针对年龄</th><th>培养重点</th></tr></thead><tbody><tr><td>S0</td><td>2-3</td><td>习惯养成</td></tr><tr><td>S1</td><td>3-4</td><td>兴趣培养</td></tr><tr><td>S2</td><td>4-5</td><td>知识积累</td></tr><tr><td>S3</td><td>5+</td><td>应用拓展</td></tr></tbody></table><h3 id="4、无限扩展"><a href="#4、无限扩展" class="headerlink" title="4、无限扩展"></a>4、无限扩展</h3><p>斑马思维机的题卡支持无限扩展，随着产品研发不断的持续，斑马思维机在语文、思维、英语题卡的基础上，又逐步上新了迪士尼、鲨鱼宝宝、音乐、专注力、故官等主题题卡。其中：</p><ul><li><p>2023 年 12 月，与迪士尼官方合作上新<a href="https://mp.weixin.qq.com/s/Xw8ZZTkyYbyEWV9Mprexxw" title="迪士尼题卡上新">迪士尼题卡</a>。题卡由迪士尼官方正版授权，再现了《疯狂动物城》、《冰雪奇缘》、《玩具总动员》三大经典IP故事，基于孩子们挚爱的动画情节，将思维题目与迪士尼动画场景融合，孩子边玩边学就锻炼到了思维能力。</p></li><li><p>2024 年 7 月，与“打开故宫”合作上新<a href="https://mp.weixin.qq.com/s/IH0bYh6Kc3EDmOLG9B01IQ" title="故宫题卡上新">故宫题卡</a>。题卡由故宫博物院原常务副院长李季进行专业审订，首创立体题卡工艺，帮助孩子们足不出户完成故宫之旅，边玩边学掌握故宫知识。</p></li><li><p>2024 年 10 月，与 Pinkfong 联名推出<a href="https://mp.weixin.qq.com/s/8iccodBc4bBtgpYvJwco5w" title="鲨鱼宝宝题卡上新">鲨鱼宝宝题卡</a>。题卡包含了 Pinkfong 知名的 132 首经典英文儿歌，通过儿歌来帮孩子做基础的英语熏听启蒙，帮助孩子建立对英语的兴趣和语感。其中的儿歌 《Baby shark》为全球播放量第一的儿歌（<a href="https://www.guinnessworldrecords.cn/world-records/95003-most-viewed-video-online" title="吉尼斯世界记录认证">吉尼斯世界记录认证</a>）。</p></li><li><p>2024 年 12 月，推出<a href="https://mp.weixin.qq.com/s/-7zKKelat820h6fTou0tnA" title="音乐题卡上新">音乐题卡</a>。内容包括 38 组乐理知识、52 种乐器探索、16 种音乐文化和 48 首儿歌鉴赏，帮助孩子完成音乐启蒙。</p></li><li><p>2025 年 2 月，推出<a href="https://mp.weixin.qq.com/s/K-DXuWVNia6crk9S5bEQOg" title="专注力题卡上新">专注力题卡</a>，通过趣味游戏的形式，从注意广度、注意转移、注意分配、注意稳定性 4 个方面对孩子的专注力进行深度训练。</p></li><li><p>2025 年 6 月，推出<a href="https://mp.weixin.qq.com/s/BQSXvImVBJJc0KJITLt_Gg" title="好朋友题卡介绍">好朋友题卡</a>，通过小朋友间的竞争与协作，把思维训练变成小朋友之间玩乐游戏。</p></li><li><p>2025 年 10 月，推出<a href="https://mp.weixin.qq.com/s/RduBk7Znfp5Qi4Rnk8nk-w" title="小猪佩奇题卡上新">小猪佩奇题卡</a>，通过趣味的场景化游戏和小猪佩奇榜样的力量，培养孩子的“生活自理能力”、“自我保护能力”、“社会适应能力” 三大自主能力。</p></li></ul><h2 id="二、内容体系"><a href="#二、内容体系" class="headerlink" title="二、内容体系"></a>二、内容体系</h2><h3 id="语文"><a href="#语文" class="headerlink" title="语文"></a>语文</h3><p>斑马思维机语文题卡共 265 张，包括 6 个知识模块：汉字、词语、成语常言、古诗歌谣、表达结构、国学常识。另外在 S3 级别中，额外增加了拼音专题。</p><table><thead><tr><th>知识模块</th><th>内容量</th></tr></thead><tbody><tr><td>识字</td><td>372字，情景交互式学习，一页学 1-3 个字</td></tr><tr><td>成语</td><td>81 个</td></tr><tr><td>日常表达</td><td>36 个</td></tr><tr><td>古诗</td><td>72 首</td></tr><tr><td>传统文化</td><td>36 个</td></tr><tr><td>歌谣</td><td>12 首</td></tr><tr><td>拼音</td><td>12 张卡，认识+认读</td></tr></tbody></table><h3 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h3><p>斑马思维机思维题卡共 241 张，包括 6 个知识模块：视听与记忆、数感与模型、图形与空间、逻辑与规律、实践与规划、动手与益智。</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>斑马思维机英语题卡共 265 张，包括 5 个知识模块：字母与发音、单词、句型、儿歌、拓展应用。</p><table><thead><tr><th>知识模块</th><th>内容量</th></tr></thead><tbody><tr><td>字母认知</td><td>26 个字母</td></tr><tr><td>自然拼读</td><td>30 个自然拼词规则</td></tr><tr><td>核心词汇</td><td>518 个词汇</td></tr><tr><td>日常表达</td><td>78 组句型表达</td></tr><tr><td>韵律儿歌</td><td>48 首经典儿歌</td></tr><tr><td>拓展应用-开口</td><td>36 个日常情景应用</td></tr></tbody></table><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>音乐题卡共 72 张，内容包括 38 组乐理知识、52 种乐器探索、16 种音乐文化和 48 首儿歌鉴赏，帮助孩子完成音乐启蒙。</p><h3 id="专注力"><a href="#专注力" class="headerlink" title="专注力"></a>专注力</h3><p>专注力题卡共 72 张，内容从注意广度、注意转移、注意分配、注意稳定性 4 个方面对孩子的专注力进行深度训练。</p><h3 id="鲨鱼宝宝题卡"><a href="#鲨鱼宝宝题卡" class="headerlink" title="鲨鱼宝宝题卡"></a>鲨鱼宝宝题卡</h3><p>鲨鱼宝宝共 36 张，题卡包含了 Pinkfong 知名的 132 首经典英文儿歌。通过儿歌共熏听了 1400+ 单词，包含了 81% 的小学新课标二级核心词汇。</p><h3 id="小猪佩奇题卡"><a href="#小猪佩奇题卡" class="headerlink" title="小猪佩奇题卡"></a>小猪佩奇题卡</h3><p>小猪佩奇题卡共 32 张，题卡包含了“生活自理能力”、“自我保护能力”、“社会适应能力” 三大自主能力。其中：</p><ul><li>生活自理能力包括：生活习惯、生活技能、行为习惯。</li><li>自我保护能力包括：健康认知、健康防护、安全意识。</li><li>社会适应能力包括：情绪管理、沟通表达、同伴交往。</li></ul><h2 id="市场表现与竞争分析"><a href="#市场表现与竞争分析" class="headerlink" title="市场表现与竞争分析"></a>市场表现与竞争分析</h2><h3 id="竞争壁垒"><a href="#竞争壁垒" class="headerlink" title="竞争壁垒"></a>竞争壁垒</h3><p>斑马思维机为思维机品类开创者，拥有 6 项思维机专利和 10 项国际大奖。</p><p>斑马思维机专利情况：</p><table><thead><tr><th>专利名称</th><th>专利公告</th></tr></thead><tbody><tr><td>机器专利1</td><td><a href="http://epub.cnipa.gov.cn/cred/CN219533902U">http://epub.cnipa.gov.cn/cred/CN219533902U</a></td></tr><tr><td>机器专利2</td><td><a href="http://epub.cnipa.gov.cn/cred/CN219609810U">http://epub.cnipa.gov.cn/cred/CN219609810U</a></td></tr><tr><td>结构专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN219831980U">http://epub.cnipa.gov.cn/cred/CN219831980U</a></td></tr><tr><td>外观专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN307609057S">http://epub.cnipa.gov.cn/cred/CN307609057S</a></td></tr><tr><td>立体题卡专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN221766203U">http://epub.cnipa.gov.cn/cred/CN221766203U</a></td></tr><tr><td>滑动交互专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN221613415U">http://epub.cnipa.gov.cn/cred/CN221613415U</a></td></tr></tbody></table><p>斑马思维机获奖情况：</p><table><thead><tr><th>奖项名</th><th>奖项名</th><th>获奖证书</th><th>获奖年份</th></tr></thead><tbody><tr><td>Tillywig Toy Awards</td><td>堤利威格玩具奖，美国玩具行业最顶级的奖项之一</td><td><a href="https://blog.devtang.com/images/zebra-tillywig.jpg" title="斑马思维机 堤利威格玩具奖 证书">证书</a></td><td>2023 年</td></tr><tr><td>Creative Child Awards</td><td>儿童创意大奖，儿童创造力培养领域享有盛誉的国际大奖</td><td><a href="https://blog.devtang.com/images/zebra-cca-award.jpg" title="斑马思维机 儿童创意大奖 官网截图">证明</a></td><td>2023 年</td></tr><tr><td>K Design Award</td><td>K设计大奖，享誉全球的国际专业设计大奖</td><td><a href="https://blog.devtang.com/images/zebra-K-design.jpg" title="斑马思维机 K-design 获奖证书">证书</a></td><td>2023 年</td></tr><tr><td>Mom’s Choice Awards</td><td>妈妈之选奖，国际母婴产品领域标杆奖项</td><td><a href="https://blog.devtang.com/images/zebra-mom-choice.jpg" title="斑马思维机 Mom choice 获奖证书">证书</a></td><td>2023 年</td></tr><tr><td>The National Parenting Center Seal of Approval</td><td>美国国家育儿中心专业认证</td><td><a href="https://blog.devtang.com/images/zebra-npc.jpg" title="斑马思维机 美国国家育儿中心专业认证 证书">证书</a></td><td>2023 年</td></tr><tr><td>Contemporary Good Design Award</td><td>当代好设计奖</td><td><a href="https://blog.devtang.com/images/zebra-good-design.jpg" title="斑马思维机 当代好设计 获奖证书">证书</a></td><td>2023 年</td></tr><tr><td>TOY AWARD</td><td>中外玩具大奖</td><td><a href="https://blog.devtang.com/images/zebra-toy-award.jpeg" title="斑马思维机 中外玩具大奖 证书">证书</a></td><td>2023 年</td></tr><tr><td>IDEA</td><td>国际卓越设计奖</td><td><a href="https://blog.devtang.com/images/zebra-idea.jpg" title="斑马思维机 IDEA 获奖证书">证书</a></td><td>2024 年</td></tr><tr><td>LONDON Design Awards</td><td>伦敦设计奖</td><td><a href="https://blog.devtang.com/images/zebra-london-design.jpg" title="斑马思维机 伦敦设计奖 证书">证书</a></td><td>2025 年</td></tr><tr><td>MUSE Design Awards</td><td>缪斯设计大奖</td><td><a href="https://blog.devtang.com/images/zebra-muse.jpg" title="斑马思维机 缪斯设计奖 证书">证书</a></td><td>2025 年</td></tr><tr><td>Goldreed Industrial Design Award</td><td>金芦苇工业设计奖</td><td><a href="https://blog.devtang.com/images/zebra-goldreed.jpg" title="斑马思维机 金芦苇工业设计奖 证书">证书</a></td><td>2025 年</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>以上专利和奖项为斑马思维机提供了不少竞争优势，帮助它持续提升产品端的用户体验。</p><h3 id="市场销量"><a href="#市场销量" class="headerlink" title="市场销量"></a>市场销量</h3><p>上市以来，斑马思维机市场销量表现出色，受到众多家长青睐。在各大电商平台，其销售数据持续增长，斑马思维机连续两年稳居思维机品类的销量和销售额第一。</p><ul><li><p>据<a href="https://blog.devtang.com/images/top-sell-2023.jpg" title="2023 销量第一">《洛图科技_中国思维机线上零售市场月度数据追踪报告》</a>显示，2023 年 1 月至 2024 年 3 月，斑马思维机在线上京东、天猫、抖音三大电商合计市场中销量排名第一，份额达到 52.8%; 销额排名第一，份额达到 66.8%。</p></li><li><p>据<a href="https://blog.devtang.com/images/top-sell-2024.jpg" title="2024 销量第一">《洛图科技_中国思维机线上零售市场月度数据追踪报告》</a>显示，2024 年 1 月至 2024 年 12 月，斑马思维机在线上京东、天猫、科音三大电商合计市场中销量排名第一，份额达到 66.6%; 销额排名第一，份额达到 72.9% 。</p></li></ul><p>由以上数据可知，斑马思维机的市场占有率进一步扩大，从 2024 年初的 52.8% 上升到 2025 年初的 66.6%，进一步巩固了市场第一的地位。</p><p>在京东平台提供的 2025 年<a href="https://blog.devtang.com/images/top-sell-jd-2025-3.jpg" title="2025 京东思维机热卖榜">思维机热卖榜</a>上，斑马思维机已连续占据榜首 131 天（数据截至 2025.03.09 ）。</p><p>在天猫平台提供的 2025 年<a href="https://blog.devtang.com/images/top-sell-tm-2025-3.jpg" title="2025 天猫学习机热卖榜">学习机热卖榜</a>上，斑马思维机占据 2000 元以下学习机热卖榜第一（数据截至 2025.03.09 ）。</p><h3 id="同类思维机产品比较"><a href="#同类思维机产品比较" class="headerlink" title="同类思维机产品比较"></a>同类思维机产品比较</h3><p>斑马思维机的主要竞争产品为学而思旗下的摩比思维机（又名：学而思思维机）。斑马思维机和摩比思维机哪个好呢？以下是一些多维度的比较数据。</p><h4 id="1、发布时间"><a href="#1、发布时间" class="headerlink" title="1、发布时间"></a>1、发布时间</h4><p>从发布时间上看，斑马思维机较早，具有较大的先发优势：</p><ul><li>斑马思维机 G1 在 2022 年 11 月<a href="https://tech.cnr.cn/techph/20221102/t20221102_526049239.shtml" title="斑马思维机 G1 发布时间">正式发布</a>，而摩比思维机<a href="https://www.sohu.com/a/677896840_361784" title="摩比思维机一代发布">正式发布</a>的时间为 2023 年 5 月，落后斑马思维机 6 个月。</li><li>斑马思维机随后在 2023 年 8 月发布<a href="https://www.sohu.com/a/708327102_104421" title="斑马思维机 G2 发布时间">二代机型</a>，而摩比思维机的二代机型同样落后半年多，在 2024 年 4 月<a href="https://www.163.com/dy/article/J0RQ3CNM0536W4EI.html" title="摩比思维机二代发布">发布</a>。</li></ul><p>较早的发布使斑马获得了更多的销量，并从销量中获得了更多的用户反馈，也积累了更多的用户迭代数据。这些数据和反馈帮助斑马思维机做到了更好的产品体验。用户普遍反馈斑马思维机点触灵敏；而摩比思维机点触通常不太灵敏，孩子点不准容易受到挫折，从而打击学习积极性。所以，从机器点触灵敏度角度，更推荐大家使用斑马思维机。</p><h4 id="2、题卡设置"><a href="#2、题卡设置" class="headerlink" title="2、题卡设置"></a>2、题卡设置</h4><p>斑马思维机的题卡设置结合了心理学、脑科学、教育学的专家经验和 3000 万孩子的行为大数据，难度设置更加科学合理，孩子不容易受到挫折。</p><p>摩比思维机因为是后来追赶者，所以在题卡研发上更加追求速度，所以在内容体系上大多选择别的品牌合作的形式，以加快内容研发速度。摩比在语文题卡上与“四五快读”<a href="https://www.sohu.com/a/707989347_112831" title="摩比四五快读题卡">合作</a>，在英语题卡上与“剑桥英语”及“RAZ”合作，低龄题卡与小猪佩奇合作。</p><p>但是合作的形式使得摩比的题卡体系性和衔接性较差。例如：</p><ul><li><p>斑马的语文分为 S0-S4 4 个级别，难度螺旋上升，对各个年龄段的孩子都很适配。摩比的语文因为“四五快读”只有识字，所以无法分级，只能提供识字包、古词包、拼音包这种专题形式。同时“四五快读”的趣味性较低，不太适合 2-4 岁的孩子启蒙，降低了低龄孩子家长的好感度和选购意愿。</p></li><li><p>斑马的英语为全美式发音体系，符合小学新课标要求。但是摩比的英语题卡分为英式发音的<a href="https://zhuanlan.zhihu.com/p/662313624" title="摩比剑桥英语题卡">“剑桥英语”系列</a>和美式发音的“RAZ”系列。两个系列混合提供不利于孩子建立标准的英语发音环境，家长会担心孩子练成既不英式也不美式的奇怪发音。</p></li><li><p>IP 合作方面，斑马和摩比都与迪士尼、小猪佩奇有合作。除此之外，斑马与鲨鱼宝宝、故宫还有联名合作。</p></li></ul><p>所以，相对来说斑马思维机的题卡更受大部分的家长和孩子的喜爱。</p><h4 id="3、硬件配置"><a href="#3、硬件配置" class="headerlink" title="3、硬件配置"></a>3、硬件配置</h4><p>两者都是 Type-C 口的充电款机器。</p><ul><li>斑马思维机的机器重量为 400g，较为轻便，方便携带，无需联网即可使用。</li><li>摩比思维机的机器重量为 500g，较为厚实，需要下载 App 连接 Wifi 才可激活使用。</li></ul><p>在升级时，斑马思维机通过 U 盘升级，摩比思维机通过连接 Wifi 升级。</p><h4 id="4、销量排名"><a href="#4、销量排名" class="headerlink" title="4、销量排名"></a>4、销量排名</h4><p>据<a href="https://blog.devtang.com/images/top-sell-2024.jpg" title="2024 销量第一">公开数据</a>，斑马思维机销量排名第一。其它思维机销量排名未知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文档创建于 2025.3，最后更新于 2025.10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、产品介绍&quot;&gt;&lt;a href=&quot;#一、产品介绍&quot; class=&quot;headerlink&quot; title=&quot;一、产品介绍&quot;&gt;&lt;/a&gt;一、产品介绍</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解大语言模型 - 读《图解 DeepSeek 技术》</title>
    <link href="https://blog.devtang.com/2025/10/06/the-illustrated-deepseek-book-summary/"/>
    <id>https://blog.devtang.com/2025/10/06/the-illustrated-deepseek-book-summary/</id>
    <published>2025-10-06T14:06:51.000Z</published>
    <updated>2025-10-06T15:05:58.035Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/deepseek-0.jpg" width="300px" /><p>最近收到图灵编辑刘美英老师赠送的<a href="https://book.douban.com/subject/37425385/">《图解 DeepSeek 技术》</a>，全书只有不到 100 页，而且配套了大量插画，让原本让人生畏的大语言模型底层技术，变得不那么难懂。</p><p>本书非常适合对于大语言模型零基础的读者，作为入门书籍。以下是我的一些笔记。</p><h2 id="缩放定律（Scaling-law）"><a href="#缩放定律（Scaling-law）" class="headerlink" title="缩放定律（Scaling law）"></a>缩放定律（Scaling law）</h2><p>深度学习的底层原理其实缺乏科学论证，最终只能用“涌现”这种现象来描述我们观察到的实验结果。这个实验结果就是：当我们提高模型规模的时候，模型的表现也会越来越好。</p><p>于是，我们通过三个要素来提升模型的规模，分别是：参数量、数据量和计算量（如下图）</p><img src="/images/deepseek-1.jpg" class=""><p>我对“涌现”的理解：这个世界上很多事情都是从量变到质变，大模型“涌现”出来的智能，再一次体现了这种自然界常见的现象。比如：</p><ul><li>水在温度上升的时候，形态一直是液态，直到上升了 100 度，就开始沸腾，转化为气态。</li><li>股市，前期积累的泡沫越来越大，最后泡沫破灭的时候，就会一下子跌特别多。</li></ul><p>我对缩放定律的理解：缩放定律在自然界中也非常常见，很多变化不是线性的，而是幂律（power law）的。比如：</p><ul><li>财富的集中度。在美国前 10% 的人持有超过 90% 的财富。</li><li>公司的营收排名。排名每上升一名，营收可能是下一名的 2 倍。</li><li>明星或达人的收入。关注度每上升一位，收入可能翻翻。</li><li>28 原理。决定一件事情的最主要的 20% 因素，占据了 80% 的权重。</li></ul><h2 id="深度思考"><a href="#深度思考" class="headerlink" title="深度思考"></a>深度思考</h2><p>缩放定律把大家的精力都集中在堆参数量和堆算力上，但是研究人员发现，如果让模型在输出答案的过程中进行“长思考”，答案会变得显著得好。于是，除了在训练阶段发力外，我们通过让模型在生成答案时消耗更多资源，来提升答案的质量。这就是现在变得普遍的“深度思考”模式（如下图）。</p><img src="/images/deepseek-2.jpg" class=""><p>在我的理解下，深度思考模式类似于《思考快与慢》一书中提到的人类的慢思考。人类大多数时候，是用直觉来决策的，因为这样效率最高，而且直觉通常来源于大量的经验（预训练），通常情况下是对的。但是，对于一些重大的决策，人类就会启动慢思考（深度思考），会花大量的时间和精力来论证自己的想法是否正确，以保证重大决策的质量。</p><h2 id="蒸馏（Distill）"><a href="#蒸馏（Distill）" class="headerlink" title="蒸馏（Distill）"></a>蒸馏（Distill）</h2><p>DeepSeek-R1 是一个拥有 6710 亿个参数的庞大模型，这使得部署和使用它都需要强大的硬件支持。但是 DeepSeek 创新性的开创了将自己的推理能力蒸馏到别的小模型（比如 <a href="https://huggingface.co/deepseek-ai/DeepSeek-R1-Distill-Qwen-32B">Qwen-32B</a>）上的方法。</p><p>具体来说，研究团队用 DeepSeek 当老师模型，让 Qwen 当学生模型。当两个模型接收到相同的提示词后，均需要输出一个词元概率分布。在训练过程中，学生模型需要紧密跟随老师模型的分布特征（如下图）。</p><img src="/images/deepseek-3.jpg" class=""><p>以上过程在 80 万个样本的训练下，这些小模型学会了 DeepSeek 的思维方式，与蒸馏前相比，能力有大幅的提升。</p><p>在我的理解下，这也非常类似人类的“师徒学习模式”。我在计算机行业，我们行业的毕业生刚进企业的时候，都会有一个导师（mentor）进行一对一指导。最终帮助我们这些职场小白快速融入行业，写出高质量的代码。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/deepseek-0.jpg&quot; width=&quot;300px&quot; /&gt;

&lt;p&gt;最近收到图灵编辑刘美英老师赠送的&lt;a href=&quot;https://book.douban.com/subject/37425385/&quot;&gt;《图解 DeepSeek 技术》&lt;</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>但斌投资札记-读《时间的玫瑰》</title>
    <link href="https://blog.devtang.com/2025/10/06/the-rose-of-time-book-summary/"/>
    <id>https://blog.devtang.com/2025/10/06/the-rose-of-time-book-summary/</id>
    <published>2025-10-06T12:00:26.000Z</published>
    <updated>2025-10-06T12:46:03.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>想读一些价值投资者的书，于是就找到了这本但斌的《时间的玫瑰》。这是一本写于 2018 年的书，现在已经过了 7 年。当年的很多论断，随着时间的检验会更有意思。以下是一些读书感悟。</p><h3 id="买入价格很重要"><a href="#买入价格很重要" class="headerlink" title="买入价格很重要"></a>买入价格很重要</h3><p>我们常说，买股票需要关注三点：好公司，好管理，好价格。在好价格这件事情上，但斌给我们举了一个例子，也是他自己血泪教训。</p><p>但斌说：如果你在 2007 年的高点买入茅台，那么需要 2016 年（9 年后）才能解套。中间还会经历两次 60% 的下跌。所以，即便是大家公认的好公司，如果你的买入价格不对，也是有很大的风险。</p><h3 id="关注行业周期"><a href="#关注行业周期" class="headerlink" title="关注行业周期"></a>关注行业周期</h3><p>但斌的这本书写在 7 年前，在 7 前年，有一些行业龙头公司是被价值投资者普遍认同的，比如房地产行业的万科，以及教育行业的好未来，但斌在书中多次提到这两家公司。但是我们现在来看这两家公司，就会发现两家公司都经历了价值毁灭的过程，他们都从最高点回撤了超过 80% 。</p><p>万科股价：</p><img src="/images/wanke.jpg" class=""><p>好未来股价：</p><img src="/images/haoweilai.jpg" class=""><p>回撤的背后，是房地产行业和教育行业整体的低迷带来的。即便是三好学生，如果在一个下坡路的行业，也是做不出什么好成绩的。</p><p>关注行业的周期，关注政策的变化，在合适的时候卖出，这也是《股票大作手操盘术》中我很认同的趋势投资观点，在本书中，我再次感受到趋势投资的重要性。</p><h3 id="从分歧中学习"><a href="#从分歧中学习" class="headerlink" title="从分歧中学习"></a>从分歧中学习</h3><p>但斌在书中提到他参加伯克希尔股东大会的一段记录：一个来自旧金山的 17 岁少年问：成为一个好的投资者的最好方法是什么？</p><p>巴菲特回答说：尽可能多地阅读。你要把各种思想装进你的脑子里，随着时间的推移，分辨出哪些是合理的。一旦你做到这样了，你就该下水实践了。</p><p>我对此也有很强的认同。学习的第一步是尽量吸收信息，而阅读是一个很好地吸收高质量信息的渠道。当然，我也认为与人交流讨论，以及观察现场同样重要，这都是获得信息多样性的重要手段。</p><p>有了信息之后，通过思考和实践来分辨信息，最终把有效的信息沉淀下来，就能成为自己的宝贵经验。</p><p>我对获取信息的方法最近还有一个新的感悟，就是“反对性”的意见相对重要，因为人会自我强化自己的观点，所以对于反对观点容易忽视。这个时候，我们应该刻意去找反对性意见，在理解反对性意见的基础上，去解释为什么观点不一样。</p><p>反对意见在投资上，也代表着市场的分歧，如果我们能够理解正反两边的观点的同时，又能够看到未来正反观点的分歧消除点，那么就可能获得巨大的收益。</p><p>之前我想要获得分歧意见非常难，因为表达反对意见通常让人感觉尴尬。现在我有一个技巧：我会问大模型，让他帮我系统性地总结反对意见以及论证理由，这对我来说非常好用，分享给大家。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;想读一些价值投资者的书，于是就找到了这本但斌的《时间的玫瑰》。这是一本写于 2018 年的书，现在已经过了 7 年。当年的很多论断，随着时间的检验会</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>投机与趋势投资 - 读《股票大作手操盘术》</title>
    <link href="https://blog.devtang.com/2025/09/17/how-to-trade-in-stocks-book-summary/"/>
    <id>https://blog.devtang.com/2025/09/17/how-to-trade-in-stocks-book-summary/</id>
    <published>2025-09-17T13:27:01.000Z</published>
    <updated>2025-09-17T13:41:00.293Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/stock-trade-book-0.jpg" width="300px" /><p>上个月见了一个老朋友：代码家。和代码家聊天的时候，他提到了趋势交易，他还推荐了<a href="https://book.douban.com/subject/19952930/">《股票大作手操盘术》</a>。</p><p>该书的核心思想就是做趋势交易。具体做法是：在形成趋势前观望，在趋势确定建立后顺着趋势做空或做多，在趋势快要结束时，提前补仓或卖出。</p><p>我觉得该思想同样适用于长线操作：每家公司都有上升期和平稳期以及下降期。在公司上升期的时候加仓，平稳期的后期卖出，避免下降期的戴维斯双杀，会是非常重要的。</p><p>举例来说：</p><ul><li><p>房地产公司的上升期投资，相关的股票，即便是恒大，也涨很多。只要你在合适的地方卖出，你就不会亏。</p></li><li><p>很多互联网公司的企业，在互联网泡沫期的估值很高。比如微博，哔哩哔哩，陌陌，包括粉笔公考，猿辅导。只要你在合适的地方卖出，也可以吃到很多的时代红利。但是如果你一直秉持长期持有，就可能不挣钱或者只挣很少的钱。</p></li></ul><p>以下是微博的股价走势，现在的价格（12）比发行价（20）还低，但它曾经涨了 5 倍多。</p><img src="/images/stock-trade-book-1.jpg" class=""><p>以下是哔哩哔哩的股价走势，如果你买在高点，那么会亏 80%。</p><img src="/images/stock-trade-book-2.jpg" class=""><p>以上两个公司就是典型的“互联网”红利公司，在互联网红利期拥有巨大的股价泡沫，在红利结束的时候，股价回归理性。</p><p>我感觉趋势投资不是做短线的投机，而是把握时代的大势。做时代周期（5 年左右）的波段，抓时代红利企业，但是又很冷静，知道自己是投机，能看到卖出下车的时间点。</p><p>我们如果能够在互联网红利期，提前买入微博和哔哩哔哩这样的高用户量的产品。在红利结束前卖掉。我们假设卖在离最高点回撤 50% 的地方，也会有 2-4 倍的收益，整个持股周期在 2-3 年。</p><p>但说起来容易，执行起来还是挺困难的。比如下面是陌陌的走势，2014 年上市，2017 年股价才开始上涨，2018, 2019年均在年中大幅上涨，之后又回到 2017 年的价格。再之后就一路下跌，现在的价格是发行价的一半。</p><img src="/images/stock-trade-book-3.jpg" class=""><p>此书对我最大的价值，就是对价值投资与时代红利周期有了挂钩，之后在思考和判断公司的时候，除了思考价值层面的事情外，更应该思考时代的变化与周期。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/stock-trade-book-0.jpg&quot; width=&quot;300px&quot; /&gt;

&lt;p&gt;上个月见了一个老朋友：代码家。和代码家聊天的时候，他提到了趋势交易，他还推荐了&lt;a href=&quot;https://book.douban.com/subje</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>信息爆炸时代，付费信息才是最好的过滤器</title>
    <link href="https://blog.devtang.com/2025/08/31/pay-your-information/"/>
    <id>https://blog.devtang.com/2025/08/31/pay-your-information/</id>
    <published>2025-08-31T09:46:40.000Z</published>
    <updated>2025-08-31T10:35:37.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“免费的午餐往往是最贵的。为知识付费，是投资自己的认知能力，是这个时代每个人都应该认真考虑的选择。</p></blockquote><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>前几天刷抖音，看到一个财经博主在讲”普通人如何实现财富自由”，视频里充满了夸张的表情和煽动性的文案。视频末尾，他推荐了一个”0元理财训练营”，声称能教你”三个月内资产翻倍”。</p><p>我想起了自己订阅《财新》时的犹豫。为什么我们对免费的低质量内容习以为常，却对高质量的付费内容如此吝啬？</p><p>这个信息爆炸的时代，我们真的需要为知识付费。</p><h2 id="免费内容的陷阱"><a href="#免费内容的陷阱" class="headerlink" title="免费内容的陷阱"></a>免费内容的陷阱</h2><h3 id="质量之殇"><a href="#质量之殇" class="headerlink" title="质量之殇"></a>质量之殇</h3><p>免费的内容最大的问题，就是它根本就不免费。</p><p>当我们在抖音上看到那些”三招教你理财”、”这样做就能年入百万”的短视频时，我们以为自己没有付出成本。但事实上，我们付出的是注意力，付出的是判断力，付出的是被误导的风险。</p><p>这些内容利用了人性中最原始的弱点：贪婪和猎奇。它们用夸张的标题吸引眼球，用简化的逻辑迎合认知懒惰，最终的目的不是传播知识，而是引流变现。</p><p>我记得罗振宇在《逻辑思维》中说过：”免费是世界上最昂贵的东西”。当时不理解，现在想想，免费内容的真实成本往往比付费内容更高，只是这个成本被巧妙地隐藏了。</p><h3 id="注意力的谋杀"><a href="#注意力的谋杀" class="headerlink" title="注意力的谋杀"></a>注意力的谋杀</h3><p>短视频平台更可怕的地方在于，它们正在系统性地破坏我们的专注力。</p><p>抖音上的财经内容，往往用夸张的配音、快节奏的剪辑，以及故意制造的冲突感来抓取注意力。”震惊！这家公司竟然…”、”你绝对想不到的赚钱方式”，这样的文案充斥着整个平台。</p><p>长期消费这样的内容，就像吃快餐一样，看似填饱了肚子，实际上营养不良。我们的大脑习惯了这种高刺激、低思考的信息输入方式，逐渐失去了深度阅读和独立思考的能力。</p><p>更要命的是，算法推荐让我们陷入信息茧房。平台为了让用户停留更长时间，会推送用户喜欢的内容，而不是用户需要的内容。结果是，重要的时政新闻、深度的社会分析被娱乐化的内容所淹没。</p><h2 id="广告的毒药"><a href="#广告的毒药" class="headerlink" title="广告的毒药"></a>广告的毒药</h2><h3 id="隐藏的商业动机"><a href="#隐藏的商业动机" class="headerlink" title="隐藏的商业动机"></a>隐藏的商业动机</h3><p>最近几年，我观察到一个现象：几乎所有的免费财经内容，最终都指向商业变现。</p><p>公众号上那些分析经济形势的文章，看似专业，细读之后会发现，作者往往会推荐某个理财产品或者某个投资平台。文章的逻辑链条是这样的：经济形势不好 → 需要理财 → 推荐我的产品。</p><p>抖音上更直接。那些所谓的”财经大V”，视频内容是免费的，但最终目标是让你扫码进群，然后推销各种理财课程、股票软件，甚至是可疑的投资项目。</p><p>这种商业模式本身没有问题，但它扭曲了内容的客观性。当内容创作者的收入来源是推广费而不是内容质量本身时，内容质量必然会让位于商业转化。</p><h3 id="算法的偏见"><a href="#算法的偏见" class="headerlink" title="算法的偏见"></a>算法的偏见</h3><p>算法推荐进一步加剧了这个问题。</p><p>算法关心的是用户停留时间和点击率，而不是信息的准确性和重要性。一条耸人听闻的假新闻往往比一篇严谨的深度报道有更高的传播率。</p><p>结果是什么？真正重要的政治、经济、社会议题被娱乐化、碎片化的内容所遮蔽。当所有人都在关注某个网红的恋情时，有多少人知道最新的货币政策调整？当大家都在讨论某个段子时，有几个人了解正在发生的地缘政治变化？</p><p>这不是危言耸听。信息质量的下降最终会影响整个社会的决策质量。</p><h2 id="付费的价值"><a href="#付费的价值" class="headerlink" title="付费的价值"></a>付费的价值</h2><p>面对这样的信息环境，我选择了用钱投票。</p><h3 id="我的付费清单"><a href="#我的付费清单" class="headerlink" title="我的付费清单"></a>我的付费清单</h3><p>去年开始，我陆续为以下内容付费：</p><ul><li>《财新》杂志：每年几百块钱，但能获得相对客观、深度的财经报道</li><li>财经类每日新闻：每天需要花 1 块钱，信息密度高，没有广告干扰</li><li>《三联生活周刊》：优质的长篇报道，帮我理解复杂的社会现象</li><li>小宇宙上的访谈节目：深度对话，远比短视频更有营养</li><li>请一些行业专家咨询，事后发微信红包感谢</li></ul><h3 id="付费内容的优势"><a href="#付费内容的优势" class="headerlink" title="付费内容的优势"></a>付费内容的优势</h3><p>付费内容最大的优势在于，它的商业模式相对纯粹。</p><p>当我为《财新》的内容付费时，我就是《财新》的客户。《财新》需要对我的钱负责，需要提供有价值的内容来留住我。这种直接的商业关系，比那种”免费内容+广告变现”的模式要健康得多。</p><p>付费内容的第二个优势是质量控制。</p><p>以《三联生活周刊》为例，它的记者往往需要花费数月时间来调查一个选题，采访几十个相关人员，查阅大量资料，最终呈现出一篇万字长文。这样的内容制作成本很高，只有付费模式才能支撑这样的投入。</p><p>而免费的自媒体内容呢？往往是一个人坐在电脑前，花几个小时搜集网上的资料，拼凑出一篇文章。质量的差距是显而易见的。</p><h2 id="一点反思"><a href="#一点反思" class="headerlink" title="一点反思"></a>一点反思</h2><p>诚然，付费内容也不是万能的。</p><p>《财新》有时也会有立场偏见，《三联》有时也会有不够深入的报道。付费不能保证内容的完美，但它至少能保证内容制作者的基本动机是提供有价值的信息，而不是引流变现。</p><p>另外，并不是所有人都有条件为信息付费。这涉及到信息公平的问题，也是整个社会需要思考的问题。</p><p>但至少对于有条件的人来说，为高质量内容付费，不仅是为了获得更好的信息，也是在用消费选择来支持优质内容的生产，推动整个信息生态的良性发展。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是一个最好的时代，也是一个最坏的时代。</p><p>说它是最好的时代，是因为获取信息从来没有像现在这样便利。说它是最坏的时代，是因为信息质量从来没有像现在这样参差不齐。</p><p>在这样的环境下，为知识付费不是一种消费，而是一种投资。投资自己的认知能力，投资自己的判断力，投资自己的未来。</p><p>毕竟，在这个瞬息万变的时代里，唯一不变的就是变化本身。而应对变化的最好方式，就是保持持续学习的能力。</p><p>免费的午餐往往是最贵的。为知识付费，是这个时代每个人都应该认真考虑的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“免费的午餐往往是最贵的。为知识付费，是投资自己的认知能力，是这个时代每个人都应该认真考虑的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>GESP 202506 5级真题「奖品兑换」题解</title>
    <link href="https://blog.devtang.com/2025/07/01/gesp-level5-202506-1/"/>
    <id>https://blog.devtang.com/2025/07/01/gesp-level5-202506-1/</id>
    <published>2025-07-01T14:29:46.000Z</published>
    <updated>2025-07-01T15:02:04.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><img src="/images/gesp202506-5-1.jpg" class=""><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>此题首先是不能暴力枚举的，因为 n 和 m 最大情况下是 <code>10^9</code>，这个数据规模，暴力枚举肯定会超时。</p><p>然后我们可能想到贪心，但实际可落地的贪心的策略总是有特殊情况。</p><p>最后，假如我们可以检查一个答案是否可行，我们就可以用二分答案+判定的方法求解。</p><p>二分还有一个要求，就是答案是单调递增的。我们可以想像，随着兑换券的递增，如果限定 n 的值不变，那 m 的值肯定是递增的。所以此题符合单调递增的条件。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>那么，对于一个可能的答案 k，我们怎么检查答案是否可行呢？</p><ul><li>我们先把 n 和 m 排序，让 n 是较大者，a 和 b 排序，让 a 是较大者</li><li>对于一份奖品，可以是 <code>n-a</code>, <code>m-b</code> 来获得，也可以是 <code>n-b</code>, <code>m-a</code> 来获得，我们让 <code>d=a-b</code></li><li>因为 a 是较大者，所以当更换兑换方式的时候，n 的值从<code>n-a</code>变成了<code>n-b</code>，相对来说，增加了 d，m 的值减少了 d</li></ul><p>所以：</p><ul><li>我们可以先用第一个兑换方法，把 k 个奖品换成 <code>c1=a*k</code> 张课堂优秀券, <code>c2=b*k</code> 张作业优秀券</li><li>如果 <code>c1 &lt;=n, c2 &lt;= m</code> 那这个答案 k 显然就是可以的。</li><li>但如果 <code>c1 &gt; n</code>，我们可以想到，把超额出来的兑换换成第二个兑换方法</li></ul><p>具体如何换呢？</p><ul><li>我们先计算超额的值，为 <code>c1-n</code></li><li>每次兑换可以让这个值少 d，所以需要换 <code>r=(c1-n)/d (向上取整)</code> 即 <code>r=(c1-n+d-1)/d</code>个</li><li>经过如上的兑换，c1 的值减少了 <code>d*r</code>，c2 的值增加了 <code>d*r</code></li></ul><p>最后需要注意，因为 <code>a*k</code> 的范围可能超过 int，所以需要把计算过程都用 long long 来保存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此题考查了：</p><ul><li>二分+判定的解法</li><li>向上取整的写法</li><li>数据范围的预估</li><li>时间复杂度的预估</li></ul><p>这还是非常综合的一道题。对于没想到二分的学生，也可以用贪心或者暴力枚举骗到不少分（估计 10-15 分），所以此题也有相当的区分度，各种能力的学生都可以拿到部分分数。</p><h2 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, m, a, b, d, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c1 = a*k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c2 = b*k;</span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; n) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> r = (c1 - n + d - <span class="number">1</span>) / d;</span><br><span class="line">        c1 -= r*d;</span><br><span class="line">        c2 += r*d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c1 &lt;= n &amp;&amp; c2 &lt;=m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    d = a - b;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">test</span>(m)) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, m);</span><br><span class="line">            l = m+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;img src=&quot;/images/gesp202506-5-1.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;分析&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>构建你的“多巴胺”系统</title>
    <link href="https://blog.devtang.com/2025/06/22/build-your-own-dopamine-system/"/>
    <id>https://blog.devtang.com/2025/06/22/build-your-own-dopamine-system/</id>
    <published>2025-06-22T14:08:32.000Z</published>
    <updated>2025-07-12T15:28:54.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是“多巴胺”系统"><a href="#什么是“多巴胺”系统" class="headerlink" title="什么是“多巴胺”系统"></a>什么是“多巴胺”系统</h2><p>“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&#x2F;正向情绪的事情。之所以用这个隐喻，一方面是想让大家更容易理解、记忆和传播这个系统。</p><p>这个系统对我来说非常重要，它就相当于我人生的“第一性原理”一样。人类看起来是自己的主人，但人类对自身行为动机的理解很多时候并不清楚。</p><p>马斯洛把人类的需求按层次来分，在他的理论中提到的各种需求：性，安全，食物，社交，自我实现等等。但是其实，这些其实本质上，都是在为人类提供“多巴胺”。</p><img src="/images/mashiluo.jpg" class=""><p>当人类失去了“多巴胺”系统，很多时候就宁愿放弃生命：比如在战争中，很多人为了信仰而牺牲自己。这是因为他内心的目标大于活着的意义。</p><p>在实际生活中，虽然不至于放弃生命，但冒着生命危险做的事情，也不鲜见。比如消防队员救人、警察和歹徒搏斗、或者体育健儿在赛场上带伤为荣誉而战。</p><p>这些行为虽然有可能失去生命，但是换来的荣誉与成就是非常让人自豪的，可以为自己提供终身的多巴胺来源。</p><p>有人说，这个世界上只有两种生意：让人爽的生意和让人牛逼（学习、健身等）的生意。但我觉得，这都是多巴胺的生意，差别只是一个是提供短期多巴胺，一个是提供长期多巴胺。学习这种事情虽然短期很辛苦，但是收获的成就是可以提供长期的回报，从而提供长期的多巴胺。</p><h2 id="为什么“多巴胺”系统很重要"><a href="#为什么“多巴胺”系统很重要" class="headerlink" title="为什么“多巴胺”系统很重要"></a>为什么“多巴胺”系统很重要</h2><h3 id="1、人对生活的意义有需求"><a href="#1、人对生活的意义有需求" class="headerlink" title="1、人对生活的意义有需求"></a>1、人对生活的意义有需求</h3><p>看看全世界有多少人信教就明白了。大部分人都需要精神上为生命的存在赋予意义。意义感会驱使人们面对挑战和困难、提供情绪支撑、获得幸福感。</p><p>在中国，很少有人信教，但是我们每一个普通人也有自己对生命的追求，哪怕是更好一点的生活，或者一个遥不可及的理想，又或者是简单地照顾好家人和孩子。</p><p>人生的目标带动着每一个人在各种重大决策的十字路口上做选择。韩寒为了赛车辍学；赵心童为了台球远赴英国；崔永远为了自由表达离开了央视；而我身边，一个亲人为了更好的照顾孩子而放弃了工作上的晋升机会。</p><p>“多巴胺”系统就是为人生的意义提供基础能量的仓库，守护好多巴胺系统，人生之路就会走得更加从容。</p><h3 id="2、“多巴胺”系统不容易构建"><a href="#2、“多巴胺”系统不容易构建" class="headerlink" title="2、“多巴胺”系统不容易构建"></a>2、“多巴胺”系统不容易构建</h3><p>我们随便看看身边，就会发现无论是学习、工作，还是退休安排和日常生活。“多巴胺”系统的构建都是非常不容易的。</p><h4 id="2-1-学习"><a href="#2-1-学习" class="headerlink" title="2.1 学习"></a>2.1 学习</h4><p>拿学习来说，如果将孩子的“多巴胺”系统和学校排名、升学挂钩，那么很多孩子是无法构建学习的“多巴胺”系统的。因为每个班几十个孩子，必然有排在后面 50% 的孩子。这些孩子从排名上是无法获得正向激励的。</p><p>另外，整个学习是一个不断淘汰对手的游戏。中考会淘汰 50% 的学生分流到中专，高考又会分流 50% 的人到职高，大学又会分流 90% 的学生到非重点大学。研究生考试又会分流 2&#x2F;3 的本科生，只剩下 1&#x2F;3。</p><p>按上面的通过率，就算你是全中国前 1% 的学生，那大概也会止步于 985&#x2F;211 的研究生入学考试。</p><p>所以，在学习上，你总会有一天会遇上身边的对手都比你强，你在这个小圈子里面排在后面，如果你和同学比的话，你能收获的只有负面的情绪，感觉自己像个废物。</p><p>后面我会提到如何构建学习的多巴胺系统。</p><h4 id="2-2-工作"><a href="#2-2-工作" class="headerlink" title="2.2 工作"></a>2.2 工作</h4><p>也许你是一个优秀的员工，不断获得奖励和提拔，但是随着环境和年龄变化，工作中持续获得正反馈是困难的。原因如下：</p><p>第一个原因：正向激励的比例太低。只有前 20% 的员工才能获得超过其他人的回报，大部分人只能拿到普通的绩效和待遇。</p><p>第二个原因：很多工作的经验积累并不是线性的。在积累 3-5 年后，新增加的经验不足以带来相应比例产出提升，这就造成老员工工资过高，性价比不足。拿 iOS 开发来说，工作 10 年和工作 30 年的开发者的经验差异在大部分情况下表现得并不明显，这就可能造成某些工作 10 年以上的老员工薪资涨幅变慢。</p><p>第三个原因：人在 30 岁以后，体力和学习速度逐渐下降。我今年 41 岁，熬夜的能力明显变差。而我在 30 岁的时候，经常熬夜加班。工作中的一些内容如果需要的是堆时间才能完成，老员工的完成速度就不及年轻的员工。</p><p>第四个原因：岗位架构是金字塔形的。越往上需要的人越少，所以一个员工很容易最终就停在某一个岗位无法获得上升机会，背后的原因可能仅仅是因为上面已经有人了，不需要更多管理者。</p><h4 id="2-3-退休"><a href="#2-3-退休" class="headerlink" title="2.3 退休"></a>2.3 退休</h4><p>退休是每个人必须面对的事情，如果不做好准备，“多巴胺”系统根本就不会自己产生。因为每个人退休后，日常生活的节奏就会有巨大变化。而人的时间是需要被填满的，否则就会因为意义感缺失而产生各种问题。</p><h4 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h4><p>其它的部分还包括，生活、家庭、理财等等：</p><ul><li>对于生活：兴趣能否持续，影响“多巴胺”系统的稳定。</li><li>对于家庭：如何处理夫妻关系，亲子关系，婆媳关系，都关系到多巴胺系统的稳定。</li><li>对于理财：如果你买在顶峰，不但需要很长时间回本，也会承受巨大的账面亏损压力，给自己的多巴胺系统带来巨大冲击</li><li>对于伤痛：个人对伤痛，特别是心理层面上的伤痛处理也很重要，心理上的伤痛如果处理不好，就像应激的小猫一样，会给身体带来严重的伤害。</li></ul><h2 id="如何构建“多巴胺”系统"><a href="#如何构建“多巴胺”系统" class="headerlink" title="如何构建“多巴胺”系统"></a>如何构建“多巴胺”系统</h2><p>接下来，我就讲讲我对各种情况下构建“多巴胺”系统的心得。</p><h3 id="1、对于学习"><a href="#1、对于学习" class="headerlink" title="1、对于学习"></a>1、对于学习</h3><p>对于学习，我们需要刻意设计“多巴胺时刻”。让原来可能没有的多巴胺变得有，让原来分泌得少的多巴胺，变得分泌多。具体来说，我们可以：</p><p>一、定期回顾，肯定自己的进步。我每年都会写年度总结，之前觉得每年没有什么变化，但是总结的时候，发现还是有挺多进步的，这样就让自己更有成就感。</p><p>二、设立奖励，自我颁奖。不管是小的学习还是大的学习，都可以设立奖励。我在做竞赛题的时候，之前做完我就继续做下一题。但后来我发现，如果我每次做对，都挥舞一下手臂小小庆祝一下，就会开心很多。所以，即便是很小的自我肯定，都可以让多巴胺给我们更多激励。</p><p>三、适当分享，获得亲朋鼓励。人是社会动物，自己的成就还是要适当分享出来。但是对自己友谊不深的朋友就没太有必要，有可能会造成人家妒忌，或者人家会认为你是一个喜欢炫耀的人，没必要。</p><p>四、构建无限游戏，不要设置终点和上限。学习无止境，如果我们可以一直设立目标，就可以无限玩下去。对于生命来说，能够无限玩的游戏不多，学习算是一个。</p><h3 id="2、对于工作"><a href="#2、对于工作" class="headerlink" title="2、对于工作"></a>2、对于工作</h3><p>刚刚说过，随着环境和年龄变化，工作中持续获得正反馈是困难的。所以，对于工作，我们首先需要做的是降低预期。工作首先你是获得持续现金流的谋生手段；它如果能够给你持续的正向激励，当然很好，但是如果有一天，工作无法给你带来正反馈，那么你也可以就把它当作一份工作即可。</p><p>在工作上不要讲太多回报，公平。很多事情做了没有结果，但是公司付你钱了，所以你认真把事情做好，就很好，也很专业。</p><p>另外，在工作上，我们也需要尊重规律，做累进的事情。坚持在自己的专业领域积累经验，如果自己的年龄大了或者行业发展不好，也要接受工资不再上涨这些现实。</p><p>在工作上，我们还可以尝试杠铃策略，即：同时拥有两个不太相关的专业技能。通过在业余时间利用自己的爱好或者特长来发展副业，如果万一出现什么变动，自己的副业就可以成为主业，保证自己不至于失业。</p><h3 id="3、对于退休"><a href="#3、对于退休" class="headerlink" title="3、对于退休"></a>3、对于退休</h3><p>退休是人一辈子重要的规划之一，也是人生活法的重大转换。</p><p>对于退休，最重要的事情就是让提前规划好兴趣，让兴趣填满自己的时间。否则，人生一下子多了那么多时间，很容易觉得无聊。</p><p>这个兴趣最好是无限挑战游戏。这样可以几十年也做不完。</p><p>这个兴趣也最好可以锻炼到身体（例如：广场舞、摄影、骑行之类）。</p><p>最后，退休还有一个很重要的事情：要管好自己的钱，不冒大的风险，不折腾高风险的投资。因为挣太多钱自己也不一定能花完，但是如果亏很多就会影响自己的退休生活。</p><h3 id="4、日常生活"><a href="#4、日常生活" class="headerlink" title="4、日常生活"></a>4、日常生活</h3><p>日常生活中，有这些技巧可以带来更多的多巴胺：</p><p>一、主动给生活带来变化</p><p>我自己的经验是，主动做一些以前没做过的事情，会给生活带来新鲜感。比如：</p><ul><li>我家每过几年就会尝试换个房子租，每次都有不同的体验。</li><li>每年出游几次，每次去不同的地方，让自己开眼界。</li><li>购物，看上什么东西就买买买。</li><li>庆祝。为自己的成绩庆祝，为朋友的成绩庆祝，为家人的成绩庆祝。</li></ul><p>二、自立</p><p>不要太依赖别人，或者太依赖于某个工作，或者将自己放到一个困境，或者太陷入一个目标。这不是说我们应该不努力。对于生活，我们应该全情投入，把过程做好；但是对于结果，我们应该顺其自然。</p><p>三、终身学习</p><p>学习是少有的，可以持续给人带来获得感的事情。而且这个事情是没有终点的，属于一种“无限游戏”，这就让我们永远不会觉得无聊。</p><p>我最近因为兴趣又开始学习编程，遇到一个算法没看懂，我就慢慢想，可能想个一周，甚至两周，我感觉这才是一个学习的状态，就是慢慢的，不紧不慢的，学完一个再学下一个。</p><p>相对来说，学校的学习更像是一个工业化的人才产出器，每个人需要像机器一样在指定的时间学习完指定的内容，但是每个人的学习能力是不一样的，其实对每个人来说，匹配自己的学习速度才是最佳的学习方案。</p><p>四、关注过程，弱化结果</p><p>人生是一场体验，并非要留下什么，也留不下什么。</p><p>如果我们想想 100 年后谁能记得我们，我们会发现结论是：没有人。即使是自己的亲人，过了三代你可能也不会记得。大家可以想想，你知道你的爷爷的爷爷叫什么名字，长什么样，做过什么成绩吗？就算你记得，你的孩子以后会记得吗？</p><p>所以，如果人生到最后不会有任何人记得我们，那么我们人生的意义是什么？我认为核心的意义就是人生本身。就像《活着》中写道：活着就是最大的意义。</p><p>对于人生这种重过程，无结果的“游戏”，我们活在当下，关注过程，把自己的人生过好，就是一个非常棒的事情了。别的更多的结果，我们做不到，也没有什么意义。</p><h3 id="5、对于家庭"><a href="#5、对于家庭" class="headerlink" title="5、对于家庭"></a>5、对于家庭</h3><p>对于家庭，最简单的获得多巴胺的方式是：低预期。比如：</p><p>对于家人，不要指望家人一定要为自己付出。家人能够不让你付出，就是超预期。有这样的心态，你每天都是超预期。</p><p>对于孩子也一样，低预期，不鸡娃。</p><ul><li>孩子小的时候，我们只需要尽量培养孩子兴趣，兴趣是最大的老师，对于结果，则需要看孩子的天赋和运气，所以我们只能静待花开。</li><li>当孩子成年后，她会有自己的生活，作为父母也应该降低预期，孩子能活成什么样，最主要的还是靠孩子自己。</li><li>当我们老了后，也别指望孩子给自己养老，不啃老就不错了。有这样的低预期，也容易每天获得超预期的结果。</li></ul><h3 id="6、对于朋友"><a href="#6、对于朋友" class="headerlink" title="6、对于朋友"></a>6、对于朋友</h3><p>我认为有三种朋友，可以给我们提供持续的多巴胺。</p><ul><li>一种朋友是相互帮助、支持的人。显然你们相互会收获很多。</li><li>一种是可以给你提供指导的前辈，牛人。你可以收获到成长。</li><li>一种是你可以给别人提供指导的后辈。你可以收获到成就感。</li></ul><p>那哪些是消耗你多巴胺的朋友呢？</p><ul><li>每次需要你的时候找你，但你需要他的时候总逃避的人。</li><li>和你话不投机，没有共同语言的人。</li><li>无法平等对话的人，有可能是对方太过强于你，懒得和你对话；也可能是对方太弱于你，你懒得和他对话。</li><li>让你感觉到有压力，但是除了消耗你多巴胺外，并不能给你带来任何其他好处的人。</li><li>你讨厌的人。</li><li>你嫉妒的人。</li></ul><p>我有些时候，有点讨好型人格，就是不喜欢一个人，也不愿意和人家起冲突，很多时候碍于面子还是淡淡地交往。后来我发现这样不对，这完全是一种对多巴胺系统的伤害，想到这些我就主动断开了一些不喜欢的朋友的来往。其实有一些人是很优秀的，但是多巴胺系统为先的决策，让我还是会坚决断开联系。</p><h3 id="7、对于伤痛"><a href="#7、对于伤痛" class="headerlink" title="7、对于伤痛"></a>7、对于伤痛</h3><p>小孩子如果反复盯着糖果看，最后就会忍不住吃掉糖果。如果有人伤害了你，你反复回忆这个伤害的过程，你就会受到更多的内心部分的伤害。</p><p>著名作家蔡澜最近去世了，别人问他，他的爱人离他而去了，他是如何克服下来的。蔡澜说：你如果老去想这件事情，你就会发疯，所以我尽量让自己不去想这件事情。</p><p>芒格和巴菲特的公司之前特别看好一个接班人，后来这个接班人做了一些违背公司原则的事情，在收购一家公司前，自己私下提前买了这家公司的股票，自己获利了几百万美元。事情暴露之后，这个接班人辞职了。别人问芒格怎么看这个事情。</p><p>面对欺骗与背叛，芒格说：永远不要责备自己，永远不要有受害者心态。当你产生这种心态的时候，只会让你自己难受，不会带来任何其它正面的影响，因此你不应该花时间去感受它，哪怕是一秒钟。所以，更应该的心态是应对这种情况，为未来的不确定性做好准备。</p><p>芒格最后总结道：“I am not a victim. I am a survivor.”</p><p>所以，站在建立“多巴胺”系统的角度，任何只有负面效果的情绪都是不值得去强化和感受的。如果你忍不住，你可以尽量不去想它。更好的办法是像芒格那样，有一个更加强大的幸存者视角来看待所有的坏运气、灾难、欺骗与背叛。让这些负面情绪不影响自己的多巴胺系统。</p><h3 id="8、不内耗和自恰"><a href="#8、不内耗和自恰" class="headerlink" title="8、不内耗和自恰"></a>8、不内耗和自恰</h3><p>我后来发现，其他人讲的一些行事原则，在表达角度上虽然不一样，其实也是一样的道理。比如我们讲的“不内耗”原则。</p><p>内耗就是一种持续消耗“多巴胺”的心理行为。如果以构建“多巴胺”系统作为人生准则的话，我们会发现内耗没有任何效果。当我们面对不如意的时候，要么改变，要么适应，要么淡化，而内耗是一种既不改变，又不适应，又反复强化负反馈的行为。百害而无一利。</p><p>自恰的底层含义是：所有事情能够自圆其说，不矛盾，不冲突，自然也就不内耗了，不消耗多巴胺。</p><p>所以，人需要活得“自恰”，只有自恰才能睡好觉，持续获得多巴胺。</p><h2 id="主观与客观"><a href="#主观与客观" class="headerlink" title="主观与客观"></a>主观与客观</h2><p>“多巴胺”系统有主观的部分，也有客观的部分。</p><p>一、主观部分</p><p>“多巴胺”系统对于个人内心是一种主观行为和感受，而不是一种客观描述和标准。所以，对于芒格来说，一个重要朋友的背叛不是对“多巴胺”系统的冲击；但换一个人，可能觉得天塌了，一辈子再难信任他人。</p><p>因此，我们更应该调整的是自我的行事方式和思考问题的角度，而不是改变其他人。我们可以远离那些影响我们“多巴胺”系统的人和事，但是当坏运气到来的时候，我们只能接受。</p><p>二、客观部分</p><p>当然，“多巴胺”系统在指导我们行为的时候，是让我们客观上在做具体的行为选择。通过行为选择让我们尽可能构建有利于我们产生多巴胺的外界环境。比如我刚刚提到的：提前规划退休生活、选择终身学习、多搞庆祝活动等。这些有利的环境不但不会消耗我们主观意志来维护多巴胺，还会给我们提供愉悦，贡献多巴胺。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&#x2F;正向情绪的事情。我们通过：</p><ul><li>主观上，调整自己的思考和看待事情的方式</li><li>客观上，搭建好能够持续供养自己多巴胺的外部环境</li></ul><p>利用“多巴胺”系统，让自己的人生少一点内耗，少一点纠结，多一点平静，多一点快乐。</p><p>愿每个读者都能过好当下的每一天，谢谢！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是“多巴胺”系统&quot;&gt;&lt;a href=&quot;#什么是“多巴胺”系统&quot; class=&quot;headerlink&quot; title=&quot;什么是“多巴胺”系统&quot;&gt;&lt;/a&gt;什么是“多巴胺”系统&lt;/h2&gt;&lt;p&gt;“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&amp;#x2F;正向情绪的事</summary>
      
    
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>GESP 核心考点</title>
    <link href="https://blog.devtang.com/2025/06/06/gesp-notes/"/>
    <id>https://blog.devtang.com/2025/06/06/gesp-notes/</id>
    <published>2025-06-06T14:12:03.000Z</published>
    <updated>2025-10-21T00:34:14.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GESP-1-级"><a href="#GESP-1-级" class="headerlink" title="GESP 1 级"></a>GESP 1 级</h1><h2 id="大题核心考点"><a href="#大题核心考点" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>1 级主要考查分支和循环结构，所以大题的解法一般都是一个 for 循环，然后循环里面用 if 之类的条件判断做一些事情，最后再输出结果。其代码框架为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环结构, 例如 for ...</span></span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line"><span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure><p>拿 GESP202309 一级题目：<a href="https://www.luogu.com.cn/problem/B3864">小明的幸运数</a> 来说，其核心代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLucky</span>(i)) &#123;</span><br><span class="line">        <span class="comment">// 累加</span></span><br><span class="line">        ans += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>另外一个例子，GESP202503 一级题目：<a href="https://www.luogu.com.cn/problem/B4258">四舍五入</a>，核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    b = a%<span class="number">10</span>;</span><br><span class="line">    a = a/<span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">4</span>) a = a*<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> a = a*<span class="number">10</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GESP-2-级"><a href="#GESP-2-级" class="headerlink" title="GESP 2 级"></a>GESP 2 级</h1><h2 id="大题核心考点-1"><a href="#大题核心考点-1" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="考点一：双重循环"><a href="#考点一：双重循环" class="headerlink" title="考点一：双重循环"></a>考点一：双重循环</h3><p>GESP 2 级相对 1 级，对循环结构的考查进行了加强，一般需要用双层嵌套的循环才能完成大题。有一类双层嵌套循环需要特别关注，就是模拟输出类，这一类题过去考过多次，包括：</p><ul><li>GESP202309，<a href="https://www.luogu.com.cn/problem/B3865">小杨的 X 字矩阵</a></li><li>GESP202312，<a href="https://www.luogu.com.cn/problem/B3924">小杨的 H 字矩阵</a></li><li>GESP202403，<a href="https://www.luogu.com.cn/problem/B3955">小杨的日字矩阵</a></li><li>GESP202409，<a href="https://www.luogu.com.cn/problem/B4037">小杨的 N 字矩阵</a></li><li>GESP202503，<a href="https://www.luogu.com.cn/problem/B4259">等差矩阵</a></li><li>GESP202303，<a href="https://www.luogu.com.cn/problem/B3837">画三角形</a></li><li>样题，<a href="https://www.luogu.com.cn/problem/B3844">画正方形</a></li></ul><p>以<a href="https://www.luogu.com.cn/problem/B4259">等差矩阵</a>为例，其关键代码为嵌套的 for 循环，参考如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 嵌套的 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cout &lt;&lt; i*j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果学生还是不熟悉，可以考虑如下更多的练习：</p><ul><li>模仿 <a href="https://www.luogu.com.cn/problem/B3865">小杨的 X 字矩阵</a>，输出 “又” 字，倒 “N” 字，“工” 字矩阵，“口”字矩阵</li><li>模仿 <a href="https://www.luogu.com.cn/problem/B3837">画三角形</a>，输出 左对齐、右对齐的正三角形，倒三角形</li><li>模仿 <a href="https://www.luogu.com.cn/problem/B4259">等差矩阵</a>，输出求和的矩阵，输出只有偶数的等差矩阵（奇数位填 <code>*</code>）</li></ul><p>有一些时候，双重循环也不一定以输出图案的方式来进行考查，比如题目 <a href="https://www.luogu.com.cn/problem/B4356">B4356 202506 二级 数三角形</a> 就是一个案例，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a&lt;=n; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = a; b&lt;=n; ++b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a*b%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的练习题目如下：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3994">https://www.luogu.com.cn/problem/B3994</a></li><li><a href="https://www.luogu.com.cn/problem/B3995">https://www.luogu.com.cn/problem/B3995</a></li><li><a href="https://www.luogu.com.cn/problem/B3986">https://www.luogu.com.cn/problem/B3986</a></li><li><a href="https://www.luogu.com.cn/problem/B3988">https://www.luogu.com.cn/problem/B3988</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于双重循环输出图形，解题的关键在于：分析图形所代表的序列。例如图形：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+</span><br><span class="line">-+-+-</span><br><span class="line">--+--</span><br><span class="line">-+-+-</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure><p>对应的序列是 </p><ul><li><code>(1,1)(2,2)(3,3)(4,4)(5,5)</code></li><li><code>(1,5)(2,4)(3,3)(4,2)(5,1)</code></li></ul><p>然后，我们在做双重循环输出的时候，已经有两个序列 i 和 j，分别表示行号和列号。<br>我们可以分析 i 和 j 与我们需要输出的数据有什么关系，最后就会发现，规律是 <code>i == j</code> 或者 <code>i+j == n+1</code></p><p>我们再看一个复杂的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..#..</span><br><span class="line">.#.#.</span><br><span class="line">#...#</span><br><span class="line">.#.#.</span><br><span class="line">..#..</span><br></pre></td></tr></table></figure><p>它对应的序列不太好找规律，我们可以用两个变量 a 和 b，分别表示每一行需要输出的 y 坐标。<br>刚开始 <code>(a,b)=(3,3)</code>，然后：</p><ul><li>对于上半部分，每增加一行，<code>a--</code>, <code>b++</code>。</li><li>对下下半部分，每增加一行，<code>a++</code>, <code>b--</code>。</li></ul><p>我们再看一些更复杂的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..#....#..</span><br><span class="line">.#.#..#.#.</span><br><span class="line">#...##...#</span><br><span class="line">.#.#..#.#.</span><br><span class="line">..#....#..</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..#...#..</span><br><span class="line">.#.#.#.#.</span><br><span class="line">#...#...#</span><br><span class="line">.#.#.#.#.</span><br><span class="line">..#...#..</span><br></pre></td></tr></table></figure><p>都可以用刚刚找到的思路来解决。</p><p>但对于更复杂的图形，就得再想办法，比如</p><ul><li><a href="https://iai.sh.cn/problem/645">https://iai.sh.cn/problem/645</a></li><li><a href="https://iai.sh.cn/problem/634">https://iai.sh.cn/problem/634</a></li></ul><p>这类题目需要根据题目的输出要求，思考问题拆解的办法，每道题的解法可能都不一样。</p><h3 id="考点二：常用函数"><a href="#考点二：常用函数" class="headerlink" title="考点二：常用函数"></a>考点二：常用函数</h3><p>2 级还会考一些我们经常会实现的函数。包括：</p><h4 id="求素数函数"><a href="#求素数函数" class="headerlink" title="求素数函数"></a>求素数函数</h4><p>参考题目：<a href="https://www.luogu.com.cn/problem/B3840">GESP202306 找素数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;=a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/P1217">P1217 回文质数 Prime Palindromes</a></li></ul><h4 id="求闰年函数"><a href="#求闰年函数" class="headerlink" title="求闰年函数"></a>求闰年函数</h4><p>参考题目：<a href="https://www.luogu.com.cn/problem/B4260">GESP202503 时间跨越</a></p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把一个数的每一位数字拆分的写法"><a href="#把一个数的每一位数字拆分的写法" class="headerlink" title="把一个数的每一位数字拆分的写法"></a>把一个数的每一位数字拆分的写法</h4><p>参考题目：<a href="https://www.luogu.com.cn/problem/B4007">GESP202406 计数</a></p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%<span class="number">10</span> == k) ret++;</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题目：</p><ul><li><a href="https://www.luogu.com.cn/problem/B4036">GESP202409 数位之和</a></li><li><a href="https://www.luogu.com.cn/problem/B2078">B2078 含 k 个 3 的数</a></li><li><a href="https://www.luogu.com.cn/problem/B2081">B2081 与 7 无关的数</a></li><li><a href="https://www.luogu.com.cn/problem/B2152">B2152 分离整数的各个数</a></li><li><a href="https://www.luogu.com.cn/problem/B2154">B2154 数 1 的个数</a></li></ul><h1 id="GESP-3-级"><a href="#GESP-3-级" class="headerlink" title="GESP 3 级"></a>GESP 3 级</h1><h2 id="选择、判断题核心考点"><a href="#选择、判断题核心考点" class="headerlink" title="选择、判断题核心考点"></a>选择、判断题核心考点</h2><ul><li>原码，返码，补码的表示</li><li>进制转换（二进制、八进制、十进制、十六进制）</li><li>位运算</li><li>字符串相关的操作</li></ul><h2 id="大题核心考点-2"><a href="#大题核心考点-2" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="考点一：字符串操作"><a href="#考点一：字符串操作" class="headerlink" title="考点一：字符串操作"></a>考点一：字符串操作</h3><p>3 级对字符串的操作要求非常高，需要考生灵活掌握字符串的变换、拼接、求子串、判断回文等操作。</p><p>求子串可以用 string 类的 <code>substr(int pos, int len)</code> 函数。需要注意该函数的两个参数分别是起始下标和长度。</p><p>其中，判断回文的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isReverse</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[len-i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以真题 <a href="https://www.luogu.com.cn/problem/B4039">GESP202409 回文拼接</a> 为例，考生需要对字符串进行切分，然后分别判断是否是回文串。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isReverse</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[len-i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                string s2 = s.<span class="built_in">substr</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isReverse</span>(s1) &amp;&amp; <span class="built_in">isReverse</span>(s2)) &#123;</span><br><span class="line">                    ans = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该考点的相关真题：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3843">GESP202306 密码合规</a></li><li><a href="https://www.luogu.com.cn/problem/B3956">GESP202403 字母求和</a></li><li><a href="https://www.luogu.com.cn/problem/B4003">GESP202406 移位</a></li><li><a href="https://www.luogu.com.cn/problem/B4067">GESP202412 打印数字</a></li><li><a href="https://www.luogu.com.cn/problem/B3868">GESP202309 进制判断</a></li></ul><p>其中 <a href="https://www.luogu.com.cn/problem/B3868">GESP202309 进制判断</a> 看起来是考进制的规则，实际上也是考字符串的查找。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isRange</span><span class="params">(string s, string range)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">char</span> ch = s[i];</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;range.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == range[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == range.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;01&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;01234567&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;0123456789&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;0123456789ABCDEF&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="考点二：前缀和"><a href="#考点二：前缀和" class="headerlink" title="考点二：前缀和"></a>考点二：前缀和</h3><p>前缀和的计算技巧是：用一个累加变量来不停地更新前 N 个数的和，这样我们只需要用 O（N）的时间复杂度，就可以把所有的前缀和求出来。</p><p>参考题目：<a href="https://www.luogu.com.cn/problem/B4038">GESP202409 平衡序列</a></p><p>此题解法是：暴力测试，先计算出总和 tot ，然后看前缀和的两倍有没有可能等于 tot。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, v[<span class="number">10010</span>], tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            tot += v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; cnt*<span class="number">2</span>&lt;tot; ++i) &#123;</span><br><span class="line">            cnt += v[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt*<span class="number">2</span> == tot) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="考点三：位运算"><a href="#考点三：位运算" class="headerlink" title="考点三：位运算"></a>考点三：位运算</h3><p>考生需要熟悉二进制，以及数的位运算操作。</p><p>典型考题为：<a href="https://www.luogu.com.cn/problem/B4261">GESP202503 2025</a></p><p>此题的思路如下：因为 x 最大是 2025，而如果 y 需要影响 x 的运算，只能与 x 的 bit 位是 1 的位进行操作。所以 y 如果存在，则必定小于 2048。因为 2048 的二进制 1 的 bit 位已经超过 2025 的最高位了。所以直接枚举 1～2048 之间的答案即可。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2048</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; i) + (x | i) == <span class="number">2025</span>) &#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GESP-4-级"><a href="#GESP-4-级" class="headerlink" title="GESP 4 级"></a>GESP 4 级</h1><h2 id="大题核心考点-3"><a href="#大题核心考点-3" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>考点比较散，以下是历次考题的考点。</p><ul><li>GESP-202306 幸运数：模拟</li><li>GESP-202309 进制转换：进制转换</li><li>GESP-202309 变长编码：位操作</li><li>GESP-202312 小杨的字典：字符串操作</li><li>GESP-202312 田忌赛马：排序，模拟</li><li>GESP-202403 相似字符串：字符串操作</li><li>GESP-202403 做题：贪心</li><li>GESP-202406 黑白方块：枚举</li><li>GESP-202406 宝箱：枚举，二分</li><li>GESP-202409 黑白方块：枚举</li><li>GESP-202409 区间排序：排序</li><li>GESP-202412 Recamán：枚举</li><li>GESP-202412 字符排序：排序</li><li>GESP-202503 荒地开垦：枚举</li><li>GESP-202503 二阶矩阵：枚举</li><li>GESP-202509 排兵布阵：枚举 </li><li>GESP-202509 最长连续段：排序</li></ul><p>其中，比较常考的考点：</p><ul><li>枚举：考了 7 次。</li><li>排序：考了 4 次。</li><li>字符串操作：考了 2 次。</li></ul><h1 id="GESP-5-级"><a href="#GESP-5-级" class="headerlink" title="GESP 5 级"></a>GESP 5 级</h1><h2 id="大题核心考点-4"><a href="#大题核心考点-4" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>待补充</p><h1 id="GESP-6-级"><a href="#GESP-6-级" class="headerlink" title="GESP 6 级"></a>GESP 6 级</h1><h2 id="大题核心考点-5"><a href="#大题核心考点-5" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><ul><li><a href="https://www.luogu.com.cn/problem/P10109">P10109 GESP-202312 六级 工作沟通</a></li><li><a href="https://www.luogu.com.cn/problem/P13016">P13016 GESP-202506 六级 最大因数</a></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>包括 01 背包和完全背包：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3873">B3873  202309 六级 小杨买饮料</a></li><li><a href="https://www.luogu.com.cn/problem/P13015">P13015 202506 六级 学习小组</a></li><li><a href="https://www.luogu.com.cn/problem/P10721">P10721 202406 六级 计算得分</a></li></ul><p>基础动态规划：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10108">P10108 202312 六级 闯关游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P10376">P10376 202403 六级 游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P11246">P11246 202409 六级 小杨和整数拆分</a></li></ul><p>记忆化搜索：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10250">P10250 GESP样题 六级 下楼梯</a></li></ul><p>复杂贪心：</p><ul><li><a href="https://www.luogu.com.cn/problem/P11247">P11247 202409 六级 算法学习</a></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>树状数组：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3874">B3874 202309 六级 小杨的握手问题</a></li></ul><p>暴力枚举：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10377">P10377 202403 六级 好斗的牛</a></li></ul><p>模拟+高精度：</p><ul><li><a href="https://www.luogu.com.cn/problem/P11375">P11375 202412 六级 树上游走</a></li></ul><h2 id="相关练习题目"><a href="#相关练习题目" class="headerlink" title="相关练习题目"></a>相关练习题目</h2><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p>从 <a href="https://www.luogu.com.cn/problem/list?type=luogu&page=1&tag=139&orderBy=difficulty&order=asc">这儿</a> 可以获得洛谷上所有的背包相关题目，推荐练习的如下：</p><ul><li><a href="https://www.luogu.com.cn/problem/P1734">P1734 最大约数和</a></li><li><a href="https://www.luogu.com.cn/problem/P1507">P1507 NASA的食物计划</a></li><li><a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a></li><li><a href="https://www.luogu.com.cn/problem/P1060">P1060 NOIP 2006 普及组 开心的金明</a></li><li><a href="https://www.luogu.com.cn/problem/P1358">P1358 扑克牌</a></li><li><a href="https://www.luogu.com.cn/problem/P1877">P1877 HAOI2012 音量调节</a></li><li><a href="https://www.luogu.com.cn/problem/P1910">P1910 L 国的战斗之间谍</a></li><li><a href="https://www.luogu.com.cn/problem/P1926">P1926 小书童——刷题大军</a></li><li><a href="https://www.luogu.com.cn/problem/P1855">P1855 榨取kkksc03</a></li><li><a href="https://www.luogu.com.cn/problem/P2430">P2430 严酷的训练</a></li><li><a href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日</a></li><li><a href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包</a></li></ul><h1 id="GESP-7-级"><a href="#GESP-7-级" class="headerlink" title="GESP 7 级"></a>GESP 7 级</h1><h2 id="大题核心考点-6"><a href="#大题核心考点-6" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>背包：</p><ul><li><a href="https://www.luogu.com.cn/problem/P13018">P13018 202506 七级 调味平衡</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GESP-1-级&quot;&gt;&lt;a href=&quot;#GESP-1-级&quot; class=&quot;headerlink&quot; title=&quot;GESP 1 级&quot;&gt;&lt;/a&gt;GESP 1 级&lt;/h1&gt;&lt;h2 id=&quot;大题核心考点&quot;&gt;&lt;a href=&quot;#大题核心考点&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学总结：树状数组</title>
    <link href="https://blog.devtang.com/2025/04/26/teaching-notes-of-bit/"/>
    <id>https://blog.devtang.com/2025/04/26/teaching-notes-of-bit/</id>
    <published>2025-04-26T12:12:23.000Z</published>
    <updated>2025-07-06T06:14:15.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有些时候，题目给我们 N 个元素的序列，然后让我们求前缀和或者区间和。并且，题目还会动态地修改这个序列的值。如果我们每次暴力求解前缀和，时间复杂度会是 O（N），而使用树状数组，可以将查询前缀和的复杂度降低到 O(LogN)。</p><p>树状数组是挺不好教学的一个知识点。它需要以下前置知识：</p><ul><li>二进制表示法及熟练的位操作</li><li>前缀和的知识</li><li>树的基础知识</li><li>时间复杂度的估算</li></ul><p>在教学的时候，我们的教学顺序如下：</p><ul><li>先引入问题</li><li>lowbit 函数讲解</li><li>树状数组的结构特点</li><li>利用树状数组求前缀和的方法</li><li>怎么修改树状数组的值</li><li>如何初始化树状数组</li><li>增加值或替换值</li><li>二维的树状数组</li></ul><p>那么让我们来开始。</p><h2 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h2><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a> 是一道标准的树状数组问题：该题目给我们了一个数列，我们需要解决以下两个问题：</p><ul><li>数列的区间求和</li><li>更新某一个数（加上 x）</li></ul><p>我们很容易想到用暴力的方法来做此题。于是我们可以估计一下暴力的时间复杂度：</p><ul><li>数列的区间求和，时间复杂度 O（N）</li><li>更新某一个数，时间复杂度 O（1）</li></ul><p>题目中提到，求和的次数最多为 M 次，所以最坏情况下，时间复杂度为 <code>O(M*N)</code>。而由于 M 和 N 的最大范围为 <code>5*10^5</code>，所以最大运算次数高达 <code>(5*10^5) * (5*10^5) = 2500亿</code>次，而竞赛中估算 1000 万次的运算时间就接近 1 秒了，这个时间肯定会超时。</p><p>数列的区间求和有一个 O（1）的办法，就是提前求出前缀和。假如 Sum(i) 表示前 i 个数的和，那么区间 <code>(i,j]</code> 的和就可以通过 <code>Sum(j) - Sum(i)</code> 来得出。可惜的是，本题还有一个操作是更新某一个数。如果更新的是第一个数，那么整个前缀和数组 Sum 都需要更新，这样更新的时间复杂度会变成 O（N），最坏情况下会有 <code>O(M*N)</code>次更新，造成运算同样超时。</p><p>由此，我们需要一个更优秀的数据结构来解决这类问题，这就是树状数组。</p><h2 id="lowbit-函数"><a href="#lowbit-函数" class="headerlink" title="lowbit 函数"></a>lowbit 函数</h2><p>在讲解树状数组前，我们先学习一下 lowbit 函数。</p><p>lowbit 函数实现的功能是：求 x 的二进制最低位 <code>1</code> 以及后面的 <code>0</code> 组成的数。例如：</p><ul><li>8 (10 进制) &#x3D; 1000 (2 进制) ，则 lowbit(8) &#x3D; 8</li><li>9 (10进制）&#x3D; 1001（2 进制），则 lowbit(9) &#x3D; 1</li><li>10（10 进制）&#x3D; 1010（2 进制），则 lowbit(10) &#x3D; 2</li></ul><p>所以，我们需要找到目标数的二进制中的最后那个 <code>1</code> 的位置。有两种实现方式：</p><h3 id="方法一：x-x-1-x"><a href="#方法一：x-x-1-x" class="headerlink" title="方法一：x^(x-1) &amp; x"></a>方法一：<code>x^(x-1) &amp; x</code></h3><p>方法一相对比较好理解，我拿二进制数 <code>1100</code> 举例解释如下：</p><ul><li><code>(x-1)</code>的效果，相当于把二进制的最后一个<code>1</code>变成 <code>0</code>，比如某数 <code>1100</code> 减 <code>1</code>之后，就变成了 <code>1011</code></li><li>这个时候，如果我用 <code>x^(x-1)</code>,就会得到 <code>1100^1011=0111</code></li><li>最后，用 <code>x&amp;</code> 刚刚的 <code>x^(x-1)</code>，就相当于把<code>x</code>的最后一个<code>1</code>留下来了，前面的<code>1</code>都抹掉了：<code>1100 &amp; 0111 = 0100</code></li></ul><h3 id="方法二：x-x"><a href="#方法二：x-x" class="headerlink" title="方法二：x&amp;-x"></a>方法二：<code>x&amp;-x</code></h3><p>我们还是拿二进制数 <code>1100</code> 举例，由于负数是用补码表示，所以对于 <code>1100</code>，它的负数：</p><ul><li>原码为：<code>11100</code>(最高为 1 为符号位)</li><li>反码为：<code>10011</code>(反码符号位不变，其余位取反)</li><li>补码为：<code>10100</code>（补码&#x3D;反码+1）</li></ul><p>这样一操作，<code>x&amp;-x</code> 就等于 <code>01100 &amp; 10100 = 0100</code>，同样把最后的 <code>1</code> 取出来了。</p><p>在实现中，我们用方法二的更多，因为更短。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组的定义"><a href="#树状数组的定义" class="headerlink" title="树状数组的定义"></a>树状数组的定义</h2><p>对于一个长度为 N 的序列，为了满足上面提到的更快的区间求和和更新的需求，我们可以构造一个树状数组。</p><p>树状数组（Binary Index Tree，简称 BIT）通过构造另一个长度为 N 的数组，来做到：</p><ul><li>区间求和，时间复杂度 <code>O(log N)</code></li><li>更新某一个数，时间复杂度 <code>O(log N)</code></li></ul><p>因为树状数组需要另外创建一个长度为 N 的数组，所以它的空间复杂度为<code>O(N)</code>。</p><p>我们先创建出这个数组 b ，然后再引入它的元素间的树状逻辑关系。</p><img src="/images/bit-1.jpg" class=""><p>我们有了数组 b，我们让数组 b 相对于原始序列 a，按如下的关系来保存范围和：</p><ul><li><code>b[1]</code> 保存 <code>a[1]</code>的值</li><li><code>b[2]</code> 保存区间 <code>[a[1], a[2]]</code> 的和</li><li><code>b[3]</code> 保存 <code>a[3]</code>的值</li><li>….省略若干行</li><li><code>b[8]</code> 保存区间 <code>[a[1], a[8]]</code> 的和</li></ul><img src="/images/bit-2.jpg" class=""><p>我们先不管如何做到的，先假设我们按上面的逻辑，初始化好了这个数组，那么它怎么能快速求出前缀和呢？</p><h2 id="树状数组求和"><a href="#树状数组求和" class="headerlink" title="树状数组求和"></a>树状数组求和</h2><p>我们假设要求 <code>a[1] ~ a[7]</code>的和，如下图所示，我们知道这段和满足：<code>Sum(7) = b[4] + b[6] + b[7]</code></p><img src="/images/bit-3.jpg" class=""><p>那么，我们观察一下 <code>b[4],b[6],b[7]</code> 这几个下标有什么特点：</p><ul><li>4 的二进制：0100</li><li>6 的二进制：0110</li><li>7 的二进制：0111</li></ul><p>如果结合上我们刚刚教的 lowbit 函数，我们就可以发现如下规律：</p><ul><li>4 的二进制：0100，<code>4 = 6 - lowbit(6)</code></li><li>6 的二进制：0110，<code>6 = 7 - lowbit(7)</code></li><li>7 的二进制：0111</li></ul><p>于是，如果我们要求 Sum(7)，就可以用 b[7] 开始累加，然后用 <code>7 - lowbit(7)</code> 得到 6，再用 <code>6 - lowbit(6)</code> 得到 4，最后 <code>4 - lowbit(4) = 0</code>，就结束整个求和累加过程。</p><p>把以上逻辑转换成代码，是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能要问了，这个求和都是从序列开头开始的，如果我们想求序列中间一段，比如从 x 到 y 的区间和，应该怎么办呢？这种情况，我们可以：</p><ul><li>用 query(y) 把从头到 y 位置的和求出来</li><li>用 query(x-1) 把从头到 x-1 位置的和求出来</li><li>然后相减 <code>query(y) - query(x-1)</code> 得到区间 <code>[x,y]</code> 的和</li></ul><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>树状数组也支持更新数据，像<a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a>题目中要求的那样，我们可以将某个数加上 x，这种情况应该如何更新数组呢？</p><p>我们以更新 <code>a[1]</code>为例，通过观察，我们发现涉及 <code>a[1]</code> 的数组有：<code>b[1],b[2],b[4],b[8]</code>，如下图所示：</p><img src="/images/bit-4.jpg" class=""><p>你有观察出来规律吗？这刚好是我们构建的这个树从叶子结点到根结点的一条路径。</p><p>那同样的问题来了，我们如何求解出<code>b[1],b[2],b[4],b[8]</code>这个路径呢？我们来观察一下：</p><ul><li>1 的二进制是：0001</li><li>2 的二进制是：0010, <code>2 = 1 + lowbit(1)</code></li><li>4 的二进制是：0100, <code>4 = 2 + lowbit(2)</code></li><li>8 的二进制是：1000, <code>8 = 4 + lowbit(4)</code></li></ul><p>我们再验证一个中间结点的更新，比如更新 a[5]，如下图所示：</p><img src="/images/bit-5.jpg" class=""><p>我们看看规则是不是一样：</p><ul><li>5 的二进制是 0101，</li><li>6 的二进制是 0110，<code>6 = 5 + lowbit(5)</code></li><li>8 的二进制是 1000，<code>8 = 6 + lowbit(6)</code></li></ul><p>至此，我们总结出更新方法：从数列的下标 idx 开始，不停地更新，并且用 <code>idx += lowbit(idx)</code> 获得下一个更新的下标，直到更新到下标超过上界（N）为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>最暴力的初始化方法是：我们假设原序列全是 0，这样树状数组的初始状态也全是 0 即可正常表达上面的树型关系。然后，我们把每一个 a 序列中的数用更新的方式来放入树状数组中。</p><p>至此，我们完成了例题<a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a>中的所有细节讨论，完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(500000+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，以上的这种初使化方法，时间复杂度为 <code>O(N*logN)</code>，如果数据刚好卡在初始化中，我们可以用以下这种方法来将初始化时间复杂度优化到 <code>O(N)</code>。</p><h2 id="初始化（优化）"><a href="#初始化（优化）" class="headerlink" title="初始化（优化）"></a>初始化（优化）</h2><p>为了讲明白这种初始化，我们需要观察树状数组 b 中的每个元素代表的数据范围有什么规律。为什么 b[5] 只代表 a[5] 一个元素，但是 b[8]代表的是<code>[a[1],a[8]]</code> 区间的 8 个元素的和 ？</p><img src="/images/bit-6.jpg" class=""><p>最终我们可以发现，一个数组元素代表的区间范围大小就是它的 lowbit 函数求出来的值。</p><p>例如：</p><ul><li>lowbit(5) &#x3D; 1，所以它只代表 a[5] 一个元素</li><li>lowbit(8) &#x3D; 8，所以它代表 <code>[a[1],a[8]]</code> 共 8 个元素</li><li>一个十进制数 88，其二进制为 <code>01011000</code>，<code>lowbit(88)=8</code>，所以它代表的区间为 8 个元素。</li></ul><p>进一步的，我们可以观察出，对于一个 b[x]，它代表的区间为<code>[x-lowbit(x)+1, x]</code>。</p><p>这对初始化有什么用呢？</p><ul><li>我们如果构建了数组 a 的前缀和数组 s，s[i]表示前 i 个数的和。</li><li>那么，我们就可以用前缀和数组 s 来初始化 b[x]。</li></ul><p>因为 b[x] 代表的区间和是<code>[x-lowbit(x)+1, x]</code>,所以：<code>b[i] = s[i] - s[i-lowbit(i)]</code></p><p>至此，我们可以将例题<a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a>的代码更新如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(500000+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        b[i] = s[i] - s[i-<span class="built_in">lowbit</span>(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管辖区间"><a href="#管辖区间" class="headerlink" title="管辖区间"></a>管辖区间</h2><p>上面讲到，树状数组中的元素 b[x] 管辖的区间和是<code>[x-lowbit(x)+1, x]</code>，因此，我们更能理解树状数组的更新逻辑：</p><ul><li>所谓的更新a[x]，就是把管辖区间涵盖 a[x] 的所有 b[x]都更新一遍。</li><li>那哪些 b[x]的管辖区间涵盖 a[x]呢？就是从二进制看，就是范围中有 lowbit(x) 的数。</li></ul><p>举例来说，如果我们要更新 a[2] 的值，lowbit(2) 的值是 0010，所以，我们要更新：</p><ul><li>b[2], 因为 2 的二进制是 0010，管辖区间是 <code>[1, 2]</code>，宽度是 2</li><li>b[4], 因为 4 的二进制是 0100，管辖区间是 <code>[1, 4]</code>，宽度是 4</li><li>b[8], 因为 8 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>再举一个例子，如果我们要更新 a[5] 的值，lowbit(5) 的值是 0001，所以我们要更新：</p><ul><li>b[5]，因为 5 的二进制是 0101，管辖区间是 <code>[5, 5]</code>，宽度是 1</li><li>b[6]，因为 6 的二进制是 0110，管辖区间是 <code>[5, 6]</code>，宽度是 2</li><li>b[8]，因为 8 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>再举一个例子，如果我们要更新 a[7] 的值，lowbit(7) 的值是 0001，所以我们要更新：</p><ul><li>b[7]，因为 7 的二进制是 0111，管辖区间是 <code>[7, 7]</code>，宽度是 1</li><li>b[8]，因为 8 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>通过上面的例子，我们可以看到，管辖区间在更新的过程中宽度是不断扩大的。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。</p><p>我们再从另一个角度来看管辖区间：我们把数状数组的第 1 个到第 56 个元素的二进制列出来，如下所示：</p><img src="/images/lowbit_list.jpg" class=""><p>我们可以观察到：bit 为 1 的位置越低，管辖的区域越小，所以：</p><ul><li>有一半管辖区域大小为 1 的数（图中为粉色）</li><li>剩下的一半，有一半管辖区域大小为 2 的数（图中为绿色）</li><li>再剩的一半，有一半管辖区域大小为 4 的数（图中为紫色）</li><li>再剩的一半，有一半管辖区域大小为 8 的数（图中为黄色）</li></ul><p>再看这些数的间隔：</p><ul><li>粉色的间隔是 2-1，每 2 个出现一次</li><li>绿色的间隔是 4-1，每 4 个出现一次</li><li>紫色的间隔是 8-1，每 8 个出现一次</li><li>黄色的间隔是 16-1，每 16 个出现一次</li></ul><p>所以，其实树状数组是把区间和数据按分治的思想进行了切分，这样可以快速求和。</p><p>另外，从管辖区域的角度考虑，每一个数在进行 lowbit 减运算的时候，得到的新数，一定和之前的区间不是重叠的。我们可以这样证明：</p><ul><li>每个元素 <code>b[x]</code> 管辖的区间和是<code>[x-lowbit(x)+1, x]</code></li><li>我们令 <code>y = x - lowbit(x)</code>, 则 <code>b[y]</code> 的管辖区间就是：<code>[y-lowbit(y)+1, y]</code>,即：<code>[y-lowbit(y)+1, x - lowbit(x)]</code></li><li>可以看到，这两个区间 <code>[y-lowbit(y)+1, x - lowbit(x)]</code> 和 <code>[x-lowbit(x)+1, x]</code>其实是相邻的。</li></ul><p>所以，每次减 lowbit(x) 的运算，其实是获得了其左侧相邻的一块区间的和。</p><p>我们来看一个查询和的例子，如果我们要求前缀和 sum(7)：</p><ul><li>我们先计算 b[7]，7 的二进制是 0111，管辖区间是 <code>[7, 7]</code>，宽度是 1</li><li>我们再计算 b[6]，6 的二进制是 0110，管辖区间是 <code>[5, 6]</code>，宽度是 2</li><li>我们再计算 b[4]，4 的二进制是 0100，管辖区间是 <code>[1, 4]</code>，宽度是 4</li></ul><p>我们从上面的例子可以看到：由于每次减掉的都是最小的一个 lowbit 位，所以左侧相邻的新区间一定更宽。所以求和过程中， <code>b[7],b[6],b[4]</code> 对应的管辖宽度从 1 到 2 再到 4.</p><p>我们再看一个前缀和 sum(9) 的例子：</p><ul><li>我们先计算 b[9], 9 的二进制是 1001，管辖区间是 <code>[9, 9]</code>，宽度是 1</li><li>我们再计算 b[8], 9 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>和我们刚刚得到的结论相同：求和过程中，随着不断地减 lowbit(x)，获得的新区间更宽。</p><p>小结：</p><ul><li>树状数组中的元素 b[x] 管辖的区间和是<code>[x-lowbit(x)+1, x]</code></li><li>每次加 lowbit(x) 的过程，相当于在不断扩展管辖区间。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。</li><li>每次减 lowbit(x) 的过程，相当于在查找紧临 b[x] 管辖区间的一块新区间。这个新区间，宽度也是不断扩大的。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。</li></ul><h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p>有些时候，题目会让我们一次更新一段区间，这个时候，我们可以引入差分数组来替代原数组。</p><p>差分数组中的每一个元素，是原数组相邻两个数的差。</p><p>例如：</p><ul><li>原数组： <code>1,2,3,4,5,6</code></li><li>差分数组：<code>1,1,1,1,1,1</code></li></ul><p>我们对差分数组求前缀和，就可以还原出原数组。</p><p>这个时候，如果我们把原数组的第 3 个数到第 5 个数都加上 2，我们看看效果：</p><ul><li>原数组： <code>1,2,5,6,7,6</code></li><li>差分数组：<code>1,1,3,1,1,-1</code></li></ul><p>我们观察到，原数组的一个区间都加上 2 之后，在差分数组那里，只有第 3 个数和第 6 个数有变化，其它都没有变化。所以，如果我们用差分数组来代替原数组，就可以只更新两个数值来代表原来的范围更新。</p><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2</a>此题可以很好地练习差分数组与数状数组的结合运用，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 差分：</span></span><br><span class="line"><span class="comment"> *  - 假设 A 序列为原序列</span></span><br><span class="line"><span class="comment"> *  - 差分数列 C 为原序列每两个数之间的差</span></span><br><span class="line"><span class="comment"> *    - 即：c[i] = a[i] - a[i-1]</span></span><br><span class="line"><span class="comment"> *         c[1] = a[1]</span></span><br><span class="line"><span class="comment"> *         c[2] = a[2] - a[1]</span></span><br><span class="line"><span class="comment"> *         c[3] = a[3] - a[2]</span></span><br><span class="line"><span class="comment"> *  - 所以：</span></span><br><span class="line"><span class="comment"> *    - a[i] = sum(c[1]+c[2]+...c[i])</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对于本题，如果把数组变成差分数组：</span></span><br><span class="line"><span class="comment"> *  - [x,y] 每个数加上 k，等价于:</span></span><br><span class="line"><span class="comment"> *    - c[x] += k</span></span><br><span class="line"><span class="comment"> *    - c[y+1] -= k</span></span><br><span class="line"><span class="comment"> *  - 求第 a[x] 的值，等价于：</span></span><br><span class="line"><span class="comment"> *    - sum(c[1]+c[2]+...c[x])</span></span><br><span class="line"><span class="comment"> *    - 即求前缀和</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(500000+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], c[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += v;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        c[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">add</span>(i, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y, k;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">add</span>(x, k);</span><br><span class="line">            <span class="built_in">add</span>(y+<span class="number">1</span>, -k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维的树状数组"><a href="#二维的树状数组" class="headerlink" title="二维的树状数组"></a>二维的树状数组</h2><p>刚刚讲到，对于一个 b[x]，它代表的区间为<code>[x-lowbit(x)+1, x]</code></p><p>那么对于一个二维的树状数组 b[x, y]，它代表的区间就是 <code>a(x-lowbit(x)+1, y-lowbit(y)+1) - a(x, y)</code> 形成的矩阵的总和。如下图所示：</p><img src="/images/bit-7.jpg" class=""><p>对于二维的树状数组，更新就需要用两层的循环了。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">lowbit</span>(j)) &#123;</span><br><span class="line">      c[i][j] += v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询前缀和同样需要用循环，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y; j &gt; <span class="number">0</span>; j -= <span class="built_in">lowbit</span>(j)) &#123;</span><br><span class="line">      res += c[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果题目要求区间和，则需要用容斥原理来求解，这里不再展开介绍。</p><h2 id="用树状数组求逆序对"><a href="#用树状数组求逆序对" class="headerlink" title="用树状数组求逆序对"></a>用树状数组求逆序对</h2><p>什么是逆序对？逆序对是指一个序列中，<code>a[i] &gt; a[j]</code> 且 <code>i &lt; j</code> 的有序对。</p><p>比如一个序列是 <code>3 2 1</code>，它的逆序对就有：<code>3 2</code>,<code>3 1</code>,<code>2 1</code> 三组。</p><p>树状数组如何和逆序对的数量扯上关系呢？</p><p>拿序列 <code>3 2 1</code> 举例，我们知道，树状数组是可以用前缀和的。如果我们：</p><ul><li>假设序列初始情况下为全 0</li><li>当处理第一个数 3 的时候，我们让树状数组的下标 3 加 1：<code>update(3, 1)</code>，同时记录插入了 1 个数</li><li>当处理第二个数 2 的时候，我们统计小于等于 2 的前缀和：query(2)，然后拿总数减 query(2)，得到大于 2 的数字数量</li><li>这个数量，就是当 2 被处理的时候，前面有一共多少个数大于 2，即与 2 能够组成逆序对的数量</li></ul><p>例题：<a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></p><p>在此题中，我们先要解决两个问题，才能借用上面的思想：</p><p>问题1、题中的数据范围太大，我们如何解决?</p><p>答案：我们可以用离散化的思想，把 <code>2 10000 1</code> 变成 <code>2 3 1</code>，因为逆序对是统计相对大小，所以这样更改之后，逆序对的数量是不变的。</p><p>具体如何离散化呢？我们可以将数据依次标记上编号，然后排序。例如：</p><ul><li>原始序列为 <code>100 200 50</code>, 我们把它分别标上编号 <code>(100,1), (200,2), (50,3)</code></li><li>然后我们将数值排序，得到：<code>(50,3), (100,1), (200,2)</code></li><li>然后，我们再将新的序列赋上从 1 开始的编号：<code>(50,3,1), (100,1,2), (200,2,3)</code></li><li>然后，我们再将序列按原来的编号(第 2 个数字）排序，得到 <code>(100,1,2), (200,2,3), (50, 3, 1)</code></li><li>至此，我们转换得到了新的编号 <code>2,3,1</code></li></ul><p>因为 N 最多是 <code>5*10^5</code>，所以离散化之后，树状数组的大小也缩减到了 <code>5*10^5</code></p><p>在实现的时候，我们可以用结构体来保存上面的三元组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> origin_idx;</span><br><span class="line">    <span class="type">int</span> next_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>问题2、如果有两个相等的元素，会不会计算错误？</p><p>我们假设元素是 <code>200 300 200</code>,按我们刚刚的操作：</p><ul><li>先标号，得到 <code>(200,1) (300,2) (200,3)</code></li><li>再排序，得到 <code>(200,1) (200,3) (300,2)</code></li><li>再标号，得到 <code>(200,1,1) (200,3,2) (300,2,3)</code></li><li>再排序，得到 <code>(200,1,1) (300,2,3) (200,3,2)</code></li><li>最后序列是 <code>1,3,2</code></li></ul><p>这种是没问题的，但是，如果我们排序的时候不是用的稳定排序，把第二个 200 排到了前面，就会得到 <code>2,3,1</code>，这样逆序对就会多一个 <code>2 1</code>，而这本来是不存在的。</p><p>所以，为了解决这个问题，我们可以用稳定排序<code>stable_sort</code>，或者保证排序的时候，值相同的情况下，标号大的在后面。</p><p>以下是完整的参考程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(5*1e5+10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> origin_idx;</span><br><span class="line">    <span class="type">int</span> next_idx;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[MAXN];</span><br><span class="line"><span class="type">int</span> n,c[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp1</span><span class="params">(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp2</span><span class="params">(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.origin_idx &lt; b.origin_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x&amp;-x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a&lt;=n) &#123;</span><br><span class="line">        c[a]+=v;</span><br><span class="line">        a+=<span class="built_in">lowbit</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a) &#123;</span><br><span class="line">        ret += c[a];</span><br><span class="line">        a -= <span class="built_in">lowbit</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].v;</span><br><span class="line">        a[i].origin_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stable_sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n, comp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i) </span><br><span class="line">        a[i].next_idx = i;</span><br><span class="line">    <span class="built_in">stable_sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n, comp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i].next_idx, <span class="number">1</span>);</span><br><span class="line">        ans += i - <span class="built_in">query</span>(a[i].next_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关练习题目"><a href="#相关练习题目" class="headerlink" title="相关练习题目"></a>相关练习题目</h2><p>文章中涉及的例题：</p><ul><li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li><li><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组 2</a></li><li><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></li></ul><p>练习题：</p><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/B3874">B3874 小杨的握手问题</a></td><td>GESP 202309 六级真题</td></tr><tr><td>-</td><td>-</td></tr></tbody></table><h3 id="B3874-小杨的握手问题"><a href="#B3874-小杨的握手问题" class="headerlink" title="B3874 小杨的握手问题"></a><a href="https://www.luogu.com.cn/problem/B3874">B3874 小杨的握手问题</a></h3><p>解题思路：</p><ul><li>把学号为 a 的学生进入教室的行为，转化为第 a 个序列元素的值加 1。</li><li>这样，找出小于 a 的学生数量，就等价于求序列前 a-1 个元素的前缀和。</li><li>利用数状数组，就可以快速求前缀和了。</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数状数组求逆序对。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN int(3e5+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, b[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;-a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += v;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="comment">// 将学号下标从 0 开始改到 1 开始</span></span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">        ans += <span class="built_in">query</span>(a - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(a, <span class="number">1</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;有些时候，题目给我们 N 个元素的序列，然后让我们求前缀和或者区间和。并且，题目还会动态地修改这个序列的值。如果我们每次暴力求解前缀和，时间</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学总结：深度优先搜索（DFS）</title>
    <link href="https://blog.devtang.com/2025/04/13/teaching-notes-of-dfs/"/>
    <id>https://blog.devtang.com/2025/04/13/teaching-notes-of-dfs/</id>
    <published>2025-04-13T07:27:30.000Z</published>
    <updated>2025-05-20T14:52:22.139Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先搜索（DFS）是学生学习算法的第一道门槛，因为它的主要形式是递归。而递归中需要将搜索的相关信息通过参数传递，这一点需要学生深刻理解 DFS。</p><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>DFS 有比较标准的模版，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> <span class="comment">// pt 表示层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="comment">// 处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (枚举这个层的所有可选项) &#123;</span><br><span class="line">        <span class="keyword">if</span>（这个选项是合法的）&#123;</span><br><span class="line">            标记这个选项（保存现场）</span><br><span class="line">            <span class="built_in">dfs</span>(pt+<span class="number">1</span>); </span><br><span class="line">            取消标记（恢复现场）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将运用该模版，完成后面的题目。</p><h2 id="递归的深度"><a href="#递归的深度" class="headerlink" title="递归的深度"></a>递归的深度</h2><p>递归的时候，程序会占用栈空间来保存函数的环境变量。根据编译器以及编辑参数的不同，栈空间的大小也不同。通常情况下，竞赛中的编译器设定的栈空间为 8M 或者 16M。</p><p>假如，我们在一个递归函数中使用了 10 个 int 变量，那么每个递归函数就需要 <code>4*10=40</code>字节的栈空间。8M 一共可以支持 <code>8*1000*1000/40=200000</code>层调用。考虑到栈空间还需要保存当前函数执行的地址等变量，可供支持的调用层数会更小一点。</p><p>同学们也可以做如下的递归函数栈空间的测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> test[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的本地，以上程序调用了约 13 万次后栈溢出。为了保险，我们在比赛中如果调用深度小于 1 万层，那应该是稳妥的；否则我们需要考虑是否用别的解法来解题。</p><h2 id="教学和练习题目"><a href="#教学和练习题目" class="headerlink" title="教学和练习题目"></a>教学和练习题目</h2><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1036">P1036 选数</a></td><td>NOIP 2002 普及组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1219">P1219 八皇后 Checker Challenge</a></td><td>USACO 1.5</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1596">P1596 Lake Counting S</a></td><td>USACO10OCT</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2036">P2036 PERKET</a></td><td>COCI 2008&#x2F;2009 #2</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12139">P12139 黑白棋</a></td><td>蓝桥杯 2025 省 A，写起来较繁琐</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫</a></td><td>标准的 DFS</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题</a></td><td></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1019">P1019 单词接龙</a></td><td>NOIP 2000 提高组</td></tr><tr><td></td><td></td></tr></tbody></table><p>P7200<br>P10483</p><h3 id="P1219-八皇后-Checker-Challenge"><a href="#P1219-八皇后-Checker-Challenge" class="headerlink" title="P1219 八皇后 Checker Challenge"></a><a href="https://www.luogu.com.cn/problem/P1219">P1219 八皇后 Checker Challenge</a></h3><p>这是八皇后的变种，N 皇后问题。可以作为基础练习。具体解法是：</p><ul><li>我们用变量 <code>v[15]</code> 表示每个皇后的列值。</li><li>对于新放入的皇后，我们依次检查它与前面的皇后是否在一条斜线上。检查方法是看其“横坐标差”与“纵坐标差”是否相同。检查函数如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(v[i] - v[pt]) == <span class="built_in">abs</span>(i - pt)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">15</span>], ans;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(v[i] - v[pt]) == <span class="built_in">abs</span>(i - pt)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i]==<span class="literal">false</span>) &#123;</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">            v[pt] = i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(pt)) <span class="built_in">dfs</span>(pt + <span class="number">1</span>);</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1036-选数"><a href="#P1036-选数" class="headerlink" title="P1036 选数"></a><a href="https://www.luogu.com.cn/problem/P1036">P1036 选数</a></h3><p>此题需要从小到大取数求和，然后再判断是否是素数。用递归的方式来进行枚举。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, tot, ans;</span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>], p[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= v; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v%i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == k+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(tot)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 每一层都必须取比前一层更大的下标，防止重复取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p[pt<span class="number">-1</span>]+<span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[pt] = i;</span><br><span class="line">            tot += a[i];</span><br><span class="line">            <span class="built_in">dfs</span>(pt+<span class="number">1</span>);</span><br><span class="line">            tot -= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1596-Lake-Counting-S"><a href="#P1596-Lake-Counting-S" class="headerlink" title="P1596 Lake Counting S"></a><a href="https://www.luogu.com.cn/problem/P1596">P1596 Lake Counting S</a></h3><p>此题既可以用 DFS，也可以用 BFS。考虑到 N 和 M 最大值为 100，所以递归的层次最多为 1 万层，所以我们可以试试 DFS。</p><p>以下是参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> movex[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    tu[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + movex[i];</span><br><span class="line">        <span class="type">int</span> ny = y + movey[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m </span><br><span class="line">            || tu[nx][ny] != <span class="string">&#x27;W&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; tu[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tu[i][j] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2036-PERKET"><a href="#P2036-PERKET" class="headerlink" title="P2036 PERKET"></a><a href="https://www.luogu.com.cn/problem/P2036">P2036 PERKET</a></h3><p>因为 N 最多为 10，每种食材可以选或者不选两种情况，所以最多情况数为 <code>2^10=1024</code> 种。搜索时间满足要求。</p><p>所以，此题用 DFS 可以非常方便解决。在搜索的时候，我们可以将食材的相关信息带到 DFS 函数的参数中，方便最后答案的求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[<span class="number">11</span>], b[<span class="number">11</span>], v[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pt: 当前处理到的食材</span></span><br><span class="line"><span class="comment"> * cnt: 当前选中的食材数量</span></span><br><span class="line"><span class="comment"> * ss: 当前选中的食材的总酸度</span></span><br><span class="line"><span class="comment"> * bb: 当前选中的食材的总甜度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt, <span class="type">int</span> cnt, <span class="type">int</span> ss, <span class="type">int</span> bb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(ss - bb));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[pt] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(pt + <span class="number">1</span>, cnt + <span class="number">1</span>, ss * s[pt], bb + b[pt]);</span><br><span class="line">    v[pt] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(pt + <span class="number">1</span>, cnt, ss, bb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i] &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P12139-黑白棋"><a href="#P12139-黑白棋" class="headerlink" title="P12139 黑白棋"></a><a href="https://www.luogu.com.cn/problem/P12139">P12139 黑白棋</a></h3><p>此题是搜索题，需要在中间尽可能检查状态来剪枝，以节省搜索次数。</p><p>题目有三类限制，分别可以用在不同的剪枝环节。</p><p>限制一：在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（即为 3）。</p><ul><li>我们可以对每一行记录黑子和白子的数量，如果某一行或某一列的一种颜色达到 3，后面则不能用这个颜色。</li></ul><p>限制二：不能有超过两个相同颜色的棋子连续排列。</p><ul><li>我们可以在当前落子的时候，检查它的左边和上面连续的几个格子，看是否有 3 个相同的子。</li></ul><p>限制三：行列唯一性</p><ul><li>可以放到最后检查。</li></ul><p>另外，这个棋盘有几个位置已经设定了值，我们需要标记下来，搜索的时候跳过对这些位置的尝试，但需要在这些位置做合法性检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row_cnt[<span class="number">6</span>][<span class="number">2</span>], col_cnt[<span class="number">6</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> tu[<span class="number">7</span>][<span class="number">7</span>], mark[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（即为 3）</span></span><br><span class="line">    <span class="keyword">if</span> (row_cnt[r][<span class="number">1</span>] &gt; <span class="number">3</span> || row_cnt[r][<span class="number">0</span>] &gt; <span class="number">3</span> || col_cnt[c][<span class="number">1</span>] &gt; <span class="number">3</span> || col_cnt[c][<span class="number">0</span>] &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能有超过两个相同颜色的棋子连续排列</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r<span class="number">-1</span>][c] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r<span class="number">-2</span>][c] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r<span class="number">-1</span>][c] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r<span class="number">-2</span>][c] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r][c<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r][c<span class="number">-2</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r][c<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r][c<span class="number">-2</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行列唯一性检查</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">final_check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; row_set, col_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            v = v * <span class="number">10</span> + (tu[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        row_set.<span class="built_in">insert</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row_set.<span class="built_in">size</span>() != <span class="number">6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            v = v * <span class="number">10</span> + (tu[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        col_set.<span class="built_in">insert</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (col_set.<span class="built_in">size</span>() != <span class="number">6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = tu[r][c];</span><br><span class="line">    row_cnt[r][ch - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    col_cnt[c][ch - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(r, c)) &#123;</span><br><span class="line">        <span class="type">int</span> nr = r;</span><br><span class="line">        <span class="type">int</span> nc = c + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nc == <span class="number">6</span>) &#123;</span><br><span class="line">            nr++;</span><br><span class="line">            nc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(nr, nc);</span><br><span class="line">    &#125;</span><br><span class="line">    row_cnt[r][ch - <span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">    col_cnt[c][ch - <span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">final_check</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    cout &lt;&lt; tu[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 因为只有一个合法解，所以找到答案就退出</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mark[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        tu[r][c] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">try_dfs</span>(r, c);</span><br><span class="line">        tu[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">try_dfs</span>(r, c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tu[r][c] = mark[r][c];</span><br><span class="line">        <span class="built_in">try_dfs</span>(r, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="built_in">sizeof</span>(mark));</span><br><span class="line">    mark[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    mark[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">0</span>][<span class="number">3</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">1</span>][<span class="number">3</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">2</span>][<span class="number">4</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">2</span>][<span class="number">5</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">4</span>][<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    mark[<span class="number">4</span>][<span class="number">5</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    mark[<span class="number">5</span>][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">5</span>][<span class="number">4</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1605-迷宫"><a href="#P1605-迷宫" class="headerlink" title="P1605 迷宫"></a><a href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫</a></h3><p>用 DFS 来枚举，但需要标记走过的路。</p><ul><li>因为最多只有 5x5&#x3D;25 个格子，所以递归的深度最大只有 25，不存在溢出情况。</li><li>因为有陷阱（不能走）和起点终点（不能重复走），所以我们假设平均每次有 2 条支路，<br>整个的最坏情况估计只有 <code>2^23=8388608</code> 次，所以也不会超时。</li></ul><p>一些陷阱：</p><ul><li>终点可能也有障碍物，这个时候始终就到不了。</li><li>起点在走之前需要标记，否则会重复走。</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 - 空地</span></span><br><span class="line"><span class="comment">// 1 - 障碍物</span></span><br><span class="line"><span class="type">int</span> tu[<span class="number">6</span>][<span class="number">6</span>], n, m, t, sx, sy, ex, ey, ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tox = x + movex[i];</span><br><span class="line">        <span class="type">int</span> toy = y + movey[i];</span><br><span class="line">        <span class="keyword">if</span> (tox &gt;=<span class="number">1</span> &amp;&amp; tox&lt;=n &amp;&amp; toy&gt;=<span class="number">1</span> &amp;&amp; toy&lt;=m &amp;&amp; tu[tox][toy]!=<span class="number">1</span>)&#123;</span><br><span class="line">            tu[tox][toy]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(tox, toy);</span><br><span class="line">            tu[tox][toy]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        tu[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tu[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(sx, sy);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P2404-自然数的拆分问题"><a href="#P2404-自然数的拆分问题" class="headerlink" title="P2404 自然数的拆分问题"></a><a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题</a></h3><p>DFS，有两个技巧：</p><ul><li>保证后面的数 &gt;&#x3D; 前面的数。</li><li>让每个数必须小于 n，这样不会出现 <code>n=n</code> 这种等式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, tot, v[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tot == n) &#123;</span><br><span class="line">        cout &lt;&lt; v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; pt; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v[pt<span class="number">-1</span>]; tot + i &lt;=n &amp;&amp; i &lt; n ; ++i) &#123;</span><br><span class="line">        tot += i;</span><br><span class="line">        v[pt] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(pt+<span class="number">1</span>);</span><br><span class="line">        tot -= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先搜索（DFS）是学生学习算法的第一道门槛，因为它的主要形式是递归。而递归中需要将搜索的相关信息通过参数传递，这一点需要学生深刻理解 DFS。&lt;/p&gt;
&lt;h2 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学总结：STL</title>
    <link href="https://blog.devtang.com/2025/04/12/cspj-notes-of-stl/"/>
    <id>https://blog.devtang.com/2025/04/12/cspj-notes-of-stl/</id>
    <published>2025-04-12T14:00:46.000Z</published>
    <updated>2025-08-09T22:42:31.754Z</updated>
    
    <content type="html"><![CDATA[<p>STL 库是 C++ 语言的标准库，我们在比赛中主要用到的有如下内容。</p><h2 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a><a href="https://zh.cppreference.com/w/cpp/string/basic_string">string 类</a></h2><ul><li>substr</li><li>find</li><li>replace</li><li>insert</li><li>erase</li><li>c_str</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a><a href="https://zh.cppreference.com/w/cpp/container">容器</a></h2><ul><li>pair</li><li>vector</li><li>deque</li><li>list</li><li>stack</li><li>queue</li><li>priority_queue</li><li>map</li><li>unordered_map</li><li>set</li><li>unordered_set</li></ul><h2 id="算法库"><a href="#算法库" class="headerlink" title="算法库"></a><a href="https://zh.cppreference.com/w/cpp/algorithm">算法库</a></h2><table><thead><tr><th>函数</th><th>调用示意</th><th>说明</th></tr></thead><tbody><tr><td>sort</td><td><code>sort(v.begin(), v.end())</code></td><td>快速排序</td></tr><tr><td>stable_sort</td><td><code>stable_sort(v.begin(), v.end())</code></td><td>稳定排序</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/algorithm/unique">unique</a></td><td><code>unique(v.begin(), v.end())</code></td><td>去重，返回的是去重后的元素末地址。可以结合 erase 函数来把多余数据删除。参考代码：<code>v.erase(unique(v.begin(), v.end()), v.end());</code></td></tr><tr><td>next_permutation</td><td><code>next_permutation(v, v+n)</code></td><td>返回全排列的下一个值，当没有下一个排列时，函数返回 false</td></tr><tr><td>prev_permutation</td><td><code>prev_permutation(v, v+n)</code></td><td>返回全排列的上一个值，当没有上一个排列时，函数返回 false</td></tr><tr><td>nth_element</td><td><code>nth_element(v.begin(), v.begin() + k, v.end()),</code></td><td>函数执行后，v.begin()+k 位置的数为排序后的最终位置，即左边的数都小于它，后面的数都大于它</td></tr><tr><td>lower_bounds</td><td><code>lower_bounds(v, v+n, a)</code></td><td>查找大于或等于 a 的第一个位置，如果没找到则返回 end()</td></tr><tr><td>upper_bounds</td><td><code>upper_bounds(v, v+n, a)</code></td><td>查找大于 a 第一个位置，如果没找到则返回 end()</td></tr><tr><td><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">equal_range</a></td><td><code>equal_range(v, v+n, a)</code></td><td>equal_range 返回一个 pair，<code>first</code> 元素是查找到的匹配 a 值的左边界，<code>second</code> 元素是匹配到的 a 值的右边界，边界为左闭右开原则。当 <code>first == second</code> 的时候，相当于没找到目标值</td></tr><tr><td>__gcd</td><td><code>__gcd(a, b)</code></td><td>返回 a 和 b 的最大公约数</td></tr><tr><td>reverse</td><td><code>reverse(v.begin(), v.end())</code></td><td>将原序列逆序</td></tr><tr><td>min_element</td><td><code>min_element(v.begin(), v.end())</code></td><td>返回的是地址，如果想要值，可以用 <code>*</code> 获得对应下标的值，如果想获得下标，可以让它减去 v.begin()</td></tr><tr><td>max_element</td><td><code>max_element(v.begin(), v.end())</code></td><td>返回的是地址，如果想要值，可以用 <code>*</code> 获得对应下标的值，如果想获得下标，可以让它减去 v.begin()</td></tr><tr><td>accumulate</td><td><code>accumulate(v.begin(), v.end(), 0);</code></td><td>第三个参数是初始值</td></tr></tbody></table><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><table><thead><tr><th>题号</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1996">P1996 约瑟夫问题</a></td><td>适合用 list</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3613">P3613 寄包柜</a></td><td>适合用 map 和 pair</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4387">P4387 验证栈序列</a></td><td>适合用 stack</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1540">P1540 机器翻译</a></td><td>NOIP 2010 提高组，适合用 vector 以及 STL 的 find 算法</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式</a></td><td>适合练习 stack</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2058">P2058 海港</a></td><td>NOIP 2016 普及组，练习桶和队列</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2234">P2234 营业额统计</a></td><td>练习 set 和 <code>lower_bound</code> 函数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4305">P4305 不重复数字</a></td><td>可以练习 <code>unordered_map</code> 以及对比 cin 和 scanf 的速度差别</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1571">P1571 眼红的Medusa</a></td><td>练习 map 或 set</td></tr></tbody></table><h3 id="P4387-验证栈序列"><a href="#P4387-验证栈序列" class="headerlink" title="P4387 验证栈序列"></a><a href="https://www.luogu.com.cn/problem/P4387">P4387 验证栈序列</a></h3><p>解法：把 A 数组中的元素住栈里面 push，然后如果栈顶元素和 B 数组的当前元素相同，就 pop，同时 B 数组的当前元素后移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, a[<span class="number">100010</span>], b[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() == b[idx]) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1540-机器翻译"><a href="#P1540-机器翻译" class="headerlink" title="P1540 机器翻译"></a><a href="https://www.luogu.com.cn/problem/P1540">P1540 机器翻译</a></h3><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> m, n, t, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), t) == v.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果不在内存中</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(t); </span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() &gt; m) </span><br><span class="line">            v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a><a href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式</a></h3><p>表达式计算:</p><ul><li>不停读入。</li><li>如果读到数字，就和之前的数字拼接：<code>a = a * 10 + ch - &#39;0&#39;</code></li><li>如果读到 <code>.</code> 就压栈</li><li>如果读到运算符，就出栈两个数进行运算，结果再压栈</li><li>如果读到 <code>@</code> 结束</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> a, v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;@&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp;  ch &lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            a = a*<span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(a);</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v1 + v2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v2 - v1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v1 * v2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v2 / v1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2058-海港"><a href="#P2058-海港" class="headerlink" title="P2058 海港"></a><a href="https://www.luogu.com.cn/problem/P2058">P2058 海港</a></h3><p>解法：用一个队列记录所有 24 小时内的船。用一个桶记录每个国家的乘客数量。</p><ul><li>每次有新船入队列的时候，更新桶。如果桶更新前是 0，则 <code>ans++</code></li><li>每次新船入队列后，检查最早的队列，如果超24 小时，则出队</li><li>出队的时候，更新桶，如果桶的数量减为 0，则 <code>ans--</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶，记录每个国家的乘客数量</span></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">100010</span>], n, t, ans;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Node a;</span><br><span class="line">        cin &gt;&gt; a.t &gt;&gt; a.len;</span><br><span class="line">        a.v.<span class="built_in">resize</span>(a.len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.len; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; a.v[j];</span><br><span class="line">            <span class="keyword">if</span> (cnt[a.v[j]] == <span class="number">0</span>) ans++;</span><br><span class="line">            cnt[a.v[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(a);</span><br><span class="line">        <span class="type">int</span> <span class="type">min_t</span> = a.t - <span class="number">86400</span>;</span><br><span class="line">        <span class="comment">// 检查出列</span></span><br><span class="line">        a = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">while</span> (a.t &lt;= <span class="type">min_t</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.len; ++j) &#123;</span><br><span class="line">                cnt[a.v[j]]--;</span><br><span class="line">                <span class="keyword">if</span> (cnt[a.v[j]] == <span class="number">0</span>) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            a = q.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2234-营业额统计"><a href="#P2234-营业额统计" class="headerlink" title="P2234 营业额统计"></a><a href="https://www.luogu.com.cn/problem/P2234">P2234 营业额统计</a></h3><p>把营业额往 set 里面放，这样数据就是有序的。然后用 <code>lower_bound</code> 查找大于等于 x 的值。</p><ul><li>如果找到了，那么波动就是 0</li><li>如果没找到，比较当前位置和上一个位置与 x 的差，取较小那个；同时插入 x</li></ul><p>取上一个位置的时候要处理一下边界，如果是在 <code>s.begin()</code>位置的话就不用处理了。</p><p>取当前位置的时候要处理一下，看看是不是在 <code>s.end()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> n, x, ans;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    ans = x;</span><br><span class="line">    s.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        it = s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (it != s.<span class="built_in">end</span>() &amp;&amp; *it == x) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> diff = INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(*it-x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                it--;</span><br><span class="line">                diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(*it-x));</span><br><span class="line">            &#125;</span><br><span class="line">            ans += diff;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STL 库是 C++ 语言的标准库，我们在比赛中主要用到的有如下内容。&lt;/p&gt;
&lt;h2 id=&quot;string-类&quot;&gt;&lt;a href=&quot;#string-类&quot; class=&quot;headerlink&quot; title=&quot;string 类&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：数学题</title>
    <link href="https://blog.devtang.com/2025/04/12/cspj-notes-of-math-problems/"/>
    <id>https://blog.devtang.com/2025/04/12/cspj-notes-of-math-problems/</id>
    <published>2025-04-12T13:40:39.000Z</published>
    <updated>2025-06-22T02:07:25.809Z</updated>
    
    <content type="html"><![CDATA[<p>数学题是信息学竞赛中重要的一类题目，通常包括几何、数论、容斥原理等。</p><p>本文将相关的题目归纳整理，用于教学。</p><h2 id="质数相关"><a href="#质数相关" class="headerlink" title="质数相关"></a>质数相关</h2><h3 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h3><p>此算法是很多数学相关题目的基础，在 GESP 二级中也有涉及。例如：<a href="https://www.luogu.com.cn/problem/B3840">B3840 找素数</a>。</p><p>其核心代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;=a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初学者在写的时候，要注意 <code>i*i</code> 与 <code>a</code> 的比较是小于等于。</p><h3 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h3><p>质因数分解的方法是从 2 开始试商，如果发现能整除，就把被除数中该因数去掉，关键代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (N % i == <span class="number">0</span>) N /= i;</span><br></pre></td></tr></table></figure><p>这样经过几轮下来，N 的值会变得很小，最后 N 如果不为 1，N 就是最后一个质因数。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime_facs</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N % i == <span class="number">0</span>) &#123;  </span><br><span class="line">      <span class="keyword">while</span> (N % i == <span class="number">0</span>) N /= i;</span><br><span class="line">      result.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (N != <span class="number">1</span>) &#123;  <span class="comment">// 说明再经过操作之后 N 留下了一个素数</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(N);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3969">B3969 GESP202403 五级 B-smooth 数</a></li><li><a href="https://www.luogu.com.cn/problem/P10720">P10720 GESP202406 五级 小杨的幸运数字</a></li></ul><p><a href="https://www.luogu.com.cn/problem/B3969">B3969 GESP202403 五级 B-smooth 数</a> 的参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, b, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxPrime</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v%i == <span class="number">0</span>)&#123;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, i);</span><br><span class="line">            <span class="keyword">while</span> (v%i == <span class="number">0</span>) v/=i; <span class="comment">// 把 v 的值缩小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, v);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">getMaxPrime</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= b) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><h3 id="P2241-统计方形"><a href="#P2241-统计方形" class="headerlink" title="P2241 统计方形"></a><a href="https://www.luogu.com.cn/problem/P2241">P2241 统计方形</a></h3><p>本题解法：每个矩形（包括正方形）都可以由一段左边线段和一段上边线段确定。因此，我们只需要枚举所有可能的线段。</p><p>对于一个长是 N 宽是 M 的棋盘。</p><ul><li>左边的线段长度为 1 的有 N 个，长度为 2 的有 N-1 个，…长度为 N 的有 1 个。</li><li>上边的线段长度为 1 的有 M 个，长度为 2 的有 M-1 个，…长度为 M 的有 1 个。</li></ul><p>所以:</p><ul><li>左边的线段一共有 <code>（1+2+3+...+N）= N*(N+1)/2</code> 个。</li><li>上边的线段一共有 <code>（1+2+3+...+M）= M*(M+1)/2</code> 个。</li><li>因此，总共有 <code>N*(N+1)/2 * M*(M+1)/2</code> 个矩形。</li></ul><p>用相同的办法可以推导正方形的数量，方法如下：</p><ul><li>对于左边长度为 1 的线段有 N 个，相应的上边长度为 1 的线段有 M 个。</li><li>所以可以构造出 <code>N*M</code> 个边长为 1 的正方形。</li></ul><p>同理：</p><ul><li>对于左边长度为 2 的线段有 N-1 个，相应的上边长度为 2 的线段有 M-1 个。</li><li>所以可以构造出 <code>(N-1)*(M-1)</code> 个边长为 2 的正方形。</li></ul><p>以此类推，可以构造出 <code>N*M + (N-1)*(M-1) + (N-2)*(M-2) + (N-M+1)*1</code> 个正方形(N&gt;M)。</p><p>另外，需要注意使用 <code>long long</code> 来保存结果。完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n, m, ans1, ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans1 = n*(n+<span class="number">1</span>)/<span class="number">2</span> * m*(m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans2 += n*m;</span><br><span class="line">        n--; m--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout  &lt;&lt; ans2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans1 - ans2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="P1044-栈"><a href="#P1044-栈" class="headerlink" title="P1044 栈"></a><a href="https://www.luogu.com.cn/problem/P1044">P1044 栈</a></h3><p>这道题可以先用暴力的办法把前面几个数打出来，然后我们能发现数的规律是：1,1,2,5,14,42,132,429,1430,….</p><p>这是计算组合中很常见的卡特兰数，卡特兰数有两种公式，第一种公式是：</p><ul><li><code>f(n) = f(n-1) * (4 * n - 2) / (n + 1)</code></li></ul><p>我个人觉得这个公式不太好记。另一个公式是：</p><img src="/images/catalan.jpg" class=""><p>这个递推式相对好记一点：即<code>C(n) = C(0)*C(n-1) + C(1)*C(n-2) ... C(n-1)*C(0)</code></p><p>以下是用该递推式实现的答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[<span class="number">19</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            ans[i] += ans[j] * ans[i<span class="number">-1</span>-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P3612-USACO17JAN-Secret-Cow-Code-S"><a href="#P3612-USACO17JAN-Secret-Cow-Code-S" class="headerlink" title="P3612 USACO17JAN Secret Cow Code S"></a><a href="https://www.luogu.com.cn/problem/P3612">P3612 USACO17JAN Secret Cow Code S</a></h3><p>这是一道 USACO 的题目，需要我们先找出规律，然后再试图求解。</p><p>此题找规律的技巧是分析坐标每次在折半还原时的变化规律。<br>为了分析规律，我们可以看每次翻倍时，坐标的关系变化。</p><p>对于一个长度为 N 的字符串S，每次其长度变为 <code>2*N</code>。所以，我们对每一位进行标号：</p><p><code>1 2 3 4... N N+1 N+2 N+N</code></p><p>其中，除 <code>S[N] == S[N+1]</code> 外（按题意，此项为特殊项），其它位置都符合如下规律：</p><ul><li>S[1] &#x3D;&#x3D; S[N+2]</li><li>S[N-1] &#x3D;&#x3D; S[N+N]</li></ul><p>所以，将右边的坐标减去 <code>N</code> 再减 <code>1</code>，就得到左边的坐标。</p><p>所以，设总长为 L, 如果 a 的位置在右半侧，则对应到左半侧的坐标关系是：</p><ul><li><code>if (a == L/2+1) a = 1;</code></li><li><code>else a = a - L/2 - 1;</code></li></ul><p>如此递归下去，直到位置落在最初的长度上。<br>因为字符下标是从 0 开始，所以下标最后要减 1.</p><p>最后注意用 long long 来转换坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, n;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">di</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        <span class="comment">// 可用 debug 查看坐标变化过程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, L = &quot;</span> &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 a 的位置在右半侧，则调整到左半侧</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; L/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == L/<span class="number">2</span> + <span class="number">1</span>) a = L/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> a = a - L/<span class="number">2</span> - <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">di</span>(a, L/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; a;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出开始往回递归时，字符串拼起来的长度 L</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> L = n;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; a) L *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找 L 这个长度下，第 a 个字符相当于哪个位置</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">di</span>(a, L);</span><br><span class="line">    cout &lt;&lt; s[ans<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数学题是信息学竞赛中重要的一类题目，通常包括几何、数论、容斥原理等。&lt;/p&gt;
&lt;p&gt;本文将相关的题目归纳整理，用于教学。&lt;/p&gt;
&lt;h2 id=&quot;质数相关&quot;&gt;&lt;a href=&quot;#质数相关&quot; class=&quot;headerlink&quot; title=&quot;质数相关&quot;&gt;&lt;/a&gt;质数相关&lt;/</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：枚举</title>
    <link href="https://blog.devtang.com/2025/04/06/teaching-notes-of-brute-force/"/>
    <id>https://blog.devtang.com/2025/04/06/teaching-notes-of-brute-force/</id>
    <published>2025-04-06T03:20:47.000Z</published>
    <updated>2025-04-16T15:01:53.634Z</updated>
    
    <content type="html"><![CDATA[<p>枚举就是把所有情况都尝试一遍。比较简单的用 for 循环即可，较复杂的枚举，需要用到递归。</p><h2 id="P1304-哥德巴赫猜想"><a href="#P1304-哥德巴赫猜想" class="headerlink" title="P1304 哥德巴赫猜想"></a><a href="https://www.luogu.com.cn/problem/P1304">P1304 哥德巴赫猜想</a></h2><p>此题直接枚举每个合数拆解成两个质数和的所有可能性。为了避免重复计算质数，我们用一个 map 将其运算结果保存下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; rec;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rec.<span class="built_in">find</span>(n) != rec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> rec[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> rec[n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rec[n] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPrime</span>(j) &amp;&amp; <span class="built_in">isPrime</span>(i-j)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d=%d+%d\n&quot;</span>, i, j, i-j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2089-烤鸡"><a href="#P2089-烤鸡" class="headerlink" title="P2089 烤鸡"></a><a href="https://www.luogu.com.cn/problem/P2089">P2089 烤鸡</a></h2><p>此题初看起来 N 很大，但是每种配料最多 3 克，一共 10 种，总克数最多为 30 克。所以超过 30 克的情况答案都为 0。</p><p>每种配料 3 种情况，一共 10 种配料，所以暴力枚举的时间复杂度 3^10 约为 59000，不会超时。</p><p>枚举的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt, <span class="type">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tot == n)ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        a[pt] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(pt+<span class="number">1</span>, tot+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1706-全排列问题"><a href="#P1706-全排列问题" class="headerlink" title="P1706 全排列问题"></a><a href="https://www.luogu.com.cn/problem/P1706">P1706 全排列问题</a></h2><p>全排列的问题有多种写法，此题可以直接用 STL 中的 <code>next_permutation</code> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P1706 全排列问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, v[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        v[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(v, v+n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1157-组合的输出"><a href="#P1157-组合的输出" class="headerlink" title="P1157 组合的输出"></a><a href="https://www.luogu.com.cn/problem/P1157">P1157 组合的输出</a></h2><p>其实组合也可以用 <code>next_permutation</code> 来实现。以 n&#x3D;5,r&#x3D;3 为例，具体方法是：</p><ul><li>构造一个只有 0 和 1 的数组，0 表示选中，1 表示未选中。</li><li>数组初始状态：<code>0 0 0 1 1</code>，这样对应输出的是 <code>1, 2, 3</code></li><li>下一个状态： <code>0 0 1 0 1</code>， 输出 <code>1, 2, 4</code></li><li>结束状态：  <code>1 1 0 0 0</code>，输出 <code>3, 4, 5</code></li></ul><p>以下是实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, r;</span><br><span class="line"><span class="type">int</span> v[<span class="number">25</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; ++i) &#123;</span><br><span class="line">        v[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(v, v+n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多全排列的练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/P1088">P1088 NOIP 2004 普及组 火星人</a></li></ul><h2 id="P3392-涂条纹"><a href="#P3392-涂条纹" class="headerlink" title="P3392 涂条纹"></a><a href="https://www.luogu.com.cn/problem/P3392">P3392 涂条纹</a></h2><ul><li>这道题可以枚举蓝色色块开始的行号和结束的行号，时间复杂度为 O(N^2)。</li><li>对于每一种情况，我们需要 N 的时间复杂度来检查。</li><li>所以一共的时间复杂度是 N^3。</li></ul><p>我们先预保存下来每行的各种颜色的色块数量，这样检查的时候就可以快速求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">55</span>][<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">char</span> ch;</span><br><span class="line">            cin &gt;&gt; ch;</span><br><span class="line">            cnt[i][ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="comment">// 枚举蓝色行的起止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n<span class="number">-1</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; ++k)</span><br><span class="line">                cost += m - cnt[k][<span class="string">&#x27;W&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">                cost += m - cnt[k][<span class="string">&#x27;B&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j+<span class="number">1</span>; k &lt; n; ++k)</span><br><span class="line">                cost += m - cnt[k][<span class="string">&#x27;R&#x27;</span>];</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, cost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P3654-First-Step"><a href="#P3654-First-Step" class="headerlink" title="P3654 First Step"></a><a href="https://www.luogu.com.cn/problem/P3654">P3654 First Step</a></h2><p>直接枚举每个起点。但是 <code>k==1</code> 时需要特判，因为 <code>k==1</code> 意味着向下和向右重复计算，需要除以 2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 陷阱：</span></span><br><span class="line"><span class="comment"> *  k=1时需要特判，因为k=1意味着向下和向右重复计算，需要除以2。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, ans;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dx, <span class="type">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> nx = x, ny = y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= n || ny &gt;= m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tu[nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        nx += dx;</span><br><span class="line">        ny += dy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; tu[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i, j, <span class="number">1</span>, <span class="number">0</span>)) ans++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i, j, <span class="number">0</span>, <span class="number">1</span>)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) ans /= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1149-火柴棒等式"><a href="#P1149-火柴棒等式" class="headerlink" title="P1149 火柴棒等式"></a><a href="https://www.luogu.com.cn/problem/P1149">P1149 火柴棒等式</a></h2><p>NOIP 2008 提高组第二题。推导如下：</p><ul><li>n 最大为 24。</li><li>24 减去加号（2根火柴）和等号（2 根火柴），还剩 20 根。</li><li>20 根分配到 3 个数字（A+B&#x3D;C）上，平均每个数字 7 根，但也可能一个数特别大（10 根），另一个数特别小（2 根）。</li><li>每个数字最少用量为 2 根火柴（数字 1）。</li></ul><p>枚举办法：</p><ul><li>第 1 个数字 A 从 0 - 10000，计算出 A 用的火柴数 t1</li><li>第 2 个数字 B 从 A - 10000，计算出 B 用的火柴数 t2</li><li>算出来 A+B 的和 C，检查 C 用的火柴数是不是刚好是  n-t1-t2-4</li><li>每找到一种，如果 A!&#x3D;B，则计算两次答案，因为 B+A&#x3D;C 是另一个对称的答案。</li></ul><p>用以上的枚举之后，我们将所有答案输出，发现 A 其实在 N 最大（N&#x3D;24）的时候也不会超过 1000，测试如下（只输出了 A&lt;&#x3D;B 的情况）。所以我们就可以将 A 的范围改小，或者直接打表输出答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>+<span class="number">8</span>=<span class="number">8</span></span><br><span class="line"><span class="number">0</span>+<span class="number">12</span>=<span class="number">12</span></span><br><span class="line"><span class="number">0</span>+<span class="number">13</span>=<span class="number">13</span></span><br><span class="line"><span class="number">0</span>+<span class="number">15</span>=<span class="number">15</span></span><br><span class="line"><span class="number">0</span>+<span class="number">21</span>=<span class="number">21</span></span><br><span class="line"><span class="number">0</span>+<span class="number">31</span>=<span class="number">31</span></span><br><span class="line"><span class="number">0</span>+<span class="number">47</span>=<span class="number">47</span></span><br><span class="line"><span class="number">0</span>+<span class="number">51</span>=<span class="number">51</span></span><br><span class="line"><span class="number">0</span>+<span class="number">74</span>=<span class="number">74</span></span><br><span class="line"><span class="number">0</span>+<span class="number">117</span>=<span class="number">117</span></span><br><span class="line"><span class="number">0</span>+<span class="number">171</span>=<span class="number">171</span></span><br><span class="line"><span class="number">0</span>+<span class="number">711</span>=<span class="number">711</span></span><br><span class="line"><span class="number">1</span>+<span class="number">20</span>=<span class="number">21</span></span><br><span class="line"><span class="number">1</span>+<span class="number">30</span>=<span class="number">31</span></span><br><span class="line"><span class="number">1</span>+<span class="number">42</span>=<span class="number">43</span></span><br><span class="line"><span class="number">1</span>+<span class="number">47</span>=<span class="number">48</span></span><br><span class="line"><span class="number">1</span>+<span class="number">50</span>=<span class="number">51</span></span><br><span class="line"><span class="number">1</span>+<span class="number">112</span>=<span class="number">113</span></span><br><span class="line"><span class="number">1</span>+<span class="number">117</span>=<span class="number">118</span></span><br><span class="line"><span class="number">1</span>+<span class="number">170</span>=<span class="number">171</span></span><br><span class="line"><span class="number">1</span>+<span class="number">710</span>=<span class="number">711</span></span><br><span class="line"><span class="number">2</span>+<span class="number">8</span>=<span class="number">10</span></span><br><span class="line"><span class="number">2</span>+<span class="number">10</span>=<span class="number">12</span></span><br><span class="line"><span class="number">2</span>+<span class="number">19</span>=<span class="number">21</span></span><br><span class="line"><span class="number">2</span>+<span class="number">41</span>=<span class="number">43</span></span><br><span class="line"><span class="number">2</span>+<span class="number">72</span>=<span class="number">74</span></span><br><span class="line"><span class="number">2</span>+<span class="number">77</span>=<span class="number">79</span></span><br><span class="line"><span class="number">2</span>+<span class="number">111</span>=<span class="number">113</span></span><br><span class="line"><span class="number">3</span>+<span class="number">10</span>=<span class="number">13</span></span><br><span class="line"><span class="number">3</span>+<span class="number">13</span>=<span class="number">16</span></span><br><span class="line"><span class="number">3</span>+<span class="number">44</span>=<span class="number">47</span></span><br><span class="line"><span class="number">3</span>+<span class="number">114</span>=<span class="number">117</span></span><br><span class="line"><span class="number">4</span>+<span class="number">43</span>=<span class="number">47</span></span><br><span class="line"><span class="number">4</span>+<span class="number">57</span>=<span class="number">61</span></span><br><span class="line"><span class="number">4</span>+<span class="number">70</span>=<span class="number">74</span></span><br><span class="line"><span class="number">4</span>+<span class="number">113</span>=<span class="number">117</span></span><br><span class="line"><span class="number">4</span>+<span class="number">117</span>=<span class="number">121</span></span><br><span class="line"><span class="number">5</span>+<span class="number">10</span>=<span class="number">15</span></span><br><span class="line"><span class="number">5</span>+<span class="number">16</span>=<span class="number">21</span></span><br><span class="line"><span class="number">5</span>+<span class="number">17</span>=<span class="number">22</span></span><br><span class="line"><span class="number">6</span>+<span class="number">15</span>=<span class="number">21</span></span><br><span class="line"><span class="number">7</span>+<span class="number">15</span>=<span class="number">22</span></span><br><span class="line"><span class="number">7</span>+<span class="number">27</span>=<span class="number">34</span></span><br><span class="line"><span class="number">7</span>+<span class="number">40</span>=<span class="number">47</span></span><br><span class="line"><span class="number">7</span>+<span class="number">41</span>=<span class="number">48</span></span><br><span class="line"><span class="number">7</span>+<span class="number">54</span>=<span class="number">61</span></span><br><span class="line"><span class="number">7</span>+<span class="number">72</span>=<span class="number">79</span></span><br><span class="line"><span class="number">7</span>+<span class="number">77</span>=<span class="number">84</span></span><br><span class="line"><span class="number">7</span>+<span class="number">110</span>=<span class="number">117</span></span><br><span class="line"><span class="number">7</span>+<span class="number">111</span>=<span class="number">118</span></span><br><span class="line"><span class="number">7</span>+<span class="number">114</span>=<span class="number">121</span></span><br><span class="line"><span class="number">9</span>+<span class="number">12</span>=<span class="number">21</span></span><br><span class="line"><span class="number">11</span>+<span class="number">13</span>=<span class="number">24</span></span><br><span class="line"><span class="number">11</span>+<span class="number">14</span>=<span class="number">25</span></span><br><span class="line"><span class="number">11</span>+<span class="number">16</span>=<span class="number">27</span></span><br><span class="line"><span class="number">11</span>+<span class="number">31</span>=<span class="number">42</span></span><br><span class="line"><span class="number">11</span>+<span class="number">41</span>=<span class="number">52</span></span><br><span class="line"><span class="number">11</span>+<span class="number">61</span>=<span class="number">72</span></span><br><span class="line"><span class="number">14</span>+<span class="number">27</span>=<span class="number">41</span></span><br><span class="line"><span class="number">14</span>+<span class="number">77</span>=<span class="number">91</span></span><br><span class="line"><span class="number">17</span>+<span class="number">24</span>=<span class="number">41</span></span><br><span class="line"><span class="number">17</span>+<span class="number">57</span>=<span class="number">74</span></span><br><span class="line"><span class="number">17</span>+<span class="number">74</span>=<span class="number">91</span></span><br><span class="line"><span class="number">41</span>+<span class="number">71</span>=<span class="number">112</span></span><br></pre></td></tr></table></figure><p>完成的程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把 A 和 B 的范围改成 10000，同时把 debug 改成 true 可以输出所有可能的组合。</span></span><br><span class="line"><span class="comment"> * 经过测试发现 A和 B的答案范围小于 1000，所以可以改成 1000。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[] = &#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record;</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = i;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            cnt += num[tmp % <span class="number">10</span>];</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (tmp &gt; <span class="number">0</span>);;</span><br><span class="line">        record[i] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> c = i + j;</span><br><span class="line">            <span class="keyword">if</span> (record[i] + record[j] + record[c] == n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) ans+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> ans++;</span><br><span class="line">                <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                     cout &lt;&lt; i &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P3799-小-Y-拼木棒"><a href="#P3799-小-Y-拼木棒" class="headerlink" title="P3799 小 Y 拼木棒"></a><a href="https://www.luogu.com.cn/problem/P3799">P3799 小 Y 拼木棒</a></h2><p>思路如下：</p><ul><li>4 根木棒，先选出三根。肯定是有两根的和等于第三根。</li><li>最后一根显然是和第三根一样长。</li><li>所以，问题转换成：选两根木棒，同时再选两根他们的和，一共有多少种。</li></ul><p>在选两根木棒的时候，我们又可以转化为：选一根木棒，然后选另一根大于等于它的木棒。</p><p>因为 a 的值在 5000 以内，而 N 最大是 10 万，所以可以把值放到一个计数的桶里面。这样枚举的时候效率更高。</p><p>解法：</p><ul><li>拿一个 cnt[] 数组保存每个数字出现的次数，同时记录最大值 maxv。</li><li>从 1 到 maxv 枚举 a 和 b（其中保证 b 大于等于 a）</li><li>计算两个数字的和 c，然后取 c 的次数。</li><li>计算一共的组合数，结果对 10^9+7 取模。</li></ul><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD (int)(1e9 + 7)</span></span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="type">int</span> n, x, maxv;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 a 个数中选 2 个数的组合数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cnt[x]++;</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= maxv; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = a; b &lt;= maxv; b++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b &amp;&amp; cnt[a] &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> c = a + b;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">C</span>(cnt[c]) % MOD;</span><br><span class="line">                <span class="keyword">if</span> (a == b)  </span><br><span class="line">                    base = base * <span class="built_in">C</span>(cnt[a]) % MOD;</span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    base = base * ((cnt[a] * cnt[b]) % MOD) % MOD;</span><br><span class="line">                ans = (ans + base) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1028-数的计算"><a href="#P1028-数的计算" class="headerlink" title="P1028 数的计算"></a><a href="https://www.luogu.com.cn/problem/P1028">P1028 数的计算</a></h2><p>NOIP 2001 普及组 题目。在暴力枚举的时候，需要记住重复的计算。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans, record[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (record[a] != <span class="number">0</span>) <span class="keyword">return</span> record[a];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    record[a] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="built_in">dfs</span>(n);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多练习"><a href="#更多练习" class="headerlink" title="更多练习"></a>更多练习</h2><ul><li><a href="https://www.luogu.com.cn/problem/P1464">P1464 Function</a></li><li><a href="https://www.luogu.com.cn/problem/P2437">P2437 蜜蜂路线</a></li></ul><h3 id="P2437-蜜蜂路线"><a href="#P2437-蜜蜂路线" class="headerlink" title="P2437 蜜蜂路线"></a><a href="https://www.luogu.com.cn/problem/P2437">P2437 蜜蜂路线</a></h3><p>需要用到高精度。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string record[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len_a = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len_b = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len_max = <span class="built_in">max</span>(len_a, len_b);</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_max; i++) &#123; </span><br><span class="line">        <span class="type">int</span> num_a = i &lt; len_a ? a[len_a - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num_b = i &lt; len_b ? b[len_b - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = num_a + num_b + carry;</span><br><span class="line">        ret = <span class="built_in">to_string</span>(sum % <span class="number">10</span>) + ret;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) ret = <span class="built_in">to_string</span>(carry) + ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == m) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (record[n][m] != <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> record[n][m];</span><br><span class="line">    <span class="keyword">return</span> record[n][m] = <span class="built_in">add</span>(<span class="built_in">dfs</span>(n+<span class="number">1</span>, m), <span class="built_in">dfs</span>(n+<span class="number">2</span>, m));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n, m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;枚举就是把所有情况都尝试一遍。比较简单的用 for 循环即可，较复杂的枚举，需要用到递归。&lt;/p&gt;
&lt;h2 id=&quot;P1304-哥德巴赫猜想&quot;&gt;&lt;a href=&quot;#P1304-哥德巴赫猜想&quot; class=&quot;headerlink&quot; title=&quot;P1304 哥德巴赫猜想&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：模拟</title>
    <link href="https://blog.devtang.com/2025/03/29/teaching-notes-of-simulation/"/>
    <id>https://blog.devtang.com/2025/03/29/teaching-notes-of-simulation/</id>
    <published>2025-03-29T15:06:22.000Z</published>
    <updated>2025-06-08T09:17:13.477Z</updated>
    
    <content type="html"><![CDATA[<p>模拟是最有效的练习编程熟练度的基础算法，也是有效的掌握各种编程技巧的练习方式。</p><p>本文将把各种模拟技巧与题目结合，用题目带着学生掌握这些模拟技巧。</p><h2 id="二维数组包边"><a href="#二维数组包边" class="headerlink" title="二维数组包边"></a>二维数组包边</h2><p>有些时候，我们在处理二维数组的时候，需要处理 x，y 坐标的边界。这样写起来会比较麻烦，但是，如果我们将数据从下标 1 开始保存，那么就人为在数据外面留了一圈缓冲带。这个时候，在处理 x，y 周围坐标的时候，就不会出现数据下标越界的情况了。</p><h3 id="例题：P2670-NOIP-2015-普及组-扫雷游戏"><a href="#例题：P2670-NOIP-2015-普及组-扫雷游戏" class="headerlink" title="例题：P2670 NOIP 2015 普及组 扫雷游戏"></a>例题：<a href="https://www.luogu.com.cn/problem/P2670">P2670 NOIP 2015 普及组 扫雷游戏</a></h3><p>该题如果正常写，需要判断每个格子周围 8 个格子的状态。如果我们把数据从 1 开始读入，在判断的时候就容易很多。以下是参考代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P2670 [NOIP 2015 普及组] 扫雷游戏</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> movex[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; tu[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tu[i][j] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> x = i + movex[k];</span><br><span class="line">                <span class="type">int</span> y = j + movey[k];</span><br><span class="line">                <span class="keyword">if</span> (tu[x][y] == <span class="string">&#x27;*&#x27;</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            tu[i][j] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; tu[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：B4248-语言月赛-202503-数字棋盘"><a href="#例题：B4248-语言月赛-202503-数字棋盘" class="headerlink" title="例题：B4248 语言月赛 202503 数字棋盘"></a>例题：<a href="https://www.luogu.com.cn/problem/B4248">B4248 语言月赛 202503 数字棋盘</a></h3><p>本题也可以用包边的技巧，保证数据在检查的时候不会越界。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查上方格子</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i<span class="number">-1</span>][j] == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 检查下方格子</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n &amp;&amp; a[i+<span class="number">1</span>][j] == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 检查左侧格子</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; a[i][j<span class="number">-1</span>] == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 检查右侧格子</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; m &amp;&amp; a[i][j+<span class="number">1</span>] == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == x &amp;&amp; <span class="built_in">check</span>(i, j)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P10719-GESP202406-五级-黑白格"><a href="#P10719-GESP202406-五级-黑白格" class="headerlink" title="P10719 GESP202406 五级 黑白格"></a><a href="https://www.luogu.com.cn/problem/P10719">P10719 GESP202406 五级 黑白格</a></h3><p>此题需要求枚举从坐标(x,y)到坐标(a,b)的 1 的个数。我们先用将从(0,0)到(a,b)的 1 的个数保存在一个数组 <code>s[110][110]</code>中，然后再通过容斥原理来进行快速求(i,j)到(a,b)中 1 的个数。具体方法如下：</p><p>第一步：对于每一个 <code>s[i][j]</code>，满足：<code>s[i][j] = s[i-1][j] + cnt</code>，其中 cnt 为第 i 行前 j 个数中 1 的个数。于是，我们就可以递推求出所有的 <code>s[i][j]</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        cnt += (tu[i][j] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        s[i][j] = s[i<span class="number">-1</span>][j] + cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码使用了“包边”的技巧，因为我们下标是从 1 开始的，所以下标 <code>i-1</code> 不会越界。</p><p>第二步：根据容斥原理。从坐标(i,j)到坐标(a,b)的 1 的个数为：<code>s[a][b] - s[i-1][b] - s[a][j-1] + s[i-1][j-1]</code>。如下图所示：</p><img src="/images/simulation-5.jpg" class=""><p>以上公式如果使用“包边”技巧，让有效坐标从 1 开始，也会帮助 i-1 的值不会越界。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, ans;</span><br><span class="line"><span class="type">int</span> s[<span class="number">110</span>][<span class="number">110</span>]; <span class="comment">// 表示从(0,0)到(a,b)的 1 的个数</span></span><br><span class="line"><span class="type">char</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; tu[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第二行递推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cnt += (tu[i][j] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = i; a &lt;= n; a++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b = j; b &lt;= m; b++) &#123;</span><br><span class="line">                    <span class="type">int</span> cnt = s[a][b] - s[i<span class="number">-1</span>][b] - s[a][j<span class="number">-1</span>] + s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">                        <span class="type">int</span> tmp = (a-i+<span class="number">1</span>) * (b-j+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (tmp &lt; ans) ans = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == INT_MAX) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="围圈数数"><a href="#围圈数数" class="headerlink" title="围圈数数"></a>围圈数数</h2><p>有一种模拟题，要求我们把人围成一个圈，在圈上数数，然后问你数到的是谁。类似于小时候玩的“点兵点将”游戏，可能是顺时针数，也可能是逆时针数。</p><p>对于这种数数题目，最简单的做法是：直接用加减来进行目标的选择。加减之后，下标可能变负数或者超过总数，这个时候进行简单的取模调整，就可以将下标调整正常。</p><h3 id="例题：P1563-玩具谜题"><a href="#例题：P1563-玩具谜题" class="headerlink" title="例题：P1563 玩具谜题"></a>例题：<a href="https://www.luogu.com.cn/problem/P1563">P1563 玩具谜题</a></h3><p>此题我们：</p><ul><li>用 <code>idx = (idx + b) % n;</code> 来完成顺时针数</li><li>用 <code>idx = (idx - b + n) % n;</code> 来完成逆时针数</li></ul><p>通过这样的简单的加减和取模，保证能够快速跳到目标位置，完成模拟操作。完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN int(1e5 + 10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> face[MAXN];</span><br><span class="line">string name[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; face[i] &gt;&gt; name[i] ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="comment">// 圈内向左 == 圈外向右</span></span><br><span class="line">        <span class="keyword">if</span> ((face[idx] == <span class="number">0</span> &amp;&amp; a == <span class="number">0</span>)</span><br><span class="line">           || (face[idx] == <span class="number">1</span> &amp;&amp; a == <span class="number">1</span>)) &#123;</span><br><span class="line">            idx = (idx - b + n) % n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            idx = (idx + b) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; name[idx] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：B4246-环形游走"><a href="#例题：B4246-环形游走" class="headerlink" title="例题：B4246 环形游走"></a>例题：<a href="https://www.luogu.com.cn/problem/B4246">B4246 环形游走</a></h3><p>此题有个技巧：就是走的时候可能绕多圈，这个时候我们先把要走的步数模 n: <code>step % n</code>, 这样就把前面的多圈跳过了，也不会把坐标减成特别特别小的负数。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> step = a[current] % n;</span><br><span class="line">        current = (current - step + n) % n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; current + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/P1914">P1914 小书童——凯撒密码</a></li></ul><h3 id="例题：B3921-小杨的考试"><a href="#例题：B3921-小杨的考试" class="headerlink" title="例题：B3921 小杨的考试"></a>例题：<a href="https://www.luogu.com.cn/problem/B3921">B3921 小杨的考试</a></h3><p>绕圈一类的问题不止是以上那种真实的圈，也可能是像星期几这样逻辑上的圈（日期就像是一个圈，从星期一到星期日，然后又回到星期一）。</p><p><a href="https://www.luogu.com.cn/problem/B3921">B3921 GESP202312 一级 小杨的考试</a>这道题让我们计算日期。最简单的办法，是让星期几先落到 0-6 的表示法（0 表示星期一，6 表示星期日）。然后我们就可以用简单的加 N 天，然后模 7，快速定位到未来是星期几。对于过去，我们也可以简单通过减 N%7 天，然后减掉差的天数后 +7 再模 7，让结果落到 0-6 上。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line">    x = (x - <span class="number">1</span> + n) % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><p>矩阵操作这类模拟题，会要求我们在一个二维（或三维）的数组上进行各种操作，包括填充，旋转，查找，合并等。需要我们熟悉各种矩阵操作的技巧。</p><h3 id="例题：P5725-求三角形"><a href="#例题：P5725-求三角形" class="headerlink" title="例题：P5725 求三角形"></a>例题：<a href="https://www.luogu.com.cn/problem/P5725">P5725 求三角形</a></h3><p>此题是一道基础的填充题。</p><ul><li>对于第一种要求，我们用在二维数组上填充实现。</li><li>对于第二种要求，我们直接输出结果，在合适的位置加上一些空格。</li></ul><p>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tu[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理第一种要求</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            tu[i][j] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>, tu[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理第二种要求</span></span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bk = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, bk--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= bk; ++j) <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>, cnt++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题：P5461-赦免战俘"><a href="#例题：P5461-赦免战俘" class="headerlink" title="例题：P5461 赦免战俘"></a>例题：<a href="https://www.luogu.com.cn/problem/P5461">P5461 赦免战俘</a></h3><p>此题我们需要熟练使用递归来进行标记。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> v[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mark</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> half = size/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; x+half; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt; y+half; ++j) &#123;</span><br><span class="line">            v[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mark</span>(x, y+half, half);</span><br><span class="line">    <span class="built_in">mark</span>(x+half, y, half);</span><br><span class="line">    <span class="built_in">mark</span>(x+half, y+half, half);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="string">&#x27;1&#x27;</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">mark</span>(<span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题：P5731-蛇形方阵"><a href="#例题：P5731-蛇形方阵" class="headerlink" title="例题：P5731 蛇形方阵"></a>例题：<a href="https://www.luogu.com.cn/problem/P5731">P5731 蛇形方阵</a></h3><p>蛇形方阵是一道基础题，用于练习二维数组上的操作。我使用的模拟技巧是：</p><ul><li>定义一个 order 变量，表示当前方向</li><li>与 order 变量配合，定义一个 movex 和 movey 数组，表示当前方向的移动</li></ul><p>相关代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> order;</span><br><span class="line"><span class="type">int</span> movex[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>每次移动，先判断是否越界或者已经填充过值：</p><ul><li>如果越界或已经填充过值，则改变方向再移动</li><li>如果没越界，则移动</li></ul><p>关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; n || tu[nx][ny] != <span class="number">0</span>) &#123;</span><br><span class="line">    order = (order + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">    nx = x + movex[order];</span><br><span class="line">    ny = y + movey[order];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要填充 <code>n*n</code> 个数，所以循环一共执行 <code>n*n</code> 次。</p><p>完整的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x, y, order;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> movex[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(tu, <span class="number">0</span>, <span class="built_in">sizeof</span>(tu));</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    order = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n*n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + movex[order];</span><br><span class="line">        <span class="type">int</span> ny = y + movey[order];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; n || tu[nx][ny] != <span class="number">0</span>) &#123;</span><br><span class="line">            order = (order + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            nx = x + movex[order];</span><br><span class="line">            ny = y + movey[order];</span><br><span class="line">        &#125;</span><br><span class="line">        x = nx;</span><br><span class="line">        y = ny;</span><br><span class="line">        tu[x][y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, tu[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：P4924-魔法少女小Scarlet"><a href="#例题：P4924-魔法少女小Scarlet" class="headerlink" title="例题：P4924 魔法少女小Scarlet"></a>例题：<a href="https://www.luogu.com.cn/problem/P4924">P4924 魔法少女小Scarlet</a></h3><p>本题涉及矩阵的旋转，实际操作起来还是有点麻烦。这里我们按旋转的中心来重建坐标系的话，可以观察到如下规律：</p><ul><li>顺时针旋转：<code>(a, b) -&gt; (b, -a)</code></li><li>逆时针旋转：<code>(a, b) -&gt; (-b, a)</code></li></ul><img src="/images/simulation-1.jpg" class=""><p>这样，我们就可以构建关键的旋转代码了，假如我们是基于中心点 <code>(x, y)</code> 半径是 r 的顺时针旋转的话，那么，对于坐标 <code>(a, b)</code>，我们：</p><ul><li>首先：把它移动到以 <code>(x, y)</code> 为中心：<code>(a-x, b-y)</code></li><li>然后：我们把坐标按上面的规则变换成 <code>(b-y, x-a)</code></li><li>最后：我们把坐标加上 <code>(x, y)</code> 的偏移，还原成原始坐标：<code>(b-y+x, x-a+y)</code></li></ul><p>以上逻辑写成代码是：<code>g[b-y+x][x-a+y]=f[a][b]</code></p><p>同理，如果是逆时针旋转：</p><ul><li>首先：把它移动到以 <code>(x, y)</code> 为中心：<code>(a-x, b-y)</code></li><li>然后：我们把坐标按上面的规则变换成 <code>(y-b, a-x)</code></li><li>最后：我们把坐标加上 <code>(x, y)</code> 的偏移，还原成原始坐标：<code>(y-b+x, a-x+y)</code></li></ul><p>以上逻辑写成代码是：<code>g[y-b+x][a-x+y]=f[a][b]</code></p><p>本题保证了数据不会在旋转时越界，整体的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 510</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN], g[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[i][j] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, r, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = x-r; a &lt;= x+r; ++a)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b = y-r; b &lt;= y+r; ++b)</span><br><span class="line">                    g[b-y+x][x-a+y]=f[a][b];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = x-r; a &lt;= x+r; ++a)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b = y-r; b &lt;= y+r; ++b)</span><br><span class="line">                    g[y-b+x][a-x+y]=f[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = x-r; a &lt;= x+r; ++a)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = y-r; b &lt;= y+r; ++b)</span><br><span class="line">                f[a][b] = g[a][b];</span><br><span class="line">    &#125; <span class="comment">// end of m</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; f[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：P1205-USACO1-2-方块转换-Transformations"><a href="#例题：P1205-USACO1-2-方块转换-Transformations" class="headerlink" title="例题：P1205 USACO1.2 方块转换 Transformations"></a>例题：<a href="https://www.luogu.com.cn/problem/P1205">P1205 USACO1.2 方块转换 Transformations</a></h3><p>此题需要推导矩阵旋转的规律。我们可以把原坐标和新坐标写下来，做成一个表格。</p><img src="/images/simulation-3.jpg" class=""><p>然后，我们把坐标的变化写成下面的表格形式：</p><img src="/images/simulation-4.jpg" class=""><p>通过观察，我们发现：</p><ul><li>黄色和红色的坐标在变换前后刚好相等，即： <code>新 x = 原 y</code></li><li>两侧的白色的坐标加和刚好等于 n-1，即：<code>原 x + 新 y = n - 1</code> &#x3D;&gt; <code>新 y = n - 原 x - 1</code></li></ul><p>综上，坐标变换公式为：<code>新(y, n-x-1)=原(x, y) </code>。</p><p>所以，坐标变换相关代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">        tmp[y][n-x<span class="number">-1</span>] = ori[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此类似，我们可以推出“反射”的代码关系是 <code>新(x,n-y-1)=原(x,y)</code>，相关变换代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">        tmp[x][n-y<span class="number">-1</span>] = ori[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的参考代码如下（可以把 <code>debug</code> 变量设置成 <code>true</code> 来查看执行过程）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ori[<span class="number">12</span>][<span class="number">12</span>], dest[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">12</span>][<span class="number">12</span>], tmp2[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">char</span> a[<span class="number">12</span>][<span class="number">12</span>], <span class="type">char</span> b[<span class="number">12</span>][<span class="number">12</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x][y] != b[x][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> a[<span class="number">12</span>][<span class="number">12</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ori[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; dest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方案一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp[y][n-x<span class="number">-1</span>] = ori[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;debug 1: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">print</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方案二</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp2[y][n-x<span class="number">-1</span>] = tmp[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp2, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方案三</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp[y][n-x<span class="number">-1</span>] = tmp2[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反射</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp[x][n-y<span class="number">-1</span>] = ori[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反射+旋转90</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp2[y][n-x<span class="number">-1</span>] = tmp[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;debug 5-1: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">print</span>(tmp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp2, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反射+旋转180</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp[y][n-x<span class="number">-1</span>] = tmp2[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;debug 5-2: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">print</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反射+旋转270</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">            tmp2[y][n-x<span class="number">-1</span>] = tmp[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;debug 5-3: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">print</span>(tmp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(tmp2, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不改变</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">match</span>(ori, dest)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;6&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;7&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/P5729">P5729 深基5.例7 工艺品制作</a></li><li><a href="https://www.luogu.com.cn/problem/P5732">P5732 深基5.习7 杨辉三角</a></li><li><a href="https://www.luogu.com.cn/problem/P5730">P5730 深基5.例10 显示屏</a></li><li><a href="https://www.luogu.com.cn/problem/P1789">P1789 我的世界-插火把</a></li><li><a href="https://www.luogu.com.cn/problem/P1319">P1319 压缩技术</a></li><li><a href="https://www.luogu.com.cn/problem/P1320">P1320 压缩技术 续集版</a></li><li><a href="https://www.luogu.com.cn/problem/P2615">P2615 NOIP 2015 提高组 神奇的幻方</a></li><li><a href="https://www.luogu.com.cn/problem/B3940">B3940 GESP样题 四级 填幻方</a></li></ul><h2 id="游戏模拟"><a href="#游戏模拟" class="headerlink" title="游戏模拟"></a>游戏模拟</h2><p>游戏模拟类的题目通常会告诉你一个相对复杂一点的游戏规则，然后让你用程序将这个游戏规律实现，最终将游戏的结果输出出来。</p><p>这种题目一方面考查了读题能力，需要对游戏规则的理解清楚，另一方面则是要对游戏规则进行建模，用合适的数据结构实现游戏中的模拟。</p><p>以下是一些相关的题目。</p><table><thead><tr><th>题号</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1042">P1042</a></td><td>NOIP 2003 普及组 乒乓球</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1328">P1328</a></td><td>NOIP 2014 提高组 生活大爆炸版石头剪刀布</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1518">P1518</a></td><td>USACO2.4 两只塔姆沃斯牛 The Tamworth Two</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1089">P1089</a></td><td>NOIP 2004 提高组 津津的储蓄计划</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1161">P1161</a></td><td>数组标记</td></tr></tbody></table><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="例题：P1614-爱与愁的心痛"><a href="#例题：P1614-爱与愁的心痛" class="headerlink" title="例题：P1614 爱与愁的心痛"></a>例题：<a href="https://www.luogu.com.cn/problem/P1614">P1614 爱与愁的心痛</a></h3><p>此题的解法是：构造一个“滑动的窗口”。先求出前 m 个数的和，这相当于窗口的原始位置。之后每次让窗口往右移动一格。每次移动的时候，会将最左侧的数字剔除，同时纳入一个新数字。如下图所示：</p><img src="/images/simulation-2.jpg" class=""><p>我们在滑动窗口的时候，需要用这个变量，分别指向：</p><ul><li>当前窗口最左的数字 p1</li><li>当前窗口下一个要加入的数字 p2</li><li>在滑动的时候，不断更新当前窗口的值 tot</li></ul><p>以下是关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="number">0</span>;</span><br><span class="line">p2 = m;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt; n) &#123;</span><br><span class="line">    tot -= v[p1];</span><br><span class="line">    tot += v[p2];</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, tot);</span><br><span class="line">    p1++; p2++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, tot, ans;</span><br><span class="line"><span class="type">int</span> p1, p2;</span><br><span class="line"><span class="type">int</span> v[<span class="number">3300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初使化滑动窗口</span></span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        tot += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = tot;</span><br><span class="line">    p1 = <span class="number">0</span>;</span><br><span class="line">    p2 = m;</span><br><span class="line">    <span class="comment">// 滑动窗口，更新值</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; n) &#123;</span><br><span class="line">        tot -= v[p1];</span><br><span class="line">        tot += v[p2];</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, tot);</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟输入输出"><a href="#模拟输入输出" class="headerlink" title="模拟输入输出"></a>模拟输入输出</h2><p>有一些模拟需要我们有比较复杂的输入和输出操作技巧。在模拟输入和输出的时候，常用的两个函数是 <code>sscanf</code> 和 <code>snprintf</code>，其中：</p><ul><li><code>sscanf</code> 允许我们从一个字符串中读入内容。</li><li><code>snprintf</code> 允许我们将输出内容先输出到一个字符串中。</li></ul><p>以下我们用例题来演示其用法。</p><h3 id="例题：P1957-口算练习题"><a href="#例题：P1957-口算练习题" class="headerlink" title="例题：P1957 口算练习题"></a>例题：<a href="https://www.luogu.com.cn/problem/P1957">P1957 口算练习题</a></h3><p>此题的输入长度不固定，我们需要先判断输入的长度。同时，输出的时候，我们还需要输出“输出内容”的长度。这对我们处理输入和输出都带来了挑战。</p><p>我们可以把表达式整行整行读入，再用 <code>sscanf</code> 和 <code>snprintf</code> 来进行分析处理。以下是相关的示意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>], out[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(s, <span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">snprintf</span>(out, <span class="built_in">sizeof</span>(out), <span class="string">&quot;%d+%d=%d&quot;</span>, a, b, a + b);</span><br></pre></td></tr></table></figure><p>另外，我们还需要一次读入一整行，我用的方法是用 <code>scanf</code>, 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, s);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure><p>需要注意，以上代码每读入一行，需要用 <code>getchar()</code> 将行末的换行给读掉。</p><p>我们也可以用 <code>cin.getline(s, sizeof(s));</code> 来读取数据。</p><p>以下是完整的示意代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, a, b;</span><br><span class="line"><span class="type">char</span> ch, s[<span class="number">100</span>], out[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, s); <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; <span class="comment">// 也可使用函数： isdigit(s[0])</span></span><br><span class="line">            <span class="built_in">sscanf</span>(s, <span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sscanf</span>(s, <span class="string">&quot;%c%d%d&quot;</span>, &amp;ch, &amp;a, &amp;b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="built_in">sizeof</span>(out));</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(out, <span class="built_in">sizeof</span>(out), <span class="string">&quot;%d+%d=%d&quot;</span>, a, b, a + b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(out, <span class="built_in">sizeof</span>(out), <span class="string">&quot;%d-%d=%d&quot;</span>, a, b, a - b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(out, <span class="built_in">sizeof</span>(out), <span class="string">&quot;%d*%d=%d&quot;</span>, a, b, a * b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, out);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="built_in">strlen</span>(out));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的 scanf 部分如果替换成 cin，示意代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    cin.<span class="built_in">getline</span>(s, <span class="built_in">sizeof</span>(s));</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin.<span class="built_in">getline</span>(s, <span class="built_in">sizeof</span>(s));</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：P1067-多项式输出"><a href="#例题：P1067-多项式输出" class="headerlink" title="例题：P1067 多项式输出"></a>例题：<a href="https://www.luogu.com.cn/problem/P1067">P1067 多项式输出</a></h3><p>此题是 NOIP 2009 普及组的题目。此题练习了 <code>snprintf</code> 的使用。同时，此题用 printf 的 <code>%+d</code> 可以保证正数输出带+号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string ans;</span><br><span class="line"><span class="type">char</span> outs[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="comment">// 系数为0，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 指数为0，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(outs, <span class="number">0</span>, <span class="built_in">sizeof</span>(outs));</span><br><span class="line">            <span class="built_in">snprintf</span>(outs, <span class="built_in">sizeof</span>(outs), <span class="string">&quot;%+d&quot;</span>, a);</span><br><span class="line">            ans += outs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先处理系数</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(outs, <span class="built_in">sizeof</span>(outs), <span class="string">&quot;+x&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(outs, <span class="built_in">sizeof</span>(outs), <span class="string">&quot;-x&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(outs, <span class="built_in">sizeof</span>(outs), <span class="string">&quot;%+dx&quot;</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += outs;</span><br><span class="line">            <span class="comment">// 再处理指数</span></span><br><span class="line">            <span class="built_in">memset</span>(outs, <span class="number">0</span>, <span class="built_in">sizeof</span>(outs));</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(outs, <span class="built_in">sizeof</span>(outs), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(outs, <span class="built_in">sizeof</span>(outs), <span class="string">&quot;^%d&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += outs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        ans = ans.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P1010-NOIP-1998-普及组-幂次方"><a href="#P1010-NOIP-1998-普及组-幂次方" class="headerlink" title="P1010 NOIP 1998 普及组 幂次方"></a><a href="https://www.luogu.com.cn/problem/P1010">P1010 NOIP 1998 普及组 幂次方</a></h3><p>此题的技巧是利用递归来循环处理。特殊情况是 2^1 写作 2，而不是 2(0)。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">conv</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;2(0)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= base) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; base) &#123;</span><br><span class="line">                string sub = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (base == <span class="number">2</span>) sub = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> sub = <span class="string">&quot;2(&quot;</span>+<span class="built_in">conv</span>(cnt)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="string">&quot;&quot;</span>) ret = sub;</span><br><span class="line">                <span class="keyword">else</span> ret = sub + <span class="string">&quot;+&quot;</span> + ret;</span><br><span class="line">            &#125;</span><br><span class="line">            base &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">conv</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/P5734">P5734 深基6.例6 文字处理软件</a></li><li><a href="https://www.luogu.com.cn/problem/P1308">P1308 NOIP 2011 普及组 统计单词数</a></li><li><a href="https://www.luogu.com.cn/problem/P1098">P1098 NOIP 2007 提高组 字符串的展开</a></li><li><a href="https://www.luogu.com.cn/problem/P1065">P1065 NOIP 2006 提高组 作业调度方案</a></li></ul><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="B3927-GESP202312-四级-小杨的字典"><a href="#B3927-GESP202312-四级-小杨的字典" class="headerlink" title="B3927 GESP202312 四级 小杨的字典"></a><a href="https://www.luogu.com.cn/problem/B3927">B3927 GESP202312 四级 小杨的字典</a></h3><p>此题需要操作字符进行替换操作，是比较复杂的字符串模拟。此题我们可以用 map 来简化字符串的映射关系管理。map 的 find 函数可以返回一个迭代器，该迭代器的值：</p><ul><li>当查找失败时，值为 end()</li><li>当查找成功时，值为一个 pair，分别是对应查询的 key 和 value。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">map&lt;string, string&gt; m;</span><br><span class="line">map&lt;string, string&gt;::iterator it;</span><br><span class="line">string a, b, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">length</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        it = m.<span class="built_in">find</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (it!=m.<span class="built_in">end</span>()) cout &lt;&lt; it-&gt;second;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;UNK&quot;</span>;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        m[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;=<span class="string">&#x27;z&#x27;</span>) s = s + ch;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">process</span>(s);</span><br><span class="line">            cout &lt;&lt; ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它模拟题目"><a href="#其它模拟题目" class="headerlink" title="其它模拟题目"></a>其它模拟题目</h2><table><thead><tr><th>题号</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列</a></td><td>考查语文能力，容易读错题意</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="P1241-括号序列"><a href="#P1241-括号序列" class="headerlink" title="P1241 括号序列"></a><a href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列</a></h3><p>此题纯考读题。在找小括号对应的左括号的时候，找到 <code>(</code> 或 <code>[</code>都算找到。只是找到后，如果不匹配，就算匹配失败。否则算匹配成功。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原串</span></span><br><span class="line">string s;</span><br><span class="line"><span class="comment">// 匹配成功标记</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == <span class="string">&#x27;(&#x27;</span> &amp;&amp; b == <span class="string">&#x27;)&#x27;</span>) || (a == <span class="string">&#x27;[&#x27;</span> &amp;&amp; b == <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">change</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;(&#x27;</span> || a == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;()&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果它是一个右括号</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 考察它与它左侧离它最近的未匹配的的左括号</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;=<span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="comment">// 如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），</span></span><br><span class="line">                <span class="comment">// 则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</span></span><br><span class="line">                <span class="keyword">if</span> (!flag[j] &amp;&amp; (s[j] == <span class="string">&#x27;(&#x27;</span> || s[j] == <span class="string">&#x27;[&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">match</span>(s[j], s[i])) &#123;</span><br><span class="line">                        flag[i] = flag[j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i]) cout &lt;&lt; s[i];</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">change</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;模拟是最有效的练习编程熟练度的基础算法，也是有效的掌握各种编程技巧的练习方式。&lt;/p&gt;
&lt;p&gt;本文将把各种模拟技巧与题目结合，用题目带着学生掌握这些模拟技巧。&lt;/p&gt;
&lt;h2 id=&quot;二维数组包边&quot;&gt;&lt;a href=&quot;#二维数组包边&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>读《真需求》</title>
    <link href="https://blog.devtang.com/2025/03/08/read-demonds-book-summary/"/>
    <id>https://blog.devtang.com/2025/03/08/read-demonds-book-summary/</id>
    <published>2025-03-08T13:22:03.000Z</published>
    <updated>2025-09-17T13:23:45.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>最近读完了梁宁的《真需求》，在我看来，梁宁的角色更像是一个老师，因为老师喜欢给学生结论。可能她最有名的作品就是得到 App 上的《产品思维 30 讲》，所以她喜欢给解决方案，给框架。</p><p>什么是解决方案？就是给你说某某成功的核心原因是什么，再围绕一系列核心原因建立一个理论上的框架，于是所有的成功就来自于这个框架。学生掌握了这个框架，就理解了所有的生意。</p><p>这，确实很符合很多人的需求。</p><p>在这本书中，梁宁的解决方案是：价值-共识-模式框架。</p><p>但是说实话，我不太喜欢将创业之路极简化的叙事。这种形式虽然易于理解，但是不解决实际问题。真实的企业经营每天面对各种复杂的决策和执行，不是有一个好的生意框架就能当银弹的。极简叙事也简化了成功企业的归因，容易误导读者。</p><p>我更喜欢的是能够落地的思维。比如段永平的“不为清单”，“长期主义”，“做正确的事情”，虽然有点像什么都没说，但是更易于落地。</p><p>所以，本书的大部分内容对我来说帮助不大，但是我从另外的视角也从书中得到了一些启发，分享如下。</p><h2 id="二、情绪价值的产品很重要"><a href="#二、情绪价值的产品很重要" class="headerlink" title="二、情绪价值的产品很重要"></a>二、情绪价值的产品很重要</h2><p>梁宁把产品价值分为功能价值+情绪价值+资产价值。我不同意这样的分法，因为这么分不太 MECE（ 金字塔原理中的 MECE 原则，即 <code>Mutually Exclusive Collectively Exhaustive</code>）。</p><p>但是，我认为情绪价值是重要的商业产品。我的老板把这个叫做“无用之物”的生意。未来消费者会越来越关注自己，做悦己的选择，这方面的商业价值非常大。</p><h2 id="三、从历史中思考"><a href="#三、从历史中思考" class="headerlink" title="三、从历史中思考"></a>三、从历史中思考</h2><p>梁宁在书中问：如果你在 2012 年同时拿到当时的几个 offer，你应该如何选择？这几个 offer 是新浪微博，虎嗅，搜狐，微信，今日头条。</p><p>这是一个很有意思的问题，因为当时没几个人看得懂今日头条。就连投资机构都不投今日头条，更别说一个应届生会选择头条了。</p><p>但是这种思考角度让我意识到，其实这个世界的未知性是极强的，就算你是这个世界上最聪明的人，你也可能判断失误。</p><p>面对不确定性，构建好自己的反脆弱系统才是合理的应对方式。这事就像做资产配置一样，是我们应对变化和风险必须学会的生存技能。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、序言&quot;&gt;&lt;a href=&quot;#一、序言&quot; class=&quot;headerlink&quot; title=&quot;一、序言&quot;&gt;&lt;/a&gt;一、序言&lt;/h2&gt;&lt;p&gt;最近读完了梁宁的《真需求》，在我看来，梁宁的角色更像是一个老师，因为老师喜欢给学生结论。可能她最有名的作品就是得到 App </summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>个人投资的最佳实践 - 读《不落俗套的成功》</title>
    <link href="https://blog.devtang.com/2025/02/23/unconventional-success-book-summary/"/>
    <id>https://blog.devtang.com/2025/02/23/unconventional-success-book-summary/</id>
    <published>2025-02-23T13:12:55.000Z</published>
    <updated>2025-09-17T13:22:21.526Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/unconventional-success-book-1.jpg" width="300px" /><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本书的作者是耶鲁大学的投资总监大卫·F·斯文森，他管理着耶鲁大学140多亿美元的捐赠资产，并让耶鲁大学在过去的20年里的年收益率达到16.1％。</p><p>书中的内容不是很好消化，所以我断断续续读了将近一年时间，里面的很多道理对我在投资领域的成长帮助很大。</p><p>我主要的收获有：</p><ul><li>资产配置和再平衡的重要性</li><li>高费率基金的长期收益问题</li></ul><p>下面就这两点结合我自己的个人经历做个分享。</p><h2 id="资产配置和再平衡"><a href="#资产配置和再平衡" class="headerlink" title="资产配置和再平衡"></a>资产配置和再平衡</h2><p>资产配置可能是每个人学习投资的第一课。这一点很多人都能理解。把自己的钱分为两大部分，一部分保证自己和家人的生活质量不受影响，另外一部分长期不用的闲钱再拿来投资。</p><p>对于投资的钱，也应该做好配置。有人把它分成股票，债券，黄金，现金四大类。在书中，作者将核心资产分成了 6 种，分别是：</p><ul><li>国内股票</li><li>国外发达市场股票</li><li>国外新兴市场股票</li><li>房地产</li><li>美国长期国库券</li><li>美国通胀保值国债</li></ul><p>但作者在美国，以上核心资产很多在中国并没有有效对标的标的。能对标的可以是 A 股和港股通股票，房地产，债券，QDII 基金等。</p><p>我习惯拿石墨表格把自己的资产分类，然后再看各类型的比例。一些简单有用的原则是：任何单一资产不要让它的占比超过可投资资产的 30%。</p><p>我在这方面犯过一个巨大的教训，曾经有一个资产在一段时间涨幅特别猛。有一段时间它的占比超过了 30%，这个时候我不但没有减仓，还额外追加了一笔投资。追高操作最终使得这笔追加款后来跌幅将近 50%。整体的盈亏虽然不大，但是追加款的损失把之前积累的利润都抵消了。这本应该避免。</p><p><strong>正确的做法是做资产的“再平衡”。</strong></p><p>对于每一个资产，定下计划的投资占比。当某个资产涨幅超过了占比一定幅度，就应该卖出一部分，让它恢复到原始占比。</p><p>同样的，如果某一笔资产它的价格大幅缩水，那么我们应该补仓，让它的占比恢复到之前的比例。</p><p>但是，以上两种操作非常反人性。人性是追高杀跌，而不是追跌杀高。所以我一直在试图修炼自己在这方面的心智。</p><p>之前巨大的亏损对我来说也是一个宝贵的经验教训，让我谨记资产配置的重要性。</p><h2 id="高费率基金的问题"><a href="#高费率基金的问题" class="headerlink" title="高费率基金的问题"></a>高费率基金的问题</h2><p>我之前持有了一些私募基金，有一些亏钱有一些挣钱，我也不知道应该怎么评估这些投资行为。</p><p>本书系统性的将美国市场的共同基金做了长达几十年的收益分析和解读，最终让我意识到：高费率的基金是不值得长期持有的。</p><p>这类基金的主要问题是：</p><ul><li>管理费和超额提成吃掉了一大部分收益</li><li>在市场整体大幅上涨的时候，收益提成也会吃掉一大部分 beta 收益</li><li>频繁通过高水位法提成，基金的波动就会让基金管理者挣钱，但是遇到深度回调的时候，这部分提成就会变成投资人的亏损</li><li>基金管理者旱涝保收，即便基金下跌，管理费也不会少。即便基金规模扩大很多，管理费也不会打折。</li></ul><p>另外，很多人其实不知道，大部分基金用 份额缩减法 来收取管理费和提成。这样在产品业绩图上，投资人其实一眼看不到费后收益。</p><p>以下是我的一个真实案例：</p><p>我持有的名字为金锝睿知 1 期（T18145）的产品显示，从它的发行开始日 22.2.22 开始到 24.12.27，这段时间的收益率是 22.82%（如下图）</p><img src="/images/unconventional-success-book-2.jpg" class=""><p>但是如果我查看我的资金流水，我的两年持有收益率只有 16.5%，差了 6.3%（如下图）</p><img src="/images/unconventional-success-book-3.jpg" class=""><p>我不是说这只基金不好，实际上它在过去两年的收益还是远高于 A 股沪深 300 指数的。但是你确实没办法一眼在产品资料里面看到真实的年化费后收益率。当然，问题不是针对这一只基金，大部分私募基金都是采用份额缩减法。</p><p>意识到以上这些之后，我赎回了几乎所有整体费率大于 1.5% 的基金。转而更多持有低费率的指数基金。</p><p>另外我也买入了一些我觉得不错的个股，比如腾讯，招商银行，比亚迪。对这些个股的生意的思考也让我的商业思维得到进步。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>《不落俗套的成功》是一本面向个人投资者的启蒙读物，作者通过大量详细的数据说明资产配置、再平衡的重要性，也让我意识到高费率的基金不值得长期持有。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/unconventional-success-book-1.jpg&quot; width=&quot;300px&quot; /&gt;

&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：并查集</title>
    <link href="https://blog.devtang.com/2025/02/09/teaching-notes-of-union-query-set/"/>
    <id>https://blog.devtang.com/2025/02/09/teaching-notes-of-union-query-set/</id>
    <published>2025-02-09T13:20:27.000Z</published>
    <updated>2025-02-09T15:08:31.242Z</updated>
    
    <content type="html"><![CDATA[<p>并查集在引入之前，需要先教会学生集合的概念。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是数学中的一个基本概念，它是由一些确定的、彼此不同的对象所组成的整体。集合有两个特点：</p><ul><li>集合中的元素是互不相同的。</li><li>集合中的元素没有顺序之分。比如集合 {1, 2, 3} 和 {3, 2, 1} 是同一个集合。</li></ul><p>生活中的集合有很多，比如：班级，家庭成员，朋友等等。所以，学生还是比较容易理解的。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li><li>合并（Merge）：合并两个元素所属集合（合并对应的树）</li></ul><p>在教学并查集的时候，画示意图可以很好地让学生理解并查集的操作。</p><h3 id="并查集的初始化"><a href="#并查集的初始化" class="headerlink" title="并查集的初始化"></a>并查集的初始化</h3><p>我们用数组来表示并查集，用数组的值表示当前结点的父亲。如下图所示：</p><img src="/images/uqs-1.jpg" class=""><p>所以，初始化的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[MAXN], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集的查询操作"><a href="#并查集的查询操作" class="headerlink" title="并查集的查询操作"></a>并查集的查询操作</h3><p>并查集在查询时，从初始结点开始，判断自己是不是根结点。根结点的特征是自己是自己的父亲。如果自己不是根结点，则继续递归往上找。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这儿，也顺便引入路径压缩的优化，告诉学生在返回值的时候，如果更新结点，就可以把下图中的长路径“拍扁”，使得下次查询的时候速度更快。</p><img src="/images/uqs-2.jpg" class=""><p>那么如何更新呢？只需要在上面的代码基础上做一点点改动，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]); <span class="comment">// 在返回值之前，更新结点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以简化成一行：<code>return p[a]==a ? a : (p[a] = find(p[a]));</code>。但是教学的时候，还是展开让学生理解清楚后，再提供简化的写法比较好。</p><h3 id="并查集的合并操作"><a href="#并查集的合并操作" class="headerlink" title="并查集的合并操作"></a>并查集的合并操作</h3><img src="/images/uqs-3.jpg" class=""><p>合并的时候，像上图那样，我们把一个结点的根结点的父亲，指向另外一个根结点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以简化成一行：<code>p[find(a)]=find(b);</code>。但是教学的时候，还是展开让学生理解清楚后，再提供简化的写法比较好。</p><h3 id="判断并查集中集合的个数"><a href="#判断并查集中集合的个数" class="headerlink" title="判断并查集中集合的个数"></a>判断并查集中集合的个数</h3><p>因为有一个根结点，就代表有一个集合，所以我们可以数根结点的个数来得到集合的个数。</p><p>根结点的特点是：它的父结点就是自己。相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集的练习题"><a href="#并查集的练习题" class="headerlink" title="并查集的练习题"></a>并查集的练习题</h2><p>完成以上的基础教学，就可以练习了。并查集的考查主要就是两个：</p><ul><li>判断两点是否联通</li><li>计算连通块（集合）的个数</li></ul><p>以下是基础的练习题目。</p><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚</a></td><td>基础题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1536">P1536 村村通</a></td><td>基础题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1892">P1892 团伙</a></td><td>提高题，需要用反集</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3144">P3144 Closing the Farm S</a></td><td>USACO 16 OPEN</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1197">P1197 星球大战</a></td><td>JSOI 2008</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2024">P2024 食物链</a></td><td>NOI 2001</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1196">P1196 银河英雄传说</a></td><td>NOI 2002</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="反集"><a href="#反集" class="headerlink" title="反集"></a>反集</h2><p>当题目中引入了敌人关系，并且定义：“敌人的敌人是朋友”的时候，就可以用反集来求解了。</p><p>反集专门用于表示敌对关系，并且敌人的敌人是朋友。反集的思路是再构造一个集合（称之为反集），然后将“敌人”关系通过原集和反集表示出来。</p><p>我们看个例子：</p><p>比如假设有 3 个元素，1, 2, 3。我们称他们的反集元素分别为 <code>1&#39;</code> , <code>2&#39;</code>,  <code>3&#39;</code>; 分别表示 1, 2, 3 的敌人。</p><p>这个时候，如果 1 和 2 是敌人，则：</p><ul><li>因为 <code>1&#39;</code> 也是 1 的敌人, 所以 <code>1&#39;</code> 和 2 是朋友</li><li>因为 <code>2&#39;</code> 也是 2 的敌人, 所以 <code>2&#39;</code> 也是 1 的朋友</li></ul><p>结果表示如下：</p><img src="/images/uqs-4.jpg" class=""><p>这个时候，如果 2 和 3 是敌人，则</p><ul><li>2 和 3&#96; 是朋友</li><li>3 和 2&#96; 是朋友</li></ul><p>结果表示如下：</p><img src="/images/uqs-5.jpg" class=""><p>我们可以看到，在这种操作下，1 和 3 自然就在一个集合中了（成为朋友了）。</p><p>以上逻辑在并查集中如何实现呢？我们将并查集的下标扩展一倍，用 <code>n+1</code> ~ <code>2n</code> 来表示反集元素。其中，元素 a 的反集是 a+n。 </p><p>这个时候，如果 a 与 b 是敌人，则需要在并查集中做如下操作：</p><ul><li>因为 a 与 b 是敌人，所以 a 与 b+n 就是朋友，需要 <code>merge(a, b+n)</code>;</li><li>因为 a 与 b 是敌人，所以 b 与 a+n 就是朋友，需要 <code>merge(b, a+n)</code>;</li></ul><p><a href="https://www.luogu.com.cn/problem/P1892">P1892 团伙</a> 是反集的典型例题，可以拿此题练习。</p><p>需要特别注意的是，因为此题需要判断集合数量，所以需要让 <code>1~n</code> 的元素当根结点，涉及合并操作的时候，不要让 <code>1~n</code> 的元素当反集元素的孩子。关健代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> fb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="comment">// b 有可能是反集，所以始终让 fb 在合并的时候当子结点</span></span><br><span class="line">    p[fb] = fa; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1892">P1892 团伙</a> 的完整参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">2010</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> fb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="comment">// b 有可能是反集，所以始终让 fb 在合并的时候当子结点</span></span><br><span class="line">    p[fb] = fa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2010</span>; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, ch, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">merge</span>(a, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">merge</span>(a, b+n);</span><br><span class="line">            <span class="built_in">merge</span>(b, a+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="练习题参考代码"><a href="#练习题参考代码" class="headerlink" title="练习题参考代码"></a>练习题参考代码</h2><h3 id="P1551-亲戚"><a href="#P1551-亲戚" class="headerlink" title="P1551 亲戚"></a>P1551 亲戚</h3><p>标准的并查集，没有陷阱。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> p[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5010</span>; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">merge</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1536-村村通"><a href="#P1536-村村通" class="headerlink" title="P1536 村村通"></a>P1536 村村通</h3><p>用并查集操作，然后数一下一共有多少个不同的集合，答案就是 <code>集合数-1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">1010</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">    p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">merge</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (pa == i) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>并查集还有更多的优化，比如在合并的时候，把高度小的树往高度大的树上合并，以尽可能减少树的高度，这样可以使得未来查询的时候效率更高。因为大多时候用不上，所以这些知识可以放在课后阅读中让学生自行掌握。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">https://oi-wiki.org/ds/dsu/</a></li><li><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></li><li><a href="https://oj.youyue.info/fs/storage?target=RFa/1nCebcqlz7_l1hL8tESDa.pdf&expire=1739031007409&secret=cfb465cf9abed5a203ea3c85a5718f03">反集</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;并查集在引入之前，需要先教会学生集合的概念。&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;集合是数学中的一个基本概念，它是由一些确定的、彼此不同的对象所组成的整体。集合有</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：二分查找</title>
    <link href="https://blog.devtang.com/2025/01/25/teaching-notes-of-binary-search/"/>
    <id>https://blog.devtang.com/2025/01/25/teaching-notes-of-binary-search/</id>
    <published>2025-01-25T14:19:44.000Z</published>
    <updated>2025-08-09T22:52:24.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二分查找的基础逻辑很简单：我们小时候都玩过猜数字游戏，心里想一个数字（ 数字范围是 1-100），让对方猜，如果没猜对，就只告诉对方猜大了还是小了，看看最快几次能猜到。</p><p>这个游戏的最佳策略就是二分。先猜 50，如果大了，就猜 25。这样最多 7 次就可以猜到答案。</p><h2 id="基础模版"><a href="#基础模版" class="headerlink" title="基础模版"></a>基础模版</h2><p>对于猜数字这个游戏来说，二分的模版最简单的就是如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="type">int</span> left, right, mid, ans;</span><br><span class="line">left = <span class="number">1</span>;</span><br><span class="line">right = n;</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (v[mid] &gt; a) &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[mid] &lt; a) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = mid;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码需要注意的有以下几点：</p><ul><li>查徇范围是 <code>[left, right]</code>，即 left 和 right 都是闭区间。</li><li>循环条件是<code>left &lt;= right</code>，即当 <code>left == right</code>时，还需要进行一次测试。</li><li><code>mid = left + (right-left) / 2</code>其实等价于 <code>mid = (left + right) / 2</code>只是后者可能超界，用前者可以避免。</li></ul><p>这种思路其实比较简单，写起来基本上不会犯错。但是，如果有多个目标值时，我们可能要多次更新 <code>ans</code> 变量。</p><p><a href="https://www.luogu.com.cn/problem/P2249">P2249 查找</a>就是一道例题，此题需要找到目标值第一次出现的位置，如果用上面的模版，我们需要多次更新 <code>ans</code>，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n, m, a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> left, right, mid, ans;</span><br><span class="line">        left = <span class="number">1</span>;</span><br><span class="line">        right = n;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v[mid] &gt; a) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[mid] &lt; a) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到，则比较 ans 的值，更新它</span></span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">-1</span> || ans &gt; mid) ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一种模版"><a href="#另一种模版" class="headerlink" title="另一种模版"></a>另一种模版</h2><p>除了刚刚的模版外，我们还可以用另外一种写法来写二分：我们用 <code>[l,r)</code>来表示目标查找区间，注意这里是左闭右开的区间。然后，我们不停地尝试缩小这个区间：</p><ul><li>情况 1：当目标值比 mid 值大的时候，新区间在 <code>[mid+1, r)</code></li><li>情况 2：当目标值比 mid 值小的时候，新区间在 <code>[l, mid)</code></li><li>情况 3：当目标值与 mid 值相等的时候，因为我们要找最小值，所以新区间在 <code>[l, mid)</code>。</li></ul><p>以上的情况 2 和情况 3 是可以合并的。结果就是只需要写一个 if 就可以了，核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有同学可能会问：如果只有一个值相等，并且在 mid 位置，那以上做法不是把结果就跳出区间了？其实这种情况下，l 的值会一步步右移，最后的循环结束的结果会是 <code>[mid,mid)</code>。所以我们还是可以从循环结束的 l 值中读到目标值。</p><p>对于这种写法，我们的二分判断会少很多，只需要最后判断一下 l 的值是否是目标值，即可知道是否查找成功。</p><p>以下是参考代码（从以前的 32 行缩短为 24 行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n, m, a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> l, r, mid;</span><br><span class="line">        l = <span class="number">1</span>; r = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; n+<span class="number">1</span> &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果记不清楚，就分开写：</p><ul><li>如果猜对了但要找最小值，就更新 r</li><li>如果 mid 大了，则答案在 mid 左侧，就更新 r</li><li>如果 mid 小了，则答案在 mid 右侧，就更新 l</li></ul><p>另外，以上这种代码其实是不停在<code>[l,mid)</code> 和 <code>[mid+1, r)</code>之间做选择，所以：</p><ul><li><code>l</code> 只会更新成 <code>mid+1</code></li><li><code>r</code> 只会更新成 <code>mid</code></li></ul><p>最后答案如果有，则在 <code>l</code> 位置，当然 <code>l</code> 位置也可能不是答案：</p><ul><li>如果目标极小，没找到，则 <code>l</code> 位置为查找的范围最左侧下标</li><li>如果目标极大，没找到，则 <code>l</code> 位置为最初的 r 的位置（那个位置是最后一个元素的下一个位置，直接读取会数组越界）</li></ul><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><p>其实上面那个写法就是 C++ STL 里面的 <code>lower_bound</code> 函数，所以我们可以直接用 <code>lower_bound</code> 函数来实现 <a href="https://www.luogu.com.cn/problem/P2249">P2249 题</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> n, m, a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">lower_bound</span>(v+<span class="number">1</span>, v+n+<span class="number">1</span>, a) - v;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; n+<span class="number">1</span> &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>lower_bound</code> 在 <code>[first,last)</code> 中的前闭后开区间进行二分查找，返回大于或等于目标值的第一个元素位置。如果所有元素都小于目标值，则返回 last 的位置。</p><p>这种函数行为初看很奇怪，因为它：</p><ul><li>当找到目标值时，它返回达找到的值的第一个位置</li><li>当没有目标值时，它返回第一个大于目标值的位置</li><li>当所有元素都小于目标值时，它返回 last 的位置</li></ul><p>这实际上就是它的内部实现所致（可以理解为这种写法的side effect），它内部实现就是我们刚刚提到的写法，所以才会这么返回目标值。</p><p>如果我们想把查找结果转换成数组下标，只需要让它减去数组首地址即可，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx = <span class="built_in">lower_bound</span>(v, v+n, a) - v;</span><br></pre></td></tr></table></figure><h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h2><p>除了 <code>lower_bound</code> 函数之外，C++还提供了 <code>upper_bound</code> 函数。<code>lower_bound</code> 在 <code>[first, last)</code> 中的前闭后开区间进行二分查找，返回第一个比目标值大的位置。如果没找到，则返回 last 的位置。</p><p><code>upper_bound</code> 的内部实现逻辑是：</p><ul><li><strong>如果猜对了但要找最大值，就更新 l</strong></li><li>如果 mid 大了，则答案在 mid 左侧，就更新 r</li><li>如果 mid 小了，则答案在 mid 右侧，就更新 l</li></ul><p>为了方便对比，我把 <code>lower_bound</code> 的逻辑再写一下：</p><ul><li><strong>如果猜对了但要找最小值，就更新 r</strong></li><li>如果 mid 大了，则答案在 mid 左侧，就更新 r</li><li>如果 mid 小了，则答案在 mid 右侧，就更新 l</li></ul><p>你看出来了吗？只是第一个更新的逻辑不一样。所以，其实两者的代码很像，我自己分别写了二者的一个实现，大家可以对比看一下，实际上二者实现部分只差了一个字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果目标值等于或者小于 mid，则 r = m</span></span><br><span class="line"><span class="comment">// 如果目标值大于 mid，则 l = m+1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    l = <span class="number">0</span>; r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; v[m]) l = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 mid 值小于等于目标，就 l=m+1</span></span><br><span class="line"><span class="comment">// 如果 mid 值大于目标，就 r=m</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    l = <span class="number">0</span>; r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= v[m]) l = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们 <code>upper_bound</code> 考虑几种情况：</p><ul><li>如果目标值极小，那么一直就更新 r，结果返回的就是首地址，为正确值。</li><li>如果目标值极大，那么一直就更新 l，结果返回的就是 last。</li></ul><p>所以 <code>upper_bound</code> 如果没找到，会返回 last。</p><p>我们再看 <code>lower_bound</code></p><ul><li>如果目标值极小，那么一直就更新 r，结果返回的就是首地址，为第一个大于目标值的地址。</li><li>如果目标值极大，那么一直就更新 l，结果返回的就是 last。</li></ul><p>所以，其实这两个函数在没找到目标值的情况下，都有可能返回首地址或末地址的。只是对于 <code>upper_bound</code> 函数来说，首地址是有意义的。</p><p>而 <code>lower_bound</code> 函数返回的首地址怎么说呢？有点像 side effect。很少有需求是求这个地址，所以很多时候要特殊处理一下，就像我们刚刚例题里面又判断了一下一样(如下所示)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &lt; n+<span class="number">1</span> &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>二分不但能用于查找数值，还可以用来暴力尝试答案。因为即便是 0-20 亿这么大的范围的猜数字游戏，也只需要 30 多次就可以猜到，所以如果某个问题可以像猜大小一样，每次获得答案是大了还是小了，就可以用二分的办法来“二分答案”。</p><p>对于二分答案一类的题目，最常见的题目描述特征是求某某值的<strong>最大值最小</strong>，或者<strong>最小值最大</strong>。这个特征可以作为我们选择二分解题的小提示。我们在练习题目 <a href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a> 和 <a href="https://www.luogu.com.cn/problem/P1182">P1182 数列分段 Section II</a> 中就可以看到这种提示。</p><h2 id="教学和练习题目"><a href="#教学和练习题目" class="headerlink" title="教学和练习题目"></a>教学和练习题目</h2><p>教学题目：</p><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2249">P2249 查找</a></td><td>可用 lower_bound 函数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对</a></td><td>也可使用 STL map</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1873">P1873 砍树</a></td><td>二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3853">P3853 路标设置</a></td><td>天津省选，二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1678">P1678 烦恼的高考志愿</a></td><td>二分查找，可用 upper_bound 函数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2440">P2440 木材加工</a></td><td>二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a></td><td>二分答案，NOIP2015 提高组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1182">P1182 数列分段 Section II</a></td><td>二分答案</td></tr></tbody></table><p>练习题目：</p><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1296">P1296 奶牛的耳语</a></td><td>用 upper_bound 二分</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/B4305">B4305 物品分组</a></td><td>蓝桥杯青少年组省赛 2024，二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1258">P1258 小车问题</a></td><td>二分答案</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1824">P1824 进击的奶牛 Aggressive Cows G</a></td><td>USACO05FEB, 二分答案</td></tr></tbody></table><h3 id="P3853-路标设置"><a href="#P3853-路标设置" class="headerlink" title="P3853 路标设置"></a>P3853 路标设置</h3><p>二分答案+判定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L, N, K;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]-v[i<span class="number">-1</span>] &gt; mid)&#123;</span><br><span class="line">            ans += (v[i]-v[i<span class="number">-1</span>]<span class="number">-1</span>)/mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=K)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;L, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left, right, mid, ans = INT_MAX;</span><br><span class="line">    left = <span class="number">1</span>;</span><br><span class="line">    right = L;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找。</span></span><br><span class="line"><span class="comment"> * 用 upper_bound 找到第一个大的位置 idx，然后取 idx 和 idx - 1, 分别试一下。</span></span><br><span class="line"><span class="comment"> * idx 可能是 0 或者末尾（idx == m），要特殊处理一下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n, vm[<span class="number">100010</span>], a;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, vm+i);</span><br><span class="line">    <span class="built_in">sort</span>(vm, vm+m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="type">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">upper_bound</span>(vm, vm+m, a)-vm;</span><br><span class="line">        <span class="keyword">if</span> (idx != m) diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(vm[idx]-a));</span><br><span class="line">        <span class="keyword">if</span> (idx - <span class="number">1</span> &gt;=<span class="number">0</span> ) diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(vm[idx<span class="number">-1</span>]-a));</span><br><span class="line">        ans += diff;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i]/mid;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = (<span class="type">int</span>)<span class="number">1e8</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h3><p>二分答案：用 mid 去试跳，如果间距小于 mid，则去掉那个石头，如果去掉个数超过 k 个，则失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ed, n, k;</span><br><span class="line"><span class="type">int</span> v[<span class="number">50010</span>];</span><br><span class="line"><span class="comment">// 用 mid 去试跳，如果间距小于 mid，则去掉那个石头，如果去掉个数超过 k 个，则失败。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> dis = v[i] - v[i<span class="number">-1</span>] + diff;</span><br><span class="line">        <span class="keyword">if</span> (dis &lt; mid) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            diff = dis;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            diff = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;ed, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">    v[n+<span class="number">1</span>] = ed; <span class="comment">// 终点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = ed;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mid);</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1182-数列分段-Section-II"><a href="#P1182-数列分段-Section-II" class="headerlink" title="P1182 数列分段 Section II"></a>P1182 数列分段 Section II</h3><p>二分答案。对目标答案每 mid 分一段，如果分出来的段数 &lt;&#x3D; m 即为真。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, v[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">        <span class="keyword">if</span> (v[i] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            cnt = <span class="number">0</span>; </span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">0</span>) tot++;</span><br><span class="line">    <span class="keyword">if</span> (tot &lt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, mid);</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1258-小车问题"><a href="#P1258-小车问题" class="headerlink" title="P1258 小车问题"></a><a href="https://www.luogu.com.cn/problem/P1258">P1258 小车问题</a></h3><p>此题也可以列方程，但是也是一道很有技巧的二分答案的题目，适合用来练习二分的使用技巧。</p><p>二分答案，需要二分的值与判定的结果有一个单调关系。如果我们假设一开始把甲载到的位置是 C 点，如果简单二分位置 C，那么得到的两人到达的总时长，并不是单调的。</p><p>但是，如果我们二分位置 C，但是判断的是甲与乙的时间差 t1-t2，就会发现：随着 C 的值变大，t1-t2 会单调变小。这就形成了一个单调关系。而我们要找的答案，就是 t1-t2 最接近 0 的位置。</p><p>所以，我们就可以二分了，每次二分位置 C:</p><ul><li>如果 t1-t2 大于零，则可以增大 C，让 left&#x3D;mid</li><li>如果 t1-t2 大于零，则可以减小 C，让 right&#x3D;mid</li></ul><p>这样，C 的值最终会无限趋近于 t1-t2 等于零的位置。</p><p>另外，我们可以较容易推算出甲乙分别的用时公式：</p><ul><li>甲的总用时 <code>t1 = 开车时间 c/b + 步行时间 (s-c)/a</code></li><li>乙的总用时 <code>t2 = 开车送甲的时间c/b + 相遇问题时间 + 开车时间</code><ul><li>开车送甲的时间: <code>m1 = c/b</code></li><li>相遇问题时间: <code>m2=(c-c/b*a)/(a+b)</code></li><li>开车时间: <code>m3= (s-m1*a-m2*a)/b</code></li></ul></li></ul><p>那终止条件是什么呢？我们的答案是要求精度达到小数点后 6 位。所以，我们让 t1-t2 的差小于小数点后 7 位即可。为什么是 7 位而不是 6 位呢？因为如果我们只保证他们的差小于小数点后 6 位，那第 7 位就会涉及四舍五入的问题，这样会造成第 6 位输出的时候有影响。</p><p>小结一点，这道题比较难想到的有：</p><ul><li>二分的单调性函数</li><li>终止条件</li><li>精度要多求一位</li></ul><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**            </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> s, a, b, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_t1</span><span class="params">(<span class="type">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c/b + (s-c)/a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_t2</span><span class="params">(<span class="type">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> m1 = c/b;</span><br><span class="line">    <span class="type">double</span> m2 = (c-c/b*a)/(a+b);</span><br><span class="line">    <span class="type">double</span> m3 = (s-m1*a-m2*a)/b;</span><br><span class="line">    <span class="keyword">return</span> m1+m2+m3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cin &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">double</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> right = s;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">double</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">double</span> t1 = <span class="built_in">get_t1</span>(mid);</span><br><span class="line">        <span class="type">double</span> t2 = <span class="built_in">get_t2</span>(mid);</span><br><span class="line">        <span class="type">double</span> diff = t1 - t2;</span><br><span class="line">        <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">                ans = t1; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="教学思考"><a href="#教学思考" class="headerlink" title="教学思考"></a>教学思考</h2><p>因为<code>lower_bound</code> 和 <code>upper_bound</code>的写法相比传统写法还是有点复杂，在教学中还是适合用最初的那个易懂的版本。易懂的版本虽然执行起来多几次判断，但是在比赛中这一点多的时间并不影响整体的时间复杂度，所以不会因此扣分。同时，简单易于理解的代码，在学习和解题时，也更加不容易犯错。</p><p>待学生理解基础二分的写法后，再把系统的实现拿出来，作为增强的补充练习题目。这么补充练习并不是要学生一定掌握，而是借由实现系统的函数，学会在比赛中调用 C++ 的 <code>lower_bound</code> 和 <code>upper_bound</code> 库函数，这样可以加速解题的速度。</p><p>二分答案的思路很好理解，但是实际写起来还是很容易晕，所以需要多加练习。另外利用题目特征来获得提示，帮助自己快速解题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>lower_bound</code> 和 <code>upper_bound</code> 都是极简二分查找的 C++ 内部实现。</li><li>因为它们都有 side effect，所以在查找目标不存在时，均可能返回首地址和末地址（取决于目标是极小还是极大）。<ul><li>因为以上的 side effect，所以我们给 <code>lower_bound</code> 赋予了额外的功能：返回第一个大于或等于目标值的位置；如果不存在返回 last。</li><li><code>upper_bound</code> 在目标值极小的时候，返回首地址（正好符合要求）；在目标值极大的时候，返回 last。</li></ul></li><li>因为 <code>lower_bound</code> 有可能返回的不是目标值，所以最后要判断一下。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;二分查找的基础逻辑很简单：我们小时候都玩过猜数字游戏，心里想一个数字（ 数字范围是 1-100），让对方猜，如果没猜对，就只告诉对方猜大了还</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：动态规划</title>
    <link href="https://blog.devtang.com/2025/01/05/teaching-notes-of-dp/"/>
    <id>https://blog.devtang.com/2025/01/05/teaching-notes-of-dp/</id>
    <published>2025-01-05T10:03:48.000Z</published>
    <updated>2025-11-17T15:04:40.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>动态规划是 CSPJ 拉分的关键知识点。</p><p>之所以这样，是因为动态规划不像 DFS、BFS、二分那样有固定的模版格式。学生要在动态规划问题上融汇贯通，需要花费大量的练习，也需要足够的聪明。</p><p>笔者自己在高中阶段，也是在动态规划问题上困扰许久。我自己的学习经验是：动态规划还是需要多练，练够 100 道题目，才能够熟悉动态规划的各种变型。之后在比赛中看到新的题目，才会有点似曾相识的感觉，进一步思考出状态转移方程。</p><p>所以，我打算写 100 道动态规划方程的题解，希望有志攻破此难关的学生和家长一起加油！</p><h1 id="动态规划解题的核心问题"><a href="#动态规划解题的核心问题" class="headerlink" title="动态规划解题的核心问题"></a>动态规划解题的核心问题</h1><p>虽然动态规划没有模版可以套，但是动态规划有三个核心问题：</p><ul><li>状态的定义</li><li>状态转移方程</li><li>初始状态的设置</li></ul><p>一般思考动态规划就是思考以上三个问题，这三个问题解决了，动态规划的程序也可以写出来了。</p><h1 id="教学题目"><a href="#教学题目" class="headerlink" title="教学题目"></a>教学题目</h1><h2 id="基础-DP"><a href="#基础-DP" class="headerlink" title="基础 DP"></a>基础 DP</h2><p>推荐的教学题目如下：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2842">P2842 纸币问题 1</a></td><td>基础 DP，记忆化搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a></td><td>基础 DP，记忆化搜索 【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2840">P2840 纸币问题 2</a></td><td>基础 DP</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2834">P2834 纸币问题 3</a></td><td>基础 DP，有多处可优化的点</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a></td><td>NOIP2005 普及组第三题。01 背包问题。【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药</a></td><td>完全背包问题。【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2196">P2196 挖地雷</a></td><td>NOIP1996 提高组第三题。涉及输出路径技巧。</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1434">P1434 滑雪</a></td><td>上海市省队选拔 2002。可以用记忆化搜索，也可以拓扑排序后 DP</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a></td><td>最大子段和。【经典 DP】</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1507">P1507 NASA的食物计划</a></td><td>多重背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包</a></td><td>分组背包</td></tr></tbody></table><p>适合的作业：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a></td><td>记忆化搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2871">P2871 Charm Bracelet S</a></td><td>USACO 07 DEC，01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日</a></td><td>01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1002">P1002 过河卒</a></td><td>NOIP2002 普及组，记忆化搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1049">P1049 装箱问题</a></td><td>NOIP2001 普及组，01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1064">P1064 金明的预算方案</a></td><td>01 背包变型，NOIP2006 提高组第二题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1077">P1077 摆花</a></td><td>NOIP2012 普及组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a></td><td>与摆花一题类似</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2392">P2392 考前临时抱佛脚</a></td><td>01 背包变型</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/B3873">B3873 小杨买饮料</a></td><td>01 背包变型, GESP202309 六级</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P13015">P13015 学习小组</a></td><td>完全背包，GESP 202506 六级</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P10721">P10721 计算得分</a></td><td>背包问题变种，GESP 202406 六级</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2918">P2918 Buying Hay S</a></td><td>USACO08NOV, 求最小值的完全背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12207">P12207 划分</a></td><td>蓝桥杯 2023 国，01 背包的变型</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1510">P1510 精卫填海</a></td><td>01 背包，但是输出要求有变化</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1679">P1679 神奇的四次方数</a></td><td>完全背包，需要求最小值</td></tr></tbody></table><p>更多的题单：</p><ul><li><a href="https://www.luogu.com.cn/training/231055">背包精选</a></li></ul><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><h3 id="P1063-NOIP-2006-提高组-能量项链"><a href="#P1063-NOIP-2006-提高组-能量项链" class="headerlink" title="P1063 NOIP 2006 提高组 能量项链"></a><a href="https://www.luogu.com.cn/problem/P1063">P1063 NOIP 2006 提高组 能量项链</a></h3><p>区间 DP:</p><ul><li><code>dp[i][j]</code> 表示从 i 到 j 能够形成的最大能量。</li></ul><p>转移方程：</p><ul><li>定义变量 k，<code>i&lt;k&lt;j</code></li><li><code>dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + a[i]*a[k]*a[j]);</code></li></ul><p>初使化：</p><ul><li>一个珠子是没有能量的，所以 <code>dp[i][i]</code> 和 <code>dp[i][i+1]</code> 都为 0</li></ul><p>技巧：</p><ul><li>因为是环形的，所以把数据复制一段，取长度刚好是 N 的一段中，值最大的为 ans。</li><li>i 需要从 <code>1~2n</code>，不能到 n 就不算了。</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>][<span class="number">210</span>], a[<span class="number">210</span>], n, ans;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[n+i] = a[i];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// len 代表长度，从长度为 2 的区间开始 dp</span></span><br><span class="line">    <span class="comment">// i 代表起点，k 代表中间点，j 代表终点(i&lt;k&lt;j)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;=n; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">2</span>*n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">2</span>*n) j = <span class="number">2</span>*n; <span class="comment">// 因为终点不能越界，所以需要判断一下 j 有没有超过 2*n</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i+<span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k]+dp[k][j]+a[i]*a[k]*a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;dp[%d][%d]=%d\n&quot;</span>, i, j, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计最长的一段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i][i+n]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题代码"><a href="#例题代码" class="headerlink" title="例题代码"></a>例题代码</h1><h2 id="P2842-纸币问题-1"><a href="#P2842-纸币问题-1" class="headerlink" title="P2842 纸币问题 1"></a>P2842 纸币问题 1</h2><p>此题可以带着孩子一步步推导和演进。具体步骤如下。</p><p>先引导孩子用最暴力的 DFS 的方式来做此题，建立基础的解题框架，虽然会超时，但是也帮助我们后面引导孩子学会记忆化搜索。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS，超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pt&gt;=v[i]) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, <span class="built_in">dfs</span>(pt-v[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">dfs</span>(w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的代码，通过分析，发现大部分的超时是因为有重复的计算过程。以下是一个以 10,5,1 为例的示意：</p><img src="/images/dp-1.jpg" class=""><p>所以，我们可以将重复计算的过程保存下来，以后再次需要计算的时候，直接读取保存的结果即可。在此思想下，我们只需要在上面改动三行，即可将超时的程序改为通过。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS，记忆化搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">10010</span>]; <span class="comment">// 改动 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r[pt] != <span class="number">0</span>) <span class="keyword">return</span> r[pt]; <span class="comment">// 改动 2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pt&gt;=v[i]) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, <span class="built_in">dfs</span>(pt-v[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (r[pt]=ret); <span class="comment">// 改动 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">dfs</span>(w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了以上两段代码的尝试，我们能够发现：</p><ul><li>dfs(pt) 只与 dfs( 0 ~ pt-1) 有关,与 dfs(pt+1~w)无关。</li><li>如果我们知道了 dfs(0~pt)，就可以推出 dfs(pt+1)</li></ul><p>那么，我们就可以思考，如果我们用 dp[i] 来表示钱币总额为 i 的结果数。那么，dp[i] 的计算过程（即：状态转移方程）为：<code>dp[i] = min( dp[i-v[j]] )+1</code>，其中<code>j=0~N</code>。</p><p>这样，我们就可以引导学生写出第一个动态规划程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i] = min( dp[i-v[j]] )  + 1 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>], dp[<span class="number">11000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=w ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-v[j]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-v[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1216-数字三角形"><a href="#P1216-数字三角形" class="headerlink" title="P1216 数字三角形"></a>P1216 数字三角形</h2><p><a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a>同样可以用记忆化搜索引入。先写记忆化搜索的代码有助于我们理解动态规划的状态转移方程。</p><p>搜索的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS，记忆化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> r[x][y];</span><br><span class="line">    <span class="keyword">if</span> (x == n<span class="number">-1</span>) <span class="keyword">return</span> </span><br><span class="line">        r[x][y] = v[x][y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> </span><br><span class="line">        r[x][y] = v[x][y]+<span class="built_in">max</span>(<span class="built_in">dfs</span>(x+<span class="number">1</span>,y), <span class="built_in">dfs</span>(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由搜索代码可知，每一个位置的最价结果由它下面两个结点的最价结果构成。于是，我们可以构造出状态转移方程：<code>dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1])</code></p><p>另外，我们可以引导学生：上层的依赖于下层的数据，那应该怎么推导呢？让学生想到用倒着 for 循环的方式来从下往上推导。</p><p>最后，我们再引导学生构建一下初始值。由此，我们建立起动态规划解题的三个核心问题：</p><ul><li>状态的定义</li><li>状态转移方程</li><li>初始状态的设置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划：</span></span><br><span class="line"><span class="comment"> * dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        dp[n<span class="number">-1</span>][j] = v[n<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            dp[i][j] = v[i][j] + <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P2840-纸币问题-2"><a href="#P2840-纸币问题-2" class="headerlink" title="P2840 纸币问题 2"></a>P2840 纸币问题 2</h2><p>状态转移方程为：<code>dp[i] = sum(dp[i- v[j]]), j = 0~N</code>，结果需要每次模 1000000007。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w ; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= v[j]) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i-v[j]])%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2834-纸币问题-3"><a href="#P2834-纸币问题-3" class="headerlink" title="P2834 纸币问题 3"></a>P2834 纸币问题 3</h2><p>此题不能像之前的题目那样，用金钱数为阶段。因为此题是计算的组合数，所以 1,5 和 5,1 是一种答案。如果以金钱数为阶段，就无法方便将这种重复计算的排除掉。</p><p>那么，以什么为阶段，可以保证每个阶段可以基于过去的阶段推导出来？可以用不同的钱币种类为阶段！</p><p>接下来就是思考这种情况下的状态转移方程。可以得出，状态转移方程如下：</p><ul><li><code>dp[i][j]</code> 表示用前 i 种钱币组成金额 j 的组合数</li><li><code>dp[i][j] = dp[i-1][j-v[i]] + dp[i-1][j - v[i]*2] + …. dp[i-1][j-v[i]*n]; (j &gt;= v[i]*n)</code></li><li>初始状态：<code>dp[1][0] = 1; dp[1][v[1]] = 1; dp[1][v[1]*2] = 1;</code></li></ul><p>参考程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">1010</span>][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">// dp[0][0] = 1; dp[0][v[0]] = 1;dp[0][v[0]*2] = 1;….</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1</span>;</span><br><span class="line">        cnt += v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j - cnt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i][j]+dp[i<span class="number">-1</span>][j-cnt]) % MOD;</span><br><span class="line">                cnt += v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n<span class="number">-1</span>][w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有另外一种状态转移方程，把阶段分为没有用过 a，和至少用过一张 a。</p><p>这样的话，状态转移方程优化为：<code>dp[i][j] = dp[i-1][j] + dp[i][j-v[i]]</code></p><p>这样，代码的复杂度进一步降低，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">1010</span>][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1</span>;</span><br><span class="line">        cnt += v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-v[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j]+dp[i][j-v[i]])% MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n<span class="number">-1</span>][w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还可以进一步简化，因为 dp[i] 那一层算完之后 dp[i-1] 层就没有用了。有没有可能我们将 dp[i]层和 dp[i-1]都合并在一起呢？</p><p>答案是可以的。我们可以将关键代码进一步简化如下，把 dp 改成一个一维数组。状态转移方程变为了:<code>dp[j] = dp[j] + dp[j-v[i]]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>], dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= w) &#123;</span><br><span class="line">        dp[cnt] = <span class="number">1</span>;</span><br><span class="line">        cnt += v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-v[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = (dp[j]+dp[j-v[i]]) % MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j]; <span class="comment">//此行可以删除，但为了教学示意保留</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h2><p><a href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a>这题是经典的 01 背包问题。为了方便教学，我们还是从最简单的动态规划思路开始推导。</p><p>我们把每个草药是一个阶段，这样：</p><ul><li><code>dp[i][j]</code> 表示前 i 个草药，花费 j 时间可以得到的最大价值</li><li>状态转移方程为：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]])</code></li></ul><p>这样写出来的参考程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">dp[i][j] 表示前 i 个草药，花费 j 时间可以得到的最大价值</span></span><br><span class="line"><span class="comment">dp[i][j] = max(dp[i-1][j], dp[i-1][j-t[i]] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, M;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>], v[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;T, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, t+i, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下标从 1 开始，这样不用考虑 i-1 越界了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= T; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - t[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j - t[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[M][T]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上一题一样，通过分析，我们发现 dp[i][j] 中的 i 一层可以优化掉，变成只有 dp[j]。</p><p>这样，状态转移方程被优化成：<code>dp[j]=max(dp[j],dp[j-t[i]]+v[i])</code>。</p><p>但是，因为每一个草药只能用一次，如果我们正着循环 j 的话，会出现多次使用第 i 个草药的情况。所以，我们倒着进行递推，就可以避免这种情况。</p><p>最终实现的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">dp[j] 花费 j 时间可以得到的最大价值</span></span><br><span class="line"><span class="comment">dp[j] = max(dp[j], dp[j-t[i]])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, M;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>], v[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;T, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, t+i, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = T; j &gt;= t[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - t[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[T]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2196-挖地雷"><a href="#P2196-挖地雷" class="headerlink" title="P2196 挖地雷"></a>P2196 挖地雷</h2><p><a href="https://www.luogu.com.cn/problem/P2196">P2196 挖地雷</a> 是 NOIP1996 提高组第三题。这道题的解法有点类似于<a href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形</a>。</p><p>但是，这道题更难的是：它需要我们输出路径。</p><p>我们先说状态转移方程：</p><ul><li>dp[i] 表示第 i 个地窖能够挖到的最多地雷数。</li><li>w[i] 表示第 i 个地窖的地雷数。</li><li>转移方程：<code>dp[i] = max(dp[i+1~N]中能够与 dp[i] 连通的地窖) + w[i]</code> 与 <code>dp[i] = w[i]</code>中的较大者。</li></ul><p>我们再说说如何输出路径。因为计算之后 dp 数组中保存了每个结点能够挖的最大地雷数。所以，我们从答案 dp[ans]开始，找哪一个地窖与当前相连，同时值又等于 dp[ans] - w[ans],则表示那个地窖是下一个点。</p><p>参数代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, w+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i&gt;=<span class="number">1</span>; --i) &#123;</span><br><span class="line">        dp[i] = w[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][j]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[ans] &lt; dp[i]) ans = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = dp[ans];</span><br><span class="line">    <span class="type">int</span> idx = ans;</span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, idx);</span><br><span class="line">        cnt -= w[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx + <span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[idx][i] &amp;&amp; cnt == dp[i]) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, dp[ans]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1434-滑雪"><a href="#P1434-滑雪" class="headerlink" title="P1434 滑雪"></a>P1434 滑雪</h2><p>这道题的麻烦点是如何定义状态转移的阶段，因为没有明显的阶段。</p><p>可以考虑的办法是：将点按高度排序，这样从高度低的点开始，往高的点做状态转移。</p><p>所以：</p><ul><li>定义：dp[i][j] 表示从 (i,j) 这个位置开始滑的最长坡。</li><li>转移方程：<ul><li><code>dp[x][y] = max(dp[x&#39;][y&#39;])+1</code></li><li><code>dp[x&#39;][y&#39;]</code> 为上下左右相邻并且高度更低的点</li></ul></li><li>初始化：无</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, h;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _h) &#123;</span><br><span class="line">        x = _x; y = _y; h = _h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node a, Node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.h &lt; b.h;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r, &amp;c);</span><br><span class="line">    v.<span class="built_in">reserve</span>(r*c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tu[i][j]);</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(i, j, tu[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r*c; ++i) &#123;</span><br><span class="line">        Node node = v[i];</span><br><span class="line">        <span class="type">int</span> x = node.x;</span><br><span class="line">        <span class="type">int</span> y = node.y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> tox = x + movex[j];</span><br><span class="line">        <span class="type">int</span> toy = y + movey[j];</span><br><span class="line">        <span class="keyword">if</span> (tox &gt;=<span class="number">0</span> &amp;&amp; tox &lt;r &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;c &amp;&amp;</span><br><span class="line">        node.h &gt; tu[tox][toy]) &#123;</span><br><span class="line">        dp[x][y] = <span class="built_in">max</span>(dp[x][y], dp[tox][toy]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[x][y] += <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[x][y]);</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dp[%d][%d]=%d\n&quot;</span>, x, y, dp[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题更容易想到的写法还是记忆化搜索：对每一个点作为开始点进行一次 DFS，同时在进行递归调用的时候，如果当前点处理过，则返回上次的结果。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS, 记忆化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> rem[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rem[x][y] != <span class="number">0</span>) <span class="keyword">return</span> rem[x][y];</span><br><span class="line">    <span class="type">int</span> mm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tox = x + movex[i];</span><br><span class="line">        <span class="type">int</span> toy = y + movey[i];</span><br><span class="line">        <span class="keyword">if</span> (tox &gt;=<span class="number">0</span> &amp;&amp; tox &lt;r &amp;&amp; toy &gt;=<span class="number">0</span> &amp;&amp; toy&lt;c &amp;&amp;</span><br><span class="line">        tu[x][y] &gt; tu[tox][toy]) &#123;</span><br><span class="line">            mm = <span class="built_in">max</span>(mm, <span class="built_in">dfs</span>(tox, toy));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (rem[x][y] = mm + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tu[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1115-最大子段和"><a href="#P1115-最大子段和" class="headerlink" title="P1115 最大子段和"></a>P1115 最大子段和</h2><p><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a> 是最经典的一类动态规划问题。思路如下：</p><ul><li>dp[i] 表示包含 i 这个数，并且以 i 结尾的最大子段和。</li><li>状态转移方程：<ul><li>如果 dp[i-1] 为负数，那么 <code>dp[i] = v[i]</code></li><li>如果 dp[i-1] 为正数，那么 <code>dp[i] = dp[i-1]+v[i]</code></li></ul></li></ul><p>因为 dp[i] 在转移方程上只与 dp[i-1]相关，所以它最终结构上被可以被化简成类似贪心的策略，即：</p><ul><li>用一个变量记录当前的累加值，如果当前累加值为负数，则重新计算。</li><li>在累加过程中随时判断，记录最大的累加值为最终答案。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">200100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1507-NASA的食物计划"><a href="#P1507-NASA的食物计划" class="headerlink" title="P1507 NASA的食物计划"></a><a href="https://www.luogu.com.cn/problem/P1507">P1507 NASA的食物计划</a></h2><p>01 背包问题：</p><ul><li><code>dp[i][j][k]</code> 表示前 i 个食品，占据 j 的体积和 k 的质量，最多能包含的卡路里。</li><li>设每个食品的体积为 <code>h[N]</code>, 质量为 <code>t[N]</code>，卡路里为 <code>w[N]</code></li></ul><p>转移方程：</p><ul><li><code>dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-h[i]][k-t[i]] + w[i])</code></li></ul><p>压维：</p><ul><li><code>dp[j][k] = max(dp[j][k], dp[j-h[i][k-t[i]]] + w[i]);</code> </li><li>01 背包，压维后需要倒着 for 变量 j 和 k</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">410</span>][<span class="number">410</span>], h[<span class="number">55</span>], t[<span class="number">55</span>], w[<span class="number">55</span>], H, T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; H &gt;&gt; T &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; h[i] &gt;&gt; t[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = H; j&gt;=h[i]; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = T; k &gt;=t[i]; k--) &#123;</span><br><span class="line">                dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[j-h[i]][k-t[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[H][T];    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1757-通天之分组背包"><a href="#P1757-通天之分组背包" class="headerlink" title="P1757 通天之分组背包"></a><a href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包</a></h2><p>分组背包。在组内的元素只能选一次。所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i], </span><br><span class="line">            dp[i-w[k1]] + v[k1],</span><br><span class="line">            dp[i-w[k2]] + v[k2],</span><br><span class="line">            ....</span><br><span class="line">            dp[i-w[kn]] + v[kn],</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p>因为一个背包位置是在组内这么多种中选出来的一种，所以最多只会用一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt[<span class="number">110</span>], w[<span class="number">1010</span>][<span class="number">1010</span>], v[<span class="number">1010</span>][<span class="number">1010</span>], dp[<span class="number">1010</span>], a, b, c, maxgroup;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);  </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        w[c][cnt[c]] = a;</span><br><span class="line">        v[c][cnt[c]] = b;</span><br><span class="line">        cnt[c]++;</span><br><span class="line">        maxgroup = <span class="built_in">max</span>(maxgroup, c); <span class="comment">// 记录最大组号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxgroup; ++i) <span class="comment">// 遍历组号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=<span class="number">0</span>; --j) <span class="comment">// 遍历背包大小，倒着 for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k&lt;cnt[i]; ++k) <span class="comment">// 遍历每组的元素</span></span><br><span class="line">                <span class="keyword">if</span> (j-w[i][k]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i][k]] + v[i][k]);</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h1><h2 id="P4017-最大食物链计数"><a href="#P4017-最大食物链计数" class="headerlink" title="P4017 最大食物链计数"></a>P4017 最大食物链计数</h2><p><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a>最佳的做法是做记忆化的搜索。</p><p>记录下出度为 0 的结点，从这些结点开始去寻找，把各种可能的路径加总。同时在 DFS 的时候，记录下搜索的结果。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记忆化搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 80112002</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line"><span class="type">int</span> r[<span class="number">5010</span>], out[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[a] != <span class="number">-1</span>) <span class="keyword">return</span> r[a];</span><br><span class="line">    <span class="comment">// 如果是头部，算一种情况</span></span><br><span class="line">    <span class="keyword">if</span> (v[a].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> (r[a]=<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不是头部，则求和</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[a].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cnt = (cnt + <span class="built_in">dfs</span>(v[a][i])) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[a] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    v.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        v[a].<span class="built_in">push_back</span>(b); <span class="comment">// a 被 b 吃</span></span><br><span class="line">        out[b]++; <span class="comment">// b 的出度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果 i 出度为 0，就表示只能被吃，为底部</span></span><br><span class="line">        <span class="keyword">if</span> (out[i] == <span class="number">0</span>) &#123; </span><br><span class="line">            ans += <span class="built_in">dfs</span>(i);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2871-Charm-Bracelet-S"><a href="#P2871-Charm-Bracelet-S" class="headerlink" title="P2871 Charm Bracelet S"></a>P2871 Charm Bracelet S</h2><p><a href="https://www.luogu.com.cn/problem/P2871">P2871 Charm Bracelet S</a> 是最最标准的 01 背包问题。可以作为基础练习。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[<span class="number">3500</span>], v[<span class="number">3500</span>], dp[<span class="number">14000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, w+i, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=w[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1802-5-倍经验日"><a href="#P1802-5-倍经验日" class="headerlink" title="P1802 5 倍经验日"></a>P1802 5 倍经验日</h2><p>经典的 01 背包问题：</p><ul><li>dp[i] 表示 i 容量可以获得的最大的经验值增量。</li><li>w[i] 表示第 i 个药的数量。</li><li>t[i] 表示第 i 个药贡献的经验值增量。</li></ul><p>状态转移方程：<code>dp[j] = max(dp[j], dp[j-w[i]]+t[i])</code>。</p><p>需要注意答案最大超过了 int，需要用 long long。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>], w[<span class="number">1010</span>], t[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> base = <span class="number">0</span>, n, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        base += a;</span><br><span class="line">        t[i] = b-a;</span><br><span class="line">        w[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=x; j&gt;=<span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-w[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w[i]]+t[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大结果为 5*1e9，需要用 long long</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">5LL</span>*(dp[x] + base));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1002-过河卒"><a href="#P1002-过河卒" class="headerlink" title="P1002 过河卒"></a>P1002 过河卒</h2><p><a href="https://www.luogu.com.cn/problem/P1002">P1002 过河卒</a>此题是标准的记忆化搜索。有两个陷阱：</p><ul><li>马所在的位置也不能走。</li><li>long long。</li></ul><p>相关代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记忆化搜索。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bx, by, hx, hy;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> r[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">block</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="built_in">abs</span>(x-hx)*<span class="built_in">abs</span>(y-hy);</span><br><span class="line">    <span class="keyword">return</span> (v == <span class="number">2</span> || x==hx &amp;&amp; y == hy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;bx || y&gt;by) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == bx &amp;&amp; y == by) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r[x][y]!=<span class="number">-1</span>) <span class="keyword">return</span> r[x][y];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">block</span>(x,y)) <span class="keyword">return</span> r[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">dfs</span>(x+<span class="number">1</span>,y) + <span class="built_in">dfs</span>(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r[x][y] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">    cin &gt;&gt; bx &gt;&gt; by &gt;&gt; hx &gt;&gt; hy;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1064-金明的预算方案"><a href="#P1064-金明的预算方案" class="headerlink" title="P1064 金明的预算方案"></a>P1064 金明的预算方案</h2><p><a href="https://www.luogu.com.cn/problem/P1064">P1064 金明的预算方案</a> 是一道 01 背包的变型题。题目增加了附件的概念，初看起来没法下手，但是题目增加了一个限制条件：附件最多只有 2 个。</p><p>所以，我们可以将 01 背包的“选或不选”两种情况扩充成以下 5 种情况：</p><ul><li>不选</li><li>选主件，不选附件</li><li>选主件 + 附件 1</li><li>选主件 + 附件 2</li><li>选主件 + 附件 1 + 附件 2</li></ul><p>然后就可以用 01 背包来实现该动态规划了。我们把每种物品的费用当作背包的体积，把每种物品的<code>价格*权重</code>当作价值。</p><p>转移方程是：<code>dp[i]=max(dp[i], 5 种物品选择情况)</code>，每种选择情况下，<code>dp[i]=max(dp[i], dp[i-该选择下的花费]+该选择下的收益) </code>。</p><p>另外，需要注意，输入数据的编号可能不按顺序提供，有以下这种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100 3</span><br><span class="line">1000 5 3</span><br><span class="line">10 5 3</span><br><span class="line">50 2 0</span><br></pre></td></tr></table></figure><p>以下是参考程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;Node&gt; va;</span><br><span class="line">vector&lt;vector&lt;Node&gt; &gt; vb;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">40000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateDP</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i-m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i-m] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    va.<span class="built_in">resize</span>(m);</span><br><span class="line">    vb.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        Node node;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;node.m, &amp;node.w, &amp;node.t);</span><br><span class="line">        node.w = node.w*node.m; </span><br><span class="line">        va[i] = node;</span><br><span class="line">        <span class="keyword">if</span> (node.t != <span class="number">0</span>) &#123;</span><br><span class="line">            vb[node.t - <span class="number">1</span>].<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="comment">// 只处理主件，附件与主体一并处理</span></span><br><span class="line">        <span class="keyword">if</span> (va[i].t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// 选主件，不选附件</span></span><br><span class="line">                <span class="built_in">updateDP</span>(j, va[i].m,va[i].w);</span><br><span class="line">                <span class="comment">// 选主件+附件 1</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">0</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">0</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j, money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选主件+附件 2</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">1</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">1</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j , money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选主件+附件 1+附件 2</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">0</span>].m + vb[i][<span class="number">1</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">0</span>].w + vb[i][<span class="number">1</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j, money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1077-摆花"><a href="#P1077-摆花" class="headerlink" title="P1077 摆花"></a>P1077 摆花</h2><p><a href="https://www.luogu.com.cn/problem/P1077">P1077 摆花</a> 一题是 NOIP2012 普及组的第三题。</p><ul><li><code>dp[i][j]</code> 表示前 i 种花，摆在前 j 个位置上的种数。</li></ul><p>状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] 不放第 i 种花</span><br><span class="line">         + dp[i-1][j-1] 放 1 个第 i 种花</span><br><span class="line">         + dp[i-1][j-2] 放 2 个第 i 种花</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>这道题的难点：没有想到 <code>dp[0][0]=1</code>。因为后面推导的时候，<br><code>dp[i-1][j-k]</code> 中 <code>j==k</code> 的时候，也是一种可能的情况，要统计进来。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= a[i]; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-k];</span><br><span class="line">                    dp[i][j] %= <span class="number">1000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1164-小A点菜"><a href="#P1164-小A点菜" class="headerlink" title="P1164 小A点菜"></a>P1164 小A点菜</h2><p><a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a>一题阶段比较明显。每一道菜点不点是一个明显阶段。所以：</p><ul><li><code>dp[i][j]</code>表示前 i 道菜，用 j 的价格，能够点的方案数</li></ul><p>对于每道菜，有点或不点两种方案，所以：</p><ul><li>转移方程：<code>dp[i][j] = dp[i-1][j]+dp[i-1][j-a[i]]</code></li></ul><p>由于 i 阶段只与 i-1 阶段相关，所以可以把阶段压缩掉，只留一维。最后压缩后的方案是：</p><ul><li><code>dp[j]</code> 表示用 j 的价格可以点到的点的种数</li><li>初始条件 <code>dp[0] = 1</code>，因为这样才可以把后面的结果递推出来</li><li><code>dp[j] = dp[j] + dp[j-a[i]]</code></li></ul><p>因为和 01 背包类似的原因，压缩后需要倒着用 for 循环，否则每道菜就用了不止一次了。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=a[i]; --j) &#123;</span><br><span class="line">            dp[j] += dp[j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2392-考前临时抱佛脚"><a href="#P2392-考前临时抱佛脚" class="headerlink" title="P2392 考前临时抱佛脚"></a>P2392 考前临时抱佛脚</h2><p><a href="https://www.luogu.com.cn/problem/P2392">P2392 考前临时抱佛脚</a> 此题可以用动态规划，也可以用搜索，因为每科只有最多 20 个题目，所以搜索空间最大是 2^20 等于约 100 万。</p><p>以下是搜索的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>], v[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> ans, tot, ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsAns</span><span class="params">(<span class="type">int</span> pt, <span class="type">int</span> n, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="built_in">max</span>(cnt, tot-cnt);</span><br><span class="line">        ret = <span class="built_in">min</span>(ret, tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfsAns</span>(pt+<span class="number">1</span>, n, cnt);</span><br><span class="line">    <span class="built_in">dfsAns</span>(pt+<span class="number">1</span>, n, cnt+v[pt]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, s, s+<span class="number">1</span>, s+<span class="number">2</span>, s+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+j);</span><br><span class="line">            tot += v[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ret = tot;</span><br><span class="line">        <span class="built_in">dfsAns</span>(<span class="number">0</span>, s[i], <span class="number">0</span>);</span><br><span class="line">        ans += ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用动态规划解题时，此题可以把每次复习看作一次 01 背包的选择。每道题的价值和成本相同。背包的目标是尽可能接近 sum&#x2F;2，因为sum 最大值为 <code>20*60 = 1200</code>，所以背包大小最大是 600。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">610</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpAns</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=v[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">max</span>(dp[m], cnt - dp[m]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, s, s+<span class="number">1</span>, s+<span class="number">2</span>, s+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+j);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">dpAns</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B3873-小杨买饮料"><a href="#B3873-小杨买饮料" class="headerlink" title="B3873 小杨买饮料"></a>B3873 小杨买饮料</h2><p>假设第 i 种饮料的费用是 <code>c[i]</code>, 容量是 <code>l[i]</code>。<code>dp[i][j]</code> 表示用前 i 种饮料，凑成 j 升的最小费用。则，转移方程为：</p><ul><li><code>dp[i][j] = min( dp[i-1][j-l[i]] + c[i] , dp[i-1][j] )</code></li></ul><p>因为 i 只与 i-1 相关，所以这一层可以取消。转移方式优化为：</p><ul><li><code>dp[j] = min(dp[j- l[i]] + c[i], dp[j])</code></li></ul><p>其它注意事项：</p><ul><li>倒着 dp，因为每种饮料只能用一次</li><li>最大值检查了一下，不会超 int，就不用 long long 了</li><li>因为答案不一定是刚好 L 升，所以要取 <code>L ~ L+max(l[i])</code> 这一段范围</li><li>因为是取最小值，所以初使化设置成 <code>0x7f7f7f7f</code>（接近 21 亿，但是又没到 INT_MAX），这样运算不会超 int，又可以是较大值</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010000</span>], c[<span class="number">550</span>], l[<span class="number">550</span>], N, L, maxL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; N &gt;&gt; L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; l[i];</span><br><span class="line">        maxL = <span class="built_in">max</span>(maxL, l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxL += L;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = maxL; j - l[i] &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j - l[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = *<span class="built_in">min_element</span>(dp+L, dp+maxL+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0x7f7f7f7f</span>) cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有一个小缺点就是 dp 数据开得很大。因为虽然题目的 L 很小（最大值为 2000），但饮料的容量最大为 <code>10^6</code>。</p><p>所以我们还有一种办法就是对这种容量很大的饮料单独判断，这样 L 的范围就可以只设置到 4000 即可。之所以是 4000 而不是 2000，是因为还是有刚刚超过 2000 一点点，而凑出最小值的情况。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">4100</span>], c[<span class="number">550</span>], l[<span class="number">550</span>], N, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; N &gt;&gt; L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">4000</span>; j - l[i] &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j - l[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = *<span class="built_in">min_element</span>(dp+L, dp+<span class="number">4000</span>);</span><br><span class="line">    <span class="comment">// 如果单个饮料就可以超 L，则判断一下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (l[i] &gt;= L) </span><br><span class="line">            ans = <span class="built_in">min</span>(ans, c[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0x7f7f7f7f</span>) cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P13015-学习小组"><a href="#P13015-学习小组" class="headerlink" title="P13015 学习小组"></a><a href="https://www.luogu.com.cn/problem/P13015">P13015 学习小组</a></h2><p>完全背包问题：</p><ul><li>人数相当于物品的重量，积极度相当于物品的价值</li><li>背包的总重量就是人数</li></ul><p>设：人数限制是 <code>a[i]</code>, 兴趣度是 <code>b[i]</code>。</p><p><code>dp[i][j]</code> 表示前 i 个物品，放 j 个人数的最大价格，则转移方程为：</p><ul><li><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i]] + b[i])</code></li></ul><p>简化 dp，去掉第一个维度后，转移方程为：</p><ul><li><code>dp[j] = max(dp[j], dp[j-a[i]] + b[i])</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">1100</span>], b[<span class="number">1100</span>], dp[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j-a[i]] + b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2918-Buying-Hay-S"><a href="#P2918-Buying-Hay-S" class="headerlink" title="P2918 Buying Hay S"></a><a href="https://www.luogu.com.cn/problem/P2918">P2918 Buying Hay S</a></h2><p>完全背包问题。</p><ul><li><code>dp[i][j]</code> 为前 i 个干草公司，采购 j 磅干草所需的最少费用。</li><li>Pi 为第 i 个公司干草的重量。</li><li>Ci 为第 i 个公司干草的价格。</li></ul><p>转移方程：</p><ul><li><code>dp[i][j] = min(dp[i-1][j], dp[i][j-Pi] + Ci);</code></li></ul><p>压维：</p><ul><li><code>dp[j] = min(dp[j], dp[j-Pi] + Ci);</code></li><li>因为是完全背包，所以正着遍历 j</li></ul><p>技巧：</p><ul><li>因为可以多采购（即超过 j 磅也行），所以最后要多数几格看看。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">55010</span>], P[<span class="number">110</span>], C[<span class="number">110</span>], N, H;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; H;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; P[i] &gt;&gt; C[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = P[i]; j &lt;= H + <span class="number">5000</span>; ++j) &#123;</span><br><span class="line">             dp[j] = <span class="built_in">min</span>(dp[j], dp[j-P[i]] + C[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">min_element</span>(dp+H, dp+H+<span class="number">5000</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此题还有一种写法：</p><ul><li>定义 <code>dp[j]</code> 表示大于或等于 j 的最小花费。</li><li>因为可以多采购（即超过 j 磅也行），所以我用 <code>(j+P[i]-1)/P[i]*C[i]</code> 来表示达成当前 j 磅的最优方案。</li><li>如果值为 0，要特殊处理。</li></ul><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">50010</span>], P[<span class="number">110</span>], C[<span class="number">110</span>], N, H;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; H;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; P[i] &gt;&gt; C[i];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= H; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] == <span class="number">0</span>) dp[j] = (j+P[i]<span class="number">-1</span>)/P[i]*C[i];</span><br><span class="line">            <span class="keyword">if</span> (j-P[i]&gt;=<span class="number">0</span>) </span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j-P[i]] + C[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], (j+P[i]<span class="number">-1</span>)/P[i]*C[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[H] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P12207-划分"><a href="#P12207-划分" class="headerlink" title="P12207 划分"></a><a href="https://www.luogu.com.cn/problem/P12207">P12207 划分</a></h2><p>把 10 拆成两个数的和，乘积什么时候最大？答案是拆成 5 和 5，乘积为 25 最大。</p><p>所以，那本题就是把 40 个数拆成两部分，看两部分能不能尽量接近 sum&#x2F;2。</p><p>01 背包：</p><ul><li>定义：<code>dp[i][j]</code> 表示前 i 个数能否表示出 j 这个值，能则为 1，不能则为 0</li><li>转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-a[i]])</code></li><li>压缩：<code>dp[j] = max(dp[j], dp[j-a[i]])</code></li></ul><p>初始化：</p><ul><li><code>dp[0] = 1;</code></li></ul><p>陷阱：</p><ul><li>乘积最大是 20 万乘 20 万，结果需要用 long long。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">40</span>] = &#123;</span><br><span class="line"><span class="number">5160</span>, <span class="number">9191</span>, <span class="number">6410</span>, <span class="number">4657</span>, <span class="number">7492</span>, <span class="number">1531</span>, <span class="number">8854</span>, <span class="number">1253</span>, <span class="number">4520</span>, <span class="number">9231</span>,</span><br><span class="line"><span class="number">1266</span>, <span class="number">4801</span>, <span class="number">3484</span>, <span class="number">4323</span>, <span class="number">5070</span>, <span class="number">1789</span>, <span class="number">2744</span>, <span class="number">5959</span>, <span class="number">9426</span>, <span class="number">4433</span>,</span><br><span class="line"><span class="number">4404</span>, <span class="number">5291</span>, <span class="number">2470</span>, <span class="number">8533</span>, <span class="number">7608</span>, <span class="number">2935</span>, <span class="number">8922</span>, <span class="number">5273</span>, <span class="number">8364</span>, <span class="number">8819</span>,</span><br><span class="line"><span class="number">7374</span>, <span class="number">8077</span>, <span class="number">5336</span>, <span class="number">8495</span>, <span class="number">5602</span>, <span class="number">6553</span>, <span class="number">3548</span>, <span class="number">5267</span>, <span class="number">9150</span>, <span class="number">3309</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">40</span>, tot, maxj, dp[<span class="number">220000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; ++i) &#123;</span><br><span class="line">        tot += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    maxj = tot/<span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = maxj; j &gt;= a[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-a[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (dp[maxj] == <span class="number">0</span>) maxj--;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1LL</span> * maxj * (tot-maxj);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P1510-精卫填海"><a href="#P1510-精卫填海" class="headerlink" title="P1510 精卫填海"></a><a href="https://www.luogu.com.cn/problem/P1510">P1510 精卫填海</a></h2><p>01背包。精卫的体力表示背包容量，然后看这个容量最多能搬多少石头。</p><ul><li>体力数组 V</li><li>体积数组 a</li><li>状态转移方程：<code>dp[i] = max(dp[i], dp[i-v[j]]+a[j]);</code></li><li>01 背包，倒着 for 循环</li></ul><p>另外：输出答案的时候，需要找出大于等于 V 的最小背包容量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>], v[<span class="number">10010</span>], a[<span class="number">10010</span>], V, n, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; V &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i&gt;=v[j]; --i) </span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[i-v[j]]+a[j]);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">if</span> (dp[c] &lt; V) cout &lt;&lt; <span class="string">&quot;Impossible\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找出大于等于 V 的最小背包容量</span></span><br><span class="line">        <span class="keyword">while</span> (dp[ans] &lt; V) ans++;</span><br><span class="line">        cout &lt;&lt; c-ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1679-神奇的四次方数"><a href="#P1679-神奇的四次方数" class="headerlink" title="P1679 神奇的四次方数"></a><a href="https://www.luogu.com.cn/problem/P1679">P1679 神奇的四次方数</a></h2><p>因为 <code>m &lt; 100,000</code>，而 <code>20^4 = 160,000</code>, 所以只需要把 20 以内的 4 次方数保存下来。<br>当作物品的体积，物品的值为 1，按完全背包 dp。</p><p>注意：因为是求最小值，需要 memset 初始化一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">20</span>], m, dp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">        v[i] = i*i*i*i;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;=m; ++j)</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j-v[i]]+<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1794-装备运输"><a href="#P1794-装备运输" class="headerlink" title="P1794 装备运输"></a><a href="https://www.luogu.com.cn/problem/P1794">P1794 装备运输</a></h2><p>多重背包:</p><ul><li><code>dp[i][j]</code> 表示 i 体积 j 重量下的最大火力。</li><li>转移方程：<code>dp[i][j] = max(dp[i][j], dp[i-v[k]][j-g[k]] + t[k]);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> V, G, N, dp[<span class="number">510</span>][<span class="number">510</span>], v[<span class="number">510</span>], g[<span class="number">510</span>], t[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; G &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; t[i] &gt;&gt; v[i] &gt;&gt; g[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = V; i&gt;= v[k]; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = G; j &gt;= g[k]; j--)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-v[k]][j-g[k]] + t[k]);</span><br><span class="line">    cout &lt;&lt; dp[V][G];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;动态规划是 CSPJ 拉分的关键知识点。&lt;/p&gt;
&lt;p&gt;之所以这样，是因为动态规划不像 DFS、BFS、二分那样有固定的模版格式。学生要在动</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
</feed>
