<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐巧的博客</title>
  
  <subtitle>记录下自己学习的点滴</subtitle>
  <link href="https://blog.devtang.com/atom.xml" rel="self"/>
  
  <link href="https://blog.devtang.com/"/>
  <updated>2026-01-29T02:08:51.761Z</updated>
  <id>https://blog.devtang.com/</id>
  
  <author>
    <name>唐巧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理财学习笔记(2)：不懂不投</title>
    <link href="https://blog.devtang.com/2026/01/29/personal-finance-note-2/"/>
    <id>https://blog.devtang.com/2026/01/29/personal-finance-note-2/</id>
    <published>2026-01-29T01:51:36.000Z</published>
    <updated>2026-01-29T02:08:51.761Z</updated>
    
    <content type="html"><![CDATA[<p>这是本系列的第 2 篇，主题是：不懂不投。</p><p>我们刚开始投资理财的时候，通常会寻求以下这些方法来找到投资标的。</p><h2 id="常见的错误办法"><a href="#常见的错误办法" class="headerlink" title="常见的错误办法"></a>常见的错误办法</h2><p>1、问朋友。我们通常会问那些看起来投资理财收益比较高的朋友，问他们应该买什么股票。<br>对于朋友推荐的股票，我们通常会“无脑”买入。但如果有一天，股票突然大幅回撤，我们通常就会陷入恐慌。我们会怀疑：这个朋友到底靠不靠谱？他之前赚钱是靠运气，还是因为现在判断出了问题？接着，我们就会陷入各种猜忌、焦虑和紧张中，最后甚至睡不着觉。如果股票持续下跌，我们甚至可能割肉离场。所以说，跟着朋友买其实并不那么靠谱。</p><p>2、看走势。我们可能会去看某些股票或基金的历史走势。看到它在过去三年或五年涨得很好，我们就买入。这也是理财 App 或者某些理财经理推荐的首选理由：它过去 X 年涨幅 XX，排名 XX。</p><p>但这很容易陷入“价值陷阱”，比如：</p><ol><li><p>周期性误判：有些股票仅仅是在某个周期内表现优秀。比如房地产在过去十年涨得很好，但这并非因为单体公司有多好，而是因为当时整个大环境让所有房企都很赚钱。如果你仅仅因为过去业绩好而买入，一旦遭遇经济下滑或泡沫破裂，就会面临巨大的损失。</p></li><li><p>均值回归陷阱：很多股票或基金某年表现出色，仅仅是因为那一年的风格与它匹配。所有行业都有“大小年”之分，未来遇到“小年”时，表现自然就会变差。我把这叫做“均值回归”。</p></li></ol><p> 这就好比考试：你的平均水平可能是第三名。发挥好的时候能考第一名，发挥不好则可能掉到第五名，但你始终是在第三名上下徘徊。</p><p>很多基金经理或股票的表现也是在自身价值上下震荡。如果你在高点买入，在回撤时就会损失惨重，甚至被深套。</p><p>3、跟风。跟风是 A 股散户的常见操作，某个时间什么热，就跟风买什么，涨了就快速卖掉，主打一个击鼓传花，赌谁是最后接盘的大傻子。</p><p>这种情况下，我们假设你的胜率是 50%。每次获胜挣 20%，每次赌失败亏 20%。如果你进行了 10 次这样的操作，那你整体的收益期望就是 <code>(1.2^5)*(0.8^5)=0.82</code>,所以你折腾了半天，最后 1 块钱的本金变成了 0.82 元。</p><p>当然，如果有人认为自己跟风总是赢，这也是有可能的，但是因为自己不敢长期持有，只要涨一点点就卖，其实每次挣的是一点点收益。但是如果偶尔遇到亏损的时候，自己舍不得卖掉，就会一次亏很多。做这种短线操作的人，需要极强的止损纪律，大部分人也是很难做到的。</p><h2 id="不懂不投"><a href="#不懂不投" class="headerlink" title="不懂不投"></a>不懂不投</h2><p>所以回到股票投资，我觉得投资理财一定要自己懂才行。如果你完全不懂或一知半解，这些都会成为你的陷阱。因为：</p><ol><li>心理层面：不懂的人往往“拿不住”。当股票大幅下跌时，无论是否割肉，你都会极度焦虑、睡不好觉，担心本金损失。</li><li>投资层面：如果你懂，面对下跌说不定还能逆势加仓；即便不加仓，至少能睡个好觉。</li></ol><p>此外，世界上还有很多投资陷阱。有些人甚至专门为“制造陷阱”而生，比如搞资金盘、割韭菜或传销。这些行为有些是非法的，有些则游走在法律边缘。如果大家没有能力分辨这些陷阱，很容易就在投资理财中遭遇严重的亏损。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>小结一下，常见的错误投资：</p><ul><li>问朋友。其实本质上信的是朋友的业绩，朋友如果业绩下滑，就会怀疑。</li><li>看走势。其实本质上是用过去业绩替代未来判断，不靠谱。</li><li>跟风。纯投机，50% 胜率下期望是负的。</li></ul><p>心理层面，只有懂了，才可能拿得住，睡得着觉。</p><p>另外，真正懂也可以避免很多骗局。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是本系列的第 2 篇，主题是：不懂不投。&lt;/p&gt;
&lt;p&gt;我们刚开始投资理财的时候，通常会寻求以下这些方法来找到投资标的。&lt;/p&gt;
&lt;h2 id=&quot;常见的错误办法&quot;&gt;&lt;a href=&quot;#常见的错误办法&quot; class=&quot;headerlink&quot; title=&quot;常见的错误办法&quot;&gt;</summary>
      
    
    
    
    
    <category term="finance" scheme="https://blog.devtang.com/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>理财学习笔记(1)：每个人必须自己懂理财</title>
    <link href="https://blog.devtang.com/2026/01/24/personal-finance-note-1/"/>
    <id>https://blog.devtang.com/2026/01/24/personal-finance-note-1/</id>
    <published>2026-01-24T00:20:53.000Z</published>
    <updated>2026-01-29T01:53:00.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我打算系统性整理一下这几年投学习投资理财的心得。因为一方面通过总结，可以让自己进一步加深对投资的理解。另一方面我也想分享给同样想学习理财的读者们。</p><p>我的女儿虽然还在读小学，但我也给她报了一个针对小学生的财商课。她对理财非常有兴趣，我也想通过这一系列的文章，给她分享她爸爸的理财成长经历。</p><p>这是本系列的第 1 篇，主题是每个人必须自己懂理财。</p><h2 id="我身边的案例"><a href="#我身边的案例" class="headerlink" title="我身边的案例"></a>我身边的案例</h2><p>我是 80 年代出生的，不得不说，我所处的是那个年代是缺乏理财和财商教育的。因此，我发现我身边的人大多不具备优秀的理财能力。</p><p>下面我举几个身边朋友的真实例子。</p><h3 id="朋友-A："><a href="#朋友-A：" class="headerlink" title="朋友 A："></a>朋友 A：</h3><p>他都把挣到的钱存银行定期或者余额宝。但是在现在这个年代，收益率是非常低的，只有一点几。但是他非常胆小，怕买其他的产品会导致亏损，所以说不敢碰。</p><h3 id="朋友-B："><a href="#朋友-B：" class="headerlink" title="朋友 B："></a>朋友 B：</h3><p>朋友 B 买了很多基金。但是他胆子很小，每个只买 1000 - 5000 块钱。然后账户里面有着几十只基金。既看不过来，也不知道应该如何操作。</p><p>唯一好的一面是：不管任何行业有行情，他都有一只基金命中。这让他的错失恐惧症（FOMO）小了很多。</p><h3 id="朋友-C："><a href="#朋友-C：" class="headerlink" title="朋友 C："></a>朋友 C：</h3><p>我这个朋友之前在快手上班，在 P2P 盛行的年代，把自己的所有积蓄都投在 P2P 上，最后爆雷，损失惨重。</p><h3 id="朋友-D："><a href="#朋友-D：" class="headerlink" title="朋友 D："></a>朋友 D：</h3><p>这个朋友通过另外一个朋友了解到有一个股票正在做庄阶段，未来会大涨，于是就听信买入，最后损失了 90%。</p><h3 id="朋友-E："><a href="#朋友-E：" class="headerlink" title="朋友 E："></a>朋友 E：</h3><p>朋友 E 的大学同学有一个在香港卖保险，于是听朋友的推荐在香港买了很多保险。但是过了 5 年，他发现收益率和最初承诺的相差非常大。这个时候看合同才发现，合同上写的收益测算并不保证。但是现在赎回的话，只能拿到非常少的本金，所以他只能继续硬着头皮每年交钱。</p><h2 id="只有理解才能有效持有"><a href="#只有理解才能有效持有" class="headerlink" title="只有理解才能有效持有"></a>只有理解才能有效持有</h2><p>听完上面几个朋友的故事，你身边有类似的朋友吗？</p><p>我跟一些朋友交流，我问他们，你们为什么不自己先学习投资理财的知识，之后再去做相关的操作呢？他们很多回答说，这个事情太专业了，专业的事情交给专业的人做就可以了。</p><p>当我反问他们：假如你买了一个专业人士管理的基金，那你对他的信仰来自于哪呢？你其实对他每个月发的报告并没有完全的判断能力，你只能选择相信他。</p><p>大多数时候，你其实相信的是他过去的业绩。如果它连续三年、连续五年一直都盈利，或者有超额收益，你就会持续持有它，甚至买入更多。</p><p>如果它连续几年亏损或者某一年大额亏损，你就会质疑它，甚至赎回它。</p><p>你的信心其实就是来源于过去的业绩表现。那这和散户的追涨杀跌有什么本质区别呢？</p><p>在你持仓持续下跌的那些时间，你能睡好觉吗？如果你不能理解它，那显然不能。</p><p>所以我说，每个人必须懂投资理财。</p><p>只有你深刻理解了你买入的是什么，才能在它下跌的时候有信心继续持有它，甚至抄底，才能睡得着觉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>每个人都必须懂理财。因为银行的定期存款利率太低，而其他理财产品都需要深刻理解，才可能做到长期持有。</p><p>另外，社会上充斥着像 P2P 一类的产品，以及宣传这类产品的巧舌如簧的销售。他们不断地诱惑着我们，如果我们没有辨识能力，也可能将自己辛苦一辈子挣到的钱损失掉。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;我打算系统性整理一下这几年投学习投资理财的心得。因为一方面通过总结，可以让自己进一步加深对投资的理解。另一方面我也想分享给同样想学习理财的读</summary>
      
    
    
    
    
    <category term="finance" scheme="https://blog.devtang.com/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：背包问题</title>
    <link href="https://blog.devtang.com/2026/01/11/pack-problem-of-dp/"/>
    <id>https://blog.devtang.com/2026/01/11/pack-problem-of-dp/</id>
    <published>2026-01-11T14:41:29.000Z</published>
    <updated>2026-01-17T16:18:22.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>背包问题是动态规划中的经典问题，也是 GESP 六级必考的知识点。其原理虽然需要花一些时间，但大多数孩子都能掌握，但是到了具体的题目时，因为背包问题变化较多，就不那么容易写出代码来。</p><p>本文将试图把背包问题的各种考法都列举出来，帮助大家巩固练习。</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题之所以叫这个名字，是因为其背景故事是：往一个容量有限的背包里面，放入一些物品。每个物品有不同的体积大小，所以会占用相应的背包的容量。物品不能被分割，所以要么整个放入背包中，要么不放入。我们需要找出放入背包的价值最大的方案。</p><p>举一个简单的例子，背包容量是 10L：</p><ul><li>物品 1：体积 7 L，价值 8</li><li>物品 2：体积 5 L，价值 5</li><li>物品 3：体积 4 L，价值 4</li></ul><p>虽然物品 1 的价值最大，价值&#x2F;体积(即单位体积的价值)也最大，但是因为放入物品 1 之后，剩余的空间 3L 无法再放入别的物品而浪费掉了。就不如不放物品 1，而放入物品 2 和物品 3 带来的总价值大。</p><p>由此我们也能看出，背包问题不能用简单的贪心来解决，而需要用动态规划。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>背包问题的转移方程可以被优化为一维，但为了方便理解，我们先看没有优化的版本。我们定义：</p><ul><li>每个元素的体积为 <code>a[i]</code>，价值为 <code>v[i]</code>。</li><li><code>dp[i][j]</code> 表示用前 i 个物品，放入容量为 j 的背包时，所能达到的最大价值</li></ul><p>那对于第 i 个物品，如果我们已经知道了前面的结果，那么我们有两种选择：</p><ul><li>不放入 第 i 个物品，这样 <code>dp[i][j] = dp[i-1][j]</code></li><li>放入 第 i 个物品，这样 <code>dp[i][j] = dp[i-1][j-a[i]] + v[i]</code></li></ul><p>而以上就是状态转移方程，我们在上面两种情况下取最优的情况：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i]] + v[i])</code> 。</p><p>另外我们需要考虑一下初始化的情况，即 <code>dp[0][1~n]</code> 应该怎么赋值。因为前 0 个物品什么都没选，那么价值肯定都是 0，所以让它们都等于 0 即可。</p><p>将以上逻辑写成代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j-a[i]&gt;=<span class="number">0</span>)</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-a[i]] + v[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为了保证 <code>j-a[i]</code> 的值为正，加了一个 if 来检查，保证没有下标越界的代码。如果下标越界，有可能会读取到随机值，也可能读取到非法地址，造成运行异常（Runtime Error）。</p><p>我们再用刚刚的例子来做一下表格演示：背包容量是 10L。</p><ul><li>物品 1：体积 7 L，价值 8</li><li>物品 2：体积 5 L，价值 5</li><li>物品 3：体积 4 L，价值 4</li></ul><p>经过转移方程的计算，最终，我们可以填出下面这个二维表格，表格中的每一项都计算出来了用前 i 个物品，体积为 j 时的最优化方案。这也是符合动态规划的最优子结构的特征。</p><img src="/images/pack-dp.jpg" class=""><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><p>所谓的 01 背包，就是指物品的数量只有 1 个，只有选与不选两种方案。刚刚的例子就是一个 01 背包的例子。</p><p>我们发现 <code>dp[i][j]</code> 只与两个值相关 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-a[i]]</code>，这样的二维数组利用的效率很低。所以，我们就想到，能不能把第 i 维省略掉，这样可以节省存储空间（但没有节省运算时间）。</p><p>压缩后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">10</span>; j &gt;= a[i]; --j) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j-a[i]] + v[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们注意到，j 的循环方式从正序变成了逆序。之所以要这么操作，读者可以用表格的方式，把正着循环的结果填一下就能明白。</p><p>如果 j 不是倒着循环，在一轮 j 的循环过程中，<code>dp[j]</code> 的值会在修改后，再一次被访问到，这样就会使得一个物品实际上已经计算了放入的价值，又被重复计算第二次。</p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>一个物品被多次重复放入和重复计算价值，其实是我们在完全背包问题中需要的效果。所以，刚刚的代码，如果我们把 j 正序循环，就是完全背包的代码，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = a[i]; j &lt;= <span class="number">10</span>; ++j) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j-a[i]] + v[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是为了方便理解，我们还是把完全背包的非压维代码也一并看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j-a[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-a[i]] + v[i]);</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][j-a[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为 <code>dp[i][j-a[i]] &gt;= dp[i-1][j-a[i]]</code>，所以以上代码可以省略成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j) &#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (j-a[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][j-a[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以记住这个写法，因为后面有一些题因为各种情况可能无法压维，就会需要这种写法。</p><p>我们还是用刚刚的例子来填写二维表格，背包容量是 10L。物品数量改为无限。</p><ul><li>物品 1：体积 7 L，价值 8</li><li>物品 2：体积 5 L，价值 5</li><li>物品 3：体积 4 L，价值 4</li></ul><p>以下是填写出来的值：</p><img src="/images/pack-dp-2.jpg" class=""><p>题目变为完全背包后，可以看到最后答案变了，最优方案变成了放入两个物品 2，得到最大价值 10。</p><p>学习完以上内容后，可以让学生练习以下两道题：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a></td><td>01 背包问题。NOIP2005 普及组第三题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药</a></td><td>完全背包问题</td></tr></tbody></table><p>以下是更多的背包基础练习题：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2871">P2871 Charm Bracelet S</a></td><td>01 背包, USACO 07 DEC</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日</a></td><td>01 背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1060">P1060 开心的金明</a></td><td>01 背包，NOIP 2006 普及组第二题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1049">P1049 装箱问题</a></td><td>01 背包，NOIP2001 普及组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2639">P2639 Bessie’s Weight Problem G</a></td><td>01 背包变型，容量与价值相同</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P13015">P13015 学习小组</a></td><td>完全背包，GESP 202506 六级</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P10721">P10721 计算得分</a></td><td>背包问题变种，GESP 202406 六级</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1926">P1926 小书童——刷题大军</a></td><td>01 背包，需拆成两个子问题</td></tr></tbody></table><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包描述了这样一种场景，一个物品将同时受两个限制条件的制约，例如：一个背包，即有体积限制，又有重量限制，让你往里放物品，求最大化物品价值的放法。</p><p><a href="https://www.luogu.com.cn/problem/P1794">P1794 装备运输</a> 就是多重背包的一道典型例题，在题目中，每件武器有体积和重量两个限制条件。</p><p>对于多重背包，我们同样用前 i 个物品来划分阶段：</p><ul><li><code>dp[i][j]</code> 表示 i 体积 j 重量下的最大火力。</li><li>转移方程：<code>dp[i][j] = max(dp[i][j], dp[i-v[k]][j-g[k]] + t[k]);</code></li></ul><p>同理，如果物品的数量是无限的，则正着 for，如果物品的数量是有限的，则倒着 for。</p><p><a href="https://www.luogu.com.cn/problem/P1794">P1794 装备运输</a> 的参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> V, G, N, dp[<span class="number">510</span>][<span class="number">510</span>], v[<span class="number">510</span>], g[<span class="number">510</span>], t[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; V &gt;&gt; G &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; t[i] &gt;&gt; v[i] &gt;&gt; g[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = V; i&gt;= v[k]; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = G; j &gt;= g[k]; j--)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-v[k]][j-g[k]] + t[k]);</span><br><span class="line">    cout &lt;&lt; dp[V][G];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 01 背包和完全背包想像成填一个一维的表格，那么多重背包就在填一个二维的表格。我们需要保证表格的填写过程符合动态规划的阶段性，表格总是从一个方向往另一个方向填，填过的数字不会再次被修改（在没压维的情况下），这样才能保证状态无后效性。</p><p>动态规划题目能够划分出清晰的阶段，后一个阶段只依赖于前面的阶段，问题就解决了一大部分。</p><p>可供练习的题目如下：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1794">P1794 装备运输</a></td><td>多重背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1910">P1910 L 国的战斗之间谍</a></td><td>多重背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1855">P1855 榨取kkksc03</a></td><td>多重背包</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2663">P2663 越越的组队</a></td><td>非多重背包的 DP</td></tr></tbody></table><h2 id="背包变型一：物品的相互依赖"><a href="#背包变型一：物品的相互依赖" class="headerlink" title="背包变型一：物品的相互依赖"></a>背包变型一：物品的相互依赖</h2><p><a href="https://www.luogu.com.cn/problem/P1064">P1064 金明的预算方案</a> 描述了一种背包问题的变型：在此题中，物品不是简单的 1 个或多个，而是分为主件或附件，每个主件可以有 0 个、1 个或 2 个附件。</p><p>应该如何表示这种复杂的物品关系呢？其实，我们可以把物品的每种组合都枚举出来，因为附件数量最多为 2 个，所以情况就可以枚举出以下情况：</p><ul><li>不选主件（当然也就没有附件）</li><li>选主件，不选附件</li><li>选主件+附件 1</li><li>选主件+附件 2</li><li>选主件+附件 1+附件 2</li></ul><p>于是，我们就可以在处理主件的时候，把以上几种情况都比较一下，选最优的方案。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;Node&gt; va;</span><br><span class="line">vector&lt;vector&lt;Node&gt; &gt; vb;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">40000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateDP</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i-m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i-m] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    va.<span class="built_in">resize</span>(m);</span><br><span class="line">    vb.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        Node node;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;node.m, &amp;node.w, &amp;node.t);</span><br><span class="line">        node.w = node.w*node.m; </span><br><span class="line">        va[i] = node;</span><br><span class="line">        <span class="keyword">if</span> (node.t != <span class="number">0</span>) &#123;</span><br><span class="line">            vb[node.t - <span class="number">1</span>].<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="comment">// 只处理主件，附件与主体一并处理</span></span><br><span class="line">        <span class="keyword">if</span> (va[i].t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// 选主件，不选附件</span></span><br><span class="line">                <span class="built_in">updateDP</span>(j, va[i].m,va[i].w);</span><br><span class="line">                <span class="comment">// 选主件+附件 1</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">0</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">0</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j, money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选主件+附件 2</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">1</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">1</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j , money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选主件+附件 1+附件 2</span></span><br><span class="line">                <span class="keyword">if</span> (vb[i].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> money = va[i].m + vb[i][<span class="number">0</span>].m + vb[i][<span class="number">1</span>].m;</span><br><span class="line">                    <span class="type">int</span> weight = va[i].w + vb[i][<span class="number">0</span>].w + vb[i][<span class="number">1</span>].w;</span><br><span class="line">                    <span class="built_in">updateDP</span>(j, money, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包变型二：求最小值"><a href="#背包变型二：求最小值" class="headerlink" title="背包变型二：求最小值"></a>背包变型二：求最小值</h2><p>有些时候，我们不是求背包能够装的物品的最大价值，而是求最小价值。例如 <a href="https://www.luogu.com.cn/problem/B3873">B3873 小杨买饮料</a> 这题，此题我们可以把饮料的容量当作背包的容量，把饮料的价格当作价值，但是此题相对于标准的背包问题有两个变化：</p><ul><li>1、题目希望求最小的费用，相当于背包所装的物品价值需要最低。</li><li>2、题目给定的背包容量不固定，而是“不低于 L”。</li></ul><p>针对以上的变化，我们的状态定义虽然不变，用 <code>dp[i][j]</code> 表示前 i 种饮料在 j 容量下的最小价值，但是状态转移变成了：<br><code>dp[i][j] = min(dp[i-1][j-l[i]] + c[i], dp[i-1][j])</code></p><p>在这种情况下，初始的第 0 种饮料什么都喝的值为 0，即：<code>dp[0][0] = 0</code>。</p><p>但是其它的值就不能设置成 0 了，如果设置成 0，那么任何情况下 <code>dp[i][j]</code>就已经是最小的值了，就不能被更新了。我们需要把 <code>dp[i][j]</code>默认的值设置成“无穷大”，这样才可能更新出有意义的值。</p><p>在设置无穷大这件事情上，有一个使用 memset 的技巧，即：<code>memset(dp, 0x7f, sizeof dp);</code>，此技巧将每个字节都填充成了二进制的 <code>01111111</code>（即 <code>0x7f</code>），因为最高为是符号位，所以保留成 0。这种 memset 技巧虽然初始化的值比 <code>INT_MAX</code> 略小一点，但是写起来更快，另外在进行加法运算的时候，也不用担心结果溢出成负数。</p><p>以上方案解决了变化一。我们再来看变化二。</p><p>变化二使得答案不一定在 <code>dp[i][L]</code>，因为答案不一定是刚好 L 升，所以要取 <code>L ~ L+max(l[i])</code> 这一段范围。这样就解决了变化二。</p><p>最后我们用滚动数组压维，然后因为是 01 背包（每个饮料只能选一次），我们压维之后需要倒着 for 循环背包大小。</p><p>以下是参考代码，代码中用 STL 的 <code>min_element</code> 来求最小值，读者也可以参考这种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 01 背包问题的变化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设第 i 种饮料的费用是 c[i], 容量是 l[i]</span></span><br><span class="line"><span class="comment"> * dp[i][j] 表示用前 i 种饮料，凑成 j 升的最小费用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 则，转移方程为：</span></span><br><span class="line"><span class="comment"> *  - dp[i][j] = min( dp[i-1][j-l[i]] + c[i] , dp[i-1][j] ) </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因为 i 只与 i-1 相关，所以这一层可以压缩。转移方式优化为：</span></span><br><span class="line"><span class="comment"> *  - dp[j] = min(dp[j- l[i]] + c[i], dp[j])</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 初使化：</span></span><br><span class="line"><span class="comment"> *  - dp[0] = 0;</span></span><br><span class="line"><span class="comment"> *  - dp[1-L] = memset(0x7f)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 其它：</span></span><br><span class="line"><span class="comment"> *  - 倒着 dp，因为每种饮料只能用一次</span></span><br><span class="line"><span class="comment"> *  - 最大值检查了一下，不会超 int，就不用 long long 了</span></span><br><span class="line"><span class="comment"> *  - 因为答案不一定是刚好 L 升，所以要取 L ~ L+max(l[i]) 这一段范围</span></span><br><span class="line"><span class="comment"> *  - 因为是取最小值，所以初使化设置成 0x7f7f7f7f（接近 21 亿，但是又没到 INT_MAX），</span></span><br><span class="line"><span class="comment"> *    这样运算不会超 int，又可以是较大值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010000</span>], c[<span class="number">550</span>], l[<span class="number">550</span>], N, L, maxL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; N &gt;&gt; L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; l[i];</span><br><span class="line">        maxL = <span class="built_in">max</span>(maxL, l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxL += L;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = maxL; j - l[i] &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j - l[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为答案不一定是刚好 L 升，所以要取 L ~ L+max(l[i]) 这一段范围</span></span><br><span class="line">    <span class="type">int</span> ans = *<span class="built_in">min_element</span>(dp+L, dp+maxL+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0x7f7f7f7f</span>) cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码虽然解决了问题，但是还有一点不完美，就是 dp 数组实在太大了。有没有可能 dp 数组更小呢？我们可以想到，因为每种饮料的价格都是正数，所以，如果有一个答案是超过 <code>2*L</code> 升的情况，同时它的价格极低，这种情况下，我们的答案就是只喝这一种饮料。不会出现超过 <code>2*L</code> 升，我们还叠加喝了两种饮料的情况。</p><p>我们可以反证：假如有一个答案是喝两种饮料，总容量超过 <code>2*L</code> 升，那么必定有一个饮料的容量是大于等于 L 升的。那么，我们只喝那个大于等于 L 升的饮料，肯定总价格更低。</p><p>所以，我们的优化方案就是：我们只需要把 dp 数组的大小开到 <code>2*L</code> 即 4000 即可（题目规定 L 最大为 2000）。在此优化方案下，我们再特判一下每个大于 L 升的饮料，看是不是更便宜。</p><p>以下是参考代码，时间和空间复杂度都更优：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">4100</span>], c[<span class="number">550</span>], l[<span class="number">550</span>], N, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; N &gt;&gt; L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">4000</span>; j - l[i] &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], dp[j - l[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = *<span class="built_in">min_element</span>(dp+L, dp+<span class="number">4000</span>);</span><br><span class="line">    <span class="comment">// 如果单个饮料就可以超 L，则判断一下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (l[i] &gt;= L) </span><br><span class="line">            ans = <span class="built_in">min</span>(ans, c[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0x7f7f7f7f</span>) cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：对于求最小值的背包问题，除了 <code>dp[0][0] = 0</code> 外，我们需要把别的初始值设置为 <code>0x7f</code>，以保证递推求 min 的过程中，每个 dp 数组值可以得到更新。</p><p>相关的练习题目还有：</p><ul><li><a href="https://www.luogu.com.cn/problem/P2918">P2918 Buying Hay S</a></li><li><a href="https://www.luogu.com.cn/problem/P1679">P1679 神奇的四次方数</a></li></ul><h2 id="背包变型三：求平均值"><a href="#背包变型三：求平均值" class="headerlink" title="背包变型三：求平均值"></a>背包变型三：求平均值</h2><p>有一类题，虽然看着不像是背包问题，但是最后可以抽象成背包问题。而且，他们背包大小都是 sum&#x2F;2。</p><p><a href="https://www.luogu.com.cn/problem/P2392">P2392 考前临时抱佛脚</a> 就是一道典型的例题。</p><p>在此题中，每一科的复习都可以看成两个并行的任务，而任务最短的时间就是让一个任务的时间尽可能接近 sum&#x2F;2。这样，我们就可以把 sum&#x2F;2 当成背包的容量，把每道题的价值和体积看成相等即可。</p><p>因为在本题中，sum 最大值为 <code>20*60 = 1200</code>，所以背包大小最大是 600 即可。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">此题可以用动态规划，也可以用搜索，因为每科只有最多 20 个题目，所以搜索空间最大是 2^20 等于约 100 万。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用动态规划解题时，此题可以把每次复习看作一次 01 背包的选择。每道题的价值和成本相同。背包的目标是尽可能接近 sum/2，因为sum 最大值为 `20*60 = 1200`，所以背包大小最大是 600。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>], v[<span class="number">25</span>], ans, dp[<span class="number">610</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpAns</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=v[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">max</span>(dp[m], cnt - dp[m]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, s, s+<span class="number">1</span>, s+<span class="number">2</span>, s+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, v+j);   </span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">dpAns</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的练习：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P12207">P12207 划分</a></td><td>01 背包的变型，蓝桥杯 2023 国</td></tr></tbody></table><h2 id="背包变型四：计数"><a href="#背包变型四：计数" class="headerlink" title="背包变型四：计数"></a>背包变型四：计数</h2><p>有一类背包问题，不是问你最大的价值，而是问你相关的计数。</p><p>例如：<a href="https://www.luogu.com.cn/problem/P1832">P1832 A+B Problem</a> 就是其中的典型例题。</p><p>要解此题，我们可以先把质数算出来保存下来，接下来，我们需要用背包的思路，对表格进行计数:</p><ul><li><code>dp[i][j]</code> 表示用前 i 个质数组成 j 一共的可能数</li><li>转移方程：<code>dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]] + dp[i-1][j-a[i]*2]...</code></li></ul><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法：</span></span><br><span class="line"><span class="comment"> *  - 无穷背包</span></span><br><span class="line"><span class="comment"> *  - 先把质数算出来，保存在数组里面</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * dp[i][j] 表示用前 i 个质数组成 j 一共的可能数</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]] + dp[i-1][j-a[i]*2]...</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 初始化：dp[0][0] = 1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：答案需要用 long long 保存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">200</span>][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i&lt;=a; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i)) </span><br><span class="line">            a[++a[<span class="number">0</span>]] = i;     </span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i) <span class="comment">// 第 i 个质数 a[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt;= n; ++j) &#123; <span class="comment">// 组成 j 这个值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = j; p &gt;= <span class="number">0</span>; p -= a[i]) &#123; <span class="comment">// 完全背包，试着放 0-n 个 a[i]</span></span><br><span class="line">                dp[i][j] += dp[i<span class="number">-1</span>][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[a[<span class="number">0</span>]][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包变型五：负数体积"><a href="#背包变型五：负数体积" class="headerlink" title="背包变型五：负数体积"></a>背包变型五：负数体积</h2><p>有一些题目，元素的体积会是负数。</p><p><a href="https://www.luogu.com.cn/problem/P13018">P13018 调味平衡</a> 就是一道典型的例题。它也是 GESP 202506 七级题目。</p><h3 id="第一种解法（空间占用过大）"><a href="#第一种解法（空间占用过大）" class="headerlink" title="第一种解法（空间占用过大）"></a>第一种解法（空间占用过大）</h3><p>用上面提到的计数类的方法。</p><p><code>dp[i][j][k]</code> 表示前 i 种食材，达到酸度 j，甜度 k 是否可能。</p><p><code>dp[i][j][k] = dp[i-1][j-a[i]][k-b[i]]</code> 是否可能。</p><p>把 i 这一层简化<code>dp[j][k] = dp[j - a[i]][k - b[i]]</code></p><p>初始化：<code>dp[0][0] = 1</code></p><p>但是以上的方法时间和空间消耗(500000x500000)太大。</p><h3 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h3><p>考虑到可以把一种食材的酸度和甜度求差，得出酸和甜的差值。如果两种食材的差值加起来为零，则刚好酸度&#x3D;甜度。</p><p>这样就可以把 dp 简化。</p><ul><li><code>dp[j]</code>表示前 i 种食材的酸甜度差值 j 是否存在，如果存在，其值为酸甜度的和。</li><li><code>dp[j] = dp[j - dif[i]] + a[i] + b[i]</code></li></ul><p>相当于背包元素的体积变成了差值，价值变成了 <code>a[i] + b[i]</code>。</p><p>因为 <code>dif[i]</code> 有正有负，所以为了保证值不会覆盖，我又恢复成二维的 dp：</p><ul><li><code>dp[i][j]</code> 表示前 i 种食物，凑成 j 的酸甜度差的最大和。</li></ul><p>因为 j 可能为负值，所以我们把平衡点设置成 50000（可以想像成刚开始差值就是 50000，求最后差值不变）</p><p>这样 j 中间最多从 50000 减成 0（因为每个食材差值最大为 500，最多有 100 个食材），所以不会变成负数。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN int(100*500+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][MAXN*<span class="number">2</span>], n, a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x8f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">50000</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        c = a-b;</span><br><span class="line">        d = a+b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">50000</span>*<span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (j-c &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-c] + d);    </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">50000</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关练习题目"><a href="#相关练习题目" class="headerlink" title="相关练习题目"></a>相关练习题目</h2><p>除了以上的变化，更多变化的练习：</p><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1510">P1510 精卫填海</a></td><td>01 背包，但是输出要求有变化</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2430">P2430 严酷的训练</a></td><td>01 背包，题目较长，需要仔细读题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P11377">P11377 武器购买</a></td><td>01 背包的变型，GESP202412 七级</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;背包问题是动态规划中的经典问题，也是 GESP 六级必考的知识点。其原理虽然需要花一些时间，但大多数孩子都能掌握，但是到了具体的题目时，因为</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>2025 年个人总结</title>
    <link href="https://blog.devtang.com/2026/01/01/2025-summary/"/>
    <id>https://blog.devtang.com/2026/01/01/2025-summary/</id>
    <published>2026-01-01T04:02:56.000Z</published>
    <updated>2026-01-01T15:51:57.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2025 年是艰难的一年，上半年玩教具业务同比下滑，下半年尝试了一些营销推广，业务量有所稳定，但是赢亏承压。最后一年下来，虽然没亏钱，但是也没挣到钱。好在团队在持续成长，每个岗位的人都比去年有了长足的进步和成长。</p><p>2025 年也立项了好几个新项目，这些项目会陆续在 2026 年上线。前面的播种会积累到 2026 年的收获，所以未来怎么样，还是挺值得期待的。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>25 年一共读了 8 本书，以下是读书笔记：</p><ul><li><a href="/2025/02/23/unconventional-success-book-summary/">个人投资的最佳实践 - 读《不落俗套的成功》</a></li><li><a href="/2025/03/08/read-demonds-book-summary/">读《真需求》</a></li><li><a href="/2025/09/17/how-to-trade-in-stocks-book-summary/">投机与趋势投资 - 读《股票大作手操盘术》</a></li><li><a href="/2025/10/06/the-rose-of-time-book-summary/">但斌投资札记-读《时间的玫瑰》</a></li><li><a href="/2025/10/06/the-illustrated-deepseek-book-summary/">理解大语言模型 - 读《图解 DeepSeek 技术》</a></li><li><a href="/2025/10/21/mcp-introduction/">理解 MCP -读《这就是 MCP》</a></li><li><a href="/2025/12/11/marketing-change/">和媒体共赢 - 读《广告的没落，公关的崛起》</a></li><li><a href="/2025/12/28/crazy-acid-book-summary/">读《疯狂的尿酸》</a></li></ul><p>其中 <a href="/2025/02/23/unconventional-success-book-summary/">《不落俗套的成功》</a> 和 <a href="/2025/12/11/marketing-change/">《广告的没落，公关的崛起》</a> 是我今年最喜欢的两本书，一本书指导我开始更多关注配置，另一本书指导我如何做品牌。</p><p>25 年还开始订阅了纸质版本的《三联生活周刊》，加上雪球 App 每个月给我寄月刊。所以整个 2025 年的阅读量还是不小的。</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>今年思考人生，总结了 4 篇文章：</p><ul><li><a href="/2025/06/22/build-your-own-dopamine-system/">构建你的“多巴胺”系统</a></li><li><a href="/2025/07/30/truth-does-not-matter/">真相不重要</a></li><li><a href="/2025/08/31/pay-your-information/">请为信息付费</a></li><li><a href="/2025/09/04/understand-insurance/">我理解的保险产品</a></li></ul><p>其中“多巴胺”系统那篇我自认为对我自己帮助最大，有效指导了我如何择友，如何工作，如何培养兴趣。</p><p>保险那篇文章，也让我理清了保险产品的购买思路，不再纠结要不要买保险，怎么买保险。</p><h2 id="编程教学"><a href="#编程教学" class="headerlink" title="编程教学"></a>编程教学</h2><p>今年继续在教小朋友编程，关于编程竞赛，今年又总结了如下文章：</p><ul><li><a href="/2025/01/05/cspj-notes-of-greedy-algorithm/">CSPJ 教学思考：贪心算法</a></li><li><a href="/2025/01/05/teaching-notes-of-dp/">CSPJ 教学思考：动态规划</a></li><li><a href="/2025/01/25/teaching-notes-of-binary-search/">CSPJ 教学思考：二分查找</a></li><li><a href="/2025/02/09/teaching-notes-of-union-query-set/">CSPJ 教学思考：并查集</a></li><li><a href="/2025/03/29/teaching-notes-of-simulation/">CSPJ 教学思考：模拟</a></li><li><a href="/2025/04/06/teaching-notes-of-brute-force/">CSPJ 教学思考：枚举</a></li><li><a href="/2025/04/12/cspj-notes-of-math-problems/">CSPJ 教学思考：数学题</a></li><li><a href="/2025/04/12/cspj-notes-of-stl/">CSPJ 教学总结：STL</a></li><li><a href="/2025/04/13/teaching-notes-of-dfs/">CSPJ 教学总结：深度优先搜索（DFS）</a></li><li><a href="/2025/04/26/teaching-notes-of-bit/">CSPJ 教学总结：树状数组</a></li><li><a href="/2025/06/06/gesp-notes/">GESP 核心考点</a></li></ul><p>加上去年写的三篇，内容越来越丰富了：</p><ul><li><a href="/2024/09/17/cspj-introduction/">五分钟弄懂 CSP-J</a></li><li><a href="/2024/11/07/teach-notes-of-for-loop/">CSPJ 教学思考：for 循环</a></li><li><a href="/2024/12/15/bfs-teaching-notes/">CSPJ 教学思考：宽度优先搜索</a></li></ul><h2 id="财务"><a href="#财务" class="headerlink" title="财务"></a>财务</h2><p>2025 是财务收获的一年。</p><ul><li>首先是年初公司允许大家出让期权，于是我卖了一些期权，补充了一些现金流。</li><li>2025 年初赶个 Deepseek 横空出世，整个港股大涨，我刚好又在那个时候有一些港币，配置了一些港股资产，于是买中了恒生高股息率，比亚迪，工商银行等股票，原来持有的腾讯也大涨。</li><li>A 股这边，之前配置的建平从亏损变成浮盈；之前配置的 500 指数增强产品一下子也有 40% 的涨幅。</li><li>美股也不用说，标普和纳指继续涨，考虑到已经浮盈很多，我在 12 月将仓位全部清空了。</li><li>2025 年一直在定投黄金，最后也成功在一个相对低位（均价 700 多）配置了一定比例的黄金，现在也有 20% 的涨幅。</li></ul><p>当然，2025 年配置的新能源组合也亏很多，特别是理想汽车，有 -30% 多的亏损。</p><p>更详细的业绩总结如下：</p><ul><li>港股：<ul><li>腾讯（00700），成本 374，现价 599，+60%</li><li>恒生高股息率（03110）<ul><li>第一笔：成本 23，现价 30，+30%</li><li>第二笔：成本 31，现价 30，-2%</li></ul></li><li>工商银行，买入 5.4，卖出 6.07，含分红赢利约 15%</li><li>新能源组合：<ul><li>理想汽车，-30%</li><li>小鹏汽车，-4%</li><li>小米，1%</li><li>比亚迪，7%</li></ul></li></ul></li><li>美股：<ul><li>标普和纳指均清仓，整体收益约 10%</li></ul></li><li>私募<ul><li>500 指增，+44%</li><li>建平远航，+72%</li></ul></li><li>A 股<ul><li>招商银行，+11%</li><li>红利 ETF 组合，+2%</li><li>恒生科技 ETF，-6%</li></ul></li><li>黄金：<ul><li>成本 795，现价 1071，+34%</li></ul></li></ul><h2 id="尝鲜"><a href="#尝鲜" class="headerlink" title="尝鲜"></a>尝鲜</h2><h3 id="24-小时血糖仪"><a href="#24-小时血糖仪" class="headerlink" title="24 小时血糖仪"></a>24 小时血糖仪</h3><p>今年戴了两次 24 小时的血糖仪，每次佩戴 14 天。我整体感觉很受用，它可以监测到不同食物和运动对血糖的影响。</p><p>然后我理解了两个事情：</p><ul><li>一个是我之前饭后犯困，我大概也猜到是晕碳，现在戴上之后明显就能确认是这个原因。而且我尝试调整饮食之后，因为血糖上升慢，就不犯困了。</li><li>第二就是理解了饭后散步和遛弯为什么重要，对比饭后坐着和散步的血糖走势，我一下子就发现散步对降血糖的意义了。所以饭后走个 10 来分钟其实对身体的帮助是很大的。</li></ul><p>另外这东西还有一个好处，就是会促进我轻度运动。我现在天气好的时候会尽量骑车上下班，因为这样我的血糖走势会很漂亮。</p><p>另外，我对比不同时段吃同样的水果对血糖的影响，明显餐后的影响更小，如下图：</p><img src="/images/xietang.jpg" class=""><p>我也总结了一些吃饭顺序的经验：</p><ul><li>同样吃一颗橙子，餐前和餐后血糖上升速度和峰值差异很大。优先餐后吃水果，不要空腹吃。</li><li>同样是吃饭，先吃蔬菜和后吃蔬菜升血糖速度也差别很大。先吃蔬菜，最后吃碳水。</li><li>面食对血糖的提升是迅速的，少吃为妙。</li></ul><h3 id="3D打印和建模"><a href="#3D打印和建模" class="headerlink" title="3D打印和建模"></a>3D打印和建模</h3><p>公司因为需要，采购了拓竹的 3D 打印机，于是我有一段时间就很痴迷它。拓竹真的是国货之光，把原来只能极客使用的 3D 打印机做成了可以普及的消费品的品质，一些配平等复杂设置都不需要人工介入，机器自动就能完成。</p><p>我顺便还在<a href="https://www.tinkercad.com/dashboard">Tinkercad</a> 上学习了建模，然后利用自己学到的建模知识，帮老婆做了一个定制款的精油瓶。它主要可以完美适配我们家的桌面，并且做得很紧凑，可以放更多的瓶子。最后我买了一种松木质感的耗材，这样放在桌子上也很搭。</p><p>以下是设计稿截图：</p><img src="/images/2025-anniversary-2.jpg" class=""><p>以下是效果：</p><img src="/images/tinkercad-1.jpg" class=""><h3 id="骑车"><a href="#骑车" class="headerlink" title="骑车"></a>骑车</h3><p>今年狠狠地试了一下骑行，但是没有花钱买装备。一方面是因为我的运动量不大，频率不高；另一方面也是希望想骑的时候可以随时骑，想放弃的时候就可以放弃，没有任何压力，共享单车月卡在这方面还是挺方便的。</p><p>最狠的一次，我花了周末一个下午绕三环骑了一圈（下图，一共 50 公里）。不过冬天骑行的体验不佳，已经断了有一个月了，希望天气暖和之后可以继续骑起来。</p><img src="/images/2025-anniversary-4.jpg" width="300px" /><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><h3 id="新疆"><a href="#新疆" class="headerlink" title="新疆"></a>新疆</h3><p>五一去了新疆，很值得去的一个地方。我们租了一辆理想 L8，驰骋在满是风力发电站的草原上，感觉非常放松。</p><img src="/images/2025-anniversary-5.jpg" class=""><h3 id="希腊"><a href="#希腊" class="headerlink" title="希腊"></a>希腊</h3><p>暑假去了希腊。</p><ul><li>欧洲的衰败让人感叹时代和周期的变化，当地有很多没人住的空置房（下图：我们下榻酒店附近的一处空置房）。<img src="/images/2025-anniversary-3.jpg" class=""></li><li>猫咪在希腊很受人待见，大街和公园上有很多猫咪。<img src="/images/2025-anniversary.jpg" class=""></li><li>在希腊吃了几天各种西餐之后，最后父母还是忍不住选择中餐，结果我们就把希腊的中餐馆吃了个遍。希腊的物价在欧洲相对低，一个菜大概 80 元人民币左右。</li><li>在希腊我也租了一辆车，是一辆 9 座的现代混动 Staria MPV，也非常好开。我们还乘坐渡轮（下图）把车运到了扎金索斯岛，在岛上放松了好几天。<img src="/images/2025-anniversary-6.jpg" class=""></li></ul><h3 id="沈阳"><a href="#沈阳" class="headerlink" title="沈阳"></a>沈阳</h3><p>十一去了沈阳，就一个感受，物价实在太低太低，锅包肉大概 20 多块钱。租了一辆比亚迪的宋 Pro 混动，油耗特别低，每百公里油耗大概只有 4L。下图是我实际驾驶的数据，因为这辆车只能慢充，所以我一直在亏电情况下行驶，并没有充过电。</p><img src="/images/2025-anniversary-7.jpg" class=""><p>这也让我明白了比亚迪为什么出海那么厉害，这么低的油耗在能源较贵的欧洲，其实很有市场。</p><h2 id="25-年的目标回顾"><a href="#25-年的目标回顾" class="headerlink" title="25 年的目标回顾"></a>25 年的目标回顾</h2><ul><li>工作：硬件稳中有增，图书赢亏打正。带好图书业务。<ul><li>❎ 硬件既不稳，也不增。</li><li>✅ 图书实际达成 60 分吧。图书赢亏基本打正了，但是要说有多好，还完全谈不上。</li></ul></li><li>理财：做好配置，找到能拿 10 年的标的，并能坚定持有。<ul><li>✅ 配置工作基本完成。先拿两年看看，看自己拿不拿得住。</li></ul></li><li>个人：读 6 本书。编程教学继续累进。<ul><li>✅ 最后读了 8 本书。编程教学写了 11 篇总结。</li></ul></li></ul><h2 id="26-年的目标"><a href="#26-年的目标" class="headerlink" title="26 年的目标"></a>26 年的目标</h2><ul><li>工作：<ul><li>产品：今年种下的花，期待 26 年结果。AI 硬件拿到一些认知。</li><li>运营：实践<a href="/2025/12/11/marketing-change/">《广告的没落，公关的崛起》</a>。</li></ul></li><li>理财：<ul><li>不折腾，配置+再平衡。</li></ul></li><li>个人：<ul><li>读 6 本书。</li><li>俯卧撑能连续做 20 个。</li><li>骑车绕四环一圈。</li></ul></li></ul><h2 id="个人-Milestone"><a href="#个人-Milestone" class="headerlink" title="个人 Milestone"></a>个人 Milestone</h2><p>好象没啥特别能说的，如果非要有什么，就是产出了 <a href="/2025/06/22/build-your-own-dopamine-system/">《构建你的“多巴胺”系统》</a> 这篇文章吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h2&gt;&lt;p&gt;2025 年是艰难的一年，上半年玩教具业务同比下滑，下半年尝试了一些营销推广，业务量有所稳定，但是赢亏承压。最后一年下来，虽然没亏钱，但是也</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="anniversary" scheme="https://blog.devtang.com/tags/anniversary/"/>
    
  </entry>
  
  <entry>
    <title>读《疯狂的尿酸》</title>
    <link href="https://blog.devtang.com/2025/12/28/crazy-acid-book-summary/"/>
    <id>https://blog.devtang.com/2025/12/28/crazy-acid-book-summary/</id>
    <published>2025-12-28T06:14:26.000Z</published>
    <updated>2025-12-28T10:24:13.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/36591951/">《疯狂的尿酸》</a>是一本关于健康的科普书，来自于美国医学博士：戴维·珀尔马特，他是一位畅销书作家，写过《谷物大脑》和《菌群大脑》。</p><h2 id="什么是尿酸"><a href="#什么是尿酸" class="headerlink" title="什么是尿酸"></a>什么是尿酸</h2><p>正常人体中的尿酸，2&#x2F;3 是内源性的。尿酸是嘌呤的代谢产物，而嘌呤是细胞的重要组成部分，可以用来合成 DNA 和 RNA，人类的细胞因为不停地在分裂和衰老，死亡的细胞在被处理的时候就会产生尿酸。</p><p>另外 1&#x2F;3 的尿酸来自于外部摄入的食物，包括动物内脏，海鲜，啤酒等。</p><p>果糖是一种特别的糖，它虽然不会造成血糖上升，但是会在代谢的时候产生尿酸。</p><h2 id="尿酸会促进脂肪的产生"><a href="#尿酸会促进脂肪的产生" class="headerlink" title="尿酸会促进脂肪的产生"></a>尿酸会促进脂肪的产生</h2><p>因为高尿酸与肥胖相关性很高，为了研究他们之间的因果关系，人们发现了“尿酸氧化酶”。这是一种存在于大多数动物体内的酶，能够迅速将尿酸排出体外，但是我们的人类祖先在几百万年的进化过程中，产生这个酶的基因被破坏了，变成了“假基因”。这就使得我们人类血液中的尿酸含量是其他哺乳动物的 3-10 倍。</p><p>当远古时代的人类吃下果糖后，果糖会在代谢过程中产生尿酸，而尿酸会打开人体的“脂肪开关”，帮助人体把果糖转化为脂肪。“从水果到脂肪”的生理机制帮助古代的灵长类动物能够度过漫长的、食物匮乏的冬天。</p><h2 id="果糖"><a href="#果糖" class="headerlink" title="果糖"></a>果糖</h2><p>果糖是所有天然的碳水化合物中最甜的一种，天然的果糖只存在于水果和蜂蜜中，所以人类摄入得很少。而且水果中富含膳食纤维，可以延缓果糖被吸收的速度；而水果中富含的维生素 C 还有降低尿酸及促进尿酸排出的功能，所以吃水果对果糖的提升是很低的，代谢产生的尿酸也很少。</p><p>纯葡萄糖和果糖都是单糖（糖的最简单形式），而蔗糖是葡萄糖和果糖的组合，是一种双糖（两个分子连接在一起）。蔗糖进入人体后在小肠被分解，释放果糖和葡萄糖，然后被吸收。</p><p>果葡糖浆是一种以果糖为主的糖浆制品，果糖占比约 55%，葡萄糖占比 42%。最早是 1957 年由美国生物化学家 理查德·O 马歇尔 和 厄尔·R 科伊 生产出来，他们创造了一种酶，可以通过化学方法使玉米糖浆中的葡萄糖的结构重新排列，将其转化为果糖。</p><p>果葡糖浆从 20 世纪 70 年代开始流行，主要是因为其甜度比蔗糖高，价格又比蔗糖低，所以逐渐取代了蔗糖。到了 1984 年，可口可乐和百事可乐也都把各自品牌的饮料从添加蔗糖改为添加果葡糖浆。</p><p>果糖的升糖指数是所有天然糖中最低的，这意味着它不会直接导致血糖升高，也就不会刺激胰岛素的分泌，所以在一段时间内，人们把果糖视为一种“更安全”和“健康”的糖。但后来人们发现，相比于葡萄糖参与能量生成，果糖则参与能量储存，所以更容易让人肥胖。</p><h2 id="果糖的代谢过程"><a href="#果糖的代谢过程" class="headerlink" title="果糖的代谢过程"></a>果糖的代谢过程</h2><p>果糖和葡萄糖除了一些化学键不同，其他结构几乎完全一样。然后，正是这微小的差异使得它们的代谢过程完全不同。</p><p>葡萄糖代谢的第一步（葡萄糖的磷酸化）是在葡萄糖激酶催化下分解，分解所释放的 ATP 也会在细胞中维持稳定的水平。ATP（三磷酸腺苷）是人体能量的来源。</p><p>果糖的代谢与葡萄糖完全不同。果糖在进入人体后，会迅速被血液吸收，然后被运输到肝脏中进行代谢。在肝细胞内，果糖激酶会开始工作，做出包括消耗 ATP 在内的一系列事情。果糖会消耗 ATP 的过程会带来一些下游效应，它会导致血液中的尿酸水平快速上升。由于果糖消耗了 ATP，细胞会发出信号：我们的能量快用完了。这会促使身体减缓新陈代谢以减少静息能量消耗。</p><p>除了消耗能量外，果糖还会触发脂肪的生成过程：肝脏中的果糖代谢会直接导致脂肪的产生：主要是以甘油三酯的形式存在，这是人体中最常见的脂肪存在形式。</p><h2 id="AMP-活化蛋白激酶"><a href="#AMP-活化蛋白激酶" class="headerlink" title="AMP 活化蛋白激酶"></a>AMP 活化蛋白激酶</h2><p>AMP 活化蛋白激酶被激活时，它会向你的身体发出“狩猎状况良好”（即食物充足）的信号，你的身体就会让自己从储存脂肪转换为燃烧脂肪，帮助身体保持良好的狩猎状态。</p><p>AMP 活化蛋白激酶还可以帮助身体减少葡萄糖生成。二甲双胍就利用了这一点来实现降血糖。</p><p>与AMP 活化蛋白激酶对应的，还有一种让身体储存脂肪的酶，叫做腺苷单磷酸脱氨酶 2。动物在准备冬眠的时候，就会激活腺苷单磷酸脱氨酶 2 用于储存脂肪；在冬眠的时候，则切换到AMP 活化蛋白激酶用于燃烧脂肪。</p><p>而果糖代谢过程产生的尿酸，就是这两种酶的调节剂，尿酸能够抑制AMP 活化蛋白激酶，同时激活腺苷单磷酸脱氨酶 2 。</p><h2 id="断食"><a href="#断食" class="headerlink" title="断食"></a>断食</h2><p>作者推荐大家可以尝试 24 小时的断食，即：24 小时内不吃任何东西，且大量饮水。如果正在服用药物，务必继续服用。</p><p>我也见过一种 16：8 的轻断食方法：即 16 小时断食，8 小时进食。通常时间设置为中午 12 点-下午 8 点，或者上午 10 点到晚 6 点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本书主要揭示了果糖和尿酸在人体代谢中的核心原理，让我们更加关注饮食和内分泌的健康。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/36591951/&quot;&gt;《疯狂的尿酸》&lt;/a&gt;是一本关于健康的科普书，来自于美国医学博士：戴维·珀尔马特，他是一位畅销书作家，写过《谷物大脑》和《菌群大脑》。&lt;/p&gt;
&lt;h2 id=&quot;什么是尿酸</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>和媒体共赢 - 读《广告的没落，公关的崛起》</title>
    <link href="https://blog.devtang.com/2025/12/11/marketing-change/"/>
    <id>https://blog.devtang.com/2025/12/11/marketing-change/</id>
    <published>2025-12-11T13:20:47.000Z</published>
    <updated>2025-12-11T14:25:42.665Z</updated>
    
    <content type="html"><![CDATA[<p>最近读完了《定位》作者艾·里斯的另一本书《广告的没落，公关的崛起》，记录一些心得。</p><h2 id="广告的没落"><a href="#广告的没落" class="headerlink" title="广告的没落"></a>广告的没落</h2><blockquote><p>当一个广告让消费者意识到是广告时，广告的效果就会大打折扣。</p></blockquote><p>我记得当年脑白金就把广告做成报纸的新闻报道形式，以此来让大家误以为是报纸在宣传脑白金的功效。但现在广告的监管越来越严，这种擦边的广告越来越难通过审核。</p><blockquote><p>广告追求创意，但消费者购买的是产品。</p></blockquote><p>如果一个产品广告很有创意，但是产品本身很普通。另一个广告很普通，但是产品本身很好。大家还是更可能购买后者。</p><p>广告追求创意和讨论，但是真正到了决策环节，影响决策的还是产品本身的心智，而不是广告创意。</p><p>产品的创意（创新）比广告的创意更重要。</p><blockquote><p>品牌是潜在顾客心智中的一个认知。</p></blockquote><p>广告很难进入消费者的心智。</p><p>相比于广告，公关（具体指通过媒体等第三方途径，间接讲述你的故事）更有可信度，也更有传播性。</p><p>消费者在试图评估一个品牌的时候，更倾向从朋友、亲戚，还有权威网站上获得信息，而不是广告。</p><h2 id="公关的崛起"><a href="#公关的崛起" class="headerlink" title="公关的崛起"></a>公关的崛起</h2><p>因为广告很难进入消费者心智，那么就应该更多通过公关来建立品牌。在通过公关建立品牌后，可以把广告作为维护品牌的工具。</p><p>书中结合各种品牌案例，提到了一些技巧。</p><p>技巧一：为媒体传播而设计，包括提前透露消息、新的品类&#x2F;品牌名称、可信度的发言人。书中的案例是 Segway 平衡车。</p><p>技巧二：成为争议话题。案例是红牛（某些成份被禁，激发年轻人尝试的好奇心）。</p><p>技巧三：创意。为品牌增加一些东西，引起讨论。</p><p>技巧四：从小媒体入手。没人比媒体更多地浏览媒体。案例是《定位》一书，该书刚开始只在一个小媒体中被报道，但后来被《华尔街日报》发现，跟进了报道。</p><h2 id="我的一些感受"><a href="#我的一些感受" class="headerlink" title="我的一些感受"></a>我的一些感受</h2><p>看完本书之后，我刚好刷到一位媒体记者在微博上吐槽小米的公关（如下图）。但是我却从这段话中，看到小米在努力让自己的任何商业行为都成为公关传播的话题。在公关这件事情上，小米做得是非常优秀的。</p><img src="/images/xiaomi_pr.jpg" class=""><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近读完了《定位》作者艾·里斯的另一本书《广告的没落，公关的崛起》，记录一些心得。&lt;/p&gt;
&lt;h2 id=&quot;广告的没落&quot;&gt;&lt;a href=&quot;#广告的没落&quot; class=&quot;headerlink&quot; title=&quot;广告的没落&quot;&gt;&lt;/a&gt;广告的没落&lt;/h2&gt;&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>理解 MCP -读《这就是 MCP》</title>
    <link href="https://blog.devtang.com/2025/10/21/mcp-introduction/"/>
    <id>https://blog.devtang.com/2025/10/21/mcp-introduction/</id>
    <published>2025-10-21T00:36:13.000Z</published>
    <updated>2025-10-21T00:41:49.196Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/mcp-book.jpg" class=""><h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>最近读完了一本讲解 MCP 实现原理的书：<a href="https://book.douban.com/subject/37441660/">《这就是 MCP》</a>，它帮助我更好地理解了 MCP，以下是一些笔记。</p><h2 id="二、什么是-MCP"><a href="#二、什么是-MCP" class="headerlink" title="二、什么是 MCP"></a>二、什么是 MCP</h2><p>MCP 的全称是 Model Context Protocol，之所以叫这个名字，是因为它可以成为大模型调用外部工具的协议，让大模型能够补充自己的上下文（即 Context）。</p><p>在没有 MCP 之前，每个大模型都在为自己扩展调用外部工具的能力，最常见的能力就是调用搜索引擎。但是这就会造成一个麻烦：每个大模型都需要自己开发一遍调用工具（重复造轮子），而且由于协议不开放，第三方开发者无法为大模型提供更多工具。</p><p>在有了 MCP 之后，整个开发流程变成了：</p><ul><li>大模型都适配 MCP 协议</li><li>各种工具都适配 MCP 协议</li></ul><p>这样，一个新的工具出来，立刻可以为所有大模型可用，而一个新的大模型也可以立刻调用市面上公开的 MCP（下图）。</p><img src="/images/mcp-book-1.jpg" class=""><p>有人把这个比作 <strong>“AI 时代的 HTTP 协议”</strong>，我是比较认同的。</p><h2 id="三、MCP-的实现细节"><a href="#三、MCP-的实现细节" class="headerlink" title="三、MCP 的实现细节"></a>三、MCP 的实现细节</h2><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1 角色"></a>3.1 角色</h3><p>不同于 HTTP协议的浏览器 &#x2F; 服务器（B&#x2F;S）架构，MCP 的协议多了一个 “主机” 的角色，一共包含三个角色，分别是：主机，客户端，服务器。</p><p>主机：创建和管理多个客户端。负责鉴权相关工作。负责多个客户端内容的聚合，</p><p>客户端：一个客户端是一个进程，负责与对应的 MCP 服务器交互数据，管理会话的状态。</p><p>服务器：为客户端提供服务。可以部署成本地服务或远程服务。</p><h3 id="3-2-协议"><a href="#3-2-协议" class="headerlink" title="3.2 协议"></a>3.2 协议</h3><p>MCP 使用 JSON-RPC 作为客户端与服务器通信的基础。</p><p>当服务器部署在本地的时候，它允许客户端用 stdio 的方式来传输 JSON 编码的数据。</p><p>当服务器部署在远程的时候，它使用 HTTP 来传输 JSON。</p><p>鉴权方面， 基于 stdio 传输实现的服务器直接从环境变量中读取授权凭证，而基于 HTTP 协议的服务器，基于 OAuth 2.1 实现授权。</p><h2 id="四、如何开发-MCP"><a href="#四、如何开发-MCP" class="headerlink" title="四、如何开发 MCP"></a>四、如何开发 MCP</h2><p>开发 SDK：MCP 支持任意语言开发 MCP 服务器，我们可以使用官方提供的 SDK 快速生成代码框架。</p><p>调试工具：官方提供的调试工具名为 MCP Inspector，用它连接对应 MCP 之后就可以在面板中调试功能。</p><p>发布 MCP：我们可以把开发好的服务发布到 MCP 市场上面供开发者检索到。</p><p>MCP 市场。市面上比较有名的市场包括：</p><ul><li>Anthropic 官方的 <a href="https://github.com/modelcontextprotocol/servers">MCP Servers 仓库</a></li><li><a href="https://smithery.ai/">Smithery</a></li><li><a href="https://glama.ai/">Glama</a></li></ul><h2 id="五、MCP-的问题"><a href="#五、MCP-的问题" class="headerlink" title="五、MCP 的问题"></a>五、MCP 的问题</h2><p>MCP 发布才一年时间，所以还有很多细节未来需要完善，包括：</p><ul><li>协议对多模态内容支持不够友好</li><li>鉴权机制不完善，很多 MCP 服务还未支持 25 年 3 月引入的 OAuth 鉴权协议</li><li>安全防护能力弱。攻击者可以构造恶意的 MCP 服务来诱导用户执行恶意命令，从而实现信息窃取，执行恶意命令等攻击。</li></ul><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/mcp-book.jpg&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;一、序言&quot;&gt;&lt;a href=&quot;#一、序言&quot; class=&quot;headerlink&quot; title=&quot;一、序言&quot;&gt;&lt;/a&gt;一、序言&lt;/h2&gt;&lt;p&gt;最近读完了一本讲解 MCP 实现原理的</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>斑马思维机的详细调研</title>
    <link href="https://blog.devtang.com/2025/10/09/zebra-logic-introduction/"/>
    <id>https://blog.devtang.com/2025/10/09/zebra-logic-introduction/</id>
    <published>2025-10-09T09:39:07.000Z</published>
    <updated>2026-01-17T06:57:30.850Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文档创建于 2025.3，最后更新于 2026.1</p></blockquote><h2 id="一、产品介绍"><a href="#一、产品介绍" class="headerlink" title="一、产品介绍"></a>一、产品介绍</h2><img src="/images/zebra-logic.jpg" class=""><p>斑马思维机是针对 2-8 岁儿童的全科启蒙学习机。由在线教育集团“猿辅导”旗下的斑马品牌在 2022 年 11 月<a href="https://tech.cnr.cn/techph/20221102/t20221102_526049239.shtml" title="斑马思维机 G1 发布时间">推向市场</a>，并在 2023 年 8 月升级为<a href="https://www.sohu.com/a/708327102_104421" title="斑马思维机 G2 发布时间">二代产品</a>：斑马思维机 G2。</p><p>它包含语文、思维、英语、音乐等学科内容，通过纸质的题卡结合点触交互的形式，让孩子在不同情景主题场景下互动，通过互动答题的形式，完成内容的教学。插卡自动出题，孩子通过点触答题。答对有鼓励，答错会有提醒，孩子可以自主完成从插卡到答题的整个过程。</p><p>相比别的早教学习机，斑马思维机的核心特点是没有传统的屏幕。它用纸质题卡来完成学习交互，在完成学习的同时可以有效保护低幼孩子的眼睛，防止过早接触电子屏幕产生沉迷。</p><p>产品上线后累计销量突破 100 万台，2023 年和 2024 年连续两年<a href="https://www.pingwest.com/a/295205" title="销量第一报道">全国销量第一</a>。</p><p>斑马思维机主要具备如下产品优势：</p><h3 id="1、专业教研"><a href="#1、专业教研" class="headerlink" title="1、专业教研"></a>1、专业教研</h3><p>团队邀请了三位行业专家共同参与内容研发，分别是：</p><ul><li>曹立宏教授：中国传媒大学的脑科学专家。</li><li>刘嘉教授：清华大学心理学专家。同时也是“最强大脑”节目的科学总顾问。</li><li>蔡可教授：首都师范大学教育学专家。同时也是语文新课标的制定者。</li></ul><img src="/images/zebra-logic-professior.jpg" class=""><p>在以上专家参与的同时，斑马结合自己斑马 AI 学产品的 3000 万用户的 100 亿次线上作答数据，为题卡的编制提供大数据支撑。</p><img src="/images/zebra-logic-big-data.jpg" class=""><p>斑马思维机题卡构建了科学合理的分级进阶体系，分设 S0、S1、S2、S3 4 个难度级别。这种设置充分考虑了 2-8 岁儿童不同阶段的认知水平和思维发展能力。题卡难度逐阶递增、螺旋上升，能够循序渐进地开发儿童大脑潜能。</p><h3 id="2、纸屏护眼"><a href="#2、纸屏护眼" class="headerlink" title="2、纸屏护眼"></a>2、纸屏护眼</h3><p>不同于传统有屏幕的学习机，斑马思维机通过插卡+点触的方式来学习，可以有效减少孩子接触电子屏幕的时间，防止孩子过早接触屏幕，影响视力。</p><p>每张题卡上都有丰富的主题元素，帮助孩子建立起学习的兴趣。</p><p>每张纸质题卡都用了食品级白卡和大豆油墨印刷，保证对孩子安全。</p><h3 id="3、全科启蒙"><a href="#3、全科启蒙" class="headerlink" title="3、全科启蒙"></a>3、全科启蒙</h3><p>斑马思维机的题卡包含语文、思维、英语三大核心题卡，相关的内容体系分为 S0、S1、S2、S3 4 个难度级别，且难度分级科学合理，充分满足不同年龄段孩子的学习需求。其中：</p><table><thead><tr><th>级别</th><th>针对年龄</th><th>培养重点</th></tr></thead><tbody><tr><td>S0</td><td>2-3</td><td>习惯养成</td></tr><tr><td>S1</td><td>3-4</td><td>兴趣培养</td></tr><tr><td>S2</td><td>4-5</td><td>知识积累</td></tr><tr><td>S3</td><td>5+</td><td>应用拓展</td></tr></tbody></table><h3 id="4、无限扩展"><a href="#4、无限扩展" class="headerlink" title="4、无限扩展"></a>4、无限扩展</h3><p>斑马思维机的题卡支持无限扩展，随着产品研发不断的持续，斑马思维机在语文、思维、英语题卡的基础上，又逐步上新了迪士尼、鲨鱼宝宝、音乐、专注力、故官等主题题卡。其中：</p><ul><li><p>2023 年 12 月，与迪士尼官方合作上新<a href="https://mp.weixin.qq.com/s/Xw8ZZTkyYbyEWV9Mprexxw" title="迪士尼题卡上新">迪士尼题卡</a>。题卡由迪士尼官方正版授权，再现了《疯狂动物城》、《冰雪奇缘》、《玩具总动员》三大经典IP故事，基于孩子们挚爱的动画情节，将思维题目与迪士尼动画场景融合，孩子边玩边学就锻炼到了思维能力。</p></li><li><p>2024 年 7 月，与“打开故宫”合作上新<a href="https://mp.weixin.qq.com/s/IH0bYh6Kc3EDmOLG9B01IQ" title="故宫题卡上新">故宫题卡</a>。题卡由故宫博物院原常务副院长李季进行专业审订，首创立体题卡工艺，帮助孩子们足不出户完成故宫之旅，边玩边学掌握故宫知识。</p></li><li><p>2024 年 10 月，与 Pinkfong 联名推出<a href="https://mp.weixin.qq.com/s/8iccodBc4bBtgpYvJwco5w" title="鲨鱼宝宝题卡上新">鲨鱼宝宝题卡</a>。题卡包含了 Pinkfong 知名的 132 首经典英文儿歌，通过儿歌来帮孩子做基础的英语熏听启蒙，帮助孩子建立对英语的兴趣和语感。其中的儿歌 《Baby shark》为全球播放量第一的儿歌（<a href="https://www.guinnessworldrecords.cn/world-records/95003-most-viewed-video-online" title="吉尼斯世界记录认证">吉尼斯世界记录认证</a>）。</p></li><li><p>2024 年 12 月，推出<a href="https://mp.weixin.qq.com/s/-7zKKelat820h6fTou0tnA" title="音乐题卡上新">音乐题卡</a>。内容包括 38 组乐理知识、52 种乐器探索、16 种音乐文化和 48 首儿歌鉴赏，帮助孩子完成音乐启蒙。</p></li><li><p>2025 年 2 月，推出<a href="https://mp.weixin.qq.com/s/K-DXuWVNia6crk9S5bEQOg" title="专注力题卡上新">专注力题卡</a>，通过趣味游戏的形式，从注意广度、注意转移、注意分配、注意稳定性 4 个方面对孩子的专注力进行深度训练。</p></li><li><p>2025 年 6 月，推出<a href="https://mp.weixin.qq.com/s/BQSXvImVBJJc0KJITLt_Gg" title="好朋友题卡介绍">好朋友题卡</a>，通过小朋友间的竞争与协作，把思维训练变成小朋友之间玩乐游戏。</p></li><li><p>2025 年 10 月，推出<a href="https://mp.weixin.qq.com/s/RduBk7Znfp5Qi4Rnk8nk-w" title="小猪佩奇题卡上新">小猪佩奇题卡</a>，通过趣味的场景化游戏和小猪佩奇榜样的力量，培养孩子的“生活自理能力”、“自我保护能力”、“社会适应能力” 三大自主能力。</p></li></ul><h2 id="二、内容体系"><a href="#二、内容体系" class="headerlink" title="二、内容体系"></a>二、内容体系</h2><h3 id="语文"><a href="#语文" class="headerlink" title="语文"></a>语文</h3><p>斑马思维机语文题卡共 265 张，包括 6 个知识模块：汉字、词语、成语常言、古诗歌谣、表达结构、国学常识。另外在 S3 级别中，额外增加了拼音专题。</p><table><thead><tr><th>知识模块</th><th>内容量</th></tr></thead><tbody><tr><td>识字</td><td>372字，情景交互式学习，一页学 1-3 个字</td></tr><tr><td>成语</td><td>81 个</td></tr><tr><td>日常表达</td><td>36 个</td></tr><tr><td>古诗</td><td>72 首</td></tr><tr><td>传统文化</td><td>36 个</td></tr><tr><td>歌谣</td><td>12 首</td></tr><tr><td>拼音</td><td>12 张卡，认识+认读</td></tr></tbody></table><h3 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h3><p>斑马思维机思维题卡共 241 张，包括 6 个知识模块：视听与记忆、数感与模型、图形与空间、逻辑与规律、实践与规划、动手与益智。</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>斑马思维机英语题卡共 265 张，包括 5 个知识模块：字母与发音、单词、句型、儿歌、拓展应用。</p><table><thead><tr><th>知识模块</th><th>内容量</th></tr></thead><tbody><tr><td>字母认知</td><td>26 个字母</td></tr><tr><td>自然拼读</td><td>30 个自然拼词规则</td></tr><tr><td>核心词汇</td><td>518 个词汇</td></tr><tr><td>日常表达</td><td>78 组句型表达</td></tr><tr><td>韵律儿歌</td><td>48 首经典儿歌</td></tr><tr><td>拓展应用-开口</td><td>36 个日常情景应用</td></tr></tbody></table><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>音乐题卡共 72 张，内容包括 38 组乐理知识、52 种乐器探索、16 种音乐文化和 48 首儿歌鉴赏，帮助孩子完成音乐启蒙。</p><h3 id="专注力"><a href="#专注力" class="headerlink" title="专注力"></a>专注力</h3><p>专注力题卡共 72 张，内容从注意广度、注意转移、注意分配、注意稳定性 4 个方面对孩子的专注力进行深度训练。</p><h3 id="鲨鱼宝宝题卡"><a href="#鲨鱼宝宝题卡" class="headerlink" title="鲨鱼宝宝题卡"></a>鲨鱼宝宝题卡</h3><p>鲨鱼宝宝共 36 张，题卡包含了 Pinkfong 知名的 132 首经典英文儿歌。通过儿歌共熏听了 1400+ 单词，包含了 81% 的小学新课标二级核心词汇。</p><h3 id="小猪佩奇题卡"><a href="#小猪佩奇题卡" class="headerlink" title="小猪佩奇题卡"></a>小猪佩奇题卡</h3><p>小猪佩奇题卡共 32 张，题卡包含了“生活自理能力”、“自我保护能力”、“社会适应能力” 三大自主能力。其中：</p><ul><li>生活自理能力包括：生活习惯、生活技能、行为习惯。</li><li>自我保护能力包括：健康认知、健康防护、安全意识。</li><li>社会适应能力包括：情绪管理、沟通表达、同伴交往。</li></ul><h2 id="市场表现与竞争分析"><a href="#市场表现与竞争分析" class="headerlink" title="市场表现与竞争分析"></a>市场表现与竞争分析</h2><h3 id="竞争壁垒"><a href="#竞争壁垒" class="headerlink" title="竞争壁垒"></a>竞争壁垒</h3><p>斑马思维机为思维机品类开创者，拥有 6 项思维机专利和 11 项国际大奖（数据更新至 2025.12）。</p><p>斑马思维机专利情况：</p><table><thead><tr><th>专利名称</th><th>专利公告</th></tr></thead><tbody><tr><td>机器专利1</td><td><a href="http://epub.cnipa.gov.cn/cred/CN219533902U">http://epub.cnipa.gov.cn/cred/CN219533902U</a></td></tr><tr><td>机器专利2</td><td><a href="http://epub.cnipa.gov.cn/cred/CN219609810U">http://epub.cnipa.gov.cn/cred/CN219609810U</a></td></tr><tr><td>结构专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN219831980U">http://epub.cnipa.gov.cn/cred/CN219831980U</a></td></tr><tr><td>外观专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN307609057S">http://epub.cnipa.gov.cn/cred/CN307609057S</a></td></tr><tr><td>立体题卡专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN221766203U">http://epub.cnipa.gov.cn/cred/CN221766203U</a></td></tr><tr><td>滑动交互专利</td><td><a href="http://epub.cnipa.gov.cn/cred/CN221613415U">http://epub.cnipa.gov.cn/cred/CN221613415U</a></td></tr></tbody></table><p>斑马思维机获奖情况：</p><table><thead><tr><th>奖项名</th><th>奖项名</th><th>获奖证书</th><th>获奖年份</th></tr></thead><tbody><tr><td>Tillywig Toy Awards</td><td>堤利威格玩具奖，美国玩具行业最顶级的奖项之一</td><td><a href="/images/zebra-tillywig.jpg" title="斑马思维机 堤利威格玩具奖 证书">证书</a></td><td>2023 年</td></tr><tr><td>Creative Child Awards</td><td>儿童创意大奖，儿童创造力培养领域享有盛誉的国际大奖</td><td><a href="/images/zebra-cca-award.jpg" title="斑马思维机 儿童创意大奖 官网截图">证明</a></td><td>2023 年</td></tr><tr><td>K Design Award</td><td>K设计大奖，享誉全球的国际专业设计大奖</td><td><a href="https://blog.devtang.com/images/zebra-K-design.jpg" title="斑马思维机 K-design 获奖证书">证书</a></td><td>2023 年</td></tr><tr><td>Mom’s Choice Awards</td><td>妈妈之选奖，国际母婴产品领域标杆奖项</td><td><a href="/images/zebra-mom-choice.jpg" title="斑马思维机 Mom choice 获奖证书">证书</a></td><td>2023 年</td></tr><tr><td>The National Parenting Center Seal of Approval</td><td>美国国家育儿中心专业认证</td><td><a href="/images/zebra-npc.jpg" title="斑马思维机 美国国家育儿中心专业认证 证书">证书</a></td><td>2023 年</td></tr><tr><td>Contemporary Good Design Award</td><td>当代好设计奖</td><td><a href="/images/zebra-good-design.jpg" title="斑马思维机 当代好设计 获奖证书">证书</a></td><td>2023 年</td></tr><tr><td>TOY AWARD</td><td>中外玩具大奖</td><td><a href="/images/zebra-toy-award.jpeg" title="斑马思维机 中外玩具大奖 证书">证书</a></td><td>2023 年</td></tr><tr><td>IDEA</td><td>国际卓越设计奖</td><td><a href="/images/zebra-idea.jpg" title="斑马思维机 IDEA 获奖证书">证书</a></td><td>2024 年</td></tr><tr><td>LONDON Design Awards</td><td>伦敦设计奖</td><td><a href="/images/zebra-london-design.jpg" title="斑马思维机 伦敦设计奖 证书">证书</a></td><td>2025 年</td></tr><tr><td>MUSE Design Awards</td><td>缪斯设计大奖</td><td><a href="/images/zebra-muse.jpg" title="斑马思维机 缪斯设计奖 证书">证书</a></td><td>2025 年</td></tr><tr><td>Goldreed Industrial Design Award</td><td>金芦苇工业设计奖</td><td><a href="/images/zebra-goldreed.jpg" title="斑马思维机 金芦苇工业设计奖 证书">证书</a></td><td>2025 年</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>以上专利和奖项为斑马思维机提供了不少竞争优势，帮助它持续提升产品端的用户体验。</p><h3 id="市场销量"><a href="#市场销量" class="headerlink" title="市场销量"></a>市场销量</h3><p>上市以来，斑马思维机市场销量表现出色，受到众多家长青睐。在各大电商平台，其销售数据持续增长，斑马思维机连续两年稳居思维机品类的销量和销售额第一。</p><ul><li><p>据<a href="/images/top-sell-2023.jpg" title="2023 销量第一">《洛图科技_中国思维机线上零售市场月度数据追踪报告》</a>显示，2023 年 1 月至 2024 年 3 月，斑马思维机在线上京东、天猫、抖音三大电商合计市场中销量排名第一，份额达到 52.8%; 销额排名第一，份额达到 66.8%。</p></li><li><p>据<a href="/images/top-sell-2024.jpg" title="2024 销量第一">《洛图科技_中国思维机线上零售市场月度数据追踪报告》</a>显示，2024 年 1 月至 2024 年 12 月，斑马思维机在线上京东、天猫、科音三大电商合计市场中销量排名第一，份额达到 66.6%; 销额排名第一，份额达到 72.9% 。</p></li><li><p>据<a href="/images/top-sell-2025.jpg" title="2025 销量第一">《洛图科技_中国思维机线上零售市场月度数据追踪报告》</a>显示，2025 年 1 月至 2025 年 12 月，斑马思维机在线上京东、天猫、科音三大电商合计市场中销量排名第一，份额达到 57.1%; 销额排名第一，份额达到 63.8% 。</p></li></ul><p>由以上数据可知，斑马思维机的市场占有率连续三年处于思维机品类市场第一的地位。</p><ul><li>在京东平台提供的思维机热卖榜：<ul><li>2025 年 3 月<a href="/images/top-sell-jd-2025-3.jpg" title="2025.3 京东思维机热卖榜">思维机热卖榜</a>，斑马思维机连续占据榜首 131 天</li><li>2025 年 12 月<a href="/images/top-sell-jd-2025-12.jpg" title="2025.12 京东思维机热卖榜">思维机热卖榜</a>，斑马思维机连续占据榜首 179 天</li></ul></li><li>在天猫平台提供的 2025 年<a href="/images/top-sell-tm-2025-3.jpg" title="2025 天猫学习机热卖榜">学习机热卖榜</a>上，斑马思维机占据 2000 元以下学习机热卖榜第一（数据截至 2025.03.09 ）。</li></ul><h3 id="同类思维机产品比较"><a href="#同类思维机产品比较" class="headerlink" title="同类思维机产品比较"></a>同类思维机产品比较</h3><p>斑马思维机的主要竞争产品为学而思旗下的摩比思维机（又名：学而思思维机）。斑马思维机和摩比思维机哪个好呢？以下是一些多维度的比较数据。</p><h4 id="1、发布时间"><a href="#1、发布时间" class="headerlink" title="1、发布时间"></a>1、发布时间</h4><p>从发布时间上看，斑马思维机较早，具有较大的先发优势：</p><ul><li>斑马思维机 G1 在 2022 年 11 月<a href="https://tech.cnr.cn/techph/20221102/t20221102_526049239.shtml" title="斑马思维机 G1 发布时间">正式发布</a>，而摩比思维机<a href="https://www.sohu.com/a/677896840_361784" title="摩比思维机一代发布">正式发布</a>的时间为 2023 年 5 月，落后斑马思维机 6 个月。</li><li>斑马思维机随后在 2023 年 8 月发布<a href="https://www.sohu.com/a/708327102_104421" title="斑马思维机 G2 发布时间">二代机型</a>，而摩比思维机的二代机型同样落后半年多，在 2024 年 4 月<a href="https://www.163.com/dy/article/J0RQ3CNM0536W4EI.html" title="摩比思维机二代发布">发布</a>。</li></ul><p>较早的发布使斑马获得了更多的销量，并从销量中获得了更多的用户反馈，也积累了更多的用户迭代数据。这些数据和反馈帮助斑马思维机做到了更好的产品体验。用户普遍反馈斑马思维机点触灵敏；而摩比思维机点触通常不太灵敏，孩子点不准容易受到挫折，从而打击学习积极性。所以，从机器点触灵敏度角度，更推荐大家使用斑马思维机。</p><h4 id="2、题卡设置"><a href="#2、题卡设置" class="headerlink" title="2、题卡设置"></a>2、题卡设置</h4><p>斑马思维机的题卡设置结合了心理学、脑科学、教育学的专家经验和 3000 万孩子的行为大数据，难度设置更加科学合理，孩子不容易受到挫折。</p><p>摩比思维机因为是后来追赶者，所以在题卡研发上更加追求速度，所以在内容体系上大多选择别的品牌合作的形式，以加快内容研发速度。摩比在语文题卡上与“四五快读”<a href="https://www.sohu.com/a/707989347_112831" title="摩比四五快读题卡">合作</a>，在英语题卡上与“剑桥英语”及“RAZ”合作，低龄题卡与小猪佩奇合作。</p><p>但是合作的形式使得摩比的题卡体系性和衔接性较差。例如：</p><ul><li><p>斑马的语文分为 S0-S4 4 个级别，难度螺旋上升，对各个年龄段的孩子都很适配。摩比的语文因为“四五快读”只有识字，所以无法分级，只能提供识字包、古词包、拼音包这种专题形式。同时“四五快读”的趣味性较低，不太适合 2-4 岁的孩子启蒙，降低了低龄孩子家长的好感度和选购意愿。</p></li><li><p>斑马的英语为全美式发音体系，符合小学新课标要求。但是摩比的英语题卡分为英式发音的<a href="https://zhuanlan.zhihu.com/p/662313624" title="摩比剑桥英语题卡">“剑桥英语”系列</a>和美式发音的“RAZ”系列。两个系列混合提供不利于孩子建立标准的英语发音环境，家长会担心孩子练成既不英式也不美式的奇怪发音。</p></li><li><p>IP 合作方面，斑马和摩比都与迪士尼、小猪佩奇有合作。除此之外，斑马与鲨鱼宝宝、故宫还有联名合作。</p></li></ul><p>所以，相对来说斑马思维机的题卡更受大部分的家长和孩子的喜爱。</p><h4 id="3、硬件配置"><a href="#3、硬件配置" class="headerlink" title="3、硬件配置"></a>3、硬件配置</h4><p>两者都是 Type-C 口的充电款机器。</p><ul><li>斑马思维机的机器重量为 400g，较为轻便，方便携带，无需联网即可使用。</li><li>摩比思维机的机器重量为 500g，较为厚实，需要下载 App 连接 Wifi 才可激活使用。</li></ul><p>在升级时，斑马思维机通过 U 盘升级，摩比思维机通过连接 Wifi 升级。</p><h4 id="4、销量排名"><a href="#4、销量排名" class="headerlink" title="4、销量排名"></a>4、销量排名</h4><p>据<a href="/images/top-sell-2024.jpg" title="2024 销量第一">公开数据</a>，斑马思维机在 2023-2025 年连续三年销量排名第一。其它思维机销量排名未知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文档创建于 2025.3，最后更新于 2026.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、产品介绍&quot;&gt;&lt;a href=&quot;#一、产品介绍&quot; class=&quot;headerlink&quot; title=&quot;一、产品介绍&quot;&gt;&lt;/a&gt;一、产品介绍&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解大语言模型 - 读《图解 DeepSeek 技术》</title>
    <link href="https://blog.devtang.com/2025/10/06/the-illustrated-deepseek-book-summary/"/>
    <id>https://blog.devtang.com/2025/10/06/the-illustrated-deepseek-book-summary/</id>
    <published>2025-10-06T14:06:51.000Z</published>
    <updated>2025-10-06T15:05:58.035Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/deepseek-0.jpg" width="300px" /><p>最近收到图灵编辑刘美英老师赠送的<a href="https://book.douban.com/subject/37425385/">《图解 DeepSeek 技术》</a>，全书只有不到 100 页，而且配套了大量插画，让原本让人生畏的大语言模型底层技术，变得不那么难懂。</p><p>本书非常适合对于大语言模型零基础的读者，作为入门书籍。以下是我的一些笔记。</p><h2 id="缩放定律（Scaling-law）"><a href="#缩放定律（Scaling-law）" class="headerlink" title="缩放定律（Scaling law）"></a>缩放定律（Scaling law）</h2><p>深度学习的底层原理其实缺乏科学论证，最终只能用“涌现”这种现象来描述我们观察到的实验结果。这个实验结果就是：当我们提高模型规模的时候，模型的表现也会越来越好。</p><p>于是，我们通过三个要素来提升模型的规模，分别是：参数量、数据量和计算量（如下图）</p><img src="/images/deepseek-1.jpg" class=""><p>我对“涌现”的理解：这个世界上很多事情都是从量变到质变，大模型“涌现”出来的智能，再一次体现了这种自然界常见的现象。比如：</p><ul><li>水在温度上升的时候，形态一直是液态，直到上升了 100 度，就开始沸腾，转化为气态。</li><li>股市，前期积累的泡沫越来越大，最后泡沫破灭的时候，就会一下子跌特别多。</li></ul><p>我对缩放定律的理解：缩放定律在自然界中也非常常见，很多变化不是线性的，而是幂律（power law）的。比如：</p><ul><li>财富的集中度。在美国前 10% 的人持有超过 90% 的财富。</li><li>公司的营收排名。排名每上升一名，营收可能是下一名的 2 倍。</li><li>明星或达人的收入。关注度每上升一位，收入可能翻翻。</li><li>28 原理。决定一件事情的最主要的 20% 因素，占据了 80% 的权重。</li></ul><h2 id="深度思考"><a href="#深度思考" class="headerlink" title="深度思考"></a>深度思考</h2><p>缩放定律把大家的精力都集中在堆参数量和堆算力上，但是研究人员发现，如果让模型在输出答案的过程中进行“长思考”，答案会变得显著得好。于是，除了在训练阶段发力外，我们通过让模型在生成答案时消耗更多资源，来提升答案的质量。这就是现在变得普遍的“深度思考”模式（如下图）。</p><img src="/images/deepseek-2.jpg" class=""><p>在我的理解下，深度思考模式类似于《思考快与慢》一书中提到的人类的慢思考。人类大多数时候，是用直觉来决策的，因为这样效率最高，而且直觉通常来源于大量的经验（预训练），通常情况下是对的。但是，对于一些重大的决策，人类就会启动慢思考（深度思考），会花大量的时间和精力来论证自己的想法是否正确，以保证重大决策的质量。</p><h2 id="蒸馏（Distill）"><a href="#蒸馏（Distill）" class="headerlink" title="蒸馏（Distill）"></a>蒸馏（Distill）</h2><p>DeepSeek-R1 是一个拥有 6710 亿个参数的庞大模型，这使得部署和使用它都需要强大的硬件支持。但是 DeepSeek 创新性的开创了将自己的推理能力蒸馏到别的小模型（比如 <a href="https://huggingface.co/deepseek-ai/DeepSeek-R1-Distill-Qwen-32B">Qwen-32B</a>）上的方法。</p><p>具体来说，研究团队用 DeepSeek 当老师模型，让 Qwen 当学生模型。当两个模型接收到相同的提示词后，均需要输出一个词元概率分布。在训练过程中，学生模型需要紧密跟随老师模型的分布特征（如下图）。</p><img src="/images/deepseek-3.jpg" class=""><p>以上过程在 80 万个样本的训练下，这些小模型学会了 DeepSeek 的思维方式，与蒸馏前相比，能力有大幅的提升。</p><p>在我的理解下，这也非常类似人类的“师徒学习模式”。我在计算机行业，我们行业的毕业生刚进企业的时候，都会有一个导师（mentor）进行一对一指导。最终帮助我们这些职场小白快速融入行业，写出高质量的代码。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/deepseek-0.jpg&quot; width=&quot;300px&quot; /&gt;

&lt;p&gt;最近收到图灵编辑刘美英老师赠送的&lt;a href=&quot;https://book.douban.com/subject/37425385/&quot;&gt;《图解 DeepSeek 技术》&lt;</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>但斌投资札记-读《时间的玫瑰》</title>
    <link href="https://blog.devtang.com/2025/10/06/the-rose-of-time-book-summary/"/>
    <id>https://blog.devtang.com/2025/10/06/the-rose-of-time-book-summary/</id>
    <published>2025-10-06T12:00:26.000Z</published>
    <updated>2025-10-06T12:46:03.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>想读一些价值投资者的书，于是就找到了这本但斌的《时间的玫瑰》。这是一本写于 2018 年的书，现在已经过了 7 年。当年的很多论断，随着时间的检验会更有意思。以下是一些读书感悟。</p><h3 id="买入价格很重要"><a href="#买入价格很重要" class="headerlink" title="买入价格很重要"></a>买入价格很重要</h3><p>我们常说，买股票需要关注三点：好公司，好管理，好价格。在好价格这件事情上，但斌给我们举了一个例子，也是他自己血泪教训。</p><p>但斌说：如果你在 2007 年的高点买入茅台，那么需要 2016 年（9 年后）才能解套。中间还会经历两次 60% 的下跌。所以，即便是大家公认的好公司，如果你的买入价格不对，也是有很大的风险。</p><h3 id="关注行业周期"><a href="#关注行业周期" class="headerlink" title="关注行业周期"></a>关注行业周期</h3><p>但斌的这本书写在 7 年前，在 7 前年，有一些行业龙头公司是被价值投资者普遍认同的，比如房地产行业的万科，以及教育行业的好未来，但斌在书中多次提到这两家公司。但是我们现在来看这两家公司，就会发现两家公司都经历了价值毁灭的过程，他们都从最高点回撤了超过 80% 。</p><p>万科股价：</p><img src="/images/wanke.jpg" class=""><p>好未来股价：</p><img src="/images/haoweilai.jpg" class=""><p>回撤的背后，是房地产行业和教育行业整体的低迷带来的。即便是三好学生，如果在一个下坡路的行业，也是做不出什么好成绩的。</p><p>关注行业的周期，关注政策的变化，在合适的时候卖出，这也是《股票大作手操盘术》中我很认同的趋势投资观点，在本书中，我再次感受到趋势投资的重要性。</p><h3 id="从分歧中学习"><a href="#从分歧中学习" class="headerlink" title="从分歧中学习"></a>从分歧中学习</h3><p>但斌在书中提到他参加伯克希尔股东大会的一段记录：一个来自旧金山的 17 岁少年问：成为一个好的投资者的最好方法是什么？</p><p>巴菲特回答说：尽可能多地阅读。你要把各种思想装进你的脑子里，随着时间的推移，分辨出哪些是合理的。一旦你做到这样了，你就该下水实践了。</p><p>我对此也有很强的认同。学习的第一步是尽量吸收信息，而阅读是一个很好地吸收高质量信息的渠道。当然，我也认为与人交流讨论，以及观察现场同样重要，这都是获得信息多样性的重要手段。</p><p>有了信息之后，通过思考和实践来分辨信息，最终把有效的信息沉淀下来，就能成为自己的宝贵经验。</p><p>我对获取信息的方法最近还有一个新的感悟，就是“反对性”的意见相对重要，因为人会自我强化自己的观点，所以对于反对观点容易忽视。这个时候，我们应该刻意去找反对性意见，在理解反对性意见的基础上，去解释为什么观点不一样。</p><p>反对意见在投资上，也代表着市场的分歧，如果我们能够理解正反两边的观点的同时，又能够看到未来正反观点的分歧消除点，那么就可能获得巨大的收益。</p><p>之前我想要获得分歧意见非常难，因为表达反对意见通常让人感觉尴尬。现在我有一个技巧：我会问大模型，让他帮我系统性地总结反对意见以及论证理由，这对我来说非常好用，分享给大家。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;想读一些价值投资者的书，于是就找到了这本但斌的《时间的玫瑰》。这是一本写于 2018 年的书，现在已经过了 7 年。当年的很多论断，随着时间的检验会</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>投机与趋势投资 - 读《股票大作手操盘术》</title>
    <link href="https://blog.devtang.com/2025/09/17/how-to-trade-in-stocks-book-summary/"/>
    <id>https://blog.devtang.com/2025/09/17/how-to-trade-in-stocks-book-summary/</id>
    <published>2025-09-17T13:27:01.000Z</published>
    <updated>2025-09-17T13:41:00.293Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/stock-trade-book-0.jpg" width="300px" /><p>上个月见了一个老朋友：代码家。和代码家聊天的时候，他提到了趋势交易，他还推荐了<a href="https://book.douban.com/subject/19952930/">《股票大作手操盘术》</a>。</p><p>该书的核心思想就是做趋势交易。具体做法是：在形成趋势前观望，在趋势确定建立后顺着趋势做空或做多，在趋势快要结束时，提前补仓或卖出。</p><p>我觉得该思想同样适用于长线操作：每家公司都有上升期和平稳期以及下降期。在公司上升期的时候加仓，平稳期的后期卖出，避免下降期的戴维斯双杀，会是非常重要的。</p><p>举例来说：</p><ul><li><p>房地产公司的上升期投资，相关的股票，即便是恒大，也涨很多。只要你在合适的地方卖出，你就不会亏。</p></li><li><p>很多互联网公司的企业，在互联网泡沫期的估值很高。比如微博，哔哩哔哩，陌陌，包括粉笔公考，猿辅导。只要你在合适的地方卖出，也可以吃到很多的时代红利。但是如果你一直秉持长期持有，就可能不挣钱或者只挣很少的钱。</p></li></ul><p>以下是微博的股价走势，现在的价格（12）比发行价（20）还低，但它曾经涨了 5 倍多。</p><img src="/images/stock-trade-book-1.jpg" class=""><p>以下是哔哩哔哩的股价走势，如果你买在高点，那么会亏 80%。</p><img src="/images/stock-trade-book-2.jpg" class=""><p>以上两个公司就是典型的“互联网”红利公司，在互联网红利期拥有巨大的股价泡沫，在红利结束的时候，股价回归理性。</p><p>我感觉趋势投资不是做短线的投机，而是把握时代的大势。做时代周期（5 年左右）的波段，抓时代红利企业，但是又很冷静，知道自己是投机，能看到卖出下车的时间点。</p><p>我们如果能够在互联网红利期，提前买入微博和哔哩哔哩这样的高用户量的产品。在红利结束前卖掉。我们假设卖在离最高点回撤 50% 的地方，也会有 2-4 倍的收益，整个持股周期在 2-3 年。</p><p>但说起来容易，执行起来还是挺困难的。比如下面是陌陌的走势，2014 年上市，2017 年股价才开始上涨，2018, 2019年均在年中大幅上涨，之后又回到 2017 年的价格。再之后就一路下跌，现在的价格是发行价的一半。</p><img src="/images/stock-trade-book-3.jpg" class=""><p>此书对我最大的价值，就是对价值投资与时代红利周期有了挂钩，之后在思考和判断公司的时候，除了思考价值层面的事情外，更应该思考时代的变化与周期。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/stock-trade-book-0.jpg&quot; width=&quot;300px&quot; /&gt;

&lt;p&gt;上个月见了一个老朋友：代码家。和代码家聊天的时候，他提到了趋势交易，他还推荐了&lt;a href=&quot;https://book.douban.com/subje</summary>
      
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/categories/summary/"/>
    
    
    <category term="books" scheme="https://blog.devtang.com/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>我理解的保险产品</title>
    <link href="https://blog.devtang.com/2025/09/04/understand-insurance/"/>
    <id>https://blog.devtang.com/2025/09/04/understand-insurance/</id>
    <published>2025-09-04T14:45:05.000Z</published>
    <updated>2025-12-01T14:51:12.006Z</updated>
    
    <content type="html"><![CDATA[<p>首先申明：<u> <strong>本文不是广告，也不推荐任何保险产品</strong> </u>。</p><p>我之前一直不理解保险，最近借助一些资料，终于想明白了各种保险的价值，给大家分享一下。</p><p>保险其实分很多种，我们需要分开理解它的用途。</p><h2 id="一、意外险"><a href="#一、意外险" class="headerlink" title="一、意外险"></a>一、意外险</h2><p>意外险是杠杆最高的保险。每年大概几百块钱，就可以保上百万的保额。因为对于大部分人来说，这个事情发生的概率极低，所以它的杠杆很高。</p><p>意外险的价值是给家庭或者父母留下一笔财富。特别适合家里面负责挣钱的那个顶梁柱买，这样可以应对极端概率情况下的风险。</p><p>很多人会想：这么低的概率，有必要买吗？有可能一辈子都遇不到意外。</p><p>我们在考虑这种保险的时候，要有 <strong>“平行宇宙”</strong>思维。即：我们要假设这个世界是量子态的，同时有许多平行宇宙，意外险是为众多平行宇宙中的某一个 “我” 的意外买单。这样，那一个平行宇宙里面的倒霉的 “我”，被另外平行宇宙中的 “我” 的保费接济，获得了极大的补偿。</p><p>我们不知道我们身处在哪个平行宇宙。所以意外险保证了我们在每个平行宇宙过得都不算太差，最倒霉的那个 “我”，也用保险给家庭留了一大笔钱。</p><h2 id="二、医疗险"><a href="#二、医疗险" class="headerlink" title="二、医疗险"></a>二、医疗险</h2><p>医疗险大多数报销门诊或者住院时候的大额费用。一般这种保险都有起付金额（比如超过 1 万部分）。</p><p>这种医疗险的费用也很低，一年也是几百块钱就可以买到。这种保险其实也是杠杆率很高的保险，因为大部分年轻人不太会超过起付金额。</p><p>医疗险和意外险类似，也是保障极端情况，比如如果一个突发疾病住院要花 10 来万，这个保险就可以报销大部分，让家庭不至于因病返贫。</p><h2 id="三、高端医疗险"><a href="#三、高端医疗险" class="headerlink" title="三、高端医疗险"></a>三、高端医疗险</h2><p>高端医疗险一般一年费用得好几千，是普通医疗险的 10 倍。大概率高端医疗险是很难从期望上 “回本” 的，而且很多疑难杂症，可能公立的三甲医院医生更有临床经验（因为他们看的病例更多）。</p><p><strong>购买高端医疗险更多可以看成是一种 “消费”</strong>。因为你得任何小病都可以享受非常好的看病体验，不用担心看个感冒花几千块钱（是的，和睦家看个感冒几千块钱很正常）。</p><h2 id="四、分红险"><a href="#四、分红险" class="headerlink" title="四、分红险"></a>四、分红险</h2><p>分红险在我看来已经脱离了保险原本的意义，但是最近我稍微理解了一点它的价值。</p><p>分红险通常需要购买者每年交上万块钱，连续交 20 年左右，之后开始累积复利，最后在几十年后，可以提取出来一笔财富。在现在低利率时代，它能保证的年化收益大概有 2.5% 左右（以后如果利率下行应该收益会更低一点）。</p><p>我开始很不喜欢分红险，因为首先它的收益率并不高。不管是股票，债券，还是黄金，如果你拉一下 30 年收益率的话，大多数都远远超过 2.5% 。另外，这笔几十万的保费，其实是丧失了几十年的流动性，如果你要强行赎回，就会损失巨大。我认为现金流对家庭来说还是很重要的，所以我很不喜欢这类保险。</p><p>大部分销售推销的香港保险也属于这类。</p><p>哦，不得不提，<u><strong>这类保险也是对销售来说提成最高的产品</strong></u>。这也是我不喜欢它的原因。因为这就相当于你的本金一开始就打了一个 9 折，对于一个打折的本金，它的复利增长就更难。</p><p>那我现在为什么稍微理解了它呢？因为我发现大部分人只会把钱存定期。对于一个定期存款来说，换成这种保险，稍微能够提升一点点长期收益率，同时帮助这些人能够 “锁定” 财富，如果希望这个钱用于养老，它被锁定就不至于被各种意外用掉。</p><p>但是我个人还是宁愿持有股票或债券。</p><p>另外，给孩子买这个保险的家长可能要想清楚，这个保单什么时候兑现？如果一直不兑现，理论上可能是给 “孙子” 买的，那么做好保单两代人的传承也是一个问题。因为如果 10 岁给孩子买，那么要 60 年之后可能才会兑现保单价值。到时候大概率自己已经不在了，孩子已经 70 岁了，保单传承不好就相当于捐给保险公司了。</p><h2 id="五、终身寿险"><a href="#五、终身寿险" class="headerlink" title="五、终身寿险"></a>五、终身寿险</h2><p>高额的终身寿险其实相对于把意外险和分红险做了一个组合。拿分红险的收益来 cover 意外险的保费。美其名曰：如果意外发生可以保多少，最后你还能拿回全部本金，还附加一些特别红利（不保证兑现）。</p><p>殊不知羊毛出在羊身上，本金每年的部分利息就其实是意外险的成本。只是换了一个说法和组合。</p><p>我是很不喜欢这种类似雪球的复合结构，因为你搞不明白年化收益率，也搞不明白你的意外险部分的杠杆率。</p><h2 id="七、车险"><a href="#七、车险" class="headerlink" title="七、车险"></a>七、车险</h2><p>车险里面的车损险是杠杆率极低的产品。拿我的特斯拉来说，一年保费要 5000 多，但是我大部分时候在城市里面开，就算有小磕碰，修车也不会花到这么多。</p><p>车险里面杠杆最高的是三者险，大概 600 块钱左右就可以保 200-300 万的保额。这样万一撞到人或者豪车，都可以 cover 全部费用。</p><p>我已经连续很多年只买交强险和三者险。这也让我驾车的时候更小心，自己不撞别人就不需要车损险，如果别人撞到自己，可以走别人的保险。</p><h2 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h2><ul><li>意外险和医疗险可以保证极端情况发生后的体验，杠杆很高，费用相对低（一年几百块钱）</li><li>高端医疗险类似消费，提升普通看病体验，一年几千。</li><li>分红险年化收益不如很多股票和债券等产品，但是比定期强。另外牺牲了现金流，但同时保证这笔钱不会被挪用。因为利润高，销售都喜欢卖这个产品。</li><li>终身寿险是意外险和分红险的组合。</li><li>车险里面三者险杠杆最高，车损险性价比低。</li></ul><p>以上。本文仅表达个人观点，不构成任何购买建议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先申明：&lt;u&gt; &lt;strong&gt;本文不是广告，也不推荐任何保险产品&lt;/strong&gt; &lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;我之前一直不理解保险，最近借助一些资料，终于想明白了各种保险的价值，给大家分享一下。&lt;/p&gt;
&lt;p&gt;保险其实分很多种，我们需要分开理解它的用途。&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>请为信息付费</title>
    <link href="https://blog.devtang.com/2025/08/31/pay-your-information/"/>
    <id>https://blog.devtang.com/2025/08/31/pay-your-information/</id>
    <published>2025-08-31T09:46:40.000Z</published>
    <updated>2025-12-01T15:02:39.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“免费的午餐往往是最贵的。为知识付费，是投资自己的认知能力，是这个时代每个人都应该认真考虑的选择。</p></blockquote><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>前几天刷抖音，看到一个财经博主在讲”普通人如何实现财富自由”，视频里充满了夸张的表情和煽动性的文案。视频末尾，他推荐了一个”0元理财训练营”，声称能教你”三个月内资产翻倍”。</p><p>我想起了自己订阅《财新》时的犹豫。为什么我们对免费的低质量内容习以为常，却对高质量的付费内容如此吝啬？</p><p>这个信息爆炸的时代，我们真的需要为知识付费。</p><h2 id="免费内容的陷阱"><a href="#免费内容的陷阱" class="headerlink" title="免费内容的陷阱"></a>免费内容的陷阱</h2><h3 id="质量之殇"><a href="#质量之殇" class="headerlink" title="质量之殇"></a>质量之殇</h3><p>免费的内容最大的问题，就是它根本就不免费。</p><p>当我们在抖音上看到那些”三招教你理财”、”这样做就能年入百万”的短视频时，我们以为自己没有付出成本。但事实上，我们付出的是注意力，付出的是判断力，付出的是被误导的风险。</p><p>这些内容利用了人性中最原始的弱点：贪婪和猎奇。它们用夸张的标题吸引眼球，用简化的逻辑迎合认知懒惰，最终的目的不是传播知识，而是引流变现。</p><p>我记得罗振宇在《逻辑思维》中说过：”免费是世界上最昂贵的东西”。当时不理解，现在想想，免费内容的真实成本往往比付费内容更高，只是这个成本被巧妙地隐藏了。</p><h3 id="注意力的谋杀"><a href="#注意力的谋杀" class="headerlink" title="注意力的谋杀"></a>注意力的谋杀</h3><p>短视频平台更可怕的地方在于，它们正在系统性地破坏我们的专注力。</p><p>抖音上的财经内容，往往用夸张的配音、快节奏的剪辑，以及故意制造的冲突感来抓取注意力。”震惊！这家公司竟然…”、”你绝对想不到的赚钱方式”，这样的文案充斥着整个平台。</p><p>长期消费这样的内容，就像吃快餐一样，看似填饱了肚子，实际上营养不良。我们的大脑习惯了这种高刺激、低思考的信息输入方式，逐渐失去了深度阅读和独立思考的能力。</p><p>更要命的是，算法推荐让我们陷入信息茧房。平台为了让用户停留更长时间，会推送用户喜欢的内容，而不是用户需要的内容。结果是，重要的时政新闻、深度的社会分析被娱乐化的内容所淹没。</p><h2 id="广告的毒药"><a href="#广告的毒药" class="headerlink" title="广告的毒药"></a>广告的毒药</h2><h3 id="隐藏的商业动机"><a href="#隐藏的商业动机" class="headerlink" title="隐藏的商业动机"></a>隐藏的商业动机</h3><p>最近几年，我观察到一个现象：几乎所有的免费财经内容，最终都指向商业变现。</p><p>公众号上那些分析经济形势的文章，看似专业，细读之后会发现，作者往往会推荐某个理财产品或者某个投资平台。文章的逻辑链条是这样的：经济形势不好 → 需要理财 → 推荐我的产品。</p><p>抖音上更直接。那些所谓的”财经大V”，视频内容是免费的，但最终目标是让你扫码进群，然后推销各种理财课程、股票软件，甚至是可疑的投资项目。</p><p>这种商业模式本身没有问题，但它扭曲了内容的客观性。当内容创作者的收入来源是推广费而不是内容质量本身时，内容质量必然会让位于商业转化。</p><h3 id="算法的偏见"><a href="#算法的偏见" class="headerlink" title="算法的偏见"></a>算法的偏见</h3><p>算法推荐进一步加剧了这个问题。</p><p>算法关心的是用户停留时间和点击率，而不是信息的准确性和重要性。一条耸人听闻的假新闻往往比一篇严谨的深度报道有更高的传播率。</p><p>结果是什么？真正重要的政治、经济、社会议题被娱乐化、碎片化的内容所遮蔽。当所有人都在关注某个网红的恋情时，有多少人知道最新的货币政策调整？当大家都在讨论某个段子时，有几个人了解正在发生的地缘政治变化？</p><p>这不是危言耸听。信息质量的下降最终会影响整个社会的决策质量。</p><h2 id="付费的价值"><a href="#付费的价值" class="headerlink" title="付费的价值"></a>付费的价值</h2><p>面对这样的信息环境，我选择了用钱投票。</p><h3 id="我的付费清单"><a href="#我的付费清单" class="headerlink" title="我的付费清单"></a>我的付费清单</h3><p>去年开始，我陆续为以下内容付费：</p><ul><li>《财新》杂志：每年几百块钱，但能获得相对客观、深度的财经报道</li><li>财经类每日新闻：每天需要花 1 块钱，信息密度高，没有广告干扰</li><li>《三联生活周刊》：优质的长篇报道，帮我理解复杂的社会现象</li><li>小宇宙上的访谈节目：深度对话，远比短视频更有营养</li><li>请一些行业专家咨询，事后发微信红包感谢</li></ul><h3 id="付费内容的优势"><a href="#付费内容的优势" class="headerlink" title="付费内容的优势"></a>付费内容的优势</h3><p>付费内容最大的优势在于，它的商业模式相对纯粹。</p><p>当我为《财新》的内容付费时，我就是《财新》的客户。《财新》需要对我的钱负责，需要提供有价值的内容来留住我。这种直接的商业关系，比那种”免费内容+广告变现”的模式要健康得多。</p><p>付费内容的第二个优势是质量控制。</p><p>以《三联生活周刊》为例，它的记者往往需要花费数月时间来调查一个选题，采访几十个相关人员，查阅大量资料，最终呈现出一篇万字长文。这样的内容制作成本很高，只有付费模式才能支撑这样的投入。</p><p>而免费的自媒体内容呢？往往是一个人坐在电脑前，花几个小时搜集网上的资料，拼凑出一篇文章。质量的差距是显而易见的。</p><h2 id="一点反思"><a href="#一点反思" class="headerlink" title="一点反思"></a>一点反思</h2><p>诚然，付费内容也不是万能的。</p><p>《财新》有时也会有立场偏见，《三联》有时也会有不够深入的报道。付费不能保证内容的完美，但它至少能保证内容制作者的基本动机是提供有价值的信息，而不是引流变现。</p><p>另外，并不是所有人都有条件为信息付费。这涉及到信息公平的问题，也是整个社会需要思考的问题。</p><p>但至少对于有条件的人来说，为高质量内容付费，不仅是为了获得更好的信息，也是在用消费选择来支持优质内容的生产，推动整个信息生态的良性发展。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是一个最好的时代，也是一个最坏的时代。</p><p>说它是最好的时代，是因为获取信息从来没有像现在这样便利。说它是最坏的时代，是因为信息质量从来没有像现在这样参差不齐。</p><p>在这样的环境下，为知识付费不是一种消费，而是一种投资。投资自己的认知能力，投资自己的判断力，投资自己的未来。</p><p>毕竟，在这个瞬息万变的时代里，唯一不变的就是变化本身。而应对变化的最好方式，就是保持持续学习的能力。</p><p>免费的午餐往往是最贵的。为知识付费，是这个时代每个人都应该认真考虑的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“免费的午餐往往是最贵的。为知识付费，是投资自己的认知能力，是这个时代每个人都应该认真考虑的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>真相不重要</title>
    <link href="https://blog.devtang.com/2025/07/30/truth-does-not-matter/"/>
    <id>https://blog.devtang.com/2025/07/30/truth-does-not-matter/</id>
    <published>2025-07-30T14:57:31.000Z</published>
    <updated>2025-12-01T15:01:14.832Z</updated>
    
    <content type="html"><![CDATA[<p>真相有时候不重要，举几个例子。</p><p>第一个例子是身边一个朋友的故事。一天早上，从来不做饭的妻子心血来潮，给他做了一份早餐，但是因为是第一次做，手艺不太娴熟。这个时候，妻子问他味道怎么样？他随口就说：感觉一般。妻子的脸色瞬间就阴下去了，说：那我以后再也不做饭了。<strong>对于妻子来说，早餐好不好吃的真相不重要，鼓励和认可才是重要的。</strong>丈夫说了实话，但是却伤了妻子的心。</p><p>去年农夫山泉被全民网暴的时候，我发文章说农夫山泉的瓶盖和日本国旗没关系。结果一堆人在评论区谩骂我。<strong>对于网暴的人来说，真相不重要，情绪和宣泄的重要性大于真相。</strong>对于这些谩骂的人来说，我忽略了讲真话的时机，所以被骂。</p><p>在今年的脱口秀节目上，一个脱口秀演员提到自己的爸妈本来打算把自己打掉的，老罗也提到他也有同样的家庭情况，他花了很多年很多时间才对这个事情“放下”。对于老罗来说，“自己出身下来不是被需要的”这个真相不重要，重要的是自己的人生意义。<strong>即便是事实，如果会伤害孩子，父母本来可以不说，真相不重要。</strong></p><p>我们曾经有一个实习生，偷偷利用公司的9点后加班可以打车福利，下班后去健身房，然后等到9点后再打车回家。我们后来给他说，我们实习岗位取消了，让他离开了公司。对于我们来说，告诉他离开的真相不重要，对于不合适的人，让他快速地离开不会起任何冲突。<strong>对于我们来说，事情顺利地执行比说出真相重要。</strong></p><p>我是一个业余编程老师，编程这件事情很难，所以孩子第一次接触编程容易会发怵。这个时候，我会设置一些很简单的题目，但是告诉他这个题目很难，然后等他做出来，我会惊讶地说：哇，你真的很有天赋！<strong>对于孩子来说，真相不重要，学习的兴趣和信心最重要。</strong></p><p>对于美国两党各自拥护的媒体，真相也不重要。如果发现事情有利于他们的政治宣传，他们就大力宣传。如果发现事情不利于他们的政党，他们就会有意淡化。<strong>在美国，媒体的中立客观在政治面前不重要，政治更重要。</strong></p><p>邓小平很早就明白真相不重要。每次被打倒他都默默承受，尽力照顾好自己的家人，不争辩不气馁。因为他知道，在那个时候<strong>只要是他说的，就都是错的，真相不重要</strong>。在后来，邓小平坚决保护毛主席，保护国家稳定，因为他知道：稳定大于一切。只要政局稳定，一切问题都可以慢慢解决。而如果为了真相导致政局混乱，那将天下大乱。</p><p>有些时候，真相因为不太容易被人接受，甚至会变成秘密，比如大家的工资。试想一下，如果每个人的工资是公开的，那么就会有大量的人向 HR 投诉自己的薪资为什么不如某某某。因为人们总是容易高看自己，低看别人。所以，<strong>薪资的真相变得不重要，大家相互之间不知道薪资变得很重要</strong>。</p><p>那真相很多时候不重要，我们是不是就不需要真相了？不是的。大部分时候，真相都是重要的。大部分时候，我们也需要讲真话，追求真相。只是我们需要明白，<u>这个世界在运转过程中，真相的权重不一定是最大的</u>。当真相被掩盖的时候，我们可能需要接受这样的现实。当我们决策的时候，有时候需要相对真相，给其他因素更高的权重。</p><p>最后，我想引用最近看到的一篇《南方周末》的报道 <a href="https://mp.weixin.qq.com/s?__biz=MzkyNTI4OTA2NQ==&mid=2247486652&idx=1&sn=c3237d6a9e3a608cab0fddc03ae7761e&scene=21&poc_token=HGitLWmjYNLeipHVtdXdFB6UA00VfcnwXcbonoVA">佛学与官场，一个主持的官场往事</a>。在文章中，释传真（时任南京市佛教协会副会长）说：</p><blockquote><p>我常常跟来聊天的官员说，做官啊，第一有文化没文化要学会听话；<br>第二，得过且过太阳出来暖和；<br>第三，有一些矛盾就要睁一只眼闭一只眼。</p></blockquote><p>你看，一位佛教高僧给官员的经验分享，每一点都在说：有比真相更重要的事情。</p><p>以上。最后再强调一遍：我不是教大家骗人，我是在强调<u>给真相赋予合适的决策权重</u>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;真相有时候不重要，举几个例子。&lt;/p&gt;
&lt;p&gt;第一个例子是身边一个朋友的故事。一天早上，从来不做饭的妻子心血来潮，给他做了一份早餐，但是因为是第一次做，手艺不太娴熟。这个时候，妻子问他味道怎么样？他随口就说：感觉一般。妻子的脸色瞬间就阴下去了，说：那我以后再也不做饭了。&lt;s</summary>
      
    
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>构建你的“多巴胺”系统</title>
    <link href="https://blog.devtang.com/2025/06/22/build-your-own-dopamine-system/"/>
    <id>https://blog.devtang.com/2025/06/22/build-your-own-dopamine-system/</id>
    <published>2025-06-22T14:08:32.000Z</published>
    <updated>2025-07-12T15:28:54.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是“多巴胺”系统"><a href="#什么是“多巴胺”系统" class="headerlink" title="什么是“多巴胺”系统"></a>什么是“多巴胺”系统</h2><p>“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&#x2F;正向情绪的事情。之所以用这个隐喻，一方面是想让大家更容易理解、记忆和传播这个系统。</p><p>这个系统对我来说非常重要，它就相当于我人生的“第一性原理”一样。人类看起来是自己的主人，但人类对自身行为动机的理解很多时候并不清楚。</p><p>马斯洛把人类的需求按层次来分，在他的理论中提到的各种需求：性，安全，食物，社交，自我实现等等。但是其实，这些其实本质上，都是在为人类提供“多巴胺”。</p><img src="/images/mashiluo.jpg" class=""><p>当人类失去了“多巴胺”系统，很多时候就宁愿放弃生命：比如在战争中，很多人为了信仰而牺牲自己。这是因为他内心的目标大于活着的意义。</p><p>在实际生活中，虽然不至于放弃生命，但冒着生命危险做的事情，也不鲜见。比如消防队员救人、警察和歹徒搏斗、或者体育健儿在赛场上带伤为荣誉而战。</p><p>这些行为虽然有可能失去生命，但是换来的荣誉与成就是非常让人自豪的，可以为自己提供终身的多巴胺来源。</p><p>有人说，这个世界上只有两种生意：让人爽的生意和让人牛逼（学习、健身等）的生意。但我觉得，这都是多巴胺的生意，差别只是一个是提供短期多巴胺，一个是提供长期多巴胺。学习这种事情虽然短期很辛苦，但是收获的成就是可以提供长期的回报，从而提供长期的多巴胺。</p><h2 id="为什么“多巴胺”系统很重要"><a href="#为什么“多巴胺”系统很重要" class="headerlink" title="为什么“多巴胺”系统很重要"></a>为什么“多巴胺”系统很重要</h2><h3 id="1、人对生活的意义有需求"><a href="#1、人对生活的意义有需求" class="headerlink" title="1、人对生活的意义有需求"></a>1、人对生活的意义有需求</h3><p>看看全世界有多少人信教就明白了。大部分人都需要精神上为生命的存在赋予意义。意义感会驱使人们面对挑战和困难、提供情绪支撑、获得幸福感。</p><p>在中国，很少有人信教，但是我们每一个普通人也有自己对生命的追求，哪怕是更好一点的生活，或者一个遥不可及的理想，又或者是简单地照顾好家人和孩子。</p><p>人生的目标带动着每一个人在各种重大决策的十字路口上做选择。韩寒为了赛车辍学；赵心童为了台球远赴英国；崔永远为了自由表达离开了央视；而我身边，一个亲人为了更好的照顾孩子而放弃了工作上的晋升机会。</p><p>“多巴胺”系统就是为人生的意义提供基础能量的仓库，守护好多巴胺系统，人生之路就会走得更加从容。</p><h3 id="2、“多巴胺”系统不容易构建"><a href="#2、“多巴胺”系统不容易构建" class="headerlink" title="2、“多巴胺”系统不容易构建"></a>2、“多巴胺”系统不容易构建</h3><p>我们随便看看身边，就会发现无论是学习、工作，还是退休安排和日常生活。“多巴胺”系统的构建都是非常不容易的。</p><h4 id="2-1-学习"><a href="#2-1-学习" class="headerlink" title="2.1 学习"></a>2.1 学习</h4><p>拿学习来说，如果将孩子的“多巴胺”系统和学校排名、升学挂钩，那么很多孩子是无法构建学习的“多巴胺”系统的。因为每个班几十个孩子，必然有排在后面 50% 的孩子。这些孩子从排名上是无法获得正向激励的。</p><p>另外，整个学习是一个不断淘汰对手的游戏。中考会淘汰 50% 的学生分流到中专，高考又会分流 50% 的人到职高，大学又会分流 90% 的学生到非重点大学。研究生考试又会分流 2&#x2F;3 的本科生，只剩下 1&#x2F;3。</p><p>按上面的通过率，就算你是全中国前 1% 的学生，那大概也会止步于 985&#x2F;211 的研究生入学考试。</p><p>所以，在学习上，你总会有一天会遇上身边的对手都比你强，你在这个小圈子里面排在后面，如果你和同学比的话，你能收获的只有负面的情绪，感觉自己像个废物。</p><p>后面我会提到如何构建学习的多巴胺系统。</p><h4 id="2-2-工作"><a href="#2-2-工作" class="headerlink" title="2.2 工作"></a>2.2 工作</h4><p>也许你是一个优秀的员工，不断获得奖励和提拔，但是随着环境和年龄变化，工作中持续获得正反馈是困难的。原因如下：</p><p>第一个原因：正向激励的比例太低。只有前 20% 的员工才能获得超过其他人的回报，大部分人只能拿到普通的绩效和待遇。</p><p>第二个原因：很多工作的经验积累并不是线性的。在积累 3-5 年后，新增加的经验不足以带来相应比例产出提升，这就造成老员工工资过高，性价比不足。拿 iOS 开发来说，工作 10 年和工作 30 年的开发者的经验差异在大部分情况下表现得并不明显，这就可能造成某些工作 10 年以上的老员工薪资涨幅变慢。</p><p>第三个原因：人在 30 岁以后，体力和学习速度逐渐下降。我今年 41 岁，熬夜的能力明显变差。而我在 30 岁的时候，经常熬夜加班。工作中的一些内容如果需要的是堆时间才能完成，老员工的完成速度就不及年轻的员工。</p><p>第四个原因：岗位架构是金字塔形的。越往上需要的人越少，所以一个员工很容易最终就停在某一个岗位无法获得上升机会，背后的原因可能仅仅是因为上面已经有人了，不需要更多管理者。</p><h4 id="2-3-退休"><a href="#2-3-退休" class="headerlink" title="2.3 退休"></a>2.3 退休</h4><p>退休是每个人必须面对的事情，如果不做好准备，“多巴胺”系统根本就不会自己产生。因为每个人退休后，日常生活的节奏就会有巨大变化。而人的时间是需要被填满的，否则就会因为意义感缺失而产生各种问题。</p><h4 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h4><p>其它的部分还包括，生活、家庭、理财等等：</p><ul><li>对于生活：兴趣能否持续，影响“多巴胺”系统的稳定。</li><li>对于家庭：如何处理夫妻关系，亲子关系，婆媳关系，都关系到多巴胺系统的稳定。</li><li>对于理财：如果你买在顶峰，不但需要很长时间回本，也会承受巨大的账面亏损压力，给自己的多巴胺系统带来巨大冲击</li><li>对于伤痛：个人对伤痛，特别是心理层面上的伤痛处理也很重要，心理上的伤痛如果处理不好，就像应激的小猫一样，会给身体带来严重的伤害。</li></ul><h2 id="如何构建“多巴胺”系统"><a href="#如何构建“多巴胺”系统" class="headerlink" title="如何构建“多巴胺”系统"></a>如何构建“多巴胺”系统</h2><p>接下来，我就讲讲我对各种情况下构建“多巴胺”系统的心得。</p><h3 id="1、对于学习"><a href="#1、对于学习" class="headerlink" title="1、对于学习"></a>1、对于学习</h3><p>对于学习，我们需要刻意设计“多巴胺时刻”。让原来可能没有的多巴胺变得有，让原来分泌得少的多巴胺，变得分泌多。具体来说，我们可以：</p><p>一、定期回顾，肯定自己的进步。我每年都会写年度总结，之前觉得每年没有什么变化，但是总结的时候，发现还是有挺多进步的，这样就让自己更有成就感。</p><p>二、设立奖励，自我颁奖。不管是小的学习还是大的学习，都可以设立奖励。我在做竞赛题的时候，之前做完我就继续做下一题。但后来我发现，如果我每次做对，都挥舞一下手臂小小庆祝一下，就会开心很多。所以，即便是很小的自我肯定，都可以让多巴胺给我们更多激励。</p><p>三、适当分享，获得亲朋鼓励。人是社会动物，自己的成就还是要适当分享出来。但是对自己友谊不深的朋友就没太有必要，有可能会造成人家妒忌，或者人家会认为你是一个喜欢炫耀的人，没必要。</p><p>四、构建无限游戏，不要设置终点和上限。学习无止境，如果我们可以一直设立目标，就可以无限玩下去。对于生命来说，能够无限玩的游戏不多，学习算是一个。</p><h3 id="2、对于工作"><a href="#2、对于工作" class="headerlink" title="2、对于工作"></a>2、对于工作</h3><p>刚刚说过，随着环境和年龄变化，工作中持续获得正反馈是困难的。所以，对于工作，我们首先需要做的是降低预期。工作首先你是获得持续现金流的谋生手段；它如果能够给你持续的正向激励，当然很好，但是如果有一天，工作无法给你带来正反馈，那么你也可以就把它当作一份工作即可。</p><p>在工作上不要讲太多回报，公平。很多事情做了没有结果，但是公司付你钱了，所以你认真把事情做好，就很好，也很专业。</p><p>另外，在工作上，我们也需要尊重规律，做累进的事情。坚持在自己的专业领域积累经验，如果自己的年龄大了或者行业发展不好，也要接受工资不再上涨这些现实。</p><p>在工作上，我们还可以尝试杠铃策略，即：同时拥有两个不太相关的专业技能。通过在业余时间利用自己的爱好或者特长来发展副业，如果万一出现什么变动，自己的副业就可以成为主业，保证自己不至于失业。</p><h3 id="3、对于退休"><a href="#3、对于退休" class="headerlink" title="3、对于退休"></a>3、对于退休</h3><p>退休是人一辈子重要的规划之一，也是人生活法的重大转换。</p><p>对于退休，最重要的事情就是让提前规划好兴趣，让兴趣填满自己的时间。否则，人生一下子多了那么多时间，很容易觉得无聊。</p><p>这个兴趣最好是无限挑战游戏。这样可以几十年也做不完。</p><p>这个兴趣也最好可以锻炼到身体（例如：广场舞、摄影、骑行之类）。</p><p>最后，退休还有一个很重要的事情：要管好自己的钱，不冒大的风险，不折腾高风险的投资。因为挣太多钱自己也不一定能花完，但是如果亏很多就会影响自己的退休生活。</p><h3 id="4、日常生活"><a href="#4、日常生活" class="headerlink" title="4、日常生活"></a>4、日常生活</h3><p>日常生活中，有这些技巧可以带来更多的多巴胺：</p><p>一、主动给生活带来变化</p><p>我自己的经验是，主动做一些以前没做过的事情，会给生活带来新鲜感。比如：</p><ul><li>我家每过几年就会尝试换个房子租，每次都有不同的体验。</li><li>每年出游几次，每次去不同的地方，让自己开眼界。</li><li>购物，看上什么东西就买买买。</li><li>庆祝。为自己的成绩庆祝，为朋友的成绩庆祝，为家人的成绩庆祝。</li></ul><p>二、自立</p><p>不要太依赖别人，或者太依赖于某个工作，或者将自己放到一个困境，或者太陷入一个目标。这不是说我们应该不努力。对于生活，我们应该全情投入，把过程做好；但是对于结果，我们应该顺其自然。</p><p>三、终身学习</p><p>学习是少有的，可以持续给人带来获得感的事情。而且这个事情是没有终点的，属于一种“无限游戏”，这就让我们永远不会觉得无聊。</p><p>我最近因为兴趣又开始学习编程，遇到一个算法没看懂，我就慢慢想，可能想个一周，甚至两周，我感觉这才是一个学习的状态，就是慢慢的，不紧不慢的，学完一个再学下一个。</p><p>相对来说，学校的学习更像是一个工业化的人才产出器，每个人需要像机器一样在指定的时间学习完指定的内容，但是每个人的学习能力是不一样的，其实对每个人来说，匹配自己的学习速度才是最佳的学习方案。</p><p>四、关注过程，弱化结果</p><p>人生是一场体验，并非要留下什么，也留不下什么。</p><p>如果我们想想 100 年后谁能记得我们，我们会发现结论是：没有人。即使是自己的亲人，过了三代你可能也不会记得。大家可以想想，你知道你的爷爷的爷爷叫什么名字，长什么样，做过什么成绩吗？就算你记得，你的孩子以后会记得吗？</p><p>所以，如果人生到最后不会有任何人记得我们，那么我们人生的意义是什么？我认为核心的意义就是人生本身。就像《活着》中写道：活着就是最大的意义。</p><p>对于人生这种重过程，无结果的“游戏”，我们活在当下，关注过程，把自己的人生过好，就是一个非常棒的事情了。别的更多的结果，我们做不到，也没有什么意义。</p><h3 id="5、对于家庭"><a href="#5、对于家庭" class="headerlink" title="5、对于家庭"></a>5、对于家庭</h3><p>对于家庭，最简单的获得多巴胺的方式是：低预期。比如：</p><p>对于家人，不要指望家人一定要为自己付出。家人能够不让你付出，就是超预期。有这样的心态，你每天都是超预期。</p><p>对于孩子也一样，低预期，不鸡娃。</p><ul><li>孩子小的时候，我们只需要尽量培养孩子兴趣，兴趣是最大的老师，对于结果，则需要看孩子的天赋和运气，所以我们只能静待花开。</li><li>当孩子成年后，她会有自己的生活，作为父母也应该降低预期，孩子能活成什么样，最主要的还是靠孩子自己。</li><li>当我们老了后，也别指望孩子给自己养老，不啃老就不错了。有这样的低预期，也容易每天获得超预期的结果。</li></ul><h3 id="6、对于朋友"><a href="#6、对于朋友" class="headerlink" title="6、对于朋友"></a>6、对于朋友</h3><p>我认为有三种朋友，可以给我们提供持续的多巴胺。</p><ul><li>一种朋友是相互帮助、支持的人。显然你们相互会收获很多。</li><li>一种是可以给你提供指导的前辈，牛人。你可以收获到成长。</li><li>一种是你可以给别人提供指导的后辈。你可以收获到成就感。</li></ul><p>那哪些是消耗你多巴胺的朋友呢？</p><ul><li>每次需要你的时候找你，但你需要他的时候总逃避的人。</li><li>和你话不投机，没有共同语言的人。</li><li>无法平等对话的人，有可能是对方太过强于你，懒得和你对话；也可能是对方太弱于你，你懒得和他对话。</li><li>让你感觉到有压力，但是除了消耗你多巴胺外，并不能给你带来任何其他好处的人。</li><li>你讨厌的人。</li><li>你嫉妒的人。</li></ul><p>我有些时候，有点讨好型人格，就是不喜欢一个人，也不愿意和人家起冲突，很多时候碍于面子还是淡淡地交往。后来我发现这样不对，这完全是一种对多巴胺系统的伤害，想到这些我就主动断开了一些不喜欢的朋友的来往。其实有一些人是很优秀的，但是多巴胺系统为先的决策，让我还是会坚决断开联系。</p><h3 id="7、对于伤痛"><a href="#7、对于伤痛" class="headerlink" title="7、对于伤痛"></a>7、对于伤痛</h3><p>小孩子如果反复盯着糖果看，最后就会忍不住吃掉糖果。如果有人伤害了你，你反复回忆这个伤害的过程，你就会受到更多的内心部分的伤害。</p><p>著名作家蔡澜最近去世了，别人问他，他的爱人离他而去了，他是如何克服下来的。蔡澜说：你如果老去想这件事情，你就会发疯，所以我尽量让自己不去想这件事情。</p><p>芒格和巴菲特的公司之前特别看好一个接班人，后来这个接班人做了一些违背公司原则的事情，在收购一家公司前，自己私下提前买了这家公司的股票，自己获利了几百万美元。事情暴露之后，这个接班人辞职了。别人问芒格怎么看这个事情。</p><p>面对欺骗与背叛，芒格说：永远不要责备自己，永远不要有受害者心态。当你产生这种心态的时候，只会让你自己难受，不会带来任何其它正面的影响，因此你不应该花时间去感受它，哪怕是一秒钟。所以，更应该的心态是应对这种情况，为未来的不确定性做好准备。</p><p>芒格最后总结道：“I am not a victim. I am a survivor.”</p><p>所以，站在建立“多巴胺”系统的角度，任何只有负面效果的情绪都是不值得去强化和感受的。如果你忍不住，你可以尽量不去想它。更好的办法是像芒格那样，有一个更加强大的幸存者视角来看待所有的坏运气、灾难、欺骗与背叛。让这些负面情绪不影响自己的多巴胺系统。</p><h3 id="8、不内耗和自恰"><a href="#8、不内耗和自恰" class="headerlink" title="8、不内耗和自恰"></a>8、不内耗和自恰</h3><p>我后来发现，其他人讲的一些行事原则，在表达角度上虽然不一样，其实也是一样的道理。比如我们讲的“不内耗”原则。</p><p>内耗就是一种持续消耗“多巴胺”的心理行为。如果以构建“多巴胺”系统作为人生准则的话，我们会发现内耗没有任何效果。当我们面对不如意的时候，要么改变，要么适应，要么淡化，而内耗是一种既不改变，又不适应，又反复强化负反馈的行为。百害而无一利。</p><p>自恰的底层含义是：所有事情能够自圆其说，不矛盾，不冲突，自然也就不内耗了，不消耗多巴胺。</p><p>所以，人需要活得“自恰”，只有自恰才能睡好觉，持续获得多巴胺。</p><h2 id="主观与客观"><a href="#主观与客观" class="headerlink" title="主观与客观"></a>主观与客观</h2><p>“多巴胺”系统有主观的部分，也有客观的部分。</p><p>一、主观部分</p><p>“多巴胺”系统对于个人内心是一种主观行为和感受，而不是一种客观描述和标准。所以，对于芒格来说，一个重要朋友的背叛不是对“多巴胺”系统的冲击；但换一个人，可能觉得天塌了，一辈子再难信任他人。</p><p>因此，我们更应该调整的是自我的行事方式和思考问题的角度，而不是改变其他人。我们可以远离那些影响我们“多巴胺”系统的人和事，但是当坏运气到来的时候，我们只能接受。</p><p>二、客观部分</p><p>当然，“多巴胺”系统在指导我们行为的时候，是让我们客观上在做具体的行为选择。通过行为选择让我们尽可能构建有利于我们产生多巴胺的外界环境。比如我刚刚提到的：提前规划退休生活、选择终身学习、多搞庆祝活动等。这些有利的环境不但不会消耗我们主观意志来维护多巴胺，还会给我们提供愉悦，贡献多巴胺。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&#x2F;正向情绪的事情。我们通过：</p><ul><li>主观上，调整自己的思考和看待事情的方式</li><li>客观上，搭建好能够持续供养自己多巴胺的外部环境</li></ul><p>利用“多巴胺”系统，让自己的人生少一点内耗，少一点纠结，多一点平静，多一点快乐。</p><p>愿每个读者都能过好当下的每一天，谢谢！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是“多巴胺”系统&quot;&gt;&lt;a href=&quot;#什么是“多巴胺”系统&quot; class=&quot;headerlink&quot; title=&quot;什么是“多巴胺”系统&quot;&gt;&lt;/a&gt;什么是“多巴胺”系统&lt;/h2&gt;&lt;p&gt;“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&amp;#x2F;正向情绪的事</summary>
      
    
    
    
    
    <category term="summary" scheme="https://blog.devtang.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>GESP 核心考点</title>
    <link href="https://blog.devtang.com/2025/06/06/gesp-notes/"/>
    <id>https://blog.devtang.com/2025/06/06/gesp-notes/</id>
    <published>2025-06-06T14:12:03.000Z</published>
    <updated>2025-12-14T14:14:43.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GESP-1-级"><a href="#GESP-1-级" class="headerlink" title="GESP 1 级"></a>GESP 1 级</h1><h2 id="大题核心考点"><a href="#大题核心考点" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>1 级主要考查分支和循环结构，所以大题的解法一般都是一个 for 循环，然后循环里面用 if 之类的条件判断做一些事情，最后再输出结果。其代码框架为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环结构, 例如 for ...</span></span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line"><span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure><p>拿 GESP202309 一级题目：<a href="https://www.luogu.com.cn/problem/B3864">小明的幸运数</a> 来说，其核心代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLucky</span>(i)) &#123;</span><br><span class="line">        <span class="comment">// 累加</span></span><br><span class="line">        ans += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>另外一个例子，GESP202503 一级题目：<a href="https://www.luogu.com.cn/problem/B4258">四舍五入</a>，核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    b = a%<span class="number">10</span>;</span><br><span class="line">    a = a/<span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt;= <span class="number">4</span>) a = a*<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> a = a*<span class="number">10</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GESP-2-级"><a href="#GESP-2-级" class="headerlink" title="GESP 2 级"></a>GESP 2 级</h1><h2 id="大题核心考点-1"><a href="#大题核心考点-1" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="考点一：双重循环"><a href="#考点一：双重循环" class="headerlink" title="考点一：双重循环"></a>考点一：双重循环</h3><p>GESP 2 级相对 1 级，对循环结构的考查进行了加强，一般需要用双层嵌套的循环才能完成大题。有一类双层嵌套循环需要特别关注，就是模拟输出类，这一类题过去考过多次，包括：</p><ul><li>GESP202309，<a href="https://www.luogu.com.cn/problem/B3865">小杨的 X 字矩阵</a></li><li>GESP202312，<a href="https://www.luogu.com.cn/problem/B3924">小杨的 H 字矩阵</a></li><li>GESP202403，<a href="https://www.luogu.com.cn/problem/B3955">小杨的日字矩阵</a></li><li>GESP202409，<a href="https://www.luogu.com.cn/problem/B4037">小杨的 N 字矩阵</a></li><li>GESP202503，<a href="https://www.luogu.com.cn/problem/B4259">等差矩阵</a></li><li>GESP202303，<a href="https://www.luogu.com.cn/problem/B3837">画三角形</a></li><li>样题，<a href="https://www.luogu.com.cn/problem/B3844">画正方形</a></li></ul><p>以<a href="https://www.luogu.com.cn/problem/B4259">等差矩阵</a>为例，其关键代码为嵌套的 for 循环，参考如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tu[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 嵌套的 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cout &lt;&lt; i*j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果学生还是不熟悉，可以考虑如下更多的练习：</p><ul><li>模仿 <a href="https://www.luogu.com.cn/problem/B3865">小杨的 X 字矩阵</a>，输出 “又” 字，倒 “N” 字，“工” 字矩阵，“口”字矩阵</li><li>模仿 <a href="https://www.luogu.com.cn/problem/B3837">画三角形</a>，输出 左对齐、右对齐的正三角形，倒三角形</li><li>模仿 <a href="https://www.luogu.com.cn/problem/B4259">等差矩阵</a>，输出求和的矩阵，输出只有偶数的等差矩阵（奇数位填 <code>*</code>）</li><li>画简单的蛇形：<a href="https://www.luogu.com.cn/problem/B4432">B4432 语言月赛 202511 基米起床</a></li><li><a href="https://www.luogu.com.cn/problem/B3898">B3898 NICA 彩灯装饰</a></li></ul><p>有一些时候，双重循环也不一定以输出图案的方式来进行考查，比如题目 <a href="https://www.luogu.com.cn/problem/B4356">B4356 202506 二级 数三角形</a> 就是一个案例，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a&lt;=n; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = a; b&lt;=n; ++b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a*b%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的练习题目如下：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3994">https://www.luogu.com.cn/problem/B3994</a></li><li><a href="https://www.luogu.com.cn/problem/B3995">https://www.luogu.com.cn/problem/B3995</a></li><li><a href="https://www.luogu.com.cn/problem/B3986">https://www.luogu.com.cn/problem/B3986</a></li><li><a href="https://www.luogu.com.cn/problem/B3988">https://www.luogu.com.cn/problem/B3988</a></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于双重循环输出图形，解题的关键在于：分析图形所代表的序列。例如图形：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+</span><br><span class="line">-+-+-</span><br><span class="line">--+--</span><br><span class="line">-+-+-</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure><p>对应的序列是 </p><ul><li><code>(1,1)(2,2)(3,3)(4,4)(5,5)</code></li><li><code>(1,5)(2,4)(3,3)(4,2)(5,1)</code></li></ul><p>然后，我们在做双重循环输出的时候，已经有两个序列 i 和 j，分别表示行号和列号。<br>我们可以分析 i 和 j 与我们需要输出的数据有什么关系，最后就会发现，规律是 <code>i == j</code> 或者 <code>i+j == n+1</code></p><p>我们再看一个复杂的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..#..</span><br><span class="line">.#.#.</span><br><span class="line">#...#</span><br><span class="line">.#.#.</span><br><span class="line">..#..</span><br></pre></td></tr></table></figure><p>它对应的序列不太好找规律，我们可以用两个变量 a 和 b，分别表示每一行需要输出的 y 坐标。<br>刚开始 <code>(a,b)=(3,3)</code>，然后：</p><ul><li>对于上半部分，每增加一行，<code>a--</code>, <code>b++</code>。</li><li>对下下半部分，每增加一行，<code>a++</code>, <code>b--</code>。</li></ul><p>我们再看一些更复杂的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..#....#..</span><br><span class="line">.#.#..#.#.</span><br><span class="line">#...##...#</span><br><span class="line">.#.#..#.#.</span><br><span class="line">..#....#..</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..#...#..</span><br><span class="line">.#.#.#.#.</span><br><span class="line">#...#...#</span><br><span class="line">.#.#.#.#.</span><br><span class="line">..#...#..</span><br></pre></td></tr></table></figure><p>都可以用刚刚找到的思路来解决。</p><p>但对于更复杂的图形，就得再想办法，比如</p><ul><li><a href="https://iai.sh.cn/problem/645">https://iai.sh.cn/problem/645</a></li><li><a href="https://iai.sh.cn/problem/634">https://iai.sh.cn/problem/634</a></li></ul><p>这类题目需要根据题目的输出要求，思考问题拆解的办法，每道题的解法可能都不一样。</p><h3 id="考点二：常用函数"><a href="#考点二：常用函数" class="headerlink" title="考点二：常用函数"></a>考点二：常用函数</h3><p>2 级还会考一些我们经常会实现的函数。包括：</p><h4 id="求素数函数"><a href="#求素数函数" class="headerlink" title="求素数函数"></a>求素数函数</h4><p>参考题目：<a href="https://www.luogu.com.cn/problem/B3840">GESP202306 找素数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;=a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/P1217">P1217 回文质数 Prime Palindromes</a></li></ul><h4 id="求闰年函数"><a href="#求闰年函数" class="headerlink" title="求闰年函数"></a>求闰年函数</h4><p>参考题目：<a href="https://www.luogu.com.cn/problem/B4260">GESP202503 时间跨越</a></p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把一个数的每一位数字拆分的写法"><a href="#把一个数的每一位数字拆分的写法" class="headerlink" title="把一个数的每一位数字拆分的写法"></a>把一个数的每一位数字拆分的写法</h4><p>参考题目：<a href="https://www.luogu.com.cn/problem/B4007">GESP202406 计数</a></p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%<span class="number">10</span> == k) ret++;</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题目：</p><ul><li><a href="https://www.luogu.com.cn/problem/B4036">GESP202409 数位之和</a></li><li><a href="https://www.luogu.com.cn/problem/B2078">B2078 含 k 个 3 的数</a></li><li><a href="https://www.luogu.com.cn/problem/B2081">B2081 与 7 无关的数</a></li><li><a href="https://www.luogu.com.cn/problem/B2152">B2152 分离整数的各个数</a></li><li><a href="https://www.luogu.com.cn/problem/B2154">B2154 数 1 的个数</a></li><li><a href="https://www.luogu.com.cn/problem/B4419">B4419 语言月赛 202510 超级整数</a></li><li><a href="https://www.luogu.com.cn/problem/B4316">B4316 语言月赛 202504 整除判断</a></li><li><a href="https://www.luogu.com.cn/problem/B4271">B4271 蓝桥杯青少年组省赛 2023 四叶玫瑰数</a></li><li><a href="https://www.luogu.com.cn/problem/B4344">B4344 语言月赛 202506 数字转转转</a></li></ul><h1 id="GESP-3-级"><a href="#GESP-3-级" class="headerlink" title="GESP 3 级"></a>GESP 3 级</h1><h2 id="选择、判断题核心考点"><a href="#选择、判断题核心考点" class="headerlink" title="选择、判断题核心考点"></a>选择、判断题核心考点</h2><ul><li>原码，返码，补码的表示</li><li>进制转换（二进制、八进制、十进制、十六进制）</li><li>位运算</li><li>字符串相关的操作</li></ul><h2 id="大题核心考点-2"><a href="#大题核心考点-2" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="考点一：字符串操作"><a href="#考点一：字符串操作" class="headerlink" title="考点一：字符串操作"></a>考点一：字符串操作</h3><p>3 级对字符串的操作要求非常高，需要考生灵活掌握字符串的变换、拼接、求子串、判断回文等操作。</p><p>求子串可以用 string 类的 <code>substr(int pos, int len)</code> 函数。需要注意该函数的两个参数分别是起始下标和长度。</p><p>其中，判断回文的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isReverse</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[len-i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以真题 <a href="https://www.luogu.com.cn/problem/B4039">GESP202409 回文拼接</a> 为例，考生需要对字符串进行切分，然后分别判断是否是回文串。</p><p>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isReverse</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[len-i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                string s1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                string s2 = s.<span class="built_in">substr</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isReverse</span>(s1) &amp;&amp; <span class="built_in">isReverse</span>(s2)) &#123;</span><br><span class="line">                    ans = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该考点的相关真题：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3843">GESP202306 密码合规</a></li><li><a href="https://www.luogu.com.cn/problem/B3956">GESP202403 字母求和</a></li><li><a href="https://www.luogu.com.cn/problem/B4003">GESP202406 移位</a></li><li><a href="https://www.luogu.com.cn/problem/B4067">GESP202412 打印数字</a></li><li><a href="https://www.luogu.com.cn/problem/B3868">GESP202309 进制判断</a></li></ul><p>其中 <a href="https://www.luogu.com.cn/problem/B3868">GESP202309 进制判断</a> 看起来是考进制的规则，实际上也是考字符串的查找。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isRange</span><span class="params">(string s, string range)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">char</span> ch = s[i];</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;range.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == range[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == range.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;01&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;01234567&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;0123456789&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">isRange</span>(s, <span class="string">&quot;0123456789ABCDEF&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的练习：</p><ul><li><a href="https://www.luogu.com.cn/problem/B4088">B4088 CSP-X2020 山东 最大回文数</a></li></ul><h3 id="考点二：前缀和"><a href="#考点二：前缀和" class="headerlink" title="考点二：前缀和"></a>考点二：前缀和</h3><p>前缀和的计算技巧是：用一个累加变量来不停地更新前 N 个数的和，这样我们只需要用 O（N）的时间复杂度，就可以把所有的前缀和求出来。</p><p>参考题目：<a href="https://www.luogu.com.cn/problem/B4038">GESP202409 平衡序列</a></p><p>此题解法是：暴力测试，先计算出总和 tot ，然后看前缀和的两倍有没有可能等于 tot。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, v[<span class="number">10010</span>], tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            tot += v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; cnt*<span class="number">2</span>&lt;tot; ++i) &#123;</span><br><span class="line">            cnt += v[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt*<span class="number">2</span> == tot) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="考点三：位运算"><a href="#考点三：位运算" class="headerlink" title="考点三：位运算"></a>考点三：位运算</h3><p>考生需要熟悉二进制，以及数的位运算操作。</p><p>典型考题为：<a href="https://www.luogu.com.cn/problem/B4261">GESP202503 2025</a></p><p>此题的思路如下：因为 x 最大是 2025，而如果 y 需要影响 x 的运算，只能与 x 的 bit 位是 1 的位进行操作。所以 y 如果存在，则必定小于 2048。因为 2048 的二进制 1 的 bit 位已经超过 2025 的最高位了。所以直接枚举 1～2048 之间的答案即可。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2048</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; i) + (x | i) == <span class="number">2025</span>) &#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GESP-4-级"><a href="#GESP-4-级" class="headerlink" title="GESP 4 级"></a>GESP 4 级</h1><h2 id="大题核心考点-3"><a href="#大题核心考点-3" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>考点比较散，以下是历次考题的考点。</p><ul><li>GESP-202306 幸运数：模拟</li><li>GESP-202309 进制转换：进制转换</li><li>GESP-202309 变长编码：位操作</li><li>GESP-202312 小杨的字典：字符串操作</li><li>GESP-202312 田忌赛马：排序，模拟</li><li>GESP-202403 相似字符串：字符串操作</li><li>GESP-202403 做题：贪心</li><li>GESP-202406 黑白方块：枚举</li><li>GESP-202406 宝箱：枚举，二分</li><li>GESP-202409 黑白方块：枚举</li><li>GESP-202409 区间排序：排序</li><li>GESP-202412 Recamán：枚举</li><li>GESP-202412 字符排序：排序</li><li>GESP-202503 荒地开垦：枚举</li><li>GESP-202503 二阶矩阵：枚举</li><li>GESP-202509 排兵布阵：枚举 </li><li>GESP-202509 最长连续段：排序</li></ul><p>其中，比较常考的考点：</p><ul><li>枚举：考了 7 次。</li><li>排序：考了 4 次。</li><li>字符串操作：考了 2 次。</li></ul><h1 id="GESP-5-级"><a href="#GESP-5-级" class="headerlink" title="GESP 5 级"></a>GESP 5 级</h1><h2 id="大题核心考点-4"><a href="#大题核心考点-4" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>待补充</p><h2 id="GESP-202506-5级真题「奖品兑换」题解"><a href="#GESP-202506-5级真题「奖品兑换」题解" class="headerlink" title="GESP 202506 5级真题「奖品兑换」题解"></a>GESP 202506 5级真题「奖品兑换」题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><img src="/images/gesp202506-5-1.jpg" class=""><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>此题首先是不能暴力枚举的，因为 n 和 m 最大情况下是 <code>10^9</code>，这个数据规模，暴力枚举肯定会超时。</p><p>然后我们可能想到贪心，但实际可落地的贪心的策略总是有特殊情况。</p><p>最后，假如我们可以检查一个答案是否可行，我们就可以用二分答案+判定的方法求解。</p><p>二分还有一个要求，就是答案是单调递增的。我们可以想像，随着兑换券的递增，如果限定 n 的值不变，那 m 的值肯定是递增的。所以此题符合单调递增的条件。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>那么，对于一个可能的答案 k，我们怎么检查答案是否可行呢？</p><ul><li>我们先把 n 和 m 排序，让 n 是较大者，a 和 b 排序，让 a 是较大者</li><li>对于一份奖品，可以是 <code>n-a</code>, <code>m-b</code> 来获得，也可以是 <code>n-b</code>, <code>m-a</code> 来获得，我们让 <code>d=a-b</code></li><li>因为 a 是较大者，所以当更换兑换方式的时候，n 的值从<code>n-a</code>变成了<code>n-b</code>，相对来说，增加了 d，m 的值减少了 d</li></ul><p>所以：</p><ul><li>我们可以先用第一个兑换方法，把 k 个奖品换成 <code>c1=a*k</code> 张课堂优秀券, <code>c2=b*k</code> 张作业优秀券</li><li>如果 <code>c1 &lt;=n, c2 &lt;= m</code> 那这个答案 k 显然就是可以的。</li><li>但如果 <code>c1 &gt; n</code>，我们可以想到，把超额出来的兑换换成第二个兑换方法</li></ul><p>具体如何换呢？</p><ul><li>我们先计算超额的值，为 <code>c1-n</code></li><li>每次兑换可以让这个值少 d，所以需要换 <code>r=(c1-n)/d (向上取整)</code> 即 <code>r=(c1-n+d-1)/d</code>个</li><li>经过如上的兑换，c1 的值减少了 <code>d*r</code>，c2 的值增加了 <code>d*r</code></li></ul><p>最后需要注意，因为 <code>a*k</code> 的范围可能超过 int，所以需要把计算过程都用 long long 来保存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此题考查了：</p><ul><li>二分+判定的解法</li><li>向上取整的写法</li><li>数据范围的预估</li><li>时间复杂度的预估</li></ul><p>这还是非常综合的一道题。对于没想到二分的学生，也可以用贪心或者暴力枚举骗到不少分（估计 10-15 分），所以此题也有相当的区分度，各种能力的学生都可以拿到部分分数。</p><h3 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, m, a, b, d, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c1 = a*k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c2 = b*k;</span><br><span class="line">    <span class="keyword">if</span> (c1 &gt; n) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> r = (c1 - n + d - <span class="number">1</span>) / d;</span><br><span class="line">        c1 -= r*d;</span><br><span class="line">        c2 += r*d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c1 &lt;= n &amp;&amp; c2 &lt;=m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);       </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    d = a - b;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">test</span>(m)) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, m);</span><br><span class="line">            l = m+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GESP-6-级"><a href="#GESP-6-级" class="headerlink" title="GESP 6 级"></a>GESP 6 级</h1><h2 id="大题核心考点-5"><a href="#大题核心考点-5" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><ul><li><a href="https://www.luogu.com.cn/problem/P10109">P10109 GESP-202312 六级 工作沟通</a></li><li><a href="https://www.luogu.com.cn/problem/P13016">P13016 GESP-202506 六级 最大因数</a></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>包括 01 背包和完全背包：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3873">B3873  202309 六级 小杨买饮料</a></li><li><a href="https://www.luogu.com.cn/problem/P13015">P13015 202506 六级 学习小组</a></li><li><a href="https://www.luogu.com.cn/problem/P10721">P10721 202406 六级 计算得分</a></li></ul><p>基础动态规划：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10108">P10108 202312 六级 闯关游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P10376">P10376 202403 六级 游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P11246">P11246 202409 六级 小杨和整数拆分</a></li></ul><p>记忆化搜索：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10250">P10250 GESP样题 六级 下楼梯</a></li></ul><p>复杂贪心：</p><ul><li><a href="https://www.luogu.com.cn/problem/P11247">P11247 202409 六级 算法学习</a></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>树状数组：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3874">B3874 202309 六级 小杨的握手问题</a></li></ul><p>暴力枚举：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10377">P10377 202403 六级 好斗的牛</a></li></ul><p>模拟+高精度：</p><ul><li><a href="https://www.luogu.com.cn/problem/P11375">P11375 202412 六级 树上游走</a></li></ul><h2 id="相关练习题目"><a href="#相关练习题目" class="headerlink" title="相关练习题目"></a>相关练习题目</h2><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p>从 <a href="https://www.luogu.com.cn/problem/list?type=luogu&page=1&tag=139&orderBy=difficulty&order=asc">这儿</a> 可以获得洛谷上所有的背包相关题目，推荐练习的如下：</p><ul><li><a href="https://www.luogu.com.cn/problem/P1734">P1734 最大约数和</a></li><li><a href="https://www.luogu.com.cn/problem/P1507">P1507 NASA的食物计划</a></li><li><a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a></li><li><a href="https://www.luogu.com.cn/problem/P1060">P1060 NOIP 2006 普及组 开心的金明</a></li><li><a href="https://www.luogu.com.cn/problem/P1358">P1358 扑克牌</a></li><li><a href="https://www.luogu.com.cn/problem/P1877">P1877 HAOI2012 音量调节</a></li><li><a href="https://www.luogu.com.cn/problem/P1910">P1910 L 国的战斗之间谍</a></li><li><a href="https://www.luogu.com.cn/problem/P1926">P1926 小书童——刷题大军</a></li><li><a href="https://www.luogu.com.cn/problem/P1855">P1855 榨取kkksc03</a></li><li><a href="https://www.luogu.com.cn/problem/P2430">P2430 严酷的训练</a></li><li><a href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日</a></li><li><a href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包</a></li><li><a href="https://www.luogu.com.cn/problem/P2563">P2563 AHOI2001 质数和分解</a></li></ul><h1 id="GESP-7-级"><a href="#GESP-7-级" class="headerlink" title="GESP 7 级"></a>GESP 7 级</h1><h2 id="大题核心考点-6"><a href="#大题核心考点-6" class="headerlink" title="大题核心考点"></a>大题核心考点</h2><p>注：名称中的 A 表示第 1 题，B 表示第 2 题。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>背包：</p><ul><li><a href="https://www.luogu.com.cn/problem/P11377">P11377 202412-A 七级 武器购买</a></li><li><a href="https://www.luogu.com.cn/problem/P13018">P13018 202506-B 七级 调味平衡</a></li></ul><p>动态规划：</p><ul><li><a href="https://www.luogu.com.cn/problem/P10111">P10111 202312-B 七级 纸牌游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P11248">P11248 202409-A 七级 矩阵移动</a></li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul><li><a href="https://www.luogu.com.cn/problem/P10378">P10378 202403-A 七级 交流问题</a></li></ul><h3 id="枚举-DFS-BFS（在树或者图上）"><a href="#枚举-DFS-BFS（在树或者图上）" class="headerlink" title="枚举&#x2F;DFS&#x2F;BFS（在树或者图上）"></a>枚举&#x2F;DFS&#x2F;BFS（在树或者图上）</h3><ul><li><a href="https://www.luogu.com.cn/problem/P10110">P10110 202312-A 七级 商品交易</a></li><li><a href="https://www.luogu.com.cn/problem/P10379">P10379 202403-B 七级 俄罗斯方块</a></li><li><a href="https://www.luogu.com.cn/problem/P11249">P11249 202409-B 七级 小杨寻宝</a></li><li><a href="https://www.luogu.com.cn/problem/P11378">P11378 202412-B 七级 燃烧</a></li><li><a href="https://www.luogu.com.cn/problem/P11964">P11964 202503-A 七级 图上移动</a></li><li><a href="https://www.luogu.com.cn/problem/P14077">P14077 202509-A 七级 连通图</a></li></ul><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ul><li><a href="https://www.luogu.com.cn/problem/P14078">P14078 202509-B 七级 金币收集</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GESP-1-级&quot;&gt;&lt;a href=&quot;#GESP-1-级&quot; class=&quot;headerlink&quot; title=&quot;GESP 1 级&quot;&gt;&lt;/a&gt;GESP 1 级&lt;/h1&gt;&lt;h2 id=&quot;大题核心考点&quot;&gt;&lt;a href=&quot;#大题核心考点&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学总结：树状数组</title>
    <link href="https://blog.devtang.com/2025/04/26/teaching-notes-of-bit/"/>
    <id>https://blog.devtang.com/2025/04/26/teaching-notes-of-bit/</id>
    <published>2025-04-26T12:12:23.000Z</published>
    <updated>2025-07-06T06:14:15.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有些时候，题目给我们 N 个元素的序列，然后让我们求前缀和或者区间和。并且，题目还会动态地修改这个序列的值。如果我们每次暴力求解前缀和，时间复杂度会是 O（N），而使用树状数组，可以将查询前缀和的复杂度降低到 O(LogN)。</p><p>树状数组是挺不好教学的一个知识点。它需要以下前置知识：</p><ul><li>二进制表示法及熟练的位操作</li><li>前缀和的知识</li><li>树的基础知识</li><li>时间复杂度的估算</li></ul><p>在教学的时候，我们的教学顺序如下：</p><ul><li>先引入问题</li><li>lowbit 函数讲解</li><li>树状数组的结构特点</li><li>利用树状数组求前缀和的方法</li><li>怎么修改树状数组的值</li><li>如何初始化树状数组</li><li>增加值或替换值</li><li>二维的树状数组</li></ul><p>那么让我们来开始。</p><h2 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h2><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a> 是一道标准的树状数组问题：该题目给我们了一个数列，我们需要解决以下两个问题：</p><ul><li>数列的区间求和</li><li>更新某一个数（加上 x）</li></ul><p>我们很容易想到用暴力的方法来做此题。于是我们可以估计一下暴力的时间复杂度：</p><ul><li>数列的区间求和，时间复杂度 O（N）</li><li>更新某一个数，时间复杂度 O（1）</li></ul><p>题目中提到，求和的次数最多为 M 次，所以最坏情况下，时间复杂度为 <code>O(M*N)</code>。而由于 M 和 N 的最大范围为 <code>5*10^5</code>，所以最大运算次数高达 <code>(5*10^5) * (5*10^5) = 2500亿</code>次，而竞赛中估算 1000 万次的运算时间就接近 1 秒了，这个时间肯定会超时。</p><p>数列的区间求和有一个 O（1）的办法，就是提前求出前缀和。假如 Sum(i) 表示前 i 个数的和，那么区间 <code>(i,j]</code> 的和就可以通过 <code>Sum(j) - Sum(i)</code> 来得出。可惜的是，本题还有一个操作是更新某一个数。如果更新的是第一个数，那么整个前缀和数组 Sum 都需要更新，这样更新的时间复杂度会变成 O（N），最坏情况下会有 <code>O(M*N)</code>次更新，造成运算同样超时。</p><p>由此，我们需要一个更优秀的数据结构来解决这类问题，这就是树状数组。</p><h2 id="lowbit-函数"><a href="#lowbit-函数" class="headerlink" title="lowbit 函数"></a>lowbit 函数</h2><p>在讲解树状数组前，我们先学习一下 lowbit 函数。</p><p>lowbit 函数实现的功能是：求 x 的二进制最低位 <code>1</code> 以及后面的 <code>0</code> 组成的数。例如：</p><ul><li>8 (10 进制) &#x3D; 1000 (2 进制) ，则 lowbit(8) &#x3D; 8</li><li>9 (10进制）&#x3D; 1001（2 进制），则 lowbit(9) &#x3D; 1</li><li>10（10 进制）&#x3D; 1010（2 进制），则 lowbit(10) &#x3D; 2</li></ul><p>所以，我们需要找到目标数的二进制中的最后那个 <code>1</code> 的位置。有两种实现方式：</p><h3 id="方法一：x-x-1-x"><a href="#方法一：x-x-1-x" class="headerlink" title="方法一：x^(x-1) &amp; x"></a>方法一：<code>x^(x-1) &amp; x</code></h3><p>方法一相对比较好理解，我拿二进制数 <code>1100</code> 举例解释如下：</p><ul><li><code>(x-1)</code>的效果，相当于把二进制的最后一个<code>1</code>变成 <code>0</code>，比如某数 <code>1100</code> 减 <code>1</code>之后，就变成了 <code>1011</code></li><li>这个时候，如果我用 <code>x^(x-1)</code>,就会得到 <code>1100^1011=0111</code></li><li>最后，用 <code>x&amp;</code> 刚刚的 <code>x^(x-1)</code>，就相当于把<code>x</code>的最后一个<code>1</code>留下来了，前面的<code>1</code>都抹掉了：<code>1100 &amp; 0111 = 0100</code></li></ul><h3 id="方法二：x-x"><a href="#方法二：x-x" class="headerlink" title="方法二：x&amp;-x"></a>方法二：<code>x&amp;-x</code></h3><p>我们还是拿二进制数 <code>1100</code> 举例，由于负数是用补码表示，所以对于 <code>1100</code>，它的负数：</p><ul><li>原码为：<code>11100</code>(最高为 1 为符号位)</li><li>反码为：<code>10011</code>(反码符号位不变，其余位取反)</li><li>补码为：<code>10100</code>（补码&#x3D;反码+1）</li></ul><p>这样一操作，<code>x&amp;-x</code> 就等于 <code>01100 &amp; 10100 = 0100</code>，同样把最后的 <code>1</code> 取出来了。</p><p>在实现中，我们用方法二的更多，因为更短。参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组的定义"><a href="#树状数组的定义" class="headerlink" title="树状数组的定义"></a>树状数组的定义</h2><p>对于一个长度为 N 的序列，为了满足上面提到的更快的区间求和和更新的需求，我们可以构造一个树状数组。</p><p>树状数组（Binary Index Tree，简称 BIT）通过构造另一个长度为 N 的数组，来做到：</p><ul><li>区间求和，时间复杂度 <code>O(log N)</code></li><li>更新某一个数，时间复杂度 <code>O(log N)</code></li></ul><p>因为树状数组需要另外创建一个长度为 N 的数组，所以它的空间复杂度为<code>O(N)</code>。</p><p>我们先创建出这个数组 b ，然后再引入它的元素间的树状逻辑关系。</p><img src="/images/bit-1.jpg" class=""><p>我们有了数组 b，我们让数组 b 相对于原始序列 a，按如下的关系来保存范围和：</p><ul><li><code>b[1]</code> 保存 <code>a[1]</code>的值</li><li><code>b[2]</code> 保存区间 <code>[a[1], a[2]]</code> 的和</li><li><code>b[3]</code> 保存 <code>a[3]</code>的值</li><li>….省略若干行</li><li><code>b[8]</code> 保存区间 <code>[a[1], a[8]]</code> 的和</li></ul><img src="/images/bit-2.jpg" class=""><p>我们先不管如何做到的，先假设我们按上面的逻辑，初始化好了这个数组，那么它怎么能快速求出前缀和呢？</p><h2 id="树状数组求和"><a href="#树状数组求和" class="headerlink" title="树状数组求和"></a>树状数组求和</h2><p>我们假设要求 <code>a[1] ~ a[7]</code>的和，如下图所示，我们知道这段和满足：<code>Sum(7) = b[4] + b[6] + b[7]</code></p><img src="/images/bit-3.jpg" class=""><p>那么，我们观察一下 <code>b[4],b[6],b[7]</code> 这几个下标有什么特点：</p><ul><li>4 的二进制：0100</li><li>6 的二进制：0110</li><li>7 的二进制：0111</li></ul><p>如果结合上我们刚刚教的 lowbit 函数，我们就可以发现如下规律：</p><ul><li>4 的二进制：0100，<code>4 = 6 - lowbit(6)</code></li><li>6 的二进制：0110，<code>6 = 7 - lowbit(7)</code></li><li>7 的二进制：0111</li></ul><p>于是，如果我们要求 Sum(7)，就可以用 b[7] 开始累加，然后用 <code>7 - lowbit(7)</code> 得到 6，再用 <code>6 - lowbit(6)</code> 得到 4，最后 <code>4 - lowbit(4) = 0</code>，就结束整个求和累加过程。</p><p>把以上逻辑转换成代码，是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能要问了，这个求和都是从序列开头开始的，如果我们想求序列中间一段，比如从 x 到 y 的区间和，应该怎么办呢？这种情况，我们可以：</p><ul><li>用 query(y) 把从头到 y 位置的和求出来</li><li>用 query(x-1) 把从头到 x-1 位置的和求出来</li><li>然后相减 <code>query(y) - query(x-1)</code> 得到区间 <code>[x,y]</code> 的和</li></ul><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>树状数组也支持更新数据，像<a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a>题目中要求的那样，我们可以将某个数加上 x，这种情况应该如何更新数组呢？</p><p>我们以更新 <code>a[1]</code>为例，通过观察，我们发现涉及 <code>a[1]</code> 的数组有：<code>b[1],b[2],b[4],b[8]</code>，如下图所示：</p><img src="/images/bit-4.jpg" class=""><p>你有观察出来规律吗？这刚好是我们构建的这个树从叶子结点到根结点的一条路径。</p><p>那同样的问题来了，我们如何求解出<code>b[1],b[2],b[4],b[8]</code>这个路径呢？我们来观察一下：</p><ul><li>1 的二进制是：0001</li><li>2 的二进制是：0010, <code>2 = 1 + lowbit(1)</code></li><li>4 的二进制是：0100, <code>4 = 2 + lowbit(2)</code></li><li>8 的二进制是：1000, <code>8 = 4 + lowbit(4)</code></li></ul><p>我们再验证一个中间结点的更新，比如更新 a[5]，如下图所示：</p><img src="/images/bit-5.jpg" class=""><p>我们看看规则是不是一样：</p><ul><li>5 的二进制是 0101，</li><li>6 的二进制是 0110，<code>6 = 5 + lowbit(5)</code></li><li>8 的二进制是 1000，<code>8 = 6 + lowbit(6)</code></li></ul><p>至此，我们总结出更新方法：从数列的下标 idx 开始，不停地更新，并且用 <code>idx += lowbit(idx)</code> 获得下一个更新的下标，直到更新到下标超过上界（N）为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>最暴力的初始化方法是：我们假设原序列全是 0，这样树状数组的初始状态也全是 0 即可正常表达上面的树型关系。然后，我们把每一个 a 序列中的数用更新的方式来放入树状数组中。</p><p>至此，我们完成了例题<a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a>中的所有细节讨论，完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(500000+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，以上的这种初使化方法，时间复杂度为 <code>O(N*logN)</code>，如果数据刚好卡在初始化中，我们可以用以下这种方法来将初始化时间复杂度优化到 <code>O(N)</code>。</p><h2 id="初始化（优化）"><a href="#初始化（优化）" class="headerlink" title="初始化（优化）"></a>初始化（优化）</h2><p>为了讲明白这种初始化，我们需要观察树状数组 b 中的每个元素代表的数据范围有什么规律。为什么 b[5] 只代表 a[5] 一个元素，但是 b[8]代表的是<code>[a[1],a[8]]</code> 区间的 8 个元素的和 ？</p><img src="/images/bit-6.jpg" class=""><p>最终我们可以发现，一个数组元素代表的区间范围大小就是它的 lowbit 函数求出来的值。</p><p>例如：</p><ul><li>lowbit(5) &#x3D; 1，所以它只代表 a[5] 一个元素</li><li>lowbit(8) &#x3D; 8，所以它代表 <code>[a[1],a[8]]</code> 共 8 个元素</li><li>一个十进制数 88，其二进制为 <code>01011000</code>，<code>lowbit(88)=8</code>，所以它代表的区间为 8 个元素。</li></ul><p>进一步的，我们可以观察出，对于一个 b[x]，它代表的区间为<code>[x-lowbit(x)+1, x]</code>。</p><p>这对初始化有什么用呢？</p><ul><li>我们如果构建了数组 a 的前缀和数组 s，s[i]表示前 i 个数的和。</li><li>那么，我们就可以用前缀和数组 s 来初始化 b[x]。</li></ul><p>因为 b[x] 代表的区间和是<code>[x-lowbit(x)+1, x]</code>,所以：<code>b[i] = s[i] - s[i-lowbit(i)]</code></p><p>至此，我们可以将例题<a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a>的代码更新如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(500000+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += val;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        b[i] = s[i] - s[i-<span class="built_in">lowbit</span>(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管辖区间"><a href="#管辖区间" class="headerlink" title="管辖区间"></a>管辖区间</h2><p>上面讲到，树状数组中的元素 b[x] 管辖的区间和是<code>[x-lowbit(x)+1, x]</code>，因此，我们更能理解树状数组的更新逻辑：</p><ul><li>所谓的更新a[x]，就是把管辖区间涵盖 a[x] 的所有 b[x]都更新一遍。</li><li>那哪些 b[x]的管辖区间涵盖 a[x]呢？就是从二进制看，就是范围中有 lowbit(x) 的数。</li></ul><p>举例来说，如果我们要更新 a[2] 的值，lowbit(2) 的值是 0010，所以，我们要更新：</p><ul><li>b[2], 因为 2 的二进制是 0010，管辖区间是 <code>[1, 2]</code>，宽度是 2</li><li>b[4], 因为 4 的二进制是 0100，管辖区间是 <code>[1, 4]</code>，宽度是 4</li><li>b[8], 因为 8 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>再举一个例子，如果我们要更新 a[5] 的值，lowbit(5) 的值是 0001，所以我们要更新：</p><ul><li>b[5]，因为 5 的二进制是 0101，管辖区间是 <code>[5, 5]</code>，宽度是 1</li><li>b[6]，因为 6 的二进制是 0110，管辖区间是 <code>[5, 6]</code>，宽度是 2</li><li>b[8]，因为 8 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>再举一个例子，如果我们要更新 a[7] 的值，lowbit(7) 的值是 0001，所以我们要更新：</p><ul><li>b[7]，因为 7 的二进制是 0111，管辖区间是 <code>[7, 7]</code>，宽度是 1</li><li>b[8]，因为 8 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>通过上面的例子，我们可以看到，管辖区间在更新的过程中宽度是不断扩大的。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。</p><p>我们再从另一个角度来看管辖区间：我们把数状数组的第 1 个到第 56 个元素的二进制列出来，如下所示：</p><img src="/images/lowbit_list.jpg" class=""><p>我们可以观察到：bit 为 1 的位置越低，管辖的区域越小，所以：</p><ul><li>有一半管辖区域大小为 1 的数（图中为粉色）</li><li>剩下的一半，有一半管辖区域大小为 2 的数（图中为绿色）</li><li>再剩的一半，有一半管辖区域大小为 4 的数（图中为紫色）</li><li>再剩的一半，有一半管辖区域大小为 8 的数（图中为黄色）</li></ul><p>再看这些数的间隔：</p><ul><li>粉色的间隔是 2-1，每 2 个出现一次</li><li>绿色的间隔是 4-1，每 4 个出现一次</li><li>紫色的间隔是 8-1，每 8 个出现一次</li><li>黄色的间隔是 16-1，每 16 个出现一次</li></ul><p>所以，其实树状数组是把区间和数据按分治的思想进行了切分，这样可以快速求和。</p><p>另外，从管辖区域的角度考虑，每一个数在进行 lowbit 减运算的时候，得到的新数，一定和之前的区间不是重叠的。我们可以这样证明：</p><ul><li>每个元素 <code>b[x]</code> 管辖的区间和是<code>[x-lowbit(x)+1, x]</code></li><li>我们令 <code>y = x - lowbit(x)</code>, 则 <code>b[y]</code> 的管辖区间就是：<code>[y-lowbit(y)+1, y]</code>,即：<code>[y-lowbit(y)+1, x - lowbit(x)]</code></li><li>可以看到，这两个区间 <code>[y-lowbit(y)+1, x - lowbit(x)]</code> 和 <code>[x-lowbit(x)+1, x]</code>其实是相邻的。</li></ul><p>所以，每次减 lowbit(x) 的运算，其实是获得了其左侧相邻的一块区间的和。</p><p>我们来看一个查询和的例子，如果我们要求前缀和 sum(7)：</p><ul><li>我们先计算 b[7]，7 的二进制是 0111，管辖区间是 <code>[7, 7]</code>，宽度是 1</li><li>我们再计算 b[6]，6 的二进制是 0110，管辖区间是 <code>[5, 6]</code>，宽度是 2</li><li>我们再计算 b[4]，4 的二进制是 0100，管辖区间是 <code>[1, 4]</code>，宽度是 4</li></ul><p>我们从上面的例子可以看到：由于每次减掉的都是最小的一个 lowbit 位，所以左侧相邻的新区间一定更宽。所以求和过程中， <code>b[7],b[6],b[4]</code> 对应的管辖宽度从 1 到 2 再到 4.</p><p>我们再看一个前缀和 sum(9) 的例子：</p><ul><li>我们先计算 b[9], 9 的二进制是 1001，管辖区间是 <code>[9, 9]</code>，宽度是 1</li><li>我们再计算 b[8], 9 的二进制是 1000，管辖区间是 <code>[1, 8]</code>，宽度是 8</li></ul><p>和我们刚刚得到的结论相同：求和过程中，随着不断地减 lowbit(x)，获得的新区间更宽。</p><p>小结：</p><ul><li>树状数组中的元素 b[x] 管辖的区间和是<code>[x-lowbit(x)+1, x]</code></li><li>每次加 lowbit(x) 的过程，相当于在不断扩展管辖区间。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。</li><li>每次减 lowbit(x) 的过程，相当于在查找紧临 b[x] 管辖区间的一块新区间。这个新区间，宽度也是不断扩大的。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。</li></ul><h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p>有些时候，题目会让我们一次更新一段区间，这个时候，我们可以引入差分数组来替代原数组。</p><p>差分数组中的每一个元素，是原数组相邻两个数的差。</p><p>例如：</p><ul><li>原数组： <code>1,2,3,4,5,6</code></li><li>差分数组：<code>1,1,1,1,1,1</code></li></ul><p>我们对差分数组求前缀和，就可以还原出原数组。</p><p>这个时候，如果我们把原数组的第 3 个数到第 5 个数都加上 2，我们看看效果：</p><ul><li>原数组： <code>1,2,5,6,7,6</code></li><li>差分数组：<code>1,1,3,1,1,-1</code></li></ul><p>我们观察到，原数组的一个区间都加上 2 之后，在差分数组那里，只有第 3 个数和第 6 个数有变化，其它都没有变化。所以，如果我们用差分数组来代替原数组，就可以只更新两个数值来代表原来的范围更新。</p><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2</a>此题可以很好地练习差分数组与数状数组的结合运用，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 差分：</span></span><br><span class="line"><span class="comment"> *  - 假设 A 序列为原序列</span></span><br><span class="line"><span class="comment"> *  - 差分数列 C 为原序列每两个数之间的差</span></span><br><span class="line"><span class="comment"> *    - 即：c[i] = a[i] - a[i-1]</span></span><br><span class="line"><span class="comment"> *         c[1] = a[1]</span></span><br><span class="line"><span class="comment"> *         c[2] = a[2] - a[1]</span></span><br><span class="line"><span class="comment"> *         c[3] = a[3] - a[2]</span></span><br><span class="line"><span class="comment"> *  - 所以：</span></span><br><span class="line"><span class="comment"> *    - a[i] = sum(c[1]+c[2]+...c[i])</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对于本题，如果把数组变成差分数组：</span></span><br><span class="line"><span class="comment"> *  - [x,y] 每个数加上 k，等价于:</span></span><br><span class="line"><span class="comment"> *    - c[x] += k</span></span><br><span class="line"><span class="comment"> *    - c[y+1] -= k</span></span><br><span class="line"><span class="comment"> *  - 求第 a[x] 的值，等价于：</span></span><br><span class="line"><span class="comment"> *    - sum(c[1]+c[2]+...c[x])</span></span><br><span class="line"><span class="comment"> *    - 即求前缀和</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(500000+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN], c[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += v;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        c[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">add</span>(i, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y, k;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">add</span>(x, k);</span><br><span class="line">            <span class="built_in">add</span>(y+<span class="number">1</span>, -k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维的树状数组"><a href="#二维的树状数组" class="headerlink" title="二维的树状数组"></a>二维的树状数组</h2><p>刚刚讲到，对于一个 b[x]，它代表的区间为<code>[x-lowbit(x)+1, x]</code></p><p>那么对于一个二维的树状数组 b[x, y]，它代表的区间就是 <code>a(x-lowbit(x)+1, y-lowbit(y)+1) - a(x, y)</code> 形成的矩阵的总和。如下图所示：</p><img src="/images/bit-7.jpg" class=""><p>对于二维的树状数组，更新就需要用两层的循环了。示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">lowbit</span>(j)) &#123;</span><br><span class="line">      c[i][j] += v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询前缀和同样需要用循环，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y; j &gt; <span class="number">0</span>; j -= <span class="built_in">lowbit</span>(j)) &#123;</span><br><span class="line">      res += c[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果题目要求区间和，则需要用容斥原理来求解，这里不再展开介绍。</p><h2 id="用树状数组求逆序对"><a href="#用树状数组求逆序对" class="headerlink" title="用树状数组求逆序对"></a>用树状数组求逆序对</h2><p>什么是逆序对？逆序对是指一个序列中，<code>a[i] &gt; a[j]</code> 且 <code>i &lt; j</code> 的有序对。</p><p>比如一个序列是 <code>3 2 1</code>，它的逆序对就有：<code>3 2</code>,<code>3 1</code>,<code>2 1</code> 三组。</p><p>树状数组如何和逆序对的数量扯上关系呢？</p><p>拿序列 <code>3 2 1</code> 举例，我们知道，树状数组是可以用前缀和的。如果我们：</p><ul><li>假设序列初始情况下为全 0</li><li>当处理第一个数 3 的时候，我们让树状数组的下标 3 加 1：<code>update(3, 1)</code>，同时记录插入了 1 个数</li><li>当处理第二个数 2 的时候，我们统计小于等于 2 的前缀和：query(2)，然后拿总数减 query(2)，得到大于 2 的数字数量</li><li>这个数量，就是当 2 被处理的时候，前面有一共多少个数大于 2，即与 2 能够组成逆序对的数量</li></ul><p>例题：<a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></p><p>在此题中，我们先要解决两个问题，才能借用上面的思想：</p><p>问题1、题中的数据范围太大，我们如何解决?</p><p>答案：我们可以用离散化的思想，把 <code>2 10000 1</code> 变成 <code>2 3 1</code>，因为逆序对是统计相对大小，所以这样更改之后，逆序对的数量是不变的。</p><p>具体如何离散化呢？我们可以将数据依次标记上编号，然后排序。例如：</p><ul><li>原始序列为 <code>100 200 50</code>, 我们把它分别标上编号 <code>(100,1), (200,2), (50,3)</code></li><li>然后我们将数值排序，得到：<code>(50,3), (100,1), (200,2)</code></li><li>然后，我们再将新的序列赋上从 1 开始的编号：<code>(50,3,1), (100,1,2), (200,2,3)</code></li><li>然后，我们再将序列按原来的编号(第 2 个数字）排序，得到 <code>(100,1,2), (200,2,3), (50, 3, 1)</code></li><li>至此，我们转换得到了新的编号 <code>2,3,1</code></li></ul><p>因为 N 最多是 <code>5*10^5</code>，所以离散化之后，树状数组的大小也缩减到了 <code>5*10^5</code></p><p>在实现的时候，我们可以用结构体来保存上面的三元组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> origin_idx;</span><br><span class="line">    <span class="type">int</span> next_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>问题2、如果有两个相等的元素，会不会计算错误？</p><p>我们假设元素是 <code>200 300 200</code>,按我们刚刚的操作：</p><ul><li>先标号，得到 <code>(200,1) (300,2) (200,3)</code></li><li>再排序，得到 <code>(200,1) (200,3) (300,2)</code></li><li>再标号，得到 <code>(200,1,1) (200,3,2) (300,2,3)</code></li><li>再排序，得到 <code>(200,1,1) (300,2,3) (200,3,2)</code></li><li>最后序列是 <code>1,3,2</code></li></ul><p>这种是没问题的，但是，如果我们排序的时候不是用的稳定排序，把第二个 200 排到了前面，就会得到 <code>2,3,1</code>，这样逆序对就会多一个 <code>2 1</code>，而这本来是不存在的。</p><p>所以，为了解决这个问题，我们可以用稳定排序<code>stable_sort</code>，或者保证排序的时候，值相同的情况下，标号大的在后面。</p><p>以下是完整的参考程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (int)(5*1e5+10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> origin_idx;</span><br><span class="line">    <span class="type">int</span> next_idx;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[MAXN];</span><br><span class="line"><span class="type">int</span> n,c[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp1</span><span class="params">(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp2</span><span class="params">(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.origin_idx &lt; b.origin_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x&amp;-x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a&lt;=n) &#123;</span><br><span class="line">        c[a]+=v;</span><br><span class="line">        a+=<span class="built_in">lowbit</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a) &#123;</span><br><span class="line">        ret += c[a];</span><br><span class="line">        a -= <span class="built_in">lowbit</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].v;</span><br><span class="line">        a[i].origin_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stable_sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n, comp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i) </span><br><span class="line">        a[i].next_idx = i;</span><br><span class="line">    <span class="built_in">stable_sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n, comp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i].next_idx, <span class="number">1</span>);</span><br><span class="line">        ans += i - <span class="built_in">query</span>(a[i].next_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关练习题目"><a href="#相关练习题目" class="headerlink" title="相关练习题目"></a>相关练习题目</h2><p>文章中涉及的例题：</p><ul><li><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组 1</a></li><li><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组 2</a></li><li><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></li></ul><p>练习题：</p><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/B3874">B3874 小杨的握手问题</a></td><td>GESP 202309 六级真题</td></tr><tr><td>-</td><td>-</td></tr></tbody></table><h3 id="B3874-小杨的握手问题"><a href="#B3874-小杨的握手问题" class="headerlink" title="B3874 小杨的握手问题"></a><a href="https://www.luogu.com.cn/problem/B3874">B3874 小杨的握手问题</a></h3><p>解题思路：</p><ul><li>把学号为 a 的学生进入教室的行为，转化为第 a 个序列元素的值加 1。</li><li>这样，找出小于 a 的学生数量，就等价于求序列前 a-1 个元素的前缀和。</li><li>利用数状数组，就可以快速求前缀和了。</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数状数组求逆序对。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN int(3e5+10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, b[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;-a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt;= n) &#123;</span><br><span class="line">        b[idx] += v;</span><br><span class="line">        idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> range)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (range) &#123;</span><br><span class="line">        ret += b[range];</span><br><span class="line">        range -= <span class="built_in">lowbit</span>(range);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="comment">// 将学号下标从 0 开始改到 1 开始</span></span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">        ans += <span class="built_in">query</span>(a - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(a, <span class="number">1</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;有些时候，题目给我们 N 个元素的序列，然后让我们求前缀和或者区间和。并且，题目还会动态地修改这个序列的值。如果我们每次暴力求解前缀和，时间</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学总结：深度优先搜索（DFS）</title>
    <link href="https://blog.devtang.com/2025/04/13/teaching-notes-of-dfs/"/>
    <id>https://blog.devtang.com/2025/04/13/teaching-notes-of-dfs/</id>
    <published>2025-04-13T07:27:30.000Z</published>
    <updated>2025-05-20T14:52:22.139Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先搜索（DFS）是学生学习算法的第一道门槛，因为它的主要形式是递归。而递归中需要将搜索的相关信息通过参数传递，这一点需要学生深刻理解 DFS。</p><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>DFS 有比较标准的模版，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> <span class="comment">// pt 表示层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="comment">// 处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (枚举这个层的所有可选项) &#123;</span><br><span class="line">        <span class="keyword">if</span>（这个选项是合法的）&#123;</span><br><span class="line">            标记这个选项（保存现场）</span><br><span class="line">            <span class="built_in">dfs</span>(pt+<span class="number">1</span>); </span><br><span class="line">            取消标记（恢复现场）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将运用该模版，完成后面的题目。</p><h2 id="递归的深度"><a href="#递归的深度" class="headerlink" title="递归的深度"></a>递归的深度</h2><p>递归的时候，程序会占用栈空间来保存函数的环境变量。根据编译器以及编辑参数的不同，栈空间的大小也不同。通常情况下，竞赛中的编译器设定的栈空间为 8M 或者 16M。</p><p>假如，我们在一个递归函数中使用了 10 个 int 变量，那么每个递归函数就需要 <code>4*10=40</code>字节的栈空间。8M 一共可以支持 <code>8*1000*1000/40=200000</code>层调用。考虑到栈空间还需要保存当前函数执行的地址等变量，可供支持的调用层数会更小一点。</p><p>同学们也可以做如下的递归函数栈空间的测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> test[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的本地，以上程序调用了约 13 万次后栈溢出。为了保险，我们在比赛中如果调用深度小于 1 万层，那应该是稳妥的；否则我们需要考虑是否用别的解法来解题。</p><h2 id="教学和练习题目"><a href="#教学和练习题目" class="headerlink" title="教学和练习题目"></a>教学和练习题目</h2><table><thead><tr><th>题目名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1036">P1036 选数</a></td><td>NOIP 2002 普及组</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1219">P1219 八皇后 Checker Challenge</a></td><td>USACO 1.5</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1596">P1596 Lake Counting S</a></td><td>USACO10OCT</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2036">P2036 PERKET</a></td><td>COCI 2008&#x2F;2009 #2</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12139">P12139 黑白棋</a></td><td>蓝桥杯 2025 省 A，写起来较繁琐</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫</a></td><td>标准的 DFS</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题</a></td><td></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1019">P1019 单词接龙</a></td><td>NOIP 2000 提高组</td></tr><tr><td></td><td></td></tr></tbody></table><p>P7200<br>P10483</p><h3 id="P1219-八皇后-Checker-Challenge"><a href="#P1219-八皇后-Checker-Challenge" class="headerlink" title="P1219 八皇后 Checker Challenge"></a><a href="https://www.luogu.com.cn/problem/P1219">P1219 八皇后 Checker Challenge</a></h3><p>这是八皇后的变种，N 皇后问题。可以作为基础练习。具体解法是：</p><ul><li>我们用变量 <code>v[15]</code> 表示每个皇后的列值。</li><li>对于新放入的皇后，我们依次检查它与前面的皇后是否在一条斜线上。检查方法是看其“横坐标差”与“纵坐标差”是否相同。检查函数如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(v[i] - v[pt]) == <span class="built_in">abs</span>(i - pt)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[<span class="number">15</span>], ans;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(v[i] - v[pt]) == <span class="built_in">abs</span>(i - pt)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i]==<span class="literal">false</span>) &#123;</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">            v[pt] = i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(pt)) <span class="built_in">dfs</span>(pt + <span class="number">1</span>);</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1036-选数"><a href="#P1036-选数" class="headerlink" title="P1036 选数"></a><a href="https://www.luogu.com.cn/problem/P1036">P1036 选数</a></h3><p>此题需要从小到大取数求和，然后再判断是否是素数。用递归的方式来进行枚举。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, tot, ans;</span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>], p[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= v; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v%i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == k+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(tot)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 每一层都必须取比前一层更大的下标，防止重复取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p[pt<span class="number">-1</span>]+<span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[pt] = i;</span><br><span class="line">            tot += a[i];</span><br><span class="line">            <span class="built_in">dfs</span>(pt+<span class="number">1</span>);</span><br><span class="line">            tot -= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1596-Lake-Counting-S"><a href="#P1596-Lake-Counting-S" class="headerlink" title="P1596 Lake Counting S"></a><a href="https://www.luogu.com.cn/problem/P1596">P1596 Lake Counting S</a></h3><p>此题既可以用 DFS，也可以用 BFS。考虑到 N 和 M 最大值为 100，所以递归的层次最多为 1 万层，所以我们可以试试 DFS。</p><p>以下是参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> tu[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> movex[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    tu[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + movex[i];</span><br><span class="line">        <span class="type">int</span> ny = y + movey[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m </span><br><span class="line">            || tu[nx][ny] != <span class="string">&#x27;W&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; tu[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tu[i][j] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2036-PERKET"><a href="#P2036-PERKET" class="headerlink" title="P2036 PERKET"></a><a href="https://www.luogu.com.cn/problem/P2036">P2036 PERKET</a></h3><p>因为 N 最多为 10，每种食材可以选或者不选两种情况，所以最多情况数为 <code>2^10=1024</code> 种。搜索时间满足要求。</p><p>所以，此题用 DFS 可以非常方便解决。在搜索的时候，我们可以将食材的相关信息带到 DFS 函数的参数中，方便最后答案的求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[<span class="number">11</span>], b[<span class="number">11</span>], v[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pt: 当前处理到的食材</span></span><br><span class="line"><span class="comment"> * cnt: 当前选中的食材数量</span></span><br><span class="line"><span class="comment"> * ss: 当前选中的食材的总酸度</span></span><br><span class="line"><span class="comment"> * bb: 当前选中的食材的总甜度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt, <span class="type">int</span> cnt, <span class="type">int</span> ss, <span class="type">int</span> bb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(ss - bb));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[pt] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(pt + <span class="number">1</span>, cnt + <span class="number">1</span>, ss * s[pt], bb + b[pt]);</span><br><span class="line">    v[pt] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(pt + <span class="number">1</span>, cnt, ss, bb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i] &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P12139-黑白棋"><a href="#P12139-黑白棋" class="headerlink" title="P12139 黑白棋"></a><a href="https://www.luogu.com.cn/problem/P12139">P12139 黑白棋</a></h3><p>此题是搜索题，需要在中间尽可能检查状态来剪枝，以节省搜索次数。</p><p>题目有三类限制，分别可以用在不同的剪枝环节。</p><p>限制一：在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（即为 3）。</p><ul><li>我们可以对每一行记录黑子和白子的数量，如果某一行或某一列的一种颜色达到 3，后面则不能用这个颜色。</li></ul><p>限制二：不能有超过两个相同颜色的棋子连续排列。</p><ul><li>我们可以在当前落子的时候，检查它的左边和上面连续的几个格子，看是否有 3 个相同的子。</li></ul><p>限制三：行列唯一性</p><ul><li>可以放到最后检查。</li></ul><p>另外，这个棋盘有几个位置已经设定了值，我们需要标记下来，搜索的时候跳过对这些位置的尝试，但需要在这些位置做合法性检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row_cnt[<span class="number">6</span>][<span class="number">2</span>], col_cnt[<span class="number">6</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> tu[<span class="number">7</span>][<span class="number">7</span>], mark[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（即为 3）</span></span><br><span class="line">    <span class="keyword">if</span> (row_cnt[r][<span class="number">1</span>] &gt; <span class="number">3</span> || row_cnt[r][<span class="number">0</span>] &gt; <span class="number">3</span> || col_cnt[c][<span class="number">1</span>] &gt; <span class="number">3</span> || col_cnt[c][<span class="number">0</span>] &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能有超过两个相同颜色的棋子连续排列</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r<span class="number">-1</span>][c] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r<span class="number">-2</span>][c] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r<span class="number">-1</span>][c] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r<span class="number">-2</span>][c] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r][c<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; tu[r][c<span class="number">-2</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tu[r][c] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r][c<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; tu[r][c<span class="number">-2</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行列唯一性检查</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">final_check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; row_set, col_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            v = v * <span class="number">10</span> + (tu[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        row_set.<span class="built_in">insert</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row_set.<span class="built_in">size</span>() != <span class="number">6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            v = v * <span class="number">10</span> + (tu[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        col_set.<span class="built_in">insert</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (col_set.<span class="built_in">size</span>() != <span class="number">6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = tu[r][c];</span><br><span class="line">    row_cnt[r][ch - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    col_cnt[c][ch - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(r, c)) &#123;</span><br><span class="line">        <span class="type">int</span> nr = r;</span><br><span class="line">        <span class="type">int</span> nc = c + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nc == <span class="number">6</span>) &#123;</span><br><span class="line">            nr++;</span><br><span class="line">            nc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(nr, nc);</span><br><span class="line">    &#125;</span><br><span class="line">    row_cnt[r][ch - <span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">    col_cnt[c][ch - <span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">final_check</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    cout &lt;&lt; tu[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 因为只有一个合法解，所以找到答案就退出</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mark[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        tu[r][c] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">try_dfs</span>(r, c);</span><br><span class="line">        tu[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">try_dfs</span>(r, c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tu[r][c] = mark[r][c];</span><br><span class="line">        <span class="built_in">try_dfs</span>(r, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="built_in">sizeof</span>(mark));</span><br><span class="line">    mark[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    mark[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">0</span>][<span class="number">3</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">1</span>][<span class="number">3</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">2</span>][<span class="number">4</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">2</span>][<span class="number">5</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">4</span>][<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    mark[<span class="number">4</span>][<span class="number">5</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    mark[<span class="number">5</span>][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    mark[<span class="number">5</span>][<span class="number">4</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1605-迷宫"><a href="#P1605-迷宫" class="headerlink" title="P1605 迷宫"></a><a href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫</a></h3><p>用 DFS 来枚举，但需要标记走过的路。</p><ul><li>因为最多只有 5x5&#x3D;25 个格子，所以递归的深度最大只有 25，不存在溢出情况。</li><li>因为有陷阱（不能走）和起点终点（不能重复走），所以我们假设平均每次有 2 条支路，<br>整个的最坏情况估计只有 <code>2^23=8388608</code> 次，所以也不会超时。</li></ul><p>一些陷阱：</p><ul><li>终点可能也有障碍物，这个时候始终就到不了。</li><li>起点在走之前需要标记，否则会重复走。</li></ul><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 - 空地</span></span><br><span class="line"><span class="comment">// 1 - 障碍物</span></span><br><span class="line"><span class="type">int</span> tu[<span class="number">6</span>][<span class="number">6</span>], n, m, t, sx, sy, ex, ey, ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> movex[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> movey[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tox = x + movex[i];</span><br><span class="line">        <span class="type">int</span> toy = y + movey[i];</span><br><span class="line">        <span class="keyword">if</span> (tox &gt;=<span class="number">1</span> &amp;&amp; tox&lt;=n &amp;&amp; toy&gt;=<span class="number">1</span> &amp;&amp; toy&lt;=m &amp;&amp; tu[tox][toy]!=<span class="number">1</span>)&#123;</span><br><span class="line">            tu[tox][toy]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(tox, toy);</span><br><span class="line">            tu[tox][toy]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        tu[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tu[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(sx, sy);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P2404-自然数的拆分问题"><a href="#P2404-自然数的拆分问题" class="headerlink" title="P2404 自然数的拆分问题"></a><a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题</a></h3><p>DFS，有两个技巧：</p><ul><li>保证后面的数 &gt;&#x3D; 前面的数。</li><li>让每个数必须小于 n，这样不会出现 <code>n=n</code> 这种等式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, tot, v[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tot == n) &#123;</span><br><span class="line">        cout &lt;&lt; v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; pt; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v[pt<span class="number">-1</span>]; tot + i &lt;=n &amp;&amp; i &lt; n ; ++i) &#123;</span><br><span class="line">        tot += i;</span><br><span class="line">        v[pt] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(pt+<span class="number">1</span>);</span><br><span class="line">        tot -= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先搜索（DFS）是学生学习算法的第一道门槛，因为它的主要形式是递归。而递归中需要将搜索的相关信息通过参数传递，这一点需要学生深刻理解 DFS。&lt;/p&gt;
&lt;h2 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学总结：STL</title>
    <link href="https://blog.devtang.com/2025/04/12/cspj-notes-of-stl/"/>
    <id>https://blog.devtang.com/2025/04/12/cspj-notes-of-stl/</id>
    <published>2025-04-12T14:00:46.000Z</published>
    <updated>2025-08-09T22:42:31.754Z</updated>
    
    <content type="html"><![CDATA[<p>STL 库是 C++ 语言的标准库，我们在比赛中主要用到的有如下内容。</p><h2 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a><a href="https://zh.cppreference.com/w/cpp/string/basic_string">string 类</a></h2><ul><li>substr</li><li>find</li><li>replace</li><li>insert</li><li>erase</li><li>c_str</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a><a href="https://zh.cppreference.com/w/cpp/container">容器</a></h2><ul><li>pair</li><li>vector</li><li>deque</li><li>list</li><li>stack</li><li>queue</li><li>priority_queue</li><li>map</li><li>unordered_map</li><li>set</li><li>unordered_set</li></ul><h2 id="算法库"><a href="#算法库" class="headerlink" title="算法库"></a><a href="https://zh.cppreference.com/w/cpp/algorithm">算法库</a></h2><table><thead><tr><th>函数</th><th>调用示意</th><th>说明</th></tr></thead><tbody><tr><td>sort</td><td><code>sort(v.begin(), v.end())</code></td><td>快速排序</td></tr><tr><td>stable_sort</td><td><code>stable_sort(v.begin(), v.end())</code></td><td>稳定排序</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/algorithm/unique">unique</a></td><td><code>unique(v.begin(), v.end())</code></td><td>去重，返回的是去重后的元素末地址。可以结合 erase 函数来把多余数据删除。参考代码：<code>v.erase(unique(v.begin(), v.end()), v.end());</code></td></tr><tr><td>next_permutation</td><td><code>next_permutation(v, v+n)</code></td><td>返回全排列的下一个值，当没有下一个排列时，函数返回 false</td></tr><tr><td>prev_permutation</td><td><code>prev_permutation(v, v+n)</code></td><td>返回全排列的上一个值，当没有上一个排列时，函数返回 false</td></tr><tr><td>nth_element</td><td><code>nth_element(v.begin(), v.begin() + k, v.end()),</code></td><td>函数执行后，v.begin()+k 位置的数为排序后的最终位置，即左边的数都小于它，后面的数都大于它</td></tr><tr><td>lower_bounds</td><td><code>lower_bounds(v, v+n, a)</code></td><td>查找大于或等于 a 的第一个位置，如果没找到则返回 end()</td></tr><tr><td>upper_bounds</td><td><code>upper_bounds(v, v+n, a)</code></td><td>查找大于 a 第一个位置，如果没找到则返回 end()</td></tr><tr><td><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">equal_range</a></td><td><code>equal_range(v, v+n, a)</code></td><td>equal_range 返回一个 pair，<code>first</code> 元素是查找到的匹配 a 值的左边界，<code>second</code> 元素是匹配到的 a 值的右边界，边界为左闭右开原则。当 <code>first == second</code> 的时候，相当于没找到目标值</td></tr><tr><td>__gcd</td><td><code>__gcd(a, b)</code></td><td>返回 a 和 b 的最大公约数</td></tr><tr><td>reverse</td><td><code>reverse(v.begin(), v.end())</code></td><td>将原序列逆序</td></tr><tr><td>min_element</td><td><code>min_element(v.begin(), v.end())</code></td><td>返回的是地址，如果想要值，可以用 <code>*</code> 获得对应下标的值，如果想获得下标，可以让它减去 v.begin()</td></tr><tr><td>max_element</td><td><code>max_element(v.begin(), v.end())</code></td><td>返回的是地址，如果想要值，可以用 <code>*</code> 获得对应下标的值，如果想获得下标，可以让它减去 v.begin()</td></tr><tr><td>accumulate</td><td><code>accumulate(v.begin(), v.end(), 0);</code></td><td>第三个参数是初始值</td></tr></tbody></table><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><table><thead><tr><th>题号</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P1996">P1996 约瑟夫问题</a></td><td>适合用 list</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3613">P3613 寄包柜</a></td><td>适合用 map 和 pair</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4387">P4387 验证栈序列</a></td><td>适合用 stack</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1540">P1540 机器翻译</a></td><td>NOIP 2010 提高组，适合用 vector 以及 STL 的 find 算法</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式</a></td><td>适合练习 stack</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2058">P2058 海港</a></td><td>NOIP 2016 普及组，练习桶和队列</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P2234">P2234 营业额统计</a></td><td>练习 set 和 <code>lower_bound</code> 函数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4305">P4305 不重复数字</a></td><td>可以练习 <code>unordered_map</code> 以及对比 cin 和 scanf 的速度差别</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1571">P1571 眼红的Medusa</a></td><td>练习 map 或 set</td></tr></tbody></table><h3 id="P4387-验证栈序列"><a href="#P4387-验证栈序列" class="headerlink" title="P4387 验证栈序列"></a><a href="https://www.luogu.com.cn/problem/P4387">P4387 验证栈序列</a></h3><p>解法：把 A 数组中的元素住栈里面 push，然后如果栈顶元素和 B 数组的当前元素相同，就 pop，同时 B 数组的当前元素后移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, a[<span class="number">100010</span>], b[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() == b[idx]) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1540-机器翻译"><a href="#P1540-机器翻译" class="headerlink" title="P1540 机器翻译"></a><a href="https://www.luogu.com.cn/problem/P1540">P1540 机器翻译</a></h3><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> m, n, t, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), t) == v.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果不在内存中</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(t); </span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() &gt; m) </span><br><span class="line">            v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a><a href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式</a></h3><p>表达式计算:</p><ul><li>不停读入。</li><li>如果读到数字，就和之前的数字拼接：<code>a = a * 10 + ch - &#39;0&#39;</code></li><li>如果读到 <code>.</code> 就压栈</li><li>如果读到运算符，就出栈两个数进行运算，结果再压栈</li><li>如果读到 <code>@</code> 结束</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> a, v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;@&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp;  ch &lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            a = a*<span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(a);</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v1 + v2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v2 - v1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v1 * v2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            v1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); v2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(v2 / v1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2058-海港"><a href="#P2058-海港" class="headerlink" title="P2058 海港"></a><a href="https://www.luogu.com.cn/problem/P2058">P2058 海港</a></h3><p>解法：用一个队列记录所有 24 小时内的船。用一个桶记录每个国家的乘客数量。</p><ul><li>每次有新船入队列的时候，更新桶。如果桶更新前是 0，则 <code>ans++</code></li><li>每次新船入队列后，检查最早的队列，如果超24 小时，则出队</li><li>出队的时候，更新桶，如果桶的数量减为 0，则 <code>ans--</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶，记录每个国家的乘客数量</span></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">100010</span>], n, t, ans;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Node a;</span><br><span class="line">        cin &gt;&gt; a.t &gt;&gt; a.len;</span><br><span class="line">        a.v.<span class="built_in">resize</span>(a.len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.len; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; a.v[j];</span><br><span class="line">            <span class="keyword">if</span> (cnt[a.v[j]] == <span class="number">0</span>) ans++;</span><br><span class="line">            cnt[a.v[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(a);</span><br><span class="line">        <span class="type">int</span> <span class="type">min_t</span> = a.t - <span class="number">86400</span>;</span><br><span class="line">        <span class="comment">// 检查出列</span></span><br><span class="line">        a = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">while</span> (a.t &lt;= <span class="type">min_t</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.len; ++j) &#123;</span><br><span class="line">                cnt[a.v[j]]--;</span><br><span class="line">                <span class="keyword">if</span> (cnt[a.v[j]] == <span class="number">0</span>) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            a = q.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2234-营业额统计"><a href="#P2234-营业额统计" class="headerlink" title="P2234 营业额统计"></a><a href="https://www.luogu.com.cn/problem/P2234">P2234 营业额统计</a></h3><p>把营业额往 set 里面放，这样数据就是有序的。然后用 <code>lower_bound</code> 查找大于等于 x 的值。</p><ul><li>如果找到了，那么波动就是 0</li><li>如果没找到，比较当前位置和上一个位置与 x 的差，取较小那个；同时插入 x</li></ul><p>取上一个位置的时候要处理一下边界，如果是在 <code>s.begin()</code>位置的话就不用处理了。</p><p>取当前位置的时候要处理一下，看看是不是在 <code>s.end()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> n, x, ans;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    ans = x;</span><br><span class="line">    s.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        it = s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (it != s.<span class="built_in">end</span>() &amp;&amp; *it == x) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> diff = INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(*it-x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                it--;</span><br><span class="line">                diff = <span class="built_in">min</span>(diff, <span class="built_in">abs</span>(*it-x));</span><br><span class="line">            &#125;</span><br><span class="line">            ans += diff;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STL 库是 C++ 语言的标准库，我们在比赛中主要用到的有如下内容。&lt;/p&gt;
&lt;h2 id=&quot;string-类&quot;&gt;&lt;a href=&quot;#string-类&quot; class=&quot;headerlink&quot; title=&quot;string 类&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
  <entry>
    <title>CSPJ 教学思考：数学题</title>
    <link href="https://blog.devtang.com/2025/04/12/cspj-notes-of-math-problems/"/>
    <id>https://blog.devtang.com/2025/04/12/cspj-notes-of-math-problems/</id>
    <published>2025-04-12T13:40:39.000Z</published>
    <updated>2025-06-22T02:07:25.809Z</updated>
    
    <content type="html"><![CDATA[<p>数学题是信息学竞赛中重要的一类题目，通常包括几何、数论、容斥原理等。</p><p>本文将相关的题目归纳整理，用于教学。</p><h2 id="质数相关"><a href="#质数相关" class="headerlink" title="质数相关"></a>质数相关</h2><h3 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h3><p>此算法是很多数学相关题目的基础，在 GESP 二级中也有涉及。例如：<a href="https://www.luogu.com.cn/problem/B3840">B3840 找素数</a>。</p><p>其核心代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;=a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初学者在写的时候，要注意 <code>i*i</code> 与 <code>a</code> 的比较是小于等于。</p><h3 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h3><p>质因数分解的方法是从 2 开始试商，如果发现能整除，就把被除数中该因数去掉，关键代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (N % i == <span class="number">0</span>) N /= i;</span><br></pre></td></tr></table></figure><p>这样经过几轮下来，N 的值会变得很小，最后 N 如果不为 1，N 就是最后一个质因数。</p><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime_facs</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N % i == <span class="number">0</span>) &#123;  </span><br><span class="line">      <span class="keyword">while</span> (N % i == <span class="number">0</span>) N /= i;</span><br><span class="line">      result.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (N != <span class="number">1</span>) &#123;  <span class="comment">// 说明再经过操作之后 N 留下了一个素数</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(N);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题：</p><ul><li><a href="https://www.luogu.com.cn/problem/B3969">B3969 GESP202403 五级 B-smooth 数</a></li><li><a href="https://www.luogu.com.cn/problem/P10720">P10720 GESP202406 五级 小杨的幸运数字</a></li></ul><p><a href="https://www.luogu.com.cn/problem/B3969">B3969 GESP202403 五级 B-smooth 数</a> 的参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, b, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxPrime</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v%i == <span class="number">0</span>)&#123;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, i);</span><br><span class="line">            <span class="keyword">while</span> (v%i == <span class="number">0</span>) v/=i; <span class="comment">// 把 v 的值缩小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, v);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">getMaxPrime</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= b) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><h3 id="P2241-统计方形"><a href="#P2241-统计方形" class="headerlink" title="P2241 统计方形"></a><a href="https://www.luogu.com.cn/problem/P2241">P2241 统计方形</a></h3><p>本题解法：每个矩形（包括正方形）都可以由一段左边线段和一段上边线段确定。因此，我们只需要枚举所有可能的线段。</p><p>对于一个长是 N 宽是 M 的棋盘。</p><ul><li>左边的线段长度为 1 的有 N 个，长度为 2 的有 N-1 个，…长度为 N 的有 1 个。</li><li>上边的线段长度为 1 的有 M 个，长度为 2 的有 M-1 个，…长度为 M 的有 1 个。</li></ul><p>所以:</p><ul><li>左边的线段一共有 <code>（1+2+3+...+N）= N*(N+1)/2</code> 个。</li><li>上边的线段一共有 <code>（1+2+3+...+M）= M*(M+1)/2</code> 个。</li><li>因此，总共有 <code>N*(N+1)/2 * M*(M+1)/2</code> 个矩形。</li></ul><p>用相同的办法可以推导正方形的数量，方法如下：</p><ul><li>对于左边长度为 1 的线段有 N 个，相应的上边长度为 1 的线段有 M 个。</li><li>所以可以构造出 <code>N*M</code> 个边长为 1 的正方形。</li></ul><p>同理：</p><ul><li>对于左边长度为 2 的线段有 N-1 个，相应的上边长度为 2 的线段有 M-1 个。</li><li>所以可以构造出 <code>(N-1)*(M-1)</code> 个边长为 2 的正方形。</li></ul><p>以此类推，可以构造出 <code>N*M + (N-1)*(M-1) + (N-2)*(M-2) + (N-M+1)*1</code> 个正方形(N&gt;M)。</p><p>另外，需要注意使用 <code>long long</code> 来保存结果。完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n, m, ans1, ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans1 = n*(n+<span class="number">1</span>)/<span class="number">2</span> * m*(m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans2 += n*m;</span><br><span class="line">        n--; m--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout  &lt;&lt; ans2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans1 - ans2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="P1044-栈"><a href="#P1044-栈" class="headerlink" title="P1044 栈"></a><a href="https://www.luogu.com.cn/problem/P1044">P1044 栈</a></h3><p>这道题可以先用暴力的办法把前面几个数打出来，然后我们能发现数的规律是：1,1,2,5,14,42,132,429,1430,….</p><p>这是计算组合中很常见的卡特兰数，卡特兰数有两种公式，第一种公式是：</p><ul><li><code>f(n) = f(n-1) * (4 * n - 2) / (n + 1)</code></li></ul><p>我个人觉得这个公式不太好记。另一个公式是：</p><img src="/images/catalan.jpg" class=""><p>这个递推式相对好记一点：即<code>C(n) = C(0)*C(n-1) + C(1)*C(n-2) ... C(n-1)*C(0)</code></p><p>以下是用该递推式实现的答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Tang Qiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[<span class="number">19</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            ans[i] += ans[j] * ans[i<span class="number">-1</span>-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P3612-USACO17JAN-Secret-Cow-Code-S"><a href="#P3612-USACO17JAN-Secret-Cow-Code-S" class="headerlink" title="P3612 USACO17JAN Secret Cow Code S"></a><a href="https://www.luogu.com.cn/problem/P3612">P3612 USACO17JAN Secret Cow Code S</a></h3><p>这是一道 USACO 的题目，需要我们先找出规律，然后再试图求解。</p><p>此题找规律的技巧是分析坐标每次在折半还原时的变化规律。<br>为了分析规律，我们可以看每次翻倍时，坐标的关系变化。</p><p>对于一个长度为 N 的字符串S，每次其长度变为 <code>2*N</code>。所以，我们对每一位进行标号：</p><p><code>1 2 3 4... N N+1 N+2 N+N</code></p><p>其中，除 <code>S[N] == S[N+1]</code> 外（按题意，此项为特殊项），其它位置都符合如下规律：</p><ul><li>S[1] &#x3D;&#x3D; S[N+2]</li><li>S[N-1] &#x3D;&#x3D; S[N+N]</li></ul><p>所以，将右边的坐标减去 <code>N</code> 再减 <code>1</code>，就得到左边的坐标。</p><p>所以，设总长为 L, 如果 a 的位置在右半侧，则对应到左半侧的坐标关系是：</p><ul><li><code>if (a == L/2+1) a = 1;</code></li><li><code>else a = a - L/2 - 1;</code></li></ul><p>如此递归下去，直到位置落在最初的长度上。<br>因为字符下标是从 0 开始，所以下标最后要减 1.</p><p>最后注意用 long long 来转换坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, n;</span><br><span class="line"><span class="type">bool</span> debug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">di</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        <span class="comment">// 可用 debug 查看坐标变化过程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, L = &quot;</span> &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 a 的位置在右半侧，则调整到左半侧</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; L/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == L/<span class="number">2</span> + <span class="number">1</span>) a = L/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> a = a - L/<span class="number">2</span> - <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">di</span>(a, L/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; a;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出开始往回递归时，字符串拼起来的长度 L</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> L = n;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; a) L *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找 L 这个长度下，第 a 个字符相当于哪个位置</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">di</span>(a, L);</span><br><span class="line">    cout &lt;&lt; s[ans<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数学题是信息学竞赛中重要的一类题目，通常包括几何、数论、容斥原理等。&lt;/p&gt;
&lt;p&gt;本文将相关的题目归纳整理，用于教学。&lt;/p&gt;
&lt;h2 id=&quot;质数相关&quot;&gt;&lt;a href=&quot;#质数相关&quot; class=&quot;headerlink&quot; title=&quot;质数相关&quot;&gt;&lt;/a&gt;质数相关&lt;/</summary>
      
    
    
    
    
    <category term="cspj" scheme="https://blog.devtang.com/tags/cspj/"/>
    
  </entry>
  
</feed>
