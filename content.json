{"meta":{"title":"唐巧的博客","subtitle":"记录下自己学习的点滴","description":"希望通过这个博客，能够将自己的学习成果总结出来，与大家分享交流。","author":"唐巧","url":"https://blog.devtang.com","root":"/"},"pages":[{"title":"关于博主","date":"2016-02-15T06:32:00.000Z","updated":"2025-01-01T12:07:30.275Z","comments":true,"path":"about/index.html","permalink":"https://blog.devtang.com/about/index.html","excerpt":"","text":"简介 唐巧，男，80 后。作为核心员工在 看云控股(原猿辅导) 参与创业。曾作为产品技术负责人孵化了 小猿搜题 和 小猿口算。曾作为业务负责人，孵化了小斑斑月龄盒。 现在是斑马智能硬件业务负责人，带领团队研发的产品累计出货量超过 400 万台。 10 多年工作下来，技术、产品、供应链、运营、市场等工作都有涉及。著有《iOS 开发进阶》 一书。曾开发 网易邮箱、网易微博、有道云笔记、猿题库、小猿搜题。 本博客主要的内容包括 iOS 开发技巧、创业感悟、读书心得、产品研究笔记。 欢迎关注我的微博：@唐巧_boy、我的 GitHub，以及我的「唐巧」微信公众号： 更多信息如果你想了解我的经历，可以看我的：读书心得，以及 年终总结： 2011 年个人总结 2012 年个人总结 2013 年个人总结 2014 年个人总结 2015 年个人总结 2016 年个人总结 2017 年个人总结 2018 年个人总结 2019 年个人总结 2020 年个人总结 2021 年个人总结 2022 年个人总结 2023 年个人总结 2024 年个人总结 以及我的创业感悟： 谈谈我的创业感受 写在创业一周年 写在创业两周年 写在创业四周年 写在创业五周年 写在创业七周年 写在创业九周年 写在创业十周年 以及我的 CSPJ 教学笔记： 五分钟弄懂 CSP-J CSPJ 教学思考：for 循环 CSPJ 教学思考：宽度优先搜索 以及我的供应链学习笔记： 供应链笔记(1)：如何挑选供应商 供应链笔记(2)：如何降本 供应链笔记(3)：挑选供应商的核心因素 供应链笔记(4)：如何防止腐败 供应链笔记(5)：注塑成本估算 供应链笔记(6)：计划岗位 供应链笔记(7)：什么时候自己投资建厂 供应链笔记(8)：印刷的环节和成本 供应链笔记(9)：开源岗位 供应链笔记(10)：采购岗位"},{"title":"购买广告位","date":"2016-02-15T06:32:00.000Z","updated":"2024-01-06T14:52:38.330Z","comments":true,"path":"sponsor/index.html","permalink":"https://blog.devtang.com/sponsor/index.html","excerpt":"","text":"概述本博客的主要内容是 iOS 开发，非常适合 iOS 开发相关的广告内容投放，例如招聘信息、商业 SDK、第三方的商业服务等。 大家可以算一下，对于招聘来说，通常招到一个 iOS 开发者需要给付猎头 3 个月左右的工资作为费用。我们假设 iOS 开发者的月薪是 1 万，那这个费用可以在本博客投放 5 年的广告。 根据 Google Analytics 的统计，本博客每天平均 3000 左右的 PV 浏览量（工作日约 4000 左右浏览量，周末约 2000 左右的浏览量），1000 以上的 UV 浏览量，平均停留时间约 3 分钟，约一半是新读者。 以下是本博客今年的概要数据统计（中间的低谷期是因为春节）： 广告位本博客右侧边栏可放置图片广告，该广告位会展示在本博客的首页和所有的文章页面。 根据刚刚的概述数据，图片广告每天约展示 2000 次，每月约 6 万次。 广告位价格： 类型 A：图片宽度 235 px，高度 200 px。1000 元一月。 类型 B：图片宽度 235 px，高度 100 px。500 元一月。 所有类型 A 的图片广告，将位于类型 B 的上方。其它的按广告投放顺序依次排序。 图片格式可以是 PNG, JPG 或 GIF，但大小需要保证在 100K 以内。 需要提供图片点击后打开的网址，用于跳转到相关网站。 联系方式如有意投放广告，请微博私信联系 @唐巧_boy。 历史广告主 蒲公英 简寻 BugTags 七牛 掘金 番茄土豆 2016 年 iDev 大会"},{"title":"使用RBTool自动提交code review请求","date":"2011-08-25T10:13:00.000Z","updated":"2024-01-06T14:52:37.910Z","comments":true,"path":"archive/2011-08-25-use-rbtool-to-post-review-request.html","permalink":"https://blog.devtang.com/archive/2011-08-25-use-rbtool-to-post-review-request.html","excerpt":"前言让我们回想一下手工提交review请求的过程: 首先得用 svn diff &gt; filename.diff 生成diff文件。 然后输入review board的网址，可能是 rb.companyname.com 然后需要输入你的账号密码进行登录验证。 然后你需要填写你的svn repository 地址，然后上传diff文件。 然后你进到review请求的详细页面，填写summary, description, test-done, group和people项，而通常情况下，你的group是固定的，review你的people也就是那么几个人来回变。 最后你填完这些内容，点击 publish 来发布你的review请求。","text":"前言让我们回想一下手工提交review请求的过程: 首先得用 svn diff &gt; filename.diff 生成diff文件。 然后输入review board的网址，可能是 rb.companyname.com 然后需要输入你的账号密码进行登录验证。 然后你需要填写你的svn repository 地址，然后上传diff文件。 然后你进到review请求的详细页面，填写summary, description, test-done, group和people项，而通常情况下，你的group是固定的，review你的people也就是那么几个人来回变。 最后你填完这些内容，点击 publish 来发布你的review请求。 RBTool安装和配置是不是觉得很烦索？其实review board官网提供了一个RBTool，可以帮你把这些步骤全部省掉，一切只需要在命令行敲一条 post-review指令即可。很心动吧？让我们来看看如何安装RBTool。 首先需要你的电脑里安装了git, python, Mac同学表示这些东西都安全装预好了，如果是老版本的mac，也可以自行下载安装。Git的windows&#x2F;mac&#x2F;linux版本下载地址是：http://git-scm.com/ 。 下载安装完git后，输入 git clone git://github.com/reviewboard/rbtools.git cd rbtools sudo python setup.py install OK，post-review已经安装好了。 然后你需要小小配置一下，在自己svn项目的根目录下，建立：.reviewboardrc 文件。在文件中输入： REVIEWBOARD_URL = &quot;http://rb.yourcompany.com&quot;REPOSITORY = &quot;https://dev.yourcompany.com/svn/xxxx&quot; 这2行分别代表你们公司的review board网址和svn根目录地址。 RBTool的使用OK，以后你要提交review请求，只需要在项目根目录下输入 post-review 即可。第一次需要输入登陆review board的用户名密码，post-review工具会记住密码，以后就不用输入了。post-review默认会将你当前svn目录下的diff修改提交到review board上。你也可以加上一些指定的参数来指定group, people, description等等。比如我就写了一个小脚本，将post-review改成： post-review --target-groups=mygroup --target-people=friendname1,friendname2 post-review还可以更新以前提交的diff,方法是用 -r 指定review number即可。具体的可以用post-review –help来查看详细信息。也可以去review board官网查看详细的说明：http://www.reviewboard.org/docs/codebase/dev/getting-started/#rbtools 如果是用git svn管理的项目，另外加上参数：–parent git-svn 即可。 赶快用RBTool工具提高你的工作效率吧～"},{"title":"放弃iOS4，拥抱iOS5","date":"2012-11-16T12:47:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"archive/2012-11-16-drop-ios4-enbrace-ios5.html","permalink":"https://blog.devtang.com/archive/2012-11-16-drop-ios4-enbrace-ios5.html","excerpt":"前言苹果在2011年的WWDC大会上发布了iOS5，不过考虑到要支持iOS4.x的系统，大多数App都无法使用iOS5的新特性。现在将近1年半过去了，从我们自己的App后台的统计数据、一些第三方的统计数据和一些业界的朋友告知我的数据都显示，iOS4.x的系统所占比例已经小于5%了，并且还在持续下降。所以，我们有必要放弃对iOS4.x的支持，全面拥抱iOS5。 只支持iOS5.0以上版本使得我们可以使用iOS5带来的诸多新特性，有些新特性可以极大地方便我们的开发，我将这些新特性列举如下。","text":"前言苹果在2011年的WWDC大会上发布了iOS5，不过考虑到要支持iOS4.x的系统，大多数App都无法使用iOS5的新特性。现在将近1年半过去了，从我们自己的App后台的统计数据、一些第三方的统计数据和一些业界的朋友告知我的数据都显示，iOS4.x的系统所占比例已经小于5%了，并且还在持续下降。所以，我们有必要放弃对iOS4.x的支持，全面拥抱iOS5。 只支持iOS5.0以上版本使得我们可以使用iOS5带来的诸多新特性，有些新特性可以极大地方便我们的开发，我将这些新特性列举如下。 StoryboardStoryboard（故事板）是XCode4和iOS5提供的一个用于控制View Controller之间跳转关系的新概念。你可以把它理解成以前一堆Nib文件的集合。在这个集合里面，每个Nib文件被称作scene（场景），scene之间的跳转关系被称作segue。segue代表着传统的界面间切换的方式，通常是Push方式和Modal方式，当然，你也可以自定义自己的Segue。如下示例图是一个Storyboard的界面： 使用Storyboard的好处有以下几点： 你可以从storyboard中很方便地梳理出所有View Controller的界面间的调用关系。比如上面那个storyboard示例图，我们就可以很清楚地了解到4个View Controller相互之间是怎么调用的。而这在以前，这些调用关系，都是隐藏在每个View Controller的代码中的，你需要一点一点读代码，才可以将整个调用逻辑整理清楚。 使用Storyboard可以使用Table View Controller的Static Cell功能。简单来说，对于象设置页面等固定内容的TableView，可以直接在Storyboard中通过拖拽就可以设置其界面了，而不是象以前那样需要写一堆table view的delegate和data source回调函数。 通过实现 - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 方法，每个View Controller的跳转逻辑都聚集在一处，这方便我们统一管理界面跳转和传递数据，这相当于多了一个编程约定。 Storyboard可以方便将一些常用功能模块化和复用。例如WWDC2011年介绍Storyboard的视频就将微博分享功能模块化成一个单独的Storyboard。我在开发App时，也将例如通过第三方注册登录模块做成一个单独的Storyboard，便于以后复用。 另外，在iOS6中，storyboard又新增了如exit segue, container view等新功能，这些功能都非常体贴，我们向新的技术方案迁移可以在未来更加方便地使用iOS和XCode的新特性，方便我们的开发。 当然，Storyboard也有它的问题。比如，如果2个人同时编译storyboard，在版本管理中出现冲突时会比较麻烦。虽然storyboard是XML格式的，但是里面的信息有些时候还是不太清晰，当冲突发生时，合并冲突可能会比较麻烦。解决办法是，将Storyboard按功能拆分，每个人尽量负责一个单独的Storyboard，如果实在需要2个人都修改它，避免同时修改。 ARC因为ARC是在编译期做的，所以虽然是与iOS5.0同时推出的Objective-C特性，但是其实ARC是支持iOS4的。只是在iOS4中，不能使用ARC的weak关键字。 由于不需要支持iOS4，我们可以将原本的 __unsafe_unretained 关键字换成weak。这样当这个弱引用对象被回收时，weak指针会被智能地设置成nil，防止“野指针”的产生。 很多人说ARC有这样那样的问题，其实他们是没有真正用好ARC。我在开发粉笔网iPhone客户端时，由于使用了ARC，花三个月开发完的应用，用instruments检测后，没有发现任何内存泄漏问题。这在没有使用ARC的工程中是不可想象的。苹果在推出ARC两年后，今年正式将ARC引入到Mac OS操作系统的SDK中，并且正式将原有的GC deprecated掉，这也说明了ARC技术方案已经是非常成熟的了。 UIKitUIKit在iOS5进行了大量更新。除了新增了如UIStepper控件外，也为以前的控件增加了更多的定制接口。我们可以方便地定义UINavigationBar, UITabBar, UIToolBar等常用控件。 苹果在iOS5中给UIViewController新增加的5方法以及一个属性。关于这个新特性我在这篇文章中详细介绍过。新增的方法主要解决的是让 view的load&#x2F;unLoad&#x2F;appear&#x2F;disappear的相关回调可以传递到子view controller中。 CoreImage苹果从iOS5开始，引入了新的图象类CIImage。CIImage相比以前的UIImage类，更加适合于图象处理和图象分析。 在图象处理方法，苹果内置了CIFilter类，方便开发者对图形进行各种各样的特效处理，在iOS5中，苹果提供了48种Filter，而在iOS6中，内置的Filter达到了93种。可以使用如下代码，查询到当前系统中提供的Filter列表： - (void)logAllFilters &#123; NSArray * properties = [CIFilter filterNamesInCategory:kCICategoryBuiltIn]; NSLog(@&quot;%@&quot;, properties); for (NSString * filterName in properties) &#123; CIFilter * fltr = [CIFilter filterWithName:filterName]; NSLog(@&quot;%@&quot;, [fltr attributes]); &#125;&#125; 这些内置的Filter在分类上，包括： 颜色效果类。例如黄昏效果，曝光度调整等。 组合效果类。把2张图片按各种规则混合成一张图。 几何变形类。例如把照片倾斜或者翻转。 重复效果类。如平铺，折叠，镜象等。 失真扭曲类。如把图片中心做成漩涡效果等。 模糊和锐化类。 Stylize效果。 Halftone效果。 以上所有效果可以叠加作用在一起，最终你可以创造出自己的图片处理效果。最终你可以通过CIContext，将处理过的CIImage转换成UIImage输出。有了Core Image，你可以方便地开发图象处理相关的应用，而不用关心图象处理算法的细节。 NSJSONSerialization在我的《不要使用SBJSON(json-framework)》 一文中，我提到了关于JSON解析库的性能测试。测试结果表明，苹果从iOS5开始提供的 NSJSONSerialization 类有着最好的性能表现。所以，从iOS5以后，你可以扔掉那些第三方JSON解析库了。 ViewController切换iOS提供了如下新的接口来切换ViewController，而以前的presentModalViewController和dismissModalViewControllerAnimated被Deprecated掉了。 // 新的接口- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion;- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^)(void))completion;// 被Deprecated的接口- (void)presentModalViewController:(UIViewController *)modalViewController animated:(BOOL)animated;- (void)dismissModalViewControllerAnimated:(BOOL)animated; 新接口的差别是提供了一个completion参数，允许你传入一个block，来定义该操作结束时的回调。使用新的函数后，可以方便同时Dismiss或Present多个View Controller，也可以方便做多个UI效果之间的衔接。 其它GameKit, Core Data, NewsstandKit, GLKit在iOS5中都有更新。可惜我都没有具体使用过，所以不便做更多介绍。 Have fun!"},{"title":"iPhone开发常问的十个问题(2012年3月版)","date":"2012-03-15T14:04:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"archive/2012-03-15-10-most-common-questions-on-stackoverflow-201203.html","permalink":"https://blog.devtang.com/archive/2012-03-15-10-most-common-questions-on-stackoverflow-201203.html","excerpt":"前言今天去stackoverflow.com上看了一下iPhone标签下排名最高的10个问题，将它们整理出来，希望这些常见问题能帮到一些iPhone开发的初学者。本来想把答案也翻译过来的，后来发现答案资料通常都比较复杂，翻译起来太麻烦。所以大家还是看英文的答案吧，我只顺带用中文总结一下答案。","text":"前言今天去stackoverflow.com上看了一下iPhone标签下排名最高的10个问题，将它们整理出来，希望这些常见问题能帮到一些iPhone开发的初学者。本来想把答案也翻译过来的，后来发现答案资料通常都比较复杂，翻译起来太麻烦。所以大家还是看英文的答案吧，我只顺带用中文总结一下答案。 问题一: 有哪些iPhone开发和Objective-C的入门资料这个确实是最常问的问题了。对于我个人来说，入门时所看的资料主要是《From C++ to Objective-c》和《iPhone开发基础教程》，另外，我也把stanford的iphone视频课程看完了，链接是：http://www.stanford.edu/class/cs193p/cgi-bin/index.php 个人体会是边学边做，上手会比较快。编程这东西，不自己上手做做，没感觉。另外，如果入门之后想提高的话，我觉得还是需要把苹果每年的WWDC视频都下载下来看看，里面讲的东西还是非常有用的, 链接是: http://developer.apple.com/WWDC/ 问题二: 如何在Windows中进行iPhone开发大家还是把Windows想太全能了。至少在开发这一块上，Windows对于程序员来说，还是相当不友好的。这一点在使用Mac系统后，差别一下子就体会到了。就比如说git，在Windows下使用就有很多问题。另外话说回来，Mac机也不是什么都好，在中国，Mac系统相关的国内软件相当少，Mac下的游戏也相对Windows少很多，如果你想用Mac机来娱乐的话，会比较受限制。 问题三: 有哪些基于iPhone的base64编码的库从这个问题的答案中，我选了一个我个人觉得比较好用的Base64编码库，放到我的Xcode Tool中了。地址是：https://github.com/tangqiaoboy/xcode_tool/tree/master/Encoding。 问题四: 如何判断当前iPhone是否联网最佳的答案是用苹果提供的Reachability类。详细的使用方式大家自己看答案吧，写得很清楚。 问题五: 如何做一个快速并且轻量级的PDF阅读器我暂时没这个需求，就没有详细看答案。 问题六: 如何让我的app支持打开一种格式的文件在iPhone 3.2以上系统中，使用URL schemes即可完成这个需求。详细见答案。 问题七: 当键盘出现的时候，如何让UITextField自动上移对于iPhone界面控件的操作应该算是开发中必备的能力。键盘出现的时候上移相关的控件算是常见的需求，但是从这么多人问这个问题就可以看出，还是有很多人对这些需求的实现方式有疑问。 对于这个问题，主要是通过增加对键盘出现和消失的相应的Notification，然后在键盘出现和消息的时候，通过设置相关控件的frame来实现。相关代码如下，来源自stackoverflow。 -(void)textFieldDidBeginEditing:(UITextField *)sender&#123; if ([sender isEqual:_textField]) &#123; //move the main view, so that the keyboard does not hide it. if (self.view.frame.origin.y &gt;= 0) &#123; [self setViewMovedUp:YES]; &#125; &#125;&#125;//method to move the view up/down whenever the keyboard is shown/dismissed-(void)setViewMovedUp:(BOOL)movedUp&#123; [UIView beginAnimations:nil context:NULL]; [UIView setAnimationDuration:0.5]; // if you want to slide up the view CGRect rect = self.view.frame; if (movedUp) &#123; // 1. move the view&#x27;s origin up so that the text field that will be hidden come above the keyboard // 2. increase the size of the view so that the area behind the keyboard is covered up. rect.origin.y -= kOFFSET_FOR_KEYBOARD; rect.size.height += kOFFSET_FOR_KEYBOARD; &#125; else &#123; // revert back to the normal state. rect.origin.y += kOFFSET_FOR_KEYBOARD; rect.size.height -= kOFFSET_FOR_KEYBOARD; &#125; self.view.frame = rect; [UIView commitAnimations];&#125;- (void)keyboardWillShow:(NSNotification *)notif&#123; //keyboard will be shown now. depending for which textfield is active, move up or move down the view appropriately if ([_textField isFirstResponder] &amp;&amp; self.view.frame.origin.y &gt;= 0) &#123; [self setViewMovedUp:YES]; &#125; else if (![_textField isFirstResponder] &amp;&amp; self.view.frame.origin.y &lt; 0) &#123; [self setViewMovedUp:NO]; &#125;&#125;- (void)viewWillAppear:(BOOL)animated&#123; // register for keyboard notifications [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:self.view.window]; &#125;- (void)viewWillDisappear:(BOOL)animated&#123; // unregister for keyboard notifications while not visible. [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil]; &#125; 问题八: 有关UIImagePickerController, Image, Memory的问题和答案整理这个其实是一个相关问题的汇总贴。其中对于UIImage的操作示例挺有用处。做iPhone开发，总是会遇到一些图象处理相关的东西，能够从这儿积累一些相应的知识，到真正自己需要的时候帮助就大了。 问题九: 如何对包含自定义元素类型的NSMutableArray排序答案讨论了各种方法，下面是其中提到的最简单的方法：定义一个比较用的selector - (NSComparisonResult)compare:(Person *)otherObject &#123; return [self.birthDate compare:otherObject.birthDate];&#125;NSArray *sortedArray;sortedArray = [drinkDetails sortedArrayUsingSelector:@selector(compare:)]; 问题十: 如何在iPhone中使用自定义字体答案讨论了在iOS3.2以前及以后的做法，现在都5.1了，估计支持3.2以前的app很少了吧。所以我把iOS3.2以后的办法附在下面。简单来说，就是iOS3.2苹果支持自定义字体，只需要在Info.plist文件中设置UIAppFonts相关的信息即可。步骤如下： 将自定义字体加到你的工程资源文件中 在 info.plist 文件中增加一名为 UIAppFonts 的key 将这个key修改成array 将你用到的所有字体的名字，作为这个array的值，一项一项填进去（包括扩展名） 保存 info.plist 现在就可以在代码中直接用[UIFont fontWithName:@”CustomFontName” size:12]来取得你自定义的字体了。"},{"title":"关于iOS测试机个数上限的详细规则","date":"2012-04-06T08:50:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"archive/2012-04-06-about-100-devices-limit.html","permalink":"https://blog.devtang.com/archive/2012-04-06-about-100-devices-limit.html","excerpt":"2016.02.16 更新关于测试机上限的规则苹果有变更，本文中的内容有一些陈旧。 前言公司的iOS测试机快达到苹果规定的100个上限了，而因为the new iPad新出，我们需要新的quota来测试新iPad，所以就仔细研究了一下苹果关于100个测试设备上限的规则。在这里分享给大家。规则的详细内容主要来自 苹果的官网文档。","text":"2016.02.16 更新关于测试机上限的规则苹果有变更，本文中的内容有一些陈旧。 前言公司的iOS测试机快达到苹果规定的100个上限了，而因为the new iPad新出，我们需要新的quota来测试新iPad，所以就仔细研究了一下苹果关于100个测试设备上限的规则。在这里分享给大家。规则的详细内容主要来自 苹果的官网文档。 规则我总结出来的规则如下（附上原文以便对应）： 每一个开发者membership year,只能有100次增加设备的名额。如果你增加一个设备,之后又将该设备删除,并不会将用掉的名额恢复. You can register up to 100 devices per year for development purposes. Any devices added, then later removed, still count towards your maximum number of registered devices per year. 在每一个开发者membership year开始的时候,Team Agent和Admin角色可以选择删掉一些设备来恢复资格, 也可以清空所有设备来恢复到最多100次设备的名额。这个操作在Team Agent和Admin在一次新的membership year开始后即可使用，在使用时，需要注意，先将需要删除的设备删掉，然后才能添加需要新增的设备。一旦开始增加新设备，删除设备以恢复名额的功能将不再可用。 At the start of a new membership year, Team Agents and Admins can remove devices and restore the available device count for their development team to 100 devices. When Team Agents or Admins first sign in to the iOS Provisioning Portal at the start of a new membership year, they will be presented with the option to remove devices and restore the device count for those removed devices. Important Note: At the start of your membership year, make sure to remove all devices you no longer use for development prior to adding any new devices. 在以后整个membership year中，删除设备不会增加新的名额。 Removing devices during your membership year will not open these slots to add new devices. 举例直接看规则比较晦涩，举个例子： 假如第一年，你增加了70个设备，同时删除了10个设备，这个时候，虽然你的设备数是60，但是可用的增加测试机的名额却只有30个了。 到了第二年，你续费了开发者身份，在你第一次登陆进去后，你可以看到你的可用设备恢复成 100 - 60 &#x3D; 40个了。这个时候，你可以选择删除一些设备，例如你又删除了20个设备，这样你的名额数变成60个。之后你增加了一个设备，因为你选择了增加新设备，苹果认为你已经放弃删除设备以恢复设备数的机会，这样，你的名额就固定成59个。以后删除设备都不会增加新名额了，直到你的下一个membership year开始时才又会有这样的机会来删除设备释放名额。 总结所以说，不管怎么样，你的账号下的可用测试设备始终不会超过100个。不会象有些人想的那样，每过一年名额就直接变成100了。另外，每年删除设备以恢复名额的机会只有开始的时候，以后删除设备也不会恢复名额。 那如果万一我的设备数达到上限，我又急需要增加新设备怎么办呢？我们不久前就遇到了这种情况。我们的解决办法是给苹果的技术客服发邮件要求他们帮助我们删除所有设备并且恢复到增加100个测试设备的名额。最终在过了2天后，苹果答应并帮助我们解决了问题。 具体做法是访问：https://developer.apple.com/contact/，点击 Program Benefits， 然后在新出来的提交界面中将需求填上。之后苹果会发邮件过来告诉你处理结果，可能需要打电话过去和他们沟通一些细节。在沟通完成后，苹果就可以立即帮助你状态修改到“可删除设备来增加测试设备名额”。这样，你就可以选择性的删除一些不需要的设备来释放一些名额了。"},{"title":"分享iOS开发技巧的微信公共账号","date":"2013-02-21T12:02:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"archive/2013-02-21-introduction-of-weixin-public-account.html","permalink":"https://blog.devtang.com/archive/2013-02-21-introduction-of-weixin-public-account.html","excerpt":"记得我以前刚学 iOS 开发的时候，常常会遇到各种问题，身边没有人交流，遇到问题只能上网搜。虽然 stackoverflow 能解决大部分问题，但是还是很渴望和身边的一些同行进行讨论和交流。 后来，我组建了一个 QQ 群，尽力把自己通过各种渠道认识的 iOS 同行聚集到群里面，希望形成一个讨论环境。现在群里面加入了包括网易，腾讯，百度，新浪，搜狐，美团，豆瓣等公司的 iOS 程序员以及一些自由职业者。因为大家都是比较有经验的开发者，所以每天大家的讨论不太多，但是都很有价值。","text":"记得我以前刚学 iOS 开发的时候，常常会遇到各种问题，身边没有人交流，遇到问题只能上网搜。虽然 stackoverflow 能解决大部分问题，但是还是很渴望和身边的一些同行进行讨论和交流。 后来，我组建了一个 QQ 群，尽力把自己通过各种渠道认识的 iOS 同行聚集到群里面，希望形成一个讨论环境。现在群里面加入了包括网易，腾讯，百度，新浪，搜狐，美团，豆瓣等公司的 iOS 程序员以及一些自由职业者。因为大家都是比较有经验的开发者，所以每天大家的讨论不太多，但是都很有价值。 但是，我发现 QQ 群对于讨论的归档性太弱。很多有代表意义的讨论，对于其他人可能是有用的，但是由于群的归档性太差，随着时间流逝，这些信息无法被有效沉淀。 所以我想做一个尝试。我想把这个 QQ 群里面有价值的讨论信息整理归档到这个公共账号上。希望大部分 iOS 同行每天都能得到少量的，但是有价值的信息。对于特别有价值的信息，我也会在后期整理成博客，发表在博客上。 希望这能对你平时的工作有所帮助。 如果你感兴趣，那么可以扫描以下二维码加该账号为好友，或者在微信中搜索 “iOS 开发”。 后记 1（2013 年 3 月 27 日）微信公共账号的运营感受上面的提到的公共账号，我尝试运营了半个月，有如下感受： 微信公共平台实时性太高，文章归档性弱，微信 4.5 才增加查看所有历史消息的功能，而且很多人还不知道从哪儿查看历史消息。 微信公共平台相对微博或 RSS 订阅，对订阅人的干扰强度更大。因为消息会实时推送到订阅人手机上，并且有消息收到提醒。 微信公共平台上的消息因为是在手机上阅读，不适合作长篇的，深度的技术讲解，但适合作简单入门的技术介绍 微信公共平台的后台管理太弱，不适宜代码的排版。 微信公共平台上的消息不能被搜索引擎检索，阻碍了有价值的信息的传播。 综上所述，微信公共平台更适合于发表新闻类或漫谈的文章（例如 Fenng 的小道消息），或者入门性技术介绍（例如池建强的 Mac 技巧）。不适合长篇的技术深入讨论，更不适合贴代码，也不适合归档文章（要归档得自己另外整理）。 另外，每天通过公共账号发表文章相当费时间精力，至少需要 1 个小时的时间。对于我这个身处于创业公司的人来说，实在没有那么多时间花在这上面。所以现在该公共账号已经基本处于停止更新状态。 后记 2（2013 年 6 月 16 日）维护这个微信号刚开始很难，原因一方面是整理信息的成本很高，写成微信很花时间。另一方面，我也没有那么多时间来写微信。不过我坚持了一段时间后，渐渐发现有一些牛人会被吸引到我们的 QQ 群里面，这样就行成了一个良性循环。QQ 群不断有牛人加入贡献高质量的讨论，讨论内容通过微信发出去后，又吸引更多牛人要求加入。 所以，该微信公共账号经过近四个月的坚持，最终不但度过了最艰难的时期，还引吸了大量牛人加入到我们的讨论群中。现在每天群里都有足够多的内容分享出来组织成文。我自己也慢慢找到了该微信公众号的定位，即给大家分享一些信息，而不是进行知识的长篇大论。很多时候，提供一些链接给大家就足够了，感兴趣的人自然会去深入阅读。 另外，6 月 6 日，本微信公共账号同时得到了 @Fenng 和 @ 池建强 在各自的微信公共账号上的 推荐，关注人数也暴涨。很高兴自己最终坚持下来了。 后记 3 (2016.02.16)这个公众号现在已经运营了三年了，不但有超过两万的粉丝，还有大量的广告收入。我很开心自己的坚持得到了回报。 后记 4（2017.11.26）由于转型做管理，这个公众号在 2017 年底改名为「唐巧」。 如何申请加群？有很多朋友留言问我们的 QQ 群号并想申请加入，在此我统一回复一下。 QQ 群由于实时性太强，所以一旦有讨论，就会对平时的工作造成影响。所以 QQ 群里面的讨论不应该太热烈，否则每天就没法干活了。 所以我希望群里面的人都足够精通 iOS 开发，对于在群里面提出来的问题，都是值得讨论的问题。通过讨论，大家都有了收获，才不致于觉得这个群太打扰而把它屏蔽掉。 因此，我不希望群里面加太多的人，现在人数基本上有讨论的气氛，对于技术问题的讨论也都会有结果。所以， 暂时不接受任何加群申请。"},{"title":"再见，viewDidUnload方法","date":"2013-05-18T09:37:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"archive/2013-05-18-goodbye-viewdidunload.html","permalink":"https://blog.devtang.com/archive/2013-05-18-goodbye-viewdidunload.html","excerpt":"前言我在去年的一篇文章 《iOS5 中 UIViewController 的新方法》 中介绍了 iOS5 引入的关于 ViewController 的新方法。但是现在如果运行该文章中的 Sample 代码的话，你会发现 Log 中不会再出现 viewDidUnload 方法被调用的记录。这是因为在 iOS6 中，viewDidUnload 回调方法被 Deprecated 掉了。查看苹果的文档，可以看到如下的说明。 那么，原本在 viewDidUnload 中的代码应该怎么处理？在 iOS6 中，又应该怎么处理内存警告？带着这些问题，我查找了一些资料，在此分享给大家。","text":"前言我在去年的一篇文章 《iOS5 中 UIViewController 的新方法》 中介绍了 iOS5 引入的关于 ViewController 的新方法。但是现在如果运行该文章中的 Sample 代码的话，你会发现 Log 中不会再出现 viewDidUnload 方法被调用的记录。这是因为在 iOS6 中，viewDidUnload 回调方法被 Deprecated 掉了。查看苹果的文档，可以看到如下的说明。 那么，原本在 viewDidUnload 中的代码应该怎么处理？在 iOS6 中，又应该怎么处理内存警告？带着这些问题，我查找了一些资料，在此分享给大家。 分析在 iOS4 和 iOS5 系统中，当内存不足，应用收到 Memory warning 时，系统会自动调用当前没在界面上的 ViewController 的 viewDidUnload 方法。通常情况下，这些未显示在界面上的 ViewController 是 UINavigationController Push 栈中未在栈顶的 ViewController，以及 UITabBarViewController 中未显示的子 ViewController。这些 View Controller 都会在 Memory Warning 事件发生时，被系统自动调用 viewDidUnload 方法。 在 iOS6 中，由于 viewDidUnload 事件在 iOS6 下任何情况都不会被触发，所以苹果在文档中建议，应该将回收内存的相关操作移到另一个回调函数：didReceiveMemoryWarning 中。但是如果你仅仅是把以前写到 viewDidUnload 函数中的代码移动到 didReceiveMemoryWarning 函数中，那么你就错了。以下是一个 错误的示例代码 ： - (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; if([self isViewLoaded] &amp;&amp; ![[self view] window]) &#123; [self setView:nil]; &#125;&#125; 这篇文章 解释了 iOS6 不推荐你将 view 置为 nil 的原因（链接打开需要翻墙）, 翻译过来如下： UIView 有一个 CALayer 的成员变量，CALayer 是具体用于将自己画到屏幕上的。如下图所示： CALayer 是一个 bitmap 图象的容器类，当 UIView 调用自身的 drawRect 时，CALayer 才会创建这个 bitmap 图象类。 具体占内存的其实是一个 bitmap 图象类，CALayer 只占 48bytes, UIView 只占 96bytes。而一个 iPad 的全屏 UIView 的 bitmap 类会占到 12M 的大小！ 在 iOS6 时，当系统发出 MemoryWarning 时，系统会自动回收 bitmap 类。但是不回收 UIView 和 CALayer 类。这样即回收了大部分内存，又能在需要 bitmap 类时，通过调用 UIView 的 drawRect: 方法重建。 内存优化另外文章中还提到苹果的操作系统对此做的一个内存优化技巧，解释如下： 当一段内存被分配时，它会被标记成 “In use“, 以防止被重复使用。当内存被释放时，这段内存会被标记成 “Not in use”，这样，在有新的内存申请时，这块内存就可能被分配给其它变量。 CALayer 包括的具体的 bitmap 内容的私有成员变量类型为 CABackingStore， 当收到 MemroyWarning 时，CABackingStore 类型的内存区会被标记成 volatile 类型（这里的 volatile 和 C 以及 Java 语言的 volatile 不是一个意思），volatile 表示，这块内存可能被再次被原变量重用。 这样，有了上面的优化后，当收到 Memoy Warning 时，虽然所有的 CALayer 所包含的 bitmap 内存都被标记成 volatile 了，但是只要这块内存没有再次被复用，那么当需要重建 bitmap 内存时，它就可以直接被复用，而避免了再次调用 UIView 的 drawRect: 方法。 总结所以，简单来说，对于 iOS6，你不需要做任何以前 viewDidUnload 的事情，更不需要把以前 viewDidUnload 的代码移动到 didReceiveMemoryWarning 方法中。 引用 WWDC 2012 中的一段话来给 viewDidUnload 说再见： The method viewWillUnload and viewDidUnload. We’re not going to call them anymore. I mean, there’s kind of a cost-benifit equation and analysis that we went through. In the early days, there was a real performance need for us to ensure that on memory warnings we unloaded views. There was all kinds of graphics and backing stores and so forth that would also get unloaded. We now unload those independently of the view, so it isn’t that big of a deal for us for those to be unloaded, and there were so many bugs where there would be pointers into。 参考链接 View Controller Lifecycle in iOS 6 CALayer Internals: Contents"},{"title":"iOS移动开发周报-第1期","date":"2014-02-27T09:23:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-02-27-ios-weekly-1.html","permalink":"https://blog.devtang.com/archive/2014-02-27-ios-weekly-1.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 新闻 《苹果收购iOS测试平台TestFlight的开发商》，苹果公司确认收购知名iOS测试平台TestFlight的开发商Burstly。与此同时，TestFlight表示将停止提供Android平台产品，不再面向新用户销售Android版测试软件开发包(SDK)，而当前用户仍可以继续使用。 《由苹果的低级Bug想到的》: 2月22日苹果修复了SSL连接验证的一个bug，该bug会引起中间人攻击。文章作者详细分析了Bug产生的潜在原因和一些思考，包括代码风格、测试、以及goto语句的使用。 《百度面试》：作者在文章中分享了百度移动云可穿戴部门iOS开发职位的面试经历，其中多个技术问题值得大家深入学习。 《Facebook Paper使用的第三方库》：作者在文章中分享了facebook paper使用的第三方库。该列表中的第三方库对广大iOS开发者来说，具有很好的参考意义。 教程 《初识iPhone基带通讯》：基带（Baseband）是手机的通讯模块，它负责移动网络的调制与解调工作，它与手机核心通讯功能息息相关。作者在文章中介绍了，如何在越狱的iPhone中，用基带进行通讯。 《[译]iOS7最佳实践：一个天气App案例(一)》和《[译]iOS7最佳实践：一个天气App案例(二)》：在这篇来自raywenderlich的教程中，作者详细介绍了如何使用依赖管理工具Cocoapods、纯代码布局、响应式编程框架ReactiveCocoa以及OpenWeatherMap完成一个天气应用，具有很高的学习价值。 《基于脚本实现动态库注入》：作者分享了她在越狱手机上，基于脚本向某个应用动态注入动态库的想法和实践。 《Xcode5 Plugins 开发简介》：作者在文章中介绍了如何给Xcode5开发插件。最后作为示例，开发了一个简单的插件，记录Xcode开发中Building的时间。 《TDD的iOS开发初步以及Kiwi使用入门》：测试驱动开发(Test Driven Development，简称为TDD)是保证代码质量的一种程序开发方法。作者介绍了在iOS开发中使用TDD及Kiwi的方法。 《objc.io系列文章中文翻译汇总》：objc.io是国外的一个iOS教程网站，它每一期的教程会有一个主题，在这个主题下会有6篇左右的文章（有时由浅入深，有时侧重点不同），实属iOS学习中的精品资源。因此，每一期objc.io文章出来的时候，都会有一些热心的读者将文章翻译成中文。作者将网上的翻译汇总在文章中，方便大家阅读。 工具 Crash Manager：Crash Manager是Crashlytics的非官方iPhone客户端，而且在AppStore上免费。InfoQ也曾撰文介绍过Crashlytics的使用：《统计Crash的工具Crashlytics》。 开源项目 DyCI ：DyCI是一个动态注入工具，用于向iOS应用中注入代码而不用重新启动应用。"},{"title":"让你的APP支持iPhone5","date":"2012-10-05T08:18:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"archive/2012-10-05-upgrade-your-app-to-support-iphone5.html","permalink":"https://blog.devtang.com/archive/2012-10-05-upgrade-your-app-to-support-iphone5.html","excerpt":"前言国庆节前，为了支持 iPhone5 的屏幕分辨率 (640 象素 x 1136 象素)，我尝试着升级粉笔网 iPhone 客户端。整个过程花了大概一天的时间，我把这个过程总结下来，希望对大家有帮助。","text":"前言国庆节前，为了支持 iPhone5 的屏幕分辨率 (640 象素 x 1136 象素)，我尝试着升级粉笔网 iPhone 客户端。整个过程花了大概一天的时间，我把这个过程总结下来，希望对大家有帮助。 升级准备为了支持 iPhone5，我们首先需要准备以下工具和资源： 下载最新版的 XCode4.5 让美术同学提供 640 x 1136 分辨率的启动画面，640 x 1136 分辨率的程序截图（用于在 app store 中显示） 由于 iPhone5 使用的 A6 处理器采用了新的 armv7s 架构，所以如果你使用了第三方的静态链接库，需要下载对应支持 armv7s 的版本。我们由于使用了第三方的数据统计工具 Flurry，所以下载更新了 Flurry 的静态链接库。 如果你的显示器分辨率太小，将无法显示完整的 iPhone5 模拟器，可选的解决办法是换个更大的显示器或者把显示器竖起来，象我这样: 另外还有一个简单的办法，可以在启动模拟器后，用快捷键 command+3(50%)，command+2(75%), command+1(100%)，来调整模拟器的显示比例，谢谢 Superrr 一一 提供的方法，比我的简单多了。 具体升级步骤如下升级启动画面和第三方链接库升级启动画面，将美术同学提供的 640 x 1136 分辨率的启动画面图片，命名为 &#68;&#x65;&#x66;&#97;&#117;&#x6c;&#116;&#x2d;&#53;&#x36;&#x38;&#x68;&#x40;&#50;&#120;&#x2e;&#112;&#x6e;&#x67;，添加到工程中即可。 升级第三方链接库，这个只需要用新的第三方链接库替换掉以前的即可。如果你使用了例如 opencv 这种需要自己编译对应版本链接库的开源库，那么替换之前，需要自己先用 xcode4.5 编译其 armv7s 版本的静态链接库。 调整 xib 文件粉笔网客户端的界面基本上都是顶部是 UINavigationBar, 底部是 UITabBar 或 UIToolBar，中间是 UITableView。 对于这一类界面，调整起来非常简单，只需要将 UITableView 设置成高度自动扩展的 Autosizing 方式，如下图所示： 对于底部的 UIToolBar，Autosizing 设置成靠底部对齐的方式即可。如下图所示： 代码调整有一些界面元素的位置是用代码来设置的，例如 “发表笔记” 界面中浮动贴在输入法键盘上面的各种可选操作的 UIToolbar。因为键盘的高度在不同的输入法下是不一样的，所以需要用代码动态调整。 我的调整代码如下： // 说明：keyboardWillShow 函数和 keyboardWillHide 函数分别监听了// UIKeyboardWillShowNotification 和 UIKeyboardWillHideNotification- (void) keyboardWillShow:(NSNotification *)notification &#123; NSDictionary * info = [notification userInfo]; CGSize kbSize = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size; float textViewHeight = UI_SCREEN_HEIGHT - UI_STATUS_BAR_HEIGHT - UI_NAVIGATION_BAR_HEIGHT - UI_TOOL_BAR_HEIGHT - kbSize.height; [UIView animateWithDuration:0.3 animations:^&#123; _textView.frame = CGRectMake(0, UI_NAVIGATION_BAR_HEIGHT, UI_SCREEN_WIDTH, textViewHeight); _toolbar.frame = CGRectMake(0, UI_NAVIGATION_BAR_HEIGHT + textViewHeight, UI_SCREEN_WIDTH, UI_TOOL_BAR_HEIGHT); &#125;];&#125;- (void) keyboardWillHide:(NSNotification *)notification &#123; CGSize kbSize = CGSizeMake(320, 216); float textViewHeight = UI_SCREEN_HEIGHT - UI_STATUS_BAR_HEIGHT - UI_NAVIGATION_BAR_HEIGHT - UI_TOOL_BAR_HEIGHT - kbSize.height; [UIView animateWithDuration:0.3 animations:^&#123; _textView.frame = CGRectMake(0, UI_NAVIGATION_BAR_HEIGHT, UI_SCREEN_WIDTH, textViewHeight); _toolbar.frame = CGRectMake(0, UI_NAVIGATION_BAR_HEIGHT + textViewHeight, UI_SCREEN_WIDTH, UI_TOOL_BAR_HEIGHT); &#125;];&#125; 可以看到，我将设备的各种高度都定义成了宏，这里的宏 UI_SCREEN_HEIGHT 表示整个设备的高度，以前这个宏的值是固定的 480，现在因为 iPhone5 中高度值变了，所以我们将这个宏定义改成了如下的值，这样，所有相关的用代码实现的界面位置调整都搞定了。我的 UI 相关的宏定义如下： #define UI_NAVIGATION_BAR_HEIGHT 44#define UI_TOOL_BAR_HEIGHT 44#define UI_TAB_BAR_HEIGHT 49#define UI_STATUS_BAR_HEIGHT 20#define UI_SCREEN_WIDTH 320// 将以下宏定义的值从 480 改成 [[UIScreen mainScreen] bounds].size.height#define UI_SCREEN_HEIGHT ([[UIScreen mainScreen] bounds].size.height) 如果你以前没有将这些设备的高度值抽取成宏，我建议你通过查找替换，先将所有用到 480 的地方修改成宏，然后再增加上面的宏定义即可。 当然，也有一些调整稍微复杂一些，例如粉笔网首页的上拉加载更多，需要判断上拉高度是否到达阈值，这些也是和设备高度相关的。这些阈值信息以前可能就直接写成和高度相关的值，例如 220 什么的，这些通过直接查找 480 还没法直接找到。 对于这些问题，只能是通过在模拟器中测试，发现问题，然后再把这些 “Magic Number” 替换成用上面提到的宏计算的公式。例如我们的上拉加载更多的阈值宏定义如下： #define LOAD_MORE_TEXT_HEIGHT 77// 显示文字阈值#define LOAD_MORE_THRESHOLD (UI_SCREEN_HEIGHT - UI_STATUS_BAR_HEIGHT - UI_NAVIGATION_BAR_HEIGHT - UI_TAB_BAR_HEIGHT - LOAD_MORE_TEXT_HEIGHT)// 刷新阈值#define LOAD_MORE_MAX (LOAD_MORE_THRESHOLD + 10.0) 调整屏幕 Rotation 的回调函数从 iOS6 开始，苹果修改了屏幕旋转的回调函数。在 iOS6 以前，回调函数是 - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation&#123; return (interfaceOrientation == UIInterfaceOrientationPortrait);&#125; 现在新的回调函数是： - (BOOL)shouldAutorotate &#123; return YES;&#125;- (NSInteger)supportedInterfaceOrientations &#123; return UIInterfaceOrientationMaskAllButUpsideDown;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationPortrait;&#125; 并且，现在是否旋转屏幕是由最上层的 View Controller 决定。例如，如果你是由 UITabBarController 或 UINavigationController 包起来的界面的话，是否旋转屏幕就由 UITabBarController 或 UINavigationController 中的 shouldAutorotate 回调决定，而默认其返回的是 YES。修改方法是给这 2 个容器 Controller 增加 Addition, 将其 shouldAutorotate 修改成由当前显示的子 view controller 决定，或者直接默认返回 NO。 提交应用基本上就是以上这些调整工作了，完了之后用 Xcode4.5 编译后提交审核，并且在 itunes connect 中设置 iPhone5 屏幕尺寸的 app 介绍截图即可。业界传言说对于支持 iPhone5 的程序，苹果在应用审核的时候会优先进行，我不知道是否是真的，不过我们的应用确实只用了 5 天时间就通过了审核，这是我个人遇到过的最快的一次审核。 祝大家国庆节玩得开心～"},{"title":"iOS移动开发周报-第2期","date":"2014-03-07T13:44:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-03-07-ios-weekly-2.html","permalink":"https://blog.devtang.com/archive/2014-03-07-ios-weekly-2.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 新闻 《利用苹果商店规则漏洞的灰色地下产业链》：作者在文章中介绍了一些投机分子，利用苹果商店在汇率上的漏洞，借助汇率和实际汇率的差价来倒卖商品。据文中介绍，一款不错的手游产品，每月的账面销售额为700万元，但可能真正到账的只有550万元，其余的150万元中约有50万元的黑卡耗损，而剩余的100万则被这些汇率倒卖者攫取。 《Apple即将推出CarPlay功能》：Apple宣布几大顶级汽车制造商即将推出CarPlay。据苹果介绍，CarPlay是一种更智能、更安全且更有意思的在车中使用iPhone的方式。 《2013移动行业分析》 腾讯移动分析发布了2013年移动行业数据分析报告，报告介绍了iOS的用户比例和版本分布。根据文中的统计，国内移动终端iOS市场份额为24.7%。另外不同于国外的情况是，国内iOS5的用户比例仍然高达12%。 《iOS Security》：苹果发布官方的安全方面的文档，介绍了iOS系统从硬件，文件系统到网络等各方面的安全细节。 《WhatsApp 架构设计》: 作者在文章中分享了最近被Facebook收购的WhatsApp的架构，包括它使用到的前后端技术框架以及硬件，文章中也分享了一些提高服务器并发连接数和可扩展性的经验。 教程 《CocoaPods详解之—-制作篇》：作者详细介绍了CocoaPods依赖库的创建过程，这对于开源项目作者来说很有帮助。 《通过实现一个TableView来理解iOS UI编程》：作者通过实现一遍TableView来理解UIKit的一些技术细节，包括几何布局框架、UI的层次架构、子类化UIScrollView、Cell的重用、响应和处理事件和可扩展性等技术细节。 《iOS 开发者应该知道的 ARM 结构》：到目前为止，所有的 iOS 设备都使用 ARM 结构处理器。作者在文章中介绍了ARM处理器的各种特点，包括条件执行、Thumb 指令集、内存对齐和除法等技术细节。 《iOS 开发：绘制像素到屏幕》：像素是如何绘制到屏幕上面的？把数据输出到屏幕的方法有很多，通过调用很多不同的framework和不同的函数。作者在文章中介绍了这个过程背后的东西，这能够帮助大家在遇到性能问题时调试解决问题。 《玩转字符串》 和 《字符串渲染》: 作者翻译了objc.io第九期关于字符串的系列文章。《玩转字符串》中介绍了字符串的比较、搜索、排序以及格式化等功能。《字符串渲染》中介绍了字符串在UILabel、UITextField以及Core Text中的渲染细节。 《Object Encoding and Decoding with NSSecureCoding Protocol》：作者在文章中介绍了如何使用NSSecureCoding来序列化和反序列化对象。文章最后，作者提供了一个名为AutoCoding的开源项目来帮助大家实现相关的功能。 《苹果最新的设计指南》: 苹果发布了其最新的设计指南，试图帮助开发者更好地学习iOS7风格的应用和游戏设计。新版指南提供了大量的视频和文档，内容涵盖应用和游戏开发的各个方面。 工具 《四个iOS开发的小工具》：作者在文章中介绍了4个有助于iOS开发的小工具。不过笔者并不同意文章后半部分的关于Blocks内联的内容。 著名的Xcode插件：Alcatraz 完成了对Xcode 5的适配，大家可以用它方便地管理XCode的相关第三方插件。 开源项目 QFish分享了一个小项目：xproj，可以帮iOS开发者批量地为工程文件添加编译参数 -fno-objc-arc 或 -fobjc-arc。 ECMobile 3.0.0发布，完全基于 BeeFramework 0.5.0 开发，它可以作为使用BeeFramework的参考项目。 移动开发小冉写了一个类似虾米音乐的iOS App首页左右滑动效果的示例程序，代码质量很高，项目地址在这里。 SWParallaxScrollView：SWParallaxScrollView是一个具有多个层次的可滑动视图，可以实现不同层之间不同的滑动速度。该技术常常用来做应用初次启动时的介绍。"},{"title":"不要使用SBJSON(json-framework)","date":"2012-05-05T01:35:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"archive/2012-05-05-do-not-use-sbjson.html","permalink":"https://blog.devtang.com/archive/2012-05-05-do-not-use-sbjson.html","excerpt":"不知道为什么，在iOS开发中，有很多人使用 SBJSON （又被称作json-framework)来做JSON解析库。我想这是因为SBJSON是最早在iOS上出现的JSON解析库。但是随着iOS开发的流行，越来越多优秀的JSON解析库也涌现出来, SBJSON和它们相比，性能上有很大的差距。","text":"不知道为什么，在iOS开发中，有很多人使用 SBJSON （又被称作json-framework)来做JSON解析库。我想这是因为SBJSON是最早在iOS上出现的JSON解析库。但是随着iOS开发的流行，越来越多优秀的JSON解析库也涌现出来, SBJSON和它们相比，性能上有很大的差距。 现在iOS行业内主要流行的JSON解析库有：NSJSONSerialization、Apple JSON、TouchJSON、SBJSON、YAJL、JSONKit 行业内许多同行都对这些库进行过benchmark测试。我在网上搜到的测试文章包括： https://github.com/samsoffes/json-benchmarks http://blog.csdn.net/arthurchenjs/article/details/7009995 http://blog.csdn.net/ccat/article/details/7207871 http://omegadelta.net/2011/11/04/json-framework-now-sbjson-is-evil/ http://stackoverflow.com/questions/2256625/comparison-of-json-parser-for-objective-c-json-framework-yajl-touchjson-etc 下图是我从ArthurChenJS的博客文章中截取的一张benchmark测试结果图(横条越短，解析速度越快)： 从这些文章中可以看到，SBJSON在多数测试中都处于倒数的第一或倒数第二的位置。所以说，SBJSON实际上在性能这一点上讲，确实是非常“SB”的，实在不值得大家留念。赶快把你的JSON解析库换成其它的吧！ 那么应该换成哪个呢？如果你的app只支持iOS 5.0以上系统，那么直接用苹果官方提供的JSON库：NSJSONSerialization库即可。如果你的app要支持iOS 5.0以下的系统，那么我个人推荐JSONKit，不过JSONKit本身做了很多内存上的优化，所以不支持ARC，你在使用时可以对其加上 -fno-objc-arc 的编译标志即可，设置这个编译标志的详细步骤可以见这篇文章。 JSONKit的使用也非常方便，在使用上只需要把SBJSON的JSONValue方法换成objectFromJSONData，JSONRepresentation方法换成JSONString即可。附上一段使用示例： #import &quot;JSONKit.h&quot;NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;json&quot;];NSData *content = [NSData dataWithContentsOfFile:path];NSDictionary *kitData = [content objectFromJSONData];NSString *kitString = [kitData JSONString]; 祝大家玩得开心。"},{"title":"使用Alcatraz来管理Xcode插件","date":"2014-03-05T14:36:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-03-05-use-alcatraz-to-manage-xcode-plugins.html","permalink":"https://blog.devtang.com/archive/2014-03-05-use-alcatraz-to-manage-xcode-plugins.html","excerpt":"简介Alcatraz 是一个帮你管理 Xcode 插件、模版以及颜色配置的工具。它可以直接集成到 Xcode 的图形界面中，让你感觉就像在使用 Xcode 自带的功能一样。 安装和删除使用如下的命令行来安装 Alcatraz： mkdir -p ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins;curl -L http://git.io/lOQWeA | tar xvz -C ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins 如果你不想使用 Alcatraz 了，可以使用如下命令来删除： rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcpluginrm -rf ~/Library/Application\\ Support/Alcatraz","text":"简介Alcatraz 是一个帮你管理 Xcode 插件、模版以及颜色配置的工具。它可以直接集成到 Xcode 的图形界面中，让你感觉就像在使用 Xcode 自带的功能一样。 安装和删除使用如下的命令行来安装 Alcatraz： mkdir -p ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins;curl -L http://git.io/lOQWeA | tar xvz -C ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins 如果你不想使用 Alcatraz 了，可以使用如下命令来删除： rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcpluginrm -rf ~/Library/Application\\ Support/Alcatraz 使用安装成功后重启 Xcode，就可以在 Xcode 的顶部菜单中找到 Alcatraz，如下所示： 点击 “Package Manager”，即可启动插件列表页面，如下所示： 之后你可以在右上角搜索插件，对于想安装的插件，点击其左边的图标，即可下载安装，如下所示，我正在安装KImageNamed插件： 安装完成后，再次点击插件左边的图标，可以将该插件删除。 插件路径Xcode 所有的插件都安装在目录~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/下，你也可以手工切换到这个目录来删除插件。 关于 Xcode 的插件机制Alcatraz 当前只支持 OSX 10.9 and Xcode 5。不要抱怨了，这其实主要是因为苹果并没有开放插件机制，每次升级 Alcatraz 都都要重新适配。如果你看 Alcatraz 的 Commit Log，你就会发现，Alcatraz 花了几个月时间，才适配到 Xcode 5，这对于插件开发者来说，是比较难受的。 所以作为一款开源并且免费的插件，只支持最新版的 Xcode 可以让开源作者节省大量精力。我也希望苹果能早日开放 Xcode 的插件机制标准，方便广大的插件开发者构建强大的第三方增强工具。 推荐的插件我个人比较喜欢 XCode 的 vim 插件 XVim，微博里大家推荐过的还有 KImageNamed 插件，Alcatraz 里面应该好用的插件很多，我还没有时间试用。 这儿有一些朋友整理的插件列表：《那些不能错过的 Xcode 插件》 如要你发现好用的插件，欢迎在留言处回复告诉我，我可以推荐给大家。谢谢～ 插件开发如果你觉得自己很牛逼，想尝试开发插件，这儿有一些教程： 《Xcode5 Plugins 开发简介》 《Xcode 4 插件制作入门》 《写个自己的 Xcode4 插件》"},{"title":"iOS移动开发周报-第4期","date":"2014-03-21T12:23:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-03-21-ios-weekly-4.html","permalink":"https://blog.devtang.com/archive/2014-03-21-ios-weekly-4.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 本周iOS移动开发周报，带来一系列iOS开发教程以及2个开源项目。这期中的2个开源项目都比较值得关注，一个是VVebo写的GIF解决方案，另一个是用OC实现的QQ自动回复机器人。后者的作者是图书《iOS应用逆向工程》的作者，这本书也是一本不错的安全方面的入门图书，一并推荐给大家。 教程 《分析iOS Crash文件：符号化iOS Crash文件的3种方法》：文章介绍了拿到用户的.crash文件之后，如何符合化（Symbolicating）crash文件的3种方法。它们分别是：使用Xcode、使用命令行工具symbolicatecrash，以及使用命令行工具atos。这些方法可以帮助开发者尽快找到应用crash的原因。 《自定义控件》：本文翻译自objc.io的《Custom Controls》，讨论了一些自定义视图和控件的诀窍和技巧。文章先对UIKit已经提供的控件做了一个概览，介绍一些渲染技巧，随后深入到视图和它们的所有者之间的通信策略，并简略探讨了辅助功能、本地化和测试。 《关于字典的介绍》：文章介绍了OS X和iOS里面系统提供的字典服务以及调用方法。其中OS X中介绍的是使用私有API的方法，而iOS中介绍的是使用公开的UIReferenceLibraryViewController的方法。 《Android Development Tips For iOS Devs》：写给iOS开发者看的Android开发技巧，适合有iOS开发背景的朋友学习Android开发。 《iOS 7之UICollectionView与UIKit Dynamics》：UIKit Dynamics 是 iOS 7 中基于物理动画引擎的一个新功能–它被特别设计使其能很好地与 CollectionView 配合工作。本文介绍了如何将这两个特性结合在一起。文章翻译自objc.io第5期。 《LLDB调试命令初探》：LLDB是LLVM下的调试器，Xcode从4.0开始编译器开始改用LLVM，相应的调试器也从gdb改为LLDB。而从 Xcode5.0开始所有工程也被自动设置为使用LLDB。本文从初学者的角度讲解了在日常的开发中如何使用LLDB以及LLDB常用的命令。 《提高Interface Builder高效工作的8个技巧》：文章介绍了Xcode的界面编辑器Interface Builder的8个使用技巧，可以提高工作效率。 《自由地控制 Xcode Open Quickly 打开方式》：文章介绍了Xcode Open Quickly使用的一则技巧，可以方便地控制打开方式。 《static和被裁的符号表》：作者念茜这次从安全防御角度出发，讲解利用static关键字裁掉函数符号，以便不让攻击者理清自己程序的敏感业务逻辑，提高应用的逆向门槛。 开源项目 微博客户端 VVebo 的作者开源了他自己为VVebo写的GIF解决方案 VVeboImageView， 占用内存很小。 《iOS客户端自动回复机器人源码》：作者实现了一个QQ的自动回复机器人。"},{"title":"iOS移动开发周报-第5期","date":"2014-03-28T15:52:29.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-03-28-ios-weekly-5.html","permalink":"https://blog.devtang.com/archive/2014-03-28-ios-weekly-5.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期移动开发周报带来如下内容：减小iOS应用程序的大小，Quartz Composer的增强工具Origami的教程以及jQC工具等。 新闻 《The Mac Freebie Bundle 3.0》：该网站提供了7个原本收费的Mac App的免费购买。笔者试用了一下其中的X-Mirage，它可以把iPhone投到Mac上，并提供录象功能，适合将演示导出成视频。另外那个页面有Bug，在购买时信用卡信息不用填写，留空就可以直接购买成功。 《App Store 将增加匹配相关搜索关键字的新功能》：新增加的功能有助于提高相关关键词的点击量。 教程 《injection plugin for xcode》：Injection Plugin For Xcode 是 Xcode 上的一个插件。利用它可以修改应用代码，实时在模拟器或实机上看到效果而不需要重启应用。作者介绍了该插件的详细使用方式。 《UI Prototyping with Quartz Composer and Origami》：由于工具的欠缺，大量的交互设计师的工作效率非常低下，他们为了做出一个新颖的效果常常需要花费大量精力。这次Facebook免费开放出基于苹果Quartz Composer的增强工具集Origami，使得交互设计工作得到更好的辅助。不过另一方面，该工具仍然需要设计师具备一定的逻辑思维能力，所以对于广大设计师来说，交互设计工具Origami对设计师带来的既是机会，同时也是挑战。本教程介绍了如何使用Quartz Composer 和 Origami来做交互设计。 写给 iOS 开发者的系列教程：从有iOS开发背景的人的角度，学习其它语言： Android篇，C++ 篇1和C++ 篇2，Go 篇。 《利用长按手势移动 Table View Cells》：本教程中介绍了如何通过长按手势来移动 table view中的cell，这种操作方式就像苹果自家的天气 App 一样。 《减小iOS应用程序的大小》：本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章: 《减小iOS应用程序升级时所需下载的大小》，这与第一次安装使用的工作原理有所不同。 《NSNumber对象缓存以及Tagged Pointer》：本文讨论了NSNumber对象的缓存以及苹果在64位系统引入的Tagged Pointer对象。 工具 jQC 1.0：jQC是一个与Facebook之前开源的Origami兼容的工具，提供了15个新的Patch来提高Quartz Composer的功能。Quartz Composer是苹果提供的一个交互设计工具。 开源项目 WechatPayDemo: WechatPayDemo是一个非官方的微信支付Demo，基于微信SDK1.4.1构建。由于微信官方并没有提供支付功能的iOS Demo，加上官方的文档错误，使得本文作者花了较大精力调试。他希望开源这个工程来帮助其他iOS开发者少有一些弯路。 微转iOS客户端和服务端：微转是一个基于微博的数码设备平台，客户端和后台全部基于AVOSCloud服务实现。作者将其iOS客户端和服务端代码全部开源。 Tweaks：Tweaks让开发者可以方便地对特定事物进行标记——比如动画效果的时间，或者是按钮的颜色，或者是图片的透明度——并在使用设备实际运行应用时让开发者方便地进行实时调整。"},{"title":"iOS移动开发周报-第6期","date":"2014-04-03T13:37:15.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-04-03-ios-weekly-6.html","permalink":"https://blog.devtang.com/archive/2014-04-03-ios-weekly-6.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果修改了中国区开发者帐号的付费价格、苹果调整了5个地区的AppStore应用价格以避免利用汇率的套利、iPhone版Office应用免费等。 新闻 苹果在最近修改了中国区的开发者帐号（Developer Program）的付费方式，开始支持人民币支付并取消了美元支付。不过相对于以前99$每年的注册费用，现在需要使用688人民币。按现在的市场价汇率计算，相比以前，开发者需要多支付将近70元费用。 iPhone版Office免费：微软将自己旗下的iPhone版Office的价格修改为免费，下载地址是这里。 苹果于4月1日给开发者发邮件称：将会调整包括南非在内的5个地区的AppStore应用价格。在这之前，由于南非的货币持续贬值，一些投机分子，利用苹果商店在汇率上的漏洞，借助苹果商店汇率和实际汇率的差价来倒卖商品。《利用苹果商店规则漏洞的灰色地下产业链》揭露了该行为。 《Projects that power GitHub for Mac》：GitHub在其官方网站上分享了在开发Mac版GitHub客户端时使用的第三方库，共30个。 教程 《面向iOS开发者的Android教程》：著名的iOS原创教程网站objc.io最近推出了一期介绍Android的教程。由于作者都是具有iOS开发经验的，所以教程内容特别适合于已经有iOS开发经验的读者。文章许多知识的讲解也会拿iOS开发中已有的概念来做对比，加深读者理解。 《小心NSAssert》：作者分享了在block中使用NSAssert时需要小心循环引用的问题。 《最近开发中遇到的问题汇总》：文章依次介绍了最近开发中遇到的问题，包括：《UIButton在Disabled状态下标题混乱的问题》、《含软连字符的字符串计算显示长度的问题》和《UINavigationBar左右两边按钮可同时点击的问题》。 《Core Bluetooth Concept》：作者介绍了在iOS设备中使用CoreBluetoothAPI来实现基于蓝牙4.0通讯相关的基础知识和示例工程。 《NSHashTable &amp; NSMapTable》：作者简单介绍了一下iOS开发中相对于NSDictionary和NSSet来说，不常被人使用的NSHashTable和NSMapTable的相关知识。 工具 CocoaPodUI：CocoaPodUI是一个Xcode中的GUI插件，为iOS工程第三方依赖管理工具CocoaPods提供UI管理界面。 开源项目 Breakpoints_v2.xcbkptlist：作者介绍了如何不修改工程设置和源码，将reveal集成到调试环境中的办法。reveal是一个动态调试和修改界面的工具。"},{"title":"iOS移动开发周报-第3期","date":"2014-03-14T07:10:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"archive/2014-03-14-ios-weekly-3.html","permalink":"https://blog.devtang.com/archive/2014-03-14-ios-weekly-3.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本周移动开发周报带来如下内容：苹果发布iOS7.1相关内容，ReactiveCocoa和Origami相关的教程，一些来自于Facebook的开源项目。 新闻 《苹果发布iOS 7.1更新》：苹果在3月11日正式发布了iOS 7.1更新，支持连接车载系统CarPlay。iOS 7.1 对用户界面进一步做了改进，同时改进了Touch ID指纹识别的能力，并针对iPhone 4做了优化。也此同时，苹果也同步放出了支持iOS 7.1的集成编译环境Xcode 5.1正式版，开发者可以从苹果开发者中心下载新版本的Xcode。 《iOS 7.1 vs iOS 7》：文章对比了iOS 7.1相对于iOS 7所做的细节上的调整，这些调整结果也支持用户打分。从打分结果上看，大部分的调整得到了用户的肯定。 《3月的TIOBE编程语言排行榜》：三月的TIOBE编程语言排行榜，Objective-C和C++继续拉开差距，稳坐第三的位置。而在半年前，二者还是几乎一样的Rating值，可见移动开发在继续升温。 升级到Xcode 5.1和iOS 7遇到的各种开发问题及解决办法汇总： 《iOS 企业证书部署无效的问题》 《clipsToBounds 属性默认值变了》 《第三方库不支持64位造成编译错误》 教程 《ReactiveCocoa Tutorial – The Definitive Introduction》: RayWenderlich网站放出了从零开始学ReactiveCocoa系列教程第一课。讲得很基本很实用，适合想学ReactiveCocoa的同学作为入门教材。 《让 Nginx SPDY 和 iOS 交朋友》：SPDY是Google开发的基于传输控制协议（TCP）的应用层协议，目前已经被用于Google Chrome浏览器中来访问Google的SSL加密服务。SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议通过压缩、多路复用和优先级来缩短加载时间。作者在文章中分享了如何在iOS应用中使用SPDY协议的经验。 《利用iPhone基带读写SIM卡联系人》 和 《利用iPhone基带发送短信息》：文章简要介绍了一下SIM卡的一些常识，AT指令中中文字符的相关处理，以及如何读写SIM卡中的联系人数据，最终实现了利用iPhone基带发送短信息的功能。不过由于苹果沙盒(sandbox)的限制，该相关知识只能在越狱手机上应用。 《The 4 Minute Guide to Quartz Composer》和《Prototyping with Facebook Origami》：两篇介绍Facebook免费提供的基于Quartz Composer的交互设计工具Origami的视频教程（需要翻墙）。 工具 手工写.gitignore文件常常费时费力还容易出错，http://www.gitignore.io/ 是一个.gitignore的生成网站，iOS工程的.gitignore生成地址是这个： http://www.gitignore.io/api/xcode,objective-c 开源项目 Shimmer: Facebook 开源了他旗下应用 Paper 的加载效果，它使用了WWDC 2009中介绍的-[CALayer mask]的技术方案。 chisel：Facebook开源了LLDB的增强工具chisel，其中的许多命令对于调试界面非常有帮助。 KVOController: Facebook开源了Key-Value Observing工具KVOController。KVO是一个在iOS应用程序开发中，用于模块间通讯的技术技术，常常用于保证界面对于模型数据变化的实时响应。"},{"title":"iOS移动开发周报-第7期","date":"2014-04-10T15:34:02.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"archive/2014-04-10-ios-weekly-7.html","permalink":"https://blog.devtang.com/archive/2014-04-10-ios-weekly-7.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果WWDC2014门票开卖，ARC下dealloc过程，修改OSX和iOS程序内容的内存修改器等。 新闻 苹果WWDC2014门票开卖，开发者需通过抽签的方式申请购买：2014年苹果开发者大会（WWDC）将于6月2日至6日在旧金山Moscone West中心举行。而本次WWDC大会的门票将于旧金山当地时间4月7日上午十点开始发售，开发者需通过抽签的方式申请购买，下午五点到八点公布获得门票的名单。 教程 《Dynamic Linking》：文章详细解释了动态链接库在iOS程序中的加载过程，作者在也尝试自己实现了一个动态链接库并且在iOS程序中成功加载，不过文章最后指出，在AppStore上架的的应用，如果要加载动态链接库，该链接库需要得到苹果的签名才能加载成功，虽然这在技术上是可行的，但苹果现阶段的审核要求是不接受这种应用的。作者也将相关代码开源在 Dynamic-iOS 项目中。 《iOS 7 交互式过渡》：iOS 7 新加入了自定义 View Controller 之间的过渡效果的方法。本文介绍了如何利用相关的API实现自定义的过滤效果。文章的内容主要包括：实现自定义过渡、使用自定义过渡、让过渡变得可以交互。文中例子的工程文件也已上传至GitHub。 《ARC下dealloc过程及.cxx_destruct的探究》：在MRC时代，我们经常在dealloc方法将内部其他对象释放掉，申请的非Objc对象的内存当然也需要一并处理掉，最后调用super，继续将父类对象做析构。而在ARC时代，大部分的代码都不再需要了。这些相应的代码是如何由编译器完成的？带着这样的疑问，作者研究了LLVM的具体实现细节。 《Enemy of the State》：作者分享了程序架构中存在状态的坏处以及避免状态的一些方法：优先使用不可变对象、使用ReactiveCocoa框架、使用Model-View-ViewModel框架。 工具 在Xcode调试时忽略部分异常：作者提供了一些llvm增强脚本，用于方便地在调试时忽略掉部分异常。增强脚本的代码也开源在这里。 ClipMenu：开源的Mac OS剪贴板管理工具。 Polychromatic：一个只高亮属性和变量的Xcode插件。 Reveal-Plugin-for-XCode：作者写了一个Reveal插件，可以使工程不作任何修改的情况下使用Reveal，该插件已在Alcatraz上架。 开源项目 HippocampHairSalon：一个可以用于修改OSX和iOS程序内容的内存修改器。内存修改器最早出现在游戏中，可以修改游戏中人物的生命值等参数。其作者也在这里介绍了其制作的详细原理。"},{"title":"iOS移动开发周报-第9期","date":"2014-04-25T12:44:56.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"archive/2014-04-25-ios-weekly-9.html","permalink":"https://blog.devtang.com/archive/2014-04-25-ios-weekly-9.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：专门针对越狱iOS设备的盗号木马出现，iOS7下载自定义的字体功能不可用，Toll-Free Bridging等。 新闻 专门针对越狱iOS设备的盗号木马出现：国外的iOS开发者 @iOn1c 发现一个来自中国的开发者”WANG XIN”签名的iOS平台的木马插件，该插件是一个名为Unflod.dylib动态链接库，可以将越狱机器上的AppleID用户名和密码盗取，并且发送到指定服务器上。这里有该恶意插件的反汇编代码。笔者作为一个资深iOS开发者，建议一般普通用户，如果是为了用盗版软件就别越狱了，各种国内的越狱渠道都非常不安全的。如果是开发者们为了研究安全而越狱的，最好也只是在专门研究用的iTouch上使用，以避免可能的安全风险。 iOS7下载自定义的字体功能不可用：墨客的作者@an00na发现iOS提供的下载自定义的字体功能有bug，完全不能使用。相关的Bug说明在这里。 教程 《Toll-Free Bridging》：作者@晨钰Lancy在文章中介绍Toll-Free Bridging的实现原理，以及在ARC下Toll-Free Bridging的使用场景和注意事项。 《iOS7.0到iOS7.1 UI修复》：作者@白仔_wyk介绍了iOS7.0下原本正常的界面在iOS7.1显示错误的问题，并且介绍了修复方法。 《Full Length Event - Building Paper》：Facebook官方分享了介绍Paper的技术细节的视频（视频来自YouTube，需要翻墙才能观看）。视频中介绍Facebook自已实现的动画框架POP，以及如何做设计，测试，代码审核等各方面的信息。 《为一个 iOS 应用编写一个简单的 Node.js&#x2F;MongoDB Web 服务》：作者@nixzhu翻译了一个来自RW的教程，介绍了如何为一个 iOS 应用编写一个简单的 Node.js&#x2F;MongoDB Web 服务。在本教程中，你将学会如何搭建了一个 Node.js 环境，驱动 Express；在此平台之上，你将构建一个通过 REST API 来提供一个 MongoDB 数据库的服务器。对于iOS端，你将构建一个很酷的叫做“有趣的地方”的应用，标记有趣的位置，让其它用户能够找出他们附近有趣的地方。 《字体加载三种方式》：作者介绍了三种加载字体的方式：静态加载、动态加载、动态下载苹果提供的多种字体。 开源项目 PromiseKit：异步模式在iOS编程中非常常见。针对异步编程，业界提出了Promise的抽象（又称作Deferred模式）。通过这些一些库，开发人员能够在实际编程中使用Promise模式，每个Promise都拥有一个叫做then的唯一接口，当Promise失败或成功时，它就会进行回调。它代表了一种可能会长时间运行而且不一定必须完成的操作结果。这种模式不会阻塞和等待长时间的操作完成，而是返回一个代表了承诺的（promised）结果的对象。PromiseKit是Promise模式的iOS实现。 IntentKit：IntentKit是一个方便你处理第三方的URL Scheme的工具。"},{"title":"iOS移动开发周报-第10期","date":"2014-05-06T13:48:24.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"archive/2014-05-06-ios-weekly-10.html","permalink":"https://blog.devtang.com/archive/2014-05-06-ios-weekly-10.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果发布 2014 年第二季度财报，Facebook将神奇动画引擎Pop开源，Objc.io中文翻译站建成，iOS 7.1.1 更新可能造成升级失败等。 新闻 《Facebook 发布应用内深度链接技术：AppLinks》：Facebook 刚刚在 f8 开发者大会上正式发布了 AppLinks 技术。该链接技术允许开发者在任何内容中植入链接，在点击后将用户带到应用内的其他地方，或是另一款应用内、或另一款应用的商城下载页面。这里有 AppLinks 技术的介绍视频。 《AppCode 3.0的改进》：jetbrains公司在其官方博客上介绍了对于AppCode 3.0的改进，他们在EAP中集成了项目设置和UI编辑。使得AppCode对Xcode的依赖性更小。在此之前，iOS工程中的UI编辑必须在Xcode中进行。 《Facebook将神奇动画引擎Pop开源》：Facebook 2月发布的新闻类应用Paper，因为其灵动的用户界面和交互，成为近来最令人眼前一亮的移动产品之一，而POP是Paper使用到的动效引擎。 iOS 7.1.1 更新，但可能造成升级失败：iOS7.1.1进一步改进了 Touch ID 的指纹识别，修复了可能影响键盘响应能力的错误，修复了启用 VoiceOver后使用蓝牙键盘时出现的问题。笔者发现非常多朋友的iPhone通过OTA升级iOS 7.1.1失败了，需要连接itunes恢复。他们的手机均未越狱。当然，也有升级成功的，大家小心，升级前一定先备份好资料。 《苹果发布 2014 年第二季度财报，收入同比增长 5%，净利润同比增7%》：苹果公司发布了2014财年第二财季业绩。报告显示，苹果公司第二财季营收为456.46亿美元，比去年同期的436.03亿美元增长5%；净利润为102.23亿美元，比去年同期的95.47亿美元增长7%。苹果公司第二财季营收和每股收益均超出华尔街分析师预期，推动其盘后股价大幅上涨逾7%。 《Facebook第一季度财报：净利润同比增193%》：4月24日Facebook发布了截至3月31日的2014财年第一季度未经审计财报。报告显示，Facebook第一季度营收为25.02亿美元，比去年同期的14.58亿美元增长72%；净利润为6.42亿美元，比去年同期的2.19亿美元增长193%。 教程 Objc.io中文翻译站建成：@onevcat和@方一雄、@nixzhu等几十个译者一起努力，完成了objc.io上的所有文章的翻译，这是一个objc.io的完整、准确、优雅的中文翻译版本，为中国 Objective-C 社区带来最佳实践和先进技术。整个过程花费了一个多月。这是值得每一个iOS开发者学习的资料。 《制作一个可以滑动操作的 Table View Cell》：Apple 通过 iOS 7 的邮件（Mail）应用介绍了一种新的用户界面方案——向左滑动以显示一个有着多个操作的菜单。本教程将会向你展示如何制作一个这样的 Table View Cell，而不用因嵌套的 Scroll View 陷入困境。 《精通iCloud文档存储》：即便已经推出了3年，iCloud 文档存储依然是一个充满神秘、误解和抱怨的话题。iCloud 同步经常被批评不可靠且速度慢。虽然在 iCloud 的早期有一些严重的 bug，开发者们还是不得不学习有关文件同步的课程。文件同步事关重大，为应用开发带来了新方向，一个经常被低估的方向，比如进行同步服务相关的合作时，对于处理文件异步更改的需要。本文会介绍几个创建支持 iCloud 的应用时可能会遇到的一些绊脚石。 《关于用 OS X 做网站服务器》：V2EX的作者分享了关于用 OS X 做网站服务器的经验。 《Xcode 5 – Tips and tricks》：文章介绍了Xcode 5相关的常用快捷键。 《研究 UIActivityViewController》：UIActivityViewController出现于 iOS 6，在应用里为分享和操作数据提供了一个统一的服务接口。作者详细介绍了UIActivityViewController的使用以及如何创建一个自定义 UIActivity。 《小细节大作为：提高iOS访问权限通过率有这几个办法》：Brenden Mulligan是群组照片聚合应用Cluster的创始人之一，兼设计师。作为一名产品设计师和企业家，Brenden的作品包括 OneSheet和ArtistData等。在文章中，Brenden讲述了原生应用Cluster是如何提高iOS访问权限通过率的。 工具 TouchColor：TouchColor是一个由@方秋枋开发的优雅简洁，功能完善的取色器。它提供照片取色，照相取色，实时取色三大功能，并且在AppStore上免费提供下载。 开源项目 POP：POP是Paper使用到的动效引擎。 PopTut：一个使用POP做动效的示例工程。除了示例代码外，作者也提供了视频教程。 《github优秀开源项目大全-iOS》：作者搜集了在github上的一些优秀的开源项目。"},{"title":"iOS移动开发周报-第8期","date":"2014-04-18T13:58:29.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"archive/2014-04-18-ios-weekly-8.html","permalink":"https://blog.devtang.com/archive/2014-04-18-ios-weekly-8.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：SDWebImage缓存图片的机制、使用Etag增强iOS的URL缓存功能、从Facebook看移动开发的发展、FuzzyAutocomplete插件等。 教程 《SDWebImage缓存图片的机制》：文章详细介绍了SDWebImage对于图片的缓存逻辑的实现细节。 《使用Etag增强iOS的URL缓存功能》：iOS下对于缓存的支持有很多，比如Core Data，它可以很方便的建模和操作本地SQLite数据库， NSUserDefaults则可以用来缓存一些用户配置等等。本篇主要谈谈使用Etag标签来解决iOS下的URL缓存问题。服务端使用的是Tornado，原生支持Etag，而且默认处于开启状态，因此在应用层面基本不需要额外的代码处理。客户端使用NSURLCache配合AFNetworking进行网络请求。 《初始化阶段 —— load 和 initialize》：文章介绍了load函数和initialize函数各自的加载顺序。最后文章总结出：将针对于类修改放在intialize中，将针对Category的修改放在load中。假如是修改系统的类，一般会通过添加Category来添加功能，如果修改initialize会导致原生的intialize不会执行，所以放在load中会比较妥当。 《ObjC @interface的设计哲学与设计技巧》：学习Objective-C语言时，尤其是先学过其他编程语言再来看Objective-C时，总会对Objective-C的类声明的关键字interface感到有点奇怪，在其它面向对象的语言中通常由class关键字来表示，而interface在Java中表示的却大约相当于Objective-C的protocol，这个关键字的区别究竟代表了Objective-C语言的设计者怎样的思想呢，在Objective-C类设计中需要注意哪些问题呢？作者在文章中对这个问题进行一些思考和探究。 《从Facebook看移动开发的发展》：作者从Facebook的故事切入，分享了未来移动开发快速发展中，给设计师和程序员带来的挑战。 《CoreData Object 变成 Fault 的另一种方式》：CoreData是一个架构庞大、学习曲线比较陡峭的 iOS 组件，每次遇到问题都会对其有新的认识。文章分享了关于错误认知 Object（NSManagedObject）与 Context（NSManagedContext）的引用关系而导致的 Fault 问题。 《关于 Mac 右键菜单》：Mac OS X Lion 的 Launch Service 用于关联应用程序和文件并维护最近打开的项目列表。在文件关联和右键菜单方面，每当系统安装一个新的应用程序，都会调用 Launch Service 的 API 注册关联的文件类型。文章详细介绍了这其中的过程。 工具 fnd.io: fnd.io 是一个App Store的网页版，搜索速度非常快，可以用来代替itunes进行应用的检索。 Shortcut Foo：Shortcut Foo是一个训练你记忆快捷键的网站，除了包括iOS的第三方IDE AppCode的内容外，还包括vim，emacs, git等内容。 FuzzyAutocomplete：FuzzyAutocomplete是一个Xcode自动补全插件，刚刚更新到了2.0版本。它可以让你不需要再遵循从头匹配的原则来补全代码，而是随便输入你记得的关键字来进行匹配，整个插件的响应速度也非常快。 开源项目 Lockbox: Lockbox是一个帮助你方便地将数据保存到keychain中的开源工具类。 Framework7： Framework7 是一个功能齐全的 HTML 框架，用来构建 iOS7 应用程序。Framework7 允许你使用Javascript代码来实现应用的列表，侧边栏，弹出框等控件。"},{"title":"iOS移动开发周报-第12期","date":"2014-05-24T02:04:19.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"archive/2014-05-24-ios-weekly-12.html","permalink":"https://blog.devtang.com/archive/2014-05-24-ios-weekly-12.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果更新WWDC 2014应用、GCD 深入理解、objc.io第12期翻译等。 新闻 《苹果更新WWDC 2014应用 公布主题演讲时间》：2014年苹果公司全球开发者大会(WWDC)将于6月2日举行。5月21日，他们更新了iOS版WWDC官方应用，并将公布主题演讲时间。 《各种WWDC2014现场聚会》：该项目列出了各种第三方公司或组织打算在WWDC时候进行的线下聚会。 《关于发现的一个流氓黑客恶意盗号插件的源头追踪》：威锋技术组分享了追踪一个恶意盗号插件源头的过程。从中我们可以看到越狱手机市场有多么混乱和危险。笔者认为，如果不是研究安全为目的，就不要越狱，特别是不要为了装盗版而越狱。 教程 《GCD 深入理解：第二部分》：本文是由Riven和@nixzhu共同翻译的GCD 深入理解的第二部分。文章更加深入地介绍了 GCD 的高级用法，包括 Dispatch Group 、并发的危害、正确的阻塞方式、信号量以及 Dispatch Source 等。 《objc.io第12期翻译：动画》：本期翻译涵盖了iOS动画的方方面面——从 UIView 动画，Core Animation，一直到从零打造一个你自己定义的动画。文章还讨论了 View Controller 和 Collection View 有关的动画，以及如何让动画变得可以交互。 《Using Sketch Mirror, LiveView, SilkScreen, Skala Preview, AirServer &amp; others via USB》：文章介绍了用 USB 热点共享提高演示时 iPhone 画面帧数的技巧，该技巧可用于在使用AirServer或Sketch mirror等应用时，在wifi糟糕的环境下解决数据传输太慢的问题。 《High Performance Core Data》：文章列出了讲Core Data 性能方面的各种资源，包括博客、Podcast以及开源代码。 NSScreenCast：NSScreenCast是一个风格有趣的iOS教程网站。 工具 avocado：avocado是一个基于Facebook Origami的交互设计工具集。其由IDEO开源，可用于做交互原型设计。 resolution.im：resolution.im是一个提问各种iOS设备尺寸信息以及设计模版的网站。 开源项目 BCMeshTransformView：BCMeshTransformView是一个用于实现Mesh变换效果的开源库，关于Mesh变换，可以查阅这篇博文。 AGGeometryKit-POP：AGGeometryKit-POP是一个基于facebook POP的动效框架，这里有一个它能提供的动效演示视频。"},{"title":"iOS移动开发周报-第11期","date":"2014-05-16T13:36:16.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"archive/2014-05-16-ios-weekly-11.html","permalink":"https://blog.devtang.com/archive/2014-05-16-ios-weekly-11.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：iOS应用安全开发概述，Collection View 动画，可变参数列表的实现原理，XcodeBoost插件等。 教程 《iOS应用安全开发，你不知道的那些事》：iOS应用由于其直接运行在手机上，相比运行在服务器的后台服务，更有可能被黑客攻击。本文从网络安全、本地文件和数据安全、源代码安全三个方面，阐述iOS应用在安全性上遇到的挑战。 《Collection View 动画》：UICollectionView 和相关类的设置非常灵活和强大。但是灵活性一旦增强，某种程度上也增加了其复杂性： UICollectionView 比老式的 UITableView 更有深度，适用性也更强。本文的第一部分将集中讨论并举例说明如何用不同的类和方法来共同帮助实现一些常见的 UICollectionView 动画。在第二部分，我们将看一下带有 collection views 的 view controller 转场动画以及在 useLayoutToLayoutNavigationTransitions 可用时使用其进行转场，如果不可用时，我们会实现一个自定义转场动画。 《Variable Argument Lists》：可变参数函数（Variadic Function），即是指一个可以接受可变数量的参数的函数。在C语言中，对该特性的支持，即是通过可变参数列表（Variable Argument list）来实现的。本文讨论了其具体的实现内部原理。最后作者晨钰Lancy介绍了其开源的一个能够接收block作为回调的自定义的AlertView组件。 《assert出问题了》：作者分享了在Xcode中使用Assert时需要注意的问题。 《CoreData的坑》：pinxue分享了一个持续3年都没有修复的CoreData的Bug。 《使用cocoapods创建多个类似工程的尝试》：因为业务的需要，作者做了一批类似无聊图的App，应用本身没有复杂的逻辑，所有类“无聊图”的应用都针对特定的用户群，设计了不同界面风格的，比如适合宅男的女神应用，适合吃货的美食应用等等诸如此类，大概一共七八个。作者介绍了其使用cocoapods创建多个类似工程的尝试。 《Mac 软件和学习经验分享》：作者介绍了一些优秀的 Mac 软件和学习Mac的经验。 subjc.com：subjc.com是一个介绍iOS界面编程技巧的网站。网站中有动画实例分析以及实现的代码。 工具 XcodeBoost：XcodeBoost包含多个辅助修改代码的小功能，比如： 可以在.m文件中复制方法实现，然后将该方法的定义粘贴到对应的.h文件中 可以在某一个源文件中直接输入正则表达式查找 可以复制粘贴代码时不启用Xcode的自动缩进功能（Xcode的自动缩进经常出问题，造成已经调整好的代码缩进，因为粘贴时被Xcode调整坏了） 开源项目 Eggscellent开源：Eggscellent是Mac上的开源的番茄钟应用。 Viewfinder：移动支付公司 Square 将去年收购的照片应用 Viewfinder 开源了，包含服务端、iOS 和 Android 应用代码。这里有该项目的介绍。 PNChart：作者周楷雯Kevin发布了PNChart 0.5版本，提供了一个更漂亮的Pie Chart界面。 文本编辑器Atom开源：GitHub将其开发的文本编辑器Atom开源。"},{"title":"iOS移动开发周报-第13期","date":"2014-06-01T09:27:22.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-06-01-ios-weekly-13.html","permalink":"https://blog.devtang.com/archive/2014-06-01-ios-weekly-13.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：Facebook Pop 使用指南，用CocoaPods做iOS程序的依赖管理，在 iOS 上捕捉签名，加密你的SQLite等。 教程 《Facebook Pop 使用指南》：Facebook Pop其实是基于CADisplayLink(Mac平台上使用的CVDisplayLink)实现的独立于Core Animation之外的动画方案。文章主要介绍了Facebook Pop如何使用。 《用CocoaPods做iOS程序的依赖管理》：文章除了介绍了CocoaPods的基本功能外，还增加了如何设置国内spec镜像、使用私有pod、podfile.lock、如何创建spec文件等内容。 《在 iOS 上捕捉签名》：文章介绍了如何绘制像 Paper 应用那样的真正平滑的曲线，包括如何使用二次贝塞尔曲线使签名平滑，以及基于触摸速度，使签名宽度可变，从而创建出更加自然的笔画。 《解決WeiboSDK Bundleid 綁定問題》：@糖炒小虾_txx 利用IDA分析和 method_swizzling 破解了微博SDK的bundle d綁定，这样就可以绕开weibo sdk 的sso 和bundle id綁定的要求，这算是Objective-C黑魔法的一次有效实践。 《加密你的SQLite》：SQLite是一个轻量的、跨平台的、开源的数据库引擎，它的在读写效率、消耗总量、延迟时间和整体简单性上具有的优越性，使其成为移动平台数据库的最佳解决方案。然而免费版的SQLite有一个致命缺点：不支持加密。这就导致存储在SQLite中的数据可以被任何人用任何文本编辑器查看到。本文讨论了各种对SQLite的加密方法。 《Reveal：分析iOS UI的利器》：Reveal能够在运行时调试和修改iOS应用程序。它能连接到应用程序，并允许开发者编辑各种用户界面参数，这反过来会立即反应在程序的UI上。就像用chrome调试HTML页面一样，在不需要重写代码、重新构建和重新部署应用程序的情况下就能够调试和修改iOS用户界面。文章简要介绍了Reveal的功能和几种加载方法。 《Sprite Kit 物理引擎初体验 Part 1》：Sprite Kit 内建了一个强大的并且非常容易使用的物理引擎，你可以很容易的使用这个内置的物理引擎来模拟真实世界中的移动。文章介绍了Sprite Kit的基本使用。 工具 Podlife：Podlife是一个免费的iOS应用，可以在手机上搜寻各种 CocoaPods，并得到更新提醒。 开源项目 popping：popping是一个POP 使用实例工程。 synx：synx可以自动帮你整理项目里的文件，按 group 重新放置。"},{"title":"将博客从GitHub迁移到GitCafe","date":"2014-06-02T09:22:02.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-06-02-use-gitcafe-to-host-blog.html","permalink":"https://blog.devtang.com/archive/2014-06-02-use-gitcafe-to-host-blog.html","excerpt":"","text":"我之前一直使用 Github Pages 功能 以及 Octopress 来搭建个人博客，我也写了一篇文章 《象写程序一样写博客：搭建基于 github 的博客》 来分享博客搭建的技术细节。 但是自从我的博客每天访问量超过 2000 次以后，我就发现博客的访问速度还是一个不可忽视的问题。通过 监控宝 和 Google Analytics，我发现有些博客文章的平均打开时间长达 4 秒钟。于是我开始考虑将博客搭建在更快的服务器上面。 我的首先考虑是购买独立的 VPS，我买的是 DigitalOcean，DigitalOcean 算下来每月只需要 5$。于是在一个周末，我花时间购买了 DigitalOcean 家的 VPS，安装了 Nginx，然后在上面运行了一个脚本，定时将我 github 博客的内容自动更新过来（其实就是定期git pull一下我博客的 repo）。 就这样运行了一个月，我发现虽然 DigitalOcean 服务器的 ping 值相比 github 要快一些。但是从监控数据上看，整体的网页访问速度并没有什么提高。就在我在微博上抱怨的时候，一个朋友推荐我试试 GitCafe。于是我就尝试了一下，结果你猜怎么着？我被吓坏了。 ping 值直接从 200ms 左右减少到 3ms 左右，如下图所示： 监控宝的统计显示，首页平均打开时间从原来的 1800ms 减少到 350ms 左右，快了 5 倍，如下图所示： 所以我强烈建议各位基于 Github Pages 功能来搭建个人博客的朋友，将博客内容镜像到 GitCafe 上。如果你有个人的独立域名，那么镜像之后就可以随时将博客地址在 Github 和 Gitcafe 之间切换了。对于各位博主来说，这样做没有任何风险，因为你可以随时再切换回去。当然，免费用了人家的服务，如果你能像我这样，在网站的底部附上感谢内容，那是再好不过的了。 以下为大家介绍详细的迁移过程。 迁移教程注册如果你还没有注册过 GitCafe，首先需要 点这里 注册一下。 注册完成之后，去 公钥管理 那儿添加一下你的 ssh 公钥，这样以后提交代码会方便很多。当然你也可以不设置这一步，每次提交通过密码来验证。 在 GitCafe 上新建一个博客项目然后我们需要先在 GitCafe 上新建一个博客项目。GitCafe 的博客搭建官方教程藏得比较深，所以我第一次还没有找到，教程地址在 这里。具体来说，就是创建一个与用户名 (如果是组织，就是组织名) 相同名称的项目。如果你创建的项目名与用户名相同，GitCafe 会自动识别成这是一个 Page 项目，如下所示： 设置多个 Git Remote 源接下来我们需要将原本提交到 Github 上的博客内容同步提交到 GitCafe。因为我的博客是基于 Octopress 的，我介绍一下 Octopress 的做法，其它博客引擎的做法类似。 对于 Octopress，我们只需要每次提交网站内容时，执行完 rake deploy之后，再执行以下脚本即可（你可以将该脚本中的代码仓库地址换成你的，然后将其保存成一个脚 本文件，需要时执行一下即可）： cd _deploy# 添加 gitcafe 源git remote add gitcafe git@gitcafe.com:tangqiaoboy/tangqiaoboy.git &gt;&gt; /dev/null 2&gt;&amp;1# 提交博客内容echo &quot;### Pushing to GitCafe...&quot;git push -u gitcafe master:gitcafe-pagesecho &quot;### Done&quot;% 大概解释一下以上内容，Octopress 在发布时会将自己的 _delpoy目录切换到 master 分支，然后将生成的博客内容放到_delpoy目录中，然后执行git push操作。正常情况下，默认内容是 push 到 github 上的。我们执行的以上脚本，就是为该项目增加了一个名为gitcafe的远程仓库，然后将 master 分支 push 到gitcafe的gitcafe-pages分支。 修改 Rakefile (可选)除了以上方法外，你也可以直接修改Rakefile。在其第 269 行后增加如下代码，也可以达到同样的目的，这样你每次就仍然只需要执行rake deploy即可同时将博客同步到 github 和 gitcafe： system &quot;git remote add gitcafe git@gitcafe.com:tangqiaoboy/tangqiaoboy.git &gt;&gt; /dev/null 2&gt;&amp;1&quot;system &quot;git push -u gitcafe master:gitcafe-pages&quot; 插入代码的示例位置如下： 设置域名GitCafe 的自定义域名设置比 github 要友好得多，它不但提供了图形界面设置，并且支持同时设置多个域名。在项目管理-&gt;域名管理中，我们可以找到相应的设置项，如下所示： 在设置完之后，我们需要去域名解析的服务商那儿，将对应的域名用A 记录类型，解析到117.79.146.98即可。 添加对 GitCafe 的感谢 (可选)如果你也想像我一样，想在博客底部添加对 GitCafe 的感谢，可以参考 这个提交。它通过修改 Octopress 的source/_includes/custom/footer.html模版文件完成。 感谢最后再次感谢 GitCafe，上个月在 QCon 大会上了解到他们的发展思路和 Github 很不一样。虽然它还是一家创业公司，但是我期待看到它最终能够推动国内开源和技术社区的发展。"},{"title":"iOS移动开发周报-第14期","date":"2014-06-10T12:36:23.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-06-10-ios-weekly-14.html","permalink":"https://blog.devtang.com/archive/2014-06-10-ios-weekly-14.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果发布Swift编程语言以及Swift编程语言相关学习资料。 教程 《The Swift Programming Language》：这是苹果官方出版的Swift学习教材，可以免费下载到iBooks中阅读。其中文版翻译项目也在 Github 上火热进行中，地址在这里。 《Swift Cheat Sheet and Quick Reference》：出自raywenderlich的一份Swift快速参考手册，现在还比较简单，但它正快速更新中。 《Swift Language Highlights: An Objective-C Developer’s Perspective》：文章比较了Swift和Objective-C语言的差异性。 《WWDC14 Session 402 》学习笔记：@糖炒小虾_txx完成了三篇关于Swift的学习笔记，主要内容均来自WWDC14 Session 402的视频。 《Swift 和Objective-C性能测试》：苹果在WWDC视频中只是简单提到Swift在排序和加密算法上比Objective-C快。本文对两者的性能进行了更复杂的测试，文章中做的测试结果如下：循环100万次，Objective-C比Swift快 29倍；变量增加1， Objective-C比Swift快 46倍。还有一些其它比较，大家可以自己看原文，所以真相是：Swift其实不一定比OC快。 《行走于 Swift 的世界中》：笔者和周围朋友讨论swift的技术细节，大家都觉得swift比想像中要复杂，onevcat的本文讲述了不少swift的细节。从中你会看到，swift真的不简单。 《Swift编程语言资料大合集》：来自CSDN整理的Swift学习合集资料。 《Swift 特刊》：来自码农周刊的Swift学习合集资料。 工具下载脚本：该脚本是WWDC 2014 PDF 及session 视频下载脚本。 开源项目 WWDC的示例代码：比起GitHub上的开源项目，官方的代码更有参考价值。比如Session 406的代码Lister就用一个Swift实现的包含OSX和iOS的Productivity App，还演示了各种Cocoa新功能。 FlappySwift：FlappySwift用swift重写的一个开源Flappy Bird游戏。 JokeClient-Swift：JokeClient-Swift是@YANGReal用swift写了一个开源的糗事百科的客户端，主要涉及网络请求，图片加载、缓存、自定义UITableViewCell、delegate以及closure，内容接口基于糗事百科API。 swift-2048：一个用Swift实现的2048游戏。 UIImageView-BetterFace-Swift：UIImageView-BetterFace-Swift是一个根据目标图象中头像的位置进行智能图片裁剪的开源库，该地址是其更新的Swift版本。 Easy-Cal-Swift：swift是类型安全（type safe) 的语言。但是，由于它有类型推断（type inference）能力，所以当能推断出类型时，你不必非要写对应的类型。对于 字面量（literal value），整数会被推断成Int，浮点数会被推断成Double类型。但是，它并没有定义整数和浮点之间的加法，本项目实现了一个常用的运算符重载，这样就可以支持整数和浮点数做加法了。 HackerNews：用Swift实现的HackerNews客户端。"},{"title":"iOS移动开发周报-第15期","date":"2014-06-24T04:58:31.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-06-24-ios-weekly-15.html","permalink":"https://blog.devtang.com/archive/2014-06-24-ios-weekly-15.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：Swift 和 C# 的语法比较，一个CoreText排版性能问题，谈谈 iOS 8 和 OS X 10.10 的 Extension等。 教程 《Swift 和 C# 的语法比较》：适合有C#开发经验的朋友快速了解Swift语言。 《Swift 和 Scala 的语法比较》：适合有 Scala 开发经验的朋友快速了解Swift语言。 《AutoLayout 相关概念介绍和动画demo》：文章从传统布局的问题入手，介绍了AutoLayout 相关概念，最后提供了一个示例的Demo程序。 《一个CoreText排版性能问题》：伊书的阅读器是用CoreText排版的，在中文字体的选择上，自带的字体中只有黑体，后来发现日文字体Hiragino也是可以用于中文，而且显示效果比黑体好很多，于是选用了这个字体。但在CoreText排版中遇到个问题，用Hiragino字体排版速度非常慢，几乎是默认黑体的100倍。作者分享了整个问题查找和最后解决的过程。 《谈谈 iOS 8 和 OS X 10.10 的 Extension》：作者介绍了 WWDC 14 的视频之《Creating Extensions for iOS and OS X》中介绍的Extensions技术，解释了为何 Extensions 这么重要。 《objc第13期：架构》：本期objc.io的中文翻译带来了5篇高质量的关于iOS程序架构方面的文章，分别是：《MVVM 介绍》、《避免滥用单例》、 《iOS 中的行为》、《子类》、 《使用 VIPER 构建 iOS 应用》。 《用 Quartz Composer 和 Origami 制作一个简单的按钮动画》: 文章由 @nixzhu 翻译。阅读本文，然后照着做一遍。只需20分钟，你就能了解 QC 和 Origami 是什么，能做什么，以及怎么做。 《Reactive Cocoa详解》：Reactive Cocoa是一个函数响应式编程思想在Objective-C语言下的实现。本文将从几个方面详细介绍Reactive Cocoa。 《Cocoa​Pods》：在Objective-C的情况下，CocoaPods提供了一个绝佳的整合合作开发的工具，并且在快速发展的开发社区中起到了一个集结点的作用。在本文中，我们将通过讨论CocoaPods的过去，现在以及将来，一起庆祝0.33版本（具有里程碑意义）的发布。 《Facebook Pop 使用指南》：Facebook Pop其实是基于CADisplayLink(Mac平台上使用的CVDisplayLink)实现的独立于Core Animation之外的动画方案。作者在文章中主要介绍了Facebook Pop的使用。 工具 WWDC2014字幕下载工具：一个 OSX App，方便下载WWDC2014的视频。 《如何导出iBooks中的笔记》：文章介绍了从iBook导出笔记的技巧。"},{"title":"iOS移动开发周报-第16期","date":"2014-07-03T12:41:49.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-07-03-ios-weekly-16.html","permalink":"https://blog.devtang.com/archive/2014-07-03-ios-weekly-16.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：i​OS 8的新特性，敏感逻辑的保护方案，iOS绘图教程，WKWebView的使用等。 教程 《i​OS 8》：Mattt Thompson在文章中介绍了iOS8的各种新特性。 《iOS安全攻防：敏感逻辑的保护方案》：文章介绍了一种低学习成本的，简易的Objective-C逻辑代码重写为C代码的办法。 《谈谈 iOS 8 拍照和摄影功能的增强》：iPhone 的照相功能有着敏捷的反应速度和不错的成像素质，使得 iPhone 成为最佳的随手拍手机。这次 WWDC 14 上尽管没有任何新硬件的更新，但是 iOS 8 在照相功能上的增强再次让我这样的随手拍狂人激动不已。文章主要介绍了iOS 8 带来的倒计时拍摄和延时摄影功能。 《WWDC14 Session 401 學習筆記》：文章总结了WWDC14 Session 401介绍的PlayGround、Interface Builder和Debug相关功能的改进。 《iOS绘图教程》：本文是《Programming iOS5》中Drawing一章的翻译，考虑到主题完整性，翻译版本中加入了一些书中未涉及到的内容。该文章中比较完整地介绍了iOS的整个绘图原理及相关的API。 《Core Animation基本概念和Additive Animation》：文章介绍一些Core Animation基本概念，最后提到一些iOS8的动画改动。 《Interesting Swift Features》：文章介绍了Swift相对于Objective-C增加的一些有趣的特性，并且讨论了其带来的好处。 《Introduction to Swift Part 6: Functions》：Ray Wenderlich上的关于Swift函数的视频教程。 《Facebook Pop Tech Talk Video》：Ray Wenderlich上的关于Facebook Pop的视频教程。 《Getting started with WKWebView using Swift in iOS 8》：文章介绍了iOS8中新加的WKWebView的使用。 工具 macdown：macdown是一个开源的Mac下的markdown编辑器。 开源项目 LTMorphingLabel：用swift写的文字飘入飘出的效果。 Crashlytics-FPCustomHandler：这是一个为 Crashlytics 写的 category, 可以方便添加自己的崩溃处理函数。 ParseChat：ParseChat是基于Parse实现的一个实时的聊天室开源应用。"},{"title":"iOS移动开发周报-第19期","date":"2014-07-30T14:10:03.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-07-29-ios-weekly-19.html","permalink":"https://blog.devtang.com/archive/2014-07-29-ios-weekly-19.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果第三季度财报公布，iOS界面开发的大一统，Flipboard开源的FLEX工具等。 新闻 《净利润达77亿美元!苹果第三季度财报公布》：苹果发布了截至6月28日的2014财年第三季度财报。从财报中我们可以看到，苹果在第三财季营收374亿美元，同比增长6%；净利润为77亿美元，同比增长12%。 《苹果iOS在日本占据了超过50%的市场》：苹果iOS在日本占据了超过50%的市场，在中国的份额为14.7%。 《苹果财报解读》：中国地区 iPhone 销量上升 48%，iPhone 6 备受瞩目。 教程 《WWDC 2014 Session笔记 - iOS界面开发的大一统》：iOS 8 和 OS X 10.10 中一个被强调了多次的主题就是大一统，Apple 希望通过 Hand-off 和各种体验的无缝切换和集成将用户黏在由 Apple 设备构成的生态圈中。对于广大 iOS 开发者赖以生存的 UIKit 来说，这次最大的变化就是 Size Classes 的引入和新的 Presentation 系统了，本文对Size Classes及其相关知识进行了详细的介绍。 《Airspeed Velocity》：一个专门介绍Swift语言的博客。 《ALEXANDROS SALAZAR》：一个专门介绍Swift语言的博客。 《Supercharging Your Xcode Efficiency》：文章介绍了各种提高开发效率的Xcode使用技巧。 《插件》：插件是给你已经发布的 App 增加功能的一个好办法，Mac 上的 App 支持插件已经有很长的历史了。在 NSBundle 的帮助下，插件开发变得很简单，本文介绍了在Mac上进行插件开发的方法。 《Awesome iOS》：一个iOS的各类优秀的开源项目集合。 《iOS开发如何提高》：本文分享了iOS开发提高的各种方法。 《如何编写 iOS 8 Widget》：作者简单介绍了 iOS 8 Widget的编写方法。 ##视频 《UIKonf 2014》：国外的iOS开发技术会议UIKonf视频。 工具 Peckham：你是否遇到这样的场景?在源码中用到一个类，写完发现因为没有import它的头文件，所以编译不通过。正常情况下，你需要跳转到源代码头部加入该头文件，然后再继续跳回上次编辑位置继续写代码。这样的跳转很不方便，而且让你的逻辑被打断。Peckham是一个帮助你填写#import头文件的Xcode插件，使用它可以方便在源代码的任意位置插入所需要的头文件。 RoboVM：用Java来写原生的iOS程序。 FLEX：FLEX是Flipboard开源的一系列在应用中调试的工具集。该工具集提供了查看和修改相关view的属性功能。 AppBot: AppBot是可以订阅App Store用户的评价和评分，不局限于自己的产品，其他App也可以订阅然后会邮件发送给你，随时了解用户的评价，改善产品。本条来自 @KooFrank的推荐。 开源项目 vpn-deploy-playbook：一个自动部署各种翻墙服务的工具，包括IPSec，L2TP，PPTP，Cisco AnyConnect，SigmaVPN，APN，shadowsocks，OpenVPN，DNS，SPDY，用户管理等功能。 iReSign：一个可以把ipa用企业证书重新签名的开源项目。"},{"title":"iOS移动开发周报-第18期","date":"2014-07-22T13:19:39.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-07-22-ios-weekly-18.html","permalink":"https://blog.devtang.com/archive/2014-07-22-ios-weekly-18.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果与 IBM 展开长期深度合作，Swift官方博客，Swift开发的视频教程等。 新闻 《苹果与 IBM 展开长期深度合作，双方优势互补，专注企业级移动市场》：苹果与 IBM 达成排他性合作协议，联合各自领先市场的优势，共同打造一样新品类商业应用，建立全新的企业级移动体验——IBM 享誉已久的大数据及分析能力将注入苹果的 iPhone 与 iPad——结合后者擅长的用户体验，共同改善企业及员工使用 iOS 设备工作的流程。 《苹果官方数据显示iOS 7渗透率已达90%》：苹果最新数据显示，7月7日到13日之间，在访问App Store的设备中，90%的设备运行了iOS 7系统，而距离iOS 7正式发布仅仅为10个月的时间。不过国内iOS 7系统的比例还远远未达到80%。 教程 《Swift官方博客》：苹果在开发者中心建立了Swift官方博客，用于帮助开发者获得Swift的相关知识和资源。 《利用QuincyKit + KSCrash构建自己的Crash Log收集与管理系统 》：iOS bug定位是极看重crash log的，目前网上Crash Log收集与管理服务较有名的有Crashlytics, Flurry, 友盟等。本文介绍了QuincyKit + KSCrash构建自己的Crash Log收集与管理系统的适用场景和特点。 《0 代码 ViewController》：作者尝试利用Interface Builder的Object控件实现了一个0行代码的View Controller，在减小Controller体积小，提供了一些新颖的思路。不过需要注意，其文章示例代码中的ViewModel持久了View对象，其实不是指的（MVVM）中ViewModel，更像是一个Controller的代理。 《From Objective-C to Swift: thoughts and hints》：文章详细比较了Objective-C与Swift在编程中的细节差异。 视频 《Swift开发的视频》：jakelin做了一个Swift开发的视频，视频从头到尾的讲述了如何开发一个Swift Weather app，同时也讲述了CococaPods，Core Location和AFNetworking的使用，源码地址在 这里 。 工具 蒲公英：蒲公英是专为iOS开发者提供的免费应用众测平台，旨在解决开发者将应用分发给内测用户及众测时的繁杂、低效的问题。使用蒲公英，开发者可将应用一键上传至蒲公英网站实现托管，托管后的应用拥单独的下载页面。开发者只需将下载页面地址（或二维码）发给内测用户，测试用户即可用手机直接安装，避免了之前测试用户需要将手机用数据线连接到电脑，才能安装测试应用的痛苦过程。它的特点是可以帮你用企业证书签名，同时设置密码，帮助大家分发测试版本。 jazzy：jazzy是一个为Objective-C和Swift语言生成帮助文档的开源工具。 开源项目 Realm：Realm是一个真正为移动设备打造的数据库，同时支持Objective-C和Swfit。Realm宣称其相比Sqlite，在移动设备上有着更好的性能表现。"},{"title":"iOS移动开发周报-第20期","date":"2014-08-12T12:08:34.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-08-12-ios-weekly-20.html","permalink":"https://blog.devtang.com/archive/2014-08-12-ios-weekly-20.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：iOS 通知中心扩展制作入门，iOS APP可执行文件的组成，objc非主流代码技巧等。 教程 《iOS 通知中心扩展制作入门》：本文通过一个简单的实用 demo 介绍了一下 iOS 8 中扩展开发的一些共通方法和一个通知中心扩展的实际制作。 《iOS APP可执行文件的组成》：iOS APP编译后，除了一些资源文件，剩下的就是一个可执行文件，本文分析了该可执行文件的组成。该文章的作者是 @bang。 《SpriteKit在iOS8和OSX10.10中的新特性》：在iOS8和OSX10.10中SpriteKit迎来了重大升级。在物理表现方面增加了着色器，光照和阴影；在物理模拟方面增加了像素物理体、力场和宇宙动力学和约束等；在Xcode中集成了场景编辑器，你不需要写代码就能完成一些复杂的工作；此外它还集成了SceneKit以及其他的改进。本文对这些新特性做了详细介绍。 《使用LLDB远程调试APP》：文章作者因为最近要开始学习一些iOS逆向的一些东西，调试别人的app自然是必不可少的工作。试验后发现用GDB调试并不好用，而且苹果推的也是LLDB，所以需要使用LLDB来进行调试工作。使用LLDB就不像使用GDB进行调试那么方便，使用GDB的话直接在Cydia里面安装好GDB之后，ssh到你的设备就可以开始工作了，使用LLDB远程调试你越狱设备上的APP稍微麻烦一点。作者详细介绍了使用细节。 《Objective-C之优雅的命名》：计算机语言是人和计算机之间通讯的媒介。好的代码应该是就像人对计算机说话那样，自然而优雅。命名看上去是一件很简单的事，而往往越是简单的事越难做好，否则大师们也不会把命名看成是计算机界的难题了。如何把Objective-C这门计算机语言以优雅的方式“说”出，还是比较考验工程师对它的理解深度的。在苹果的SDK中有大量的API，我们可以从这些API中体会到一些命名的艺术。 《Apples to apples, Part II》：本文是JSQMessagesViewController 的作者 Jesse Squires 博客上写的一篇 Objective-C 与 Swift 性能对比分析文章。从中可以了解到在开启完优化之后，Swift在性能上的表现是非常不错的。本文来自 @isaced的推荐。 《iOS8-day-by-day》：这是一个学习iOS8的系列文章合集，一共有16篇文章。 《objc非主流代码技巧》：看开源代码时，总会看到一些大神级别的代码，给人眼前一亮的感觉，多数都是被淡忘的C语言语法，作者在文章中总结了objc写码中遇到的各类非主流代码技巧和一些妙用。 《iOS音频播放 (五)：AudioQueue》：本文讲解了如何使用AudioQueue播放音频数据。 工具 Faux Pas for Xcode：Faux Pas for Xcode是一个项目检查工具。使用它相当于给自己的项目请了一个专业的 Reviewer，它会指出项目级别上不规范不合理的地方，并且有相关内容的链接可以学习。 App Icons Create Tool：这是 @往何处寻 做的一键创建iOS APP应用图标的在线工具，可以帮助你生成各种尺寸的应用图标。 ios-dev-playbook: ios-dev-playbook是一个快速配置 iOS 开发需要的服务器工具。目前只支持 Debian Wheezy服务器，可以安装 GitLab、Countly、Jenkins 等。该项目作者是@lexrus。 开源项目 Alamofire：Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。 EasyIOS: EasyIOS是基于MVVM 的iOS开发框架。它封装了Scene、SceneModel、Model、Action四种模型来对IOS进行开发，4种模型的定义解决了IOS开发中ViewController承担了过多角色而造成的代码质量低下，使得结构思路更加清晰。 1Password Extension for iOS Apps：1Password的扩展SDK，可以方便地集成到iOS应用中。"},{"title":"iOS移动开发周报-第22期","date":"2014-08-24T11:14:22.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-08-24-ios-weekly-22.html","permalink":"https://blog.devtang.com/archive/2014-08-24-ios-weekly-22.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果股价创新高，iOS8自动调整UITableView布局，Swift学习心得等。 新闻 《苹果股价创新高 市值全球第一超第二名30%》： 8月20日，苹果公司周二收盘股价创下历史新高水平，超过了2012年保持的最高记录。苹果作为全球市值最高的公司，比全球市值第二大的埃克森美孚公司高出了30%。 教程 《Swift学习心得》：作者分享了学习Swift语言的心得，包括苹果为什么要设计Swift语言以及Swift语言的各种特性。 《iOS8自动调整UITableView和UICollectionView布局》：本文讲述了UITableView、UICollectionView实现self-sizing cell布局的知识，以及如何用InvalidationContext优化UICollectionView布局的更新。作者微博：@杨萧玉HIT。 《创建SpriteKit游戏的最佳范例》：本文从拓展性、游戏构造和性能三个方面分别讲述建立SpriteKit游戏时的一些实践经验和范例。作者微博：@杨萧玉HIT。 《在企业内部分发 iOS 应用程序》：在企业内部分发 iOS 应用程序非常复杂，作者详细介绍了实现的过程。 《Value and Reference Types》：苹果的这篇官方微博介绍了Swift的值类型和引用类型的差别。 《How to Add Table View Search in Swift》：来自raywenderlich的教程，用Swift实现为TableView增加搜索功能。 《Swift Name Mangling》：文章分析了Swift编译器对于函数名的处理方式。 《Swift Literal Convertibles》：文章介绍了Swift中的字面量（Literal）的类型转换规则。 开源项目 fishhook：fishhook是Facebook开源的一个可以hook系统方法的工具。"},{"title":"iOS移动开发周报-第17期","date":"2014-07-11T11:36:11.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-07-11-ios-weekly-17.html","permalink":"https://blog.devtang.com/archive/2014-07-11-ios-weekly-17.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：Swift 进入TIOBE 指数排名16，Swift 在 Beta3 中的变化，WebKit in iOS 8等。 新闻 《Swift 进入TIOBE 指数排名16》：在TIOBE的 2014年7月编程语言排行榜上，苹果公司新的编程语言Swift发布一个月内就进入TIOBE指数，名列位置16，前三名则没有变化，依旧是C、Java、Objective-C。 《韩国当局下令 Apple 改变 App Store 退款政策》：近日韩国当局已经下令 Apple 修改其公司的 App Store 退款政策，理由是现有政策违反了公平贸易的相关规定。众所周知，目前 App Store 的退款政策是用户先提交请求，然后由 Apple 员工审核要不要进行退款。也就是说，最终是否能够退款存在着员工一定的主观因素，因此被韩国公平贸易委员会认为这是不公平的。 教程 《Swift 在 Beta3 中的变化》：刚刚更新的Xcode 6 Beta3中，Swift编译器又进行了较大的更改，本文章详细介绍了改动细节。 《用Swift实现Pinterest中的转场效果》：在StackOverFlow上有人问Pinterest中转场的效果是如何实现的，在Pinterest的Blog上工程师大致对Pinterest的结构作了大致的介绍，但是没有涉及到具体动画部分的实现。所以作者抽空用Swift重新实现了一遍这个转场的效果。 《WebKit in iOS 8》：苹果在WWDC上公布了iOS的新框架WebKit.framework，其包含了新的网页浏览控件WKWebView。本文介绍了其相对于UIWebView所做的改进。 《iOS 8 presentation controller》：iOS 8 新加入一个类：UIPresentationController，它与 iOS 7 新添加的类与协议一道，帮助我们方便快捷地实现View Controller 的自定义过渡效果。作者完成了一个使用相关API的演示程序。 《MVVM Tutorial with ReactiveCocoa》：RW新的ReactiveCocoa教材出炉了。不同于上次SimpleWeather的面面俱到，这次主讲MVVM设计模式和数据绑定。 《Strings in Swift》：文章介绍了Swift中字符串的各种细节上的使用注意事项。 视频 《移动APP背后的安全问题》：现在已进入移动互联网时代，吃喝玩乐、办公支付等等各种应用都在抢占移动APP市场，由于安全无处不在的本质，在多年前就已经有少数人在研究移动APP的中木马、钓鱼等等，但很少有人想到移动APP安全跟WEB安全的关系。安全宝安全团队Leader尹毅在视频中分享了： 1、移动APP市场安全现状 2、安卓APP的反编译及漏洞挖掘 3、利用移动APP渗透的各种“猥琐”思路 4、自动化移动APP安全漏洞挖掘的程序实现。 工具 《dSYM 文件分析工具》：Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件。作者分享了一个工具，能够根据dSYM文件方便从Crash信息中分析出有可能错误的地方。 开源项目 QueryKit：QueryKit是一个用Swift实现的、方便对CoreData数据进行查询的工具库。"},{"title":"iOS移动开发周报-第23期","date":"2014-09-01T12:22:54.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-08-30-ios-weekly-23.html","permalink":"https://blog.devtang.com/archive/2014-08-30-ios-weekly-23.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果发出9月9日发布会邀请函，AFNetworking2.0源码解析，objc与鸭子对象，Protecting iOS Applications等。 新闻 《苹果发出9月9日发布会邀请函》：苹果公司刚刚向外界发出邀请函，太平洋时间9月9日上午10点（北京时间9月10日凌晨1点），将在美国库伯提诺市弗林特剧院举行发布会。本次发布会的主角极有可能是iPhone 6及iWatch智能手表。 教程 《AFNetworking2.0源码解析》：AFNetworking是著名的iOS网络库，文章作者分享了其阅读AFNetworking2.0源码的收获。 《Creating a Custom Control in Swift》：文章介绍了如何使用Swift自定义一个进度条控件。 《iOS干货精选》：本文是《码农周刊》中的精品文章的集合，包括iOS和Android部分。 《Kicking Off our $500K Learn Swift Series》：TopCoder推出学习Swift系列比赛，拿出多达50万美元奖励学习成绩突出者。 《Optionals Case Study: valuesForKeys》：来自苹果官方博客的教程，通过学习Dictionary的valuesForKeys方法，来了解Optional类型。 《Xcode5 Asset Catalog 使用备忘》：Asset Catalog是Xcode5引入的一个新的图片管理方式，文章介绍了使用Asset Catalog创建可拉伸图片的方法。 《objc与鸭子对象（上）》、《objc与鸭子对象（下）》：文章上半部分介绍了鸭子类型和它在ObjC中的实践，以及一个使用NSProxy实现JSON Entity的鸭子类。下半部分介绍了鸭子对象的进阶用法，并简单介绍由鸭子对象思想衍生出的依赖注入。 《Protecting iOS Applications》：文章系统地介绍了如何保护iOS程序的代码安全，防止反汇编分析。 《Swift’s Answer to #pragma mark, FIXME and TODO》：文章介绍了在ObjC中支持的#pragma mark, FIXME 和 TODO，在Swift语言中是如何使用的。 开源项目 ios-class-guard：一个用于混淆iOS的类名、方法名以及变量名的开源库。"},{"title":"iOS移动开发周报-第24期","date":"2014-09-09T13:16:05.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-09-09-ios-weekly-24.html","permalink":"https://blog.devtang.com/archive/2014-09-09-ios-weekly-24.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果更新了iTunes Connect的设计、UIKit Dynamics 教程：抛掷 Views、iOS APP 架构漫谈等。 新闻 《苹果更新了 iTunes Connect 的设计》：新版的iTunes Connect与 iOS 即视感更浓厚，与 iCloud.com 的风格更搭。 教程 《UIKit Dynamics 教程：抛掷 Views》：文章介绍了如何用手势很自然的将 view 抛掷出屏幕。本文非常适合中级开发者，因为对 view 抛掷操作中，使用的技术嵌套了多个效果，例如使用内置的 UIKit 框架对 view 进行旋转 (rotation)、飞离 (fly-away) 动画。 《iOS APP 架构漫谈》：文章从一些具体的场景出发，讲解iOS应用架构的技巧。 《Objective-C中的+initialize和+load》：文章介绍了Objective-C中的+initialize和+load方法的一些执行细节和注意事项。 《iOS程序main函数之前发生了什么》：一个iOS app的main()函数位于main.m中，这是我们熟知的程序入口。但对objc了解更多之后发现，程序在进入我们的main函数前已经执行了很多代码，比如熟知的+ load方法等。本文将跟随程序执行顺序，刨根问底，从dyld到runtime，看看main函数之前都发生了什么。 《API Design》：文章介绍了Objective-C中类、接口以及通知的接口设计原则。 《Common App Rejections》：苹果官方总结了一些常见的应用审核被拒的情况。 《Xcode vs. Gatekeeper》：文章介绍了通过禁用 Gatekeeper 的功能，来加快第一次开启Xcode 的速度的办法。 《Implementing Observable in Swift》：文章介绍了如何在Swift中实现类似Objective-C中的KVO功能。 《Some ideas for projects in Swift》：文章列出了Swift要真正被大家方便使用起来，还需要提供的第三方库。 ##视频 《QQ IM后台架构的演化与启示(二) –移动时代》：腾讯技术副总监韦彬介绍了QQ IM后台包括状态系统、消息系统、逻辑层等基础架构是如何应对移动时代的挑战并继续演化。 工具 MCLog: MCLog是一个可以提供Xcode中的console log过滤功能的Xcode插件。 Form：Form是一个类似Origami的原型设计工具。它比Origami强大的地方在于，它可以直接在移动端查看效果。 开源项目 f8DeveloperConferenceApp：这是一个f8 Conference Apps的会议应用，由Parse开源。"},{"title":"iOS移动开发周报-第21期","date":"2014-08-18T13:53:55.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"archive/2014-08-18-ios-weekly-21.html","permalink":"https://blog.devtang.com/archive/2014-08-18-ios-weekly-21.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果iCloud中国数据转存中国电信，Swift Operators，100 个 Swift 必备 tips，FLEXLoader等。 新闻 《苹果iCloud中国数据转存中国电信》：出自抚州市崇仁县电信分公司的新闻显示：中国电信正式为苹果 iCloud 中国用户提供云存储服务，成为苹果公司在中国大陆地区唯一的云存储服务提供商。 教程 《Swift Operators》：AFNetworking的作者Mattt Thompson在本文中详细介绍了swift的操作符，包括基本操作符，操作符重载以及一些使用原则。 《为移动而设计，第3章：视觉设计》：理解规则，打破规则，为移动而设计需要我们不断思考，持续发现新的、优美的、易用的解决方案。本文讨论了在视觉设计上如何创造优美、移动应用的解决方案，以及相关的最佳实践。 《Beginning Core Image in Swift》：文章介绍了在Swift中使用Core Image，包括使用基础滤镜、从相册加载图片、保存图片到相册等。 《Introduction to Unity Part 1: Introduction》：本视频对Unity进行了入门性的介绍。 ##图书 《Swifter - 100 个 Swift 必备 tips》：著名iOS博客作者onevcat总结和分享了 Swift 中 100 条十分实用的小技巧和需要特别注意的地方，希望能让大家更好更快地掌握 Swift。本书提供了5章的试读，最低售价3.99$。 工具 FLEXLoader：FLEXLoader是@拓词Joey写的一个可以动态加载FLEX的开源越狱插件，它以加载动态库的方式注入到系统App和用户的App中。FLEX全称是”Flipboard Explorer”，是Flipboard团队开发一组调试和探测App的开源工具，功能非常强大，比如查看和修改View的层级结构，查看和修改堆内存中的对象信息等等，更多FLEX介绍和使用信息参考这里。 开源项目 Design-Patterns-In-Swift：该项目用Swift实现了多种设计模式，读者可以当作代码示例参考。"},{"title":"iOS移动开发周报-第26期","date":"2014-09-24T12:49:02.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-09-24-ios-weekly-26.html","permalink":"https://blog.devtang.com/archive/2014-09-24-ios-weekly-26.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：Swift 的强大之处、iOS8开发者专题、在Xcode 6中使用矢量PDF、iOS 8 App Extensions等。 新闻 《Apple 上线 Android 到 iPhone 数据迁移教程》：为了让更多的 Android 用户加入到 iPhone 阵营，Apple 主动出击，上线了一个专门的页面，帮助 Android 用户购买 iPhone 之后迁移数据。涉及到的内容包括邮件、通讯录、日历、照片、视频、音乐、电子书、PDF、文档、应用等的迁移。 教程 《Swift 的强大之处》：介绍了Swift语言的特性，包括支持函数式编程、类型安全、不可变性等。 《Swift 的函数式 API》：Swift 引入了泛型和函数式编程的思想，极大地扩展了设计的空间。文章借对 Core Image 进行函数式 API 封装为例，展示出应用 Swift 进行函数式编程的能力。 《iOS8开发者专题》：由CocoaChina整理出来的iOS8相关的资料汇总。 《用 Swift 开发一个 TODO 应用》：作者 @请叫我汪二 在文章中教你如何完成一个 TODO 的应用，功能包括添加任务和浏览任务。适合有一定 Objective-C 的开发基础但是还没怎么接触 Swift 的 iOS 开发者，希望通过这样一个简单的例子可以和大家一起熟悉一下 Swift。 《黑魔法__attribute__((cleanup))》：编译器属性 __attribute__用于向编译器描述特殊的标识、检查或优化。作者在文章中介绍了其中一个名为cleanup的“黑魔法”属性。 《Swift中类的初始化器与继承》：Swift 为类定义了两种初始化器来确保类中所有的储存属性都能得到一个初始化值。这两种初始化器就是「指定初始化器」(Designated Initializer)与「便利初始化器」(Convenience Initializer)，文章对其做了介绍。 《大屏iPhone的适配》：自从苹果出了大屏iPhone后，iOS开发也要做适配了， 这里大概总结下这几天了解到的大屏适配的注意事项。 《Using Vector Images in Xcode 6》：文章介绍了在Xcode 6中使用矢量PDF图形的具体操作方法。 《Swifty methods》：文章讨论了Swift的函数命名习惯，并与Objective-C语言做了对比。 《Apple Pay Human Interface Guidelines》：苹果发布了支付功能Apple Pay的人机交互指南。 视频 《iOS 8 App Extensions Tech Talk Video》：该视频介绍了iOS 8引入的App Extensions功能。从用户视角和开发者视角分别对其做了介绍。 工具 specKing：specKing 与 马克鳗 功能类似，用于全自动标示美术稿。不过 specKing 是以付费的 PS 外挂的形式发布的。 开源项目 iOS8-Sampler：日本的shuさん制作的 iOS8 参考代码集。由 @kimsungwhee 推荐。"},{"title":"iOS移动开发周报-第25期","date":"2014-09-14T11:56:42.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-09-14-ios-weekly-25.html","permalink":"https://blog.devtang.com/archive/2014-09-14-ios-weekly-25.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果发布 iPhone6 和 Apple Watch、Swift 1.0 GM发布、Xcode 6支持PDF Vector作为图像素材、iPhone6分辨率与适配等。 新闻 《苹果发布 iPhone6 和 Apple Watch》：北京时间9月10日凌晨1点，美国苹果公司在30年前发布Mac电脑的故地，正式发布了全新一代 iPhone 6以及可穿戴设备 Apple Watch。 《Swift 1.0 GM发布》：北京时间9月10日，Swift迎来了第二个里程碑：Swift 1.0 GM发布。GM是Golden Master的缩写，GM版几乎等同于正式版.不过这次苹果还特意在发布新闻中提到GM版并非final版本，未来Swift还将添加其它更高级的新功能、提升性能以及精简语法。 《Xcode 6支持PDF Vector作为图像素材》：Xcode 6 的默认 App 模板已经用 PDF Vector 矢量作为图像素材了。所以 iOS 的适配可以说是轻松的，布局用 AutoLayout，图标用矢量，可以无视分辨率的存在。设计师们在用 Sketch 设计时，不要再输出1x、2x、3x 的 PNG 了。 《苹果隐晦表示Apple Watch续航约为一天》：苹果没有在发布会上提到Apple Watch的续航问题，但在记者问到时，苹果官方的回复是：“我们没有对外公布，但是我们希望用户白天戴表，晚上可以充电。” 《iTunes Connect Bug导致只接受支持arm64的应用》：苹果9月10日的iTunes Connect更新造成一个Bug，导致审核后台只接受支持arm64的应用上传。由于国内大量的第三方SDK并未更新到支持arm64，所以此Bug导致国内众多应用无法上传。好在问题只持续了一天，但是此事也给那些一直懒于更新第三方SDK的厂商敲响了警钟。 教程 《Swift》：objc.io第16期的专题为Swift，为我们带来了关于Swift的5篇精品文章。 《iPhone6分辨率与适配》：文章介绍了iPhone6的图片适配问题。 《你的Pod出现内存泄露了吗》：文章介绍了深度使用Cocoapods时可能遇到的内存泄漏问题。 《xcode6 开启 iPhone6 &amp; iPhone6 plus 分辨率》：文章介绍了在Xcode6 GM下如何开启iPhone6和iPhone6 plus的分辨率。作者微博：@kimsungwhee。 《Asynchronous Testing With Xcode 6》：在Xcode 6以前，写异步的测试用例比较麻烦。该文章介绍了在Xcode 6下使用XCTestExpectation类，如何更方便地写一些异步的测试用例。 开源项目 Reachability：苹果提供过一个Reachability类，用于检测网络状态。但是该类由于年代久远，并不支持ARC。该项目旨在提供一个苹果的Reachability类的替代品，支持ARC和block的使用方式。 ZAlert：ZAlert是一个用Swift实现的，用于显示UIAlertView和UIActionSheet的工具类，支持链式调用，仅支持iOS8。作者微博：@ch3nz。"},{"title":"iOS移动开发周报-第28期","date":"2014-10-22T13:49:37.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-10-22-ios-weekly-28.html","permalink":"https://blog.devtang.com/archive/2014-10-22-ios-weekly-28.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果召开新品发布会、收据验证、Facebook开源AsyncDisplayKit等。 新闻 《苹果召开新品发布会》：北京时间10月17日凌晨1点，苹果在美国加州库比蒂诺总部Infinite Loop园区的Town Hall大会堂如期召开了主题为“久违了（It’s been way too long）”的新品发布会。这也是继苹果iPhone6、iPhone 6 Plus正式发布后，苹果在今年秋季举办的第二场大型发布会。在此次发布会上，苹果正式发布了iPad Air 2、iPad mini 3；视网膜屏iMac；新款Mac mini；以及iOS8.1和Yosemite系统。 教程 《( ) -&gt; ( )》：() -&gt; ()不是什么表情符号，而是一种高度抽象的编程范式，它表示了一个函数式的编程思想，即值的变化过程。本文从swift语言入手分析，元组，函数，闭包等的设计对它进行解释，并阐释swift语言设计的大局观，最后分享一个Reactive Cocoa作者的Talk中的编程思想。 《收据验证》：收据 (Receipts) 是在 OS X 10.6.6 更新后，和 Mac App Store 一起出现的。 iOS 在内购的时候总是需要向服务器提供收据。验证收据的代码部分必须在安全方面高度敏感。如果被避开或者攻击，你就失去了核实用户权限的能力，并且无法验证用户是否购买。因此，让验证收据的代码能够承受黑客的攻击变得至关重要。本文讨论了如何安全地验证收据。 《如何用Swift做一个不错的按钮变换动画》：文章介绍了如何用Swift语言，采用Core Graphics来完成两个按钮之间的切换动画效果（效果图如下所示）。作者也将相关的代码开源在了这里。 《适配 iOS 8 时遇到的问题两则：远程推送和 Unwind Segue》：作者介绍了适配 iOS 8 时遇到的问题以及解决方案，值得大家参考。 《为什么唱吧iOS 6.0选择了Mantle》：唱吧6.0一个很重大的修改就是基于Mantle重建(新建)了Model层。文章分享了使用Mantle的决策及执行过程。 开源项目 AsyncDisplayKit：AsyncDisplayKit是facebook开源的一个框架，它能让复杂的用户交互效果流畅地显示，facebook使用它开发完成了paper。Facebook也在 这篇文章 中，详细介绍了AsyncDisplayKit。 KZBootstrap：一个方便iOS工程初始化的项目，它包含一些推荐的工程设置和工具。 NewsFourApp：一个模仿网易4.0新UI框架的开源项目。"},{"title":"iOS移动开发周报-第30期","date":"2014-11-15T00:38:00.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-11-15-ios-weekly-30.html","permalink":"https://blog.devtang.com/archive/2014-11-15-ios-weekly-30.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：Masonry介绍与使用实践、Objective-C Runtime、iOS APP 架构漫谈、教你用KEYNOTE做出APP原型等。 教程 《Masonry介绍与使用实践(快速上手Autolayout)》：iPhone6发布之后，我知道使用autolayout势在必行了，这时想起了以前在浏览Github看到过的一个第三方库Masonry。在花了几个小时的研究使用后，我就将autolayout掌握了(重点是我并没有学习任何的官方文档或者其他的关于autolayout的知识)，这就是我为什么要写下这篇文章来推荐它的原因。Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了并具有高可读性。 《Objective-C Runtime》：因为OC是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个OC运行框架的一块基石。本文详细整理了 Cocoa 的 Runtime 系统的知识，它使得 Objective-C 如虎添翼，具备了灵活的动态特性，使这门古老的语言焕发生机。主要内容包括：与Runtime交互、Runtime术语、消息机制、动态方法解析、消息转发、壮的实例变量(Non Fragile ivars)、Objective-C Associated Objects。 《刨根问底Objective－C Runtime（1）－ Self &amp; Super》：本文通过分析clang重写的Objective-C源码，从而解释Objective-C中的self和super在编译器层面分别是如何处理的。 《刨根问底Objective－C Runtime（2）－ Object &amp; Class &amp; Meta Class》：本文主要讲述objc runtime中关于Object &amp; Class &amp; Meta Class的细节。 《iOS APP 架构漫谈二》：这篇文章简单介绍了一个在编程中非常重要的思想或工具——状态机（State machine）。对大多数计算机专业的家伙们来说，这应该是一门比较难学的课程，里面包含一大堆揪心的名字比如DFA，NFA，还有一大堆各种各样的数学符号,又是编译原理的基础。不过很遗憾，似乎在做完编译原理课程作业之后，很多人再也没有实现过或是用过状态机了。本文通过一个游戏demo来简单描述一下状态机在实践中的应用。 《iCloud 和 iCloud Drive》：最近发现很多人对 iCloud 和 iCloud Drive 有些误解，而且还没有看见中文里面有一个比较正确的说法，本文详细讲解了 iCloud Drive 相关的知识。 《教你用KEYNOTE做出APP原型》：WWDC 2014 Session Videos里有个视频Prototyping: Fake It Till You Make It ，在视频中，他们指导大家如何用Keynote做出逼真的交互原型。作者结合这个视频的截图，介绍了如何充分发挥Keynote的特点的做出逼真的交互原型。 《Working with JSON in Swift Tutorial》：文章介绍了在Swift中用原生方式处理JSON的不便之处，并详细介绍了开源库SwiftyJSON的使用。 开源项目 CBStoreHouseRefreshControl：一个效果很酷炫的下拉刷新控件。 ZLSwipeableView：ZLSwipeableView是一个方便做出卡片效果的UI库，支持各种卡片的滑动效果。 YTKNetwork：YTKNetwork 是基于 AFNetworking 封装的 iOS 网络库，提供了更高层次的网络访问抽象。相比 AFNetworking，YTKNetwork 提供了以下更高级的功能：按时间或版本号缓存网络请求内容、检查返回 JSON 内容的合法性、文件的断点续传、批量的网络请求发送、filter和插件机制等。 Objective-Chain：Objective-Chain是一个面向对象的响应式框架，作者表示该框架吸收了 ReactiveCocoa 的思想，并且想做得更面向对象一些。"},{"title":"iOS移动开发周报-第31期","date":"2014-11-19T14:09:57.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-11-19-ios-weekly-31.html","permalink":"https://blog.devtang.com/archive/2014-11-19-ios-weekly-31.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：黑幕背后的__block修饰符、刨根问底Objective－C Runtime、Flashlight等。 新闻 《三名iOS系统恶意程序制作者被抓获》：11月14日据首都网警微博报道，北京市公安局将iOS系统恶意程序的三名制作者抓获，涉案网站被关停。11月初，有研究人员在iOS系统中发现了一个名为Wirelurker的漏洞，可以让iPhone在不越狱的情况下感染病毒，并且有可能已经影响了数十万用户。 《第三方SSD的电脑升级Yosemite需要关闭kext signing》：苹果在本次升级里为 Yosemite 增加了一个新型的安全插件“kext signing”，存储在 NVRAM&#x2F;PRAM 里，未经苹果认证的第三方 SSD 硬盘都将被这个插件过滤掉，所以会有用户在升级后开机遇到灰叉的情况，这时你可以使用最新版的Trim Enabler 3.3 ，升级前可提前关闭“kext signing”。 教程 《黑幕背后的__block修饰符》：文章通过使用 clang -rewrite-objc 命令，分析了 __block 修饰符是如何做到改变引用的变量的值。 《刨根问底Objective－C Runtime（3）－ 消息 和 Category》：文章通过一道习题，利用分析Objective-C实现源代码，讲解了Objective-C的消息和Category的实现原理。 《刨根问底Objective－C Runtime（4）－ 成员变量与属性》：本篇笔记主要是讲述Objective－C Runtime的成员变量和属性。 《UIAlert​Controller》：你知道 UIAlertView、UIActionSheet (以及它们各自的 delegate protocols) 在 iOS 8 中已经被废弃了吗？本文章的主题就是 UIAlertController，向大家展示如何替换旧的 alert，以及这些操作方法的高级扩展。 《Swift Comparison Protocols》：Objective-C 让我们对相等性和唯一性的本质慢慢有了带有哲学色彩的思考。为了解救那些不愿意向论文一样的哲理卑身屈膝的开发者，Swift 为此作出了很多改进。在 Swift 中，Equatable 是一个基本类型，由此也演变出了 Comparable 和 Hashable 两种类型。这三个一起组成了这门语言关于对象比较的核心元素。本文介绍了 Swift 中的比较功能。 《WKWeb​View》：WKWebView 是现代 WebKit API 在 iOS 8 和 OS X Yosemite 应用中的核心部分。它代替了 UIKit 中的 UIWebView 和 AppKit 中的 WebView，提供了统一的跨双平台 API。本文比较了 WKWebView 与 UIWebView 的功能。 工具 Flashlight：Flashlight 是为 Spotlight 写插件的非官方框架。 FlashlightPlugins：FlashlightPlugins 基于 Flashlight 的中文插件列表。"},{"title":"iOS移动开发周报-第32期","date":"2014-11-24T13:42:41.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-11-23-ios-weekly-32.html","permalink":"https://blog.devtang.com/archive/2014-11-23-ios-weekly-32.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：“1元”正式成苹果中国区应用商店新定价、Apple Watch人机界面指南、Apple WatchKit 初探等。 新闻 《苹果公司发布iOS 8.1.1升级补丁》：11月18日凌晨消息，苹果公司已对上个月针对iPhone、iPad和iPod Touch发布的iOS 8.1操作系统正式推出了iOS 8.1.1升级补丁。iOS 8.1.1将可改善基于iOS 8系统运行的、使用A5芯片的较老设备的表现，也就是指iPad 2和iPhone 4s。除了发布iOS 8.1.1以外，苹果公司还发布了OS X 10.10.1升级补丁以修复WiFi网络表现及其他问题。 《“1元”正式成苹果中国区应用商店新定价》：11月19日，苹果中国区App Store应用商店出现1元应用，当时曾有消息称这是短期促销行为，不过目前苹果公司已经正式宣布，人民币1元及3元将是中国区应用商店的新定价，作为一个永久价格选项。 《CocoaPods将要支持Swift》：从 CocoaPods 的一个pull request中，我们了解到著名的 iOS 依赖管理工具 CocoaPods 将要支持 Swift 语言。 《AppleWatch需求被低估 苹果股价创历史新高》：11月21日，据外国媒体报道，在经过新一轮的多名华尔街分析师上调公司目标股价之后，再加上摩根士丹利认为一些投资者低估了苹果智能手表Apple Watch的市场需求预期，苹果周四股价呈现出上涨局面。苹果股价在当周曾达到历史新高的117.28美元。 教程 《Apple Watch人机界面指南（中文版）》：苹果于11月19号放出了Apple Watch的官方设计指南。这是由微博无线设计团队翻译的中文版指南。 《使用 Swift 构建自定义（且“可设计”的）控件》：大约两年前，我写了一篇关于在 iOS 上构件自定义控件的教程。那篇教程获得了社区的高度赞赏，所以我决定将其用 Swift 更新并加入 Designable&#x2F;Inspectable 属性以支持直接在 Interface Builder 里调整控件的外观。 《Apple WatchKit 初探》： 11月19日，Apple 发布了第一版的 Watch Kit 的 API，对于开发者来说，这款新设备的一些更详细的信息也算是逐渐浮出水面。可以说第一版的 WatchKit 开放的功能总体还是令人满意的。Apple 在承诺逐渐开放的方向上继续前进。本文介绍了Watch app 架构和主要的类等相关知识。 《WatchKit 之 数据共享》：本文介绍了如何使 Watch App 与 iOS App 之间进行数据共享。 《WatchKit 之 导航》：在 Watch App 中，当涉及到多个界面跳转时，我们共有两种导航方式可使用：Hierarchical 与 Page-based。本文将对这两种导航方式以及 Modal 展现方式做简单的介绍。 工具 Auto-Importer：Auto-Importer是一个自动导入类对应的头文件的Xcode插件。 开源项目 Carthage：Carthage是一个去中心化的依赖管理工具。 CotEditor：CotEditor是一个OS X下的开源的纯文本编辑器。"},{"title":"iOS移动开发周报-第33期","date":"2014-12-01T13:31:30.000Z","updated":"2024-01-06T14:52:37.920Z","comments":true,"path":"archive/2014-12-01-ios-weekly-33.html","permalink":"https://blog.devtang.com/archive/2014-12-01-ios-weekly-33.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：Google Inbox 是如何跨平台重用代码的、iOS8.1.1系统被越狱、SizeClass 和AutoLayout教程等。 新闻 《乔布斯去世后仍获141项专利》：据《麻省理工技术评论》称，尽管苹果公司联合创始人史蒂夫·乔布斯过世已三年有余，但直到今天仍陆续有新的专利归于他名下。截至目前已被授予乔布斯的专利总数共有458项。 《iPhone 6在俄售价提高25%》：近日16G版iPhone 6在俄罗斯官网上的售价提高了25%，从31990卢布提价至39990卢布(约5215元人民币)。此前，俄罗斯的iPhone 6售价是全欧洲最低，因此经常有特地去俄罗斯购买iPhone 6的游客。 《iOS8.1.1系统被越狱》：某团队正式对外发布了iOS 8.1.1完美越狱工具，支持 iOS 8.1.1 版本。 《Google Inbox 是如何跨平台重用代码的？》：开发一个移动应用在当下并不是一件容易的事情。如果想要获得最多的用户，你的应用通常需要覆盖 iOS, Android, 和 Web 三大平台。这就意味着同一个应用需要开发三个版本，使用 Objective-C 或者 Swift 开发 iOS 版本，使用 Java 开发 Android 版本，使用 JavaScript&#x2F;CSS&#x2F;HTML5 开发 Web 版本。工作量增大的同时也意味着有更多的 bug 需要修复。本文介绍了 Google 在发布 Google Inbox 时，使用 J2Objc 实现了70%的代码跨平台复用。 教程 《读 Facebook App 头文件的一些收获》：最近在看一些 App 架构相关的文章，也看了 Facebook 分享的两个不同时期的架构（2013 和 2014），于是就想一窥 Facebook App 的头文件，看看会不会有更多的收获，确实有，还不少。作者分享了从头文件中获取到的一些信息。 《SizeClass 和AutoLayout教程3》：文章翻译自《iOS8 by tutorials》的第一章，以开发一个天气应用为例子，介绍了SizeClass 和AutoLayout相关知识。译者：@叶孤城___。 《SizeClasss和AutoLayout教程4》：文章翻译自《iOS8 by tutorials》的第一章，介绍了如何在不同的 SizeClass 给同一个label设定不同的字体大小和样式。译者：@叶孤城___。 《如何做出炫酷的卡片动画1》：作者介绍了有关卡片动画的研究和实现。 《走进 WatchKit Framework》：作者整理了关于 WatchKit Framework API的知识点。 《Core Data 版本迁移经验总结》：大家在学习和使用Core Data过程中，第一次进行版本迁移的经历一定是记忆犹新，至少我是这样的，XD。弄的不好，就会搞出一些由于迁移过程中数据模型出错导致的Crash。作者在本文中总结了一下Core Data版本迁移过程中的经验。 《Beginning Alamofire Tutorial》：Alamofire 是 AFNetworking 的作者 Mattt Thompson，用 Swift 实现的网络基础库。本文介绍了其基本的使用方法。 ##视频 《一起来做价值百万的Apple Watch App：分歧终端机》：视频展示了如何使用WatchKit，如何通过MVC的绑定来处理用户事件，如何制作动画的功能。 开源项目 MobileDataSwitch：MobileDataSwitch 使用 CoreTelephony 中的私有接口，切换移动网络开关。作者还添加了App Extensions支持，可以在下拉通知 Today 中增加快速设置开关。 HeapInspector：HeapInspector是一个用于检测应用中的内存泄漏的开源调试工具。"},{"title":"iOS移动开发周报-第34期","date":"2014-12-21T11:56:06.000Z","updated":"2024-01-06T14:52:37.920Z","comments":true,"path":"archive/2014-12-21-ios-weekly-34.html","permalink":"https://blog.devtang.com/archive/2014-12-21-ios-weekly-34.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：浅谈 iOS 版本号、UIScrollView 实践经验、设计优雅的移动游戏、如何把iOS代码编译为Android应用等。 新闻 《iPhone 6&#x2F;6 Plus中国销量曝光：单月销量650万》：据iSuppli Corp.中国研究总监王阳爆料，iPhone 6和iPhone 6 Plus在国内受欢迎的情况大大超过预期，苹果在中国的单月销量在11月超过了650万台，全年在中国的销量将超过4000万台。 教程 《 Date parsing performance on iOS》：文章介绍了一个关于格式化时间的”黑科技“，作者使用 sqlite 替换 NSDateFormatter，提高了16倍的转换效率。 《浅谈 iOS 版本号》：FIR.im 一直在尽量兼容不同使用习惯的版本号形式, 但是在使用中我们发现好多开发者对怎么更好的用版本号来标示应用很陌生。这是篇基础文章，简单介绍 iOS 的版本号。 《UIScrollView 实践经验》：UIScrollView（包括它的子类 UITableView 和 UICollectionView）是 iOS 开发中最常用也是最有意思的 UI 组件，大部分 App 的核心界面都是基于三者之一或三者的组合实现。UIScrollView 是 UIKit 中为数不多能响应滑动手势的 view，相比自己用 UIPanGestureRecognizer 实现一些基于滑动手势的效果，用 UIScrollView 的优势在于 bounce 和 decelerate 等特性可以让 App 的用户体验与 iOS 系统的用户体验保持一致。本文通过一些实例讲解 UIScrollView 的特性和实际使用中的经验。 《设计优雅的移动游戏》：设计手机游戏是一个有趣的主意，理论上，做智能手机或者平板电脑游戏与其他平台游戏设计没有根本的不同。手机游戏在传统系统属性上与其他类型以及平台极其相似，无论你想创造一个开心农场，使命召唤还是国际象棋。但实践中，想要创建一个成功的手机游戏完全是另一回事。有很多其他的顾虑，从市场饱和及难以被发现，到玩法定型及设备的尺寸因素等。由于这些原因，作为一个设计师来说创造一个优秀的手机游戏就像在玩“困难模式”。文章介绍了手机游戏的两个特征：游戏时长和交互方法，另外介绍了几种适用于移动平台的系统设计方法。本文译者：@唯木念。 《Metal》：Metal 是针对 iPhone 和 iPad 中 GPU 编程的高度优化的框架。其名字来源是因为 Metal 是 iOS 平台中最底层的图形框架 (意指 “最接近硬件”)。该框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在 GPU 上执行。本文介绍了 Metal 的好处以及使用基础。本文译者：migrant。 《Scene Kit》：在 WWDC 2012，Apple 向 OS X 开发者们介绍了 Scene Kit，这个 Cocoa 下的 3D 渲染框架。在第一版通用 3D 渲染器发布后，一年内又陆续增加了像 shader (着色器) 修改器、节点约束、骨骼动画等几个强大的特性 (随 Mavericks 发布)。今年，Scene Kit 变的更加强大，支持了粒子效果、物理引擎、脚本事件以及多通道分层渲染等多种技术，而且，对于很多人来说更关键的是，它终于可以在 iOS 中使用了。本文介绍了Scene Kit的概要知识，以及如何使用它来写游戏。本文译者：孙源。 《游戏中的多点互联》：多点互联是苹果的一个传输无关的网络框架，提供网络的发现、创建和通信功能。MPC 的关键用途在于创建临时网络中的点对点连接，而不需要考虑天气、无线、蓝牙等各种因素，只需要有个人网络就行。一旦创建之后，各个节点可以安全地共享消息、数据和文件资源。大部分的游戏都更适合用 GameKit 开发，它有很多直接使用 MPC 实现的游戏相关的封装。不过作为 MPC 的进阶手册，本文主要涉及 MPC 的各种使用技巧。本文译者：汪海洋。 《虚拟音域 - 声音设计的艺术》：由于声音占据我们日常生活的很大部分，所以声音在游戏开发中也越来越重要。然而，要实现完全身临其境的虚拟现实，最大的挑战之一就是设计逼真的声音环境。如果你身处一个虚拟森林中，但却听不到树叶的沙沙声，也听不到昆虫的鸣叫声，你就不会感觉到真实。在某些方面，音效设计是吃力不讨好的活计。你什么都正确的话，没人会注意到这些，但是一旦你做错了什么，人们百分之百会注意到。这是一项痛苦，细节导向，但又几乎被忽略的工作。但是，当你捕捉到一种美妙的声音体验或真实的声音环境时，你会感觉到一种乐趣，这种乐趣很大程度上弥补了工作辛苦、收获甚少的不足。本文介绍了音效各方面的知识，包括：记录声音、麦克风、数码音频软件、拟音、音频滤波器、混合音效等知识。本文译者：树叶 《Continuous Integration for iOS Development》：文章介绍了如何基于Xcode的Bot做持续集成。 《NSUndo​Manager》：本文介绍了 NSUndoManager 的使用。NSUndoManager 可以用来做一些撤销操作。 《视频特效制作》：文章介绍了一些视频特效制作方法，包括给视频添加边框、给视频添加水印、给视频添加动画、做出3D效果、视频推进效果等技术细节。 ##视频 《如何把iOS代码编译为Android应用》：OurCoders.com站长 @tinyfool介绍了他们通过将Objective-C底层移植到Android平台，最终把iOS代码编译为Android应用的过程。 开源项目 MMWormhole：MMWormhole 是一个方便开发者在 iOS 应用与 iOS extensions 之间交换数据的开源框架。 RTImageAssets：RTImageAssets 是一个 Xcode 插件，用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本，只要拖拽高清图到 @3x 的位置上，然后按 Ctrl+Shift+A 即可自动生成两张低清的补全空位。当然，如果你对图片质量要求不高的话，你也可以从 @2x 的图生成 @3x 版本。 PQFCustomLoaders：PQFCustomLoaders 提供了高质量的、定制化的加载进度条。"},{"title":"iOS移动开发周报-第35期","date":"2014-12-31T14:03:13.000Z","updated":"2024-01-06T14:52:37.920Z","comments":true,"path":"archive/2014-12-31-ios-weekly-35.html","permalink":"https://blog.devtang.com/archive/2014-12-31-ios-weekly-35.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：90后CEO的开源心得、iOS8 企业应用部署Bug、盘点开发者最喜爱的Swift技巧、iOS开发的一些奇巧淫技等。 新闻 《90后CEO的开源心得：Github 2500 star是如何炼成的》：如果你是一名 iOS 开发者同时还是 Github 的重度使用者，那么你多半见过这个项目：PNChart，一个提供带动画的图表控件。截止到目前为止，PNChart 在 Github上 的 star 数已经超过2500，是一个备受开发者喜爱的 iOS 第三方开源库。该开源库的作者周楷雯，在本文中分享了如何打造一个成功的iOS开源项目。 《苹果获反向AirPlay专利，在iPhone上同步播放Apple TV内容》：苹果刚刚获得了美国专利与商标局授予的一项新专利，这项专利可以让内容在便携式设备上同步显示，即可以让 Apple TV 这样位置固定的设备上播放的内容，实时同步到 iPhone、iPad 等 iOS 设备上。 教程 《iOS8 企业应用部署Bug》：使用iOS企业部署（In-House Distribution）方式进行应用升级时，在 iOS8 下无法成功，删除应用再重新安装也不行。如果你也遇到了这个问题，那么可以看看作者是如何解决的。需要说明的是，该Bug在 iOS 8.1.2 更新中得到了修复。 《盘点开发者最喜爱的Swift技巧》：Swift 发布才半年左右，却已深得众多开发者的青睐，也有了许多学习资源、项目和开发工具。在本文中，来自objc.io、LinkedIn等各个公司的软件工程师及资深开发者总结了自己在接触 Swift 过程中最喜爱的贴士与技巧。 《iOS开发的一些奇巧淫技》：作者分享了一些 iOS 开发中涉及的小技巧。 《Swift 脚本编写》：作为苹果新一代的编程语言，Swift 不仅可以用来开发 iOS 应用，还可以用来编写脚本，来完成 OS X 下的一些自动化的工作。终于可以用我们熟悉的语言来写自动化脚本了，想想是不是就觉得心里有点小激动呢^_^。本文从一个Hello World脚本开始，介绍了如何用Swift完成脚本编写工作。 《一步一步教你写classdump》：最近刚读完《Mac OS X and iOS Internals》的前几章，也想练练手，写tweak，app也烦了，基于上述原因就试着写了这个demo。虽然这些功能都可以通过 otool 和 classdump 去实现，但也算是对 macho 文件格式的一种学习吧。 《iOS-Core-Animation-Advanced-Techniques》：一本不错的翻译图书，介绍了关于Core Animation的各方面的知识。 《Swift语言指南》：这份指南汇集了 Swift 语言主流学习资源，并以开发者的视角整理编排。 《Swift 项目使用 CoreData 可能会碰到的 32 位系统问题》：最近在项目中偶然发现了一个问题，那就是 Swift 的 CoreData 在 32 位系统下与 64 位系统下表现不一致的问题。简单的说：如果你的 CoreData 模型有一个声明为 Boolean 的 Attribute，并且在代码中使用 NSNumber 来包装（而不是Bool）的话，很可能会遇到这个问题。作者介绍了该问题的细节和解决办法。 开源项目 peertalk：peertalk 是一个支持 iOS 与 Mac 通过 USB 相互通讯的开源库。 Duet Display 基于此实现了将 Mac 界面呈现到 iOS 设备上。"},{"title":"iOS移动开发周报-第36期","date":"2015-01-18T02:25:45.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"archive/2015-01-18-ios-weekly-36.html","permalink":"https://blog.devtang.com/archive/2015-01-18-ios-weekly-36.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：中国超越美国成最大iPhone消费市场、一个iOS开发工程师的职业规划思考、Functional Swift Conference等。 新闻 《瑞士银行：中国超越美国成最大iPhone消费市场》：瑞士银行统计报告显示，在过去一个季度，苹果向消费者出售了6930万支iPhone。其中，中国区的销量占到总销量的35%，超过美国区24%的占比。瑞士银行的分析师Steven Milunovich提到，“数据显示，iPhone在中国区的销量出现显著增长，在过去这个季度iPhone中国区的销量占到总销量的35%，而这一数 据在去年同期只是22%”。 《解读2014之iOS篇：拥抱变化》：对于 iOS 技术领域，2014 年是变化巨大的一年。除了软硬件外，编程语言、中国区、开发社区在 2014 年也有着巨大变化，文章试着用几个关键词来勾勒出 iOS 技术领域在 2014 年所经历的变化。 《苹果调整多个国家App Store应用售价》：苹果最近通过邮件告知开发者，即将调整加拿大、俄罗斯以及欧洲一些国家App Store中软件售价。 《奔向三张，不破不立：一个iOS开发工程师的职业规划思考》：本文作者是《iOS应用逆向工程：分析与实战》的作者。他从自己的经历为例，分享了他自己对于iOS开发工程师的职业规划思考。 教程 《自学 iOS 开发的一些经验》：不知不觉作为 iOS 开发也有两年多的时间了，记得当初看到 OC 的语法时，愣是被吓了回去，隔了好久才重新耐下心去啃一啃。啃了一阵，觉得大概有了点概念，看到 Cocoa 那么多的 Class，又懵了，怎么才能调用系统的相机？怎么保存信息？怎么做一个像 Twitter 个人页那样的页面？总之就是不知道该从哪切入。现在回想起来，其实路一直都在，而且有很多条，当初如果有人能够指出一条还不错的道，或许就能走得不那么艰难。于是就有了这篇文章，希望对后人能有所帮助吧。 《Swift 小技巧（一）：如何正确地定义一个类变量（和类常量）》：Swift 语言对于无论是静态语言过来还是动态语言过来的开发者来说，都有点点不适应，很多问题的解决思路不能用已经习以为常的方法去做。比如一个很常用的：如何定义类变量（和类常量）？本文介绍了作者对此问题的思考。 ##视频 Functional Swift Conference：这是在美国布鲁克林举办的一个关于Swift函数式编程的会议视频。共有6位演讲者介绍了他们对于Swift函数式编程的感悟和心得。 工具 Log Guru：Log Guru是一个收集Log的小工具, 可以在 Mac 上查看 iOS 设备的实时系统日志. 现在可以直接高亮显示在 FIR.im 上安装 app 失败的原因。后续会增加各种进程过滤、高亮某进程、只看 Error level 等功能。与此类似的工具还有：iOS Console。 SwiftDoc：SwiftDoc是一个在线的Swift帮助文档。 开源项目 VVBlurPresentation：VVBlurPresentation是一个很简单易用的在原来view conntroller基础上做模糊，然后present新的view controller的小项目。作者是onevcat。 《Swift开源项目精选》：该作者将 2014 年 Swift 开源项目做了一个筛选和汇总。"},{"title":"iOS移动开发周报-第29期","date":"2014-10-30T13:34:29.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-10-30-ios-weekly-29.html","permalink":"https://blog.devtang.com/archive/2014-10-30-ios-weekly-29.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：苹果要求所有iOS新应用2015年2月起支持64位、怎样为iOS8应用制作预览视频、可视化开发 - IB的新时代等。 新闻 《苹果要求所有iOS新应用2015年2月起支持64位》：苹果通过官方开发中心宣布，从2015年2月1日开始，所有上传至App Store官方商店的新iOS应用都必须支持64位。目前，支持64位的苹果设备包括iPhone 5S及以后的iPhone设备。 教程 《终极指南 - 怎样为iOS8应用制作预览视频》：说到App Store的改版，最值得设计师、开发者和市场人员关注的大概就是视频预览功能了。官方将其称为“应用预览(App Previews)”，如今已经正式出现在iOS8的App Store当中。自然，已经有一大波设计师和开发者为他们的产品制作了预览视频并通过iTunes Connect上传。坦率的说，如果你也有自己的产品，那么也该开始考虑做这件事了。本文介绍了为iOS8应用制作预览视频技巧和工具。 《WWDC 2014 Session笔记 - 可视化开发，IB 的新时代》：文章介绍了 Xcode 6 中为 IB 锦上添花的一个特性，那就是实时地预览自定义 view，这个特性让 IB 开发的流程更加直观可视，也可以减少很多无聊的参数配置和 UI 设置的时间。 《我在开发第一个Swift App过程中学到的四件事》：本文作者Greg Heo，这是他为讲授iOS 8 App Extensions视频教程而实际使用Swift开发了一款App的经验，本是是他开发过程中的心得体验。 《让你的 Mac App 支持 OS X Yosemite 的暗色菜单（Dark Menu）》：文章介绍了如何让应用兼容 Yosemite 的暗色菜单。 《玩转 Sketch 系列文章一：进入一个全新的时代》：很多设计师都已经把主要的工作平台彻底迁移到了 Sketch。那么，是什么让他们放下了多年的 Photoshop，转身投入了 Sketch 的怀抱呢？理由很复杂，但用一句话表达：再也找不到比 Sketch 更顺手的设计软件了！对于那些还没有深入接触 Sketch 的同学，本文将是一个入门引导。虽然没有具体某一模块或功能的介绍，但文章从 Sketch 那上百种吸引人的特性中，选出几样与你分享，让你对它有一个大致的了解。 《Custom Subscripting in Swift Tutorial》：文章介绍了在Swift语言中使用自定义下标操作符。 《Fully Scaleable Apple iOS Devices for Sketch》：作者提供了用于设计的iOS设备Sketch资源。 开源项目 YTKKeyValueStore：YTKKeyValueStore是由笔者开源出来的一个基于sqlite的key-value存储工具。它被使用在了粉笔网、猿题库、小猿搜题三个客户端中后，我发现它不但完全能够满足大多数移动端开发的需求，而且非常适合移动端采用，所以开源出来。 SuperRecord：SuperRecord是一个方便在Swift语言中使用CoreData的库。"},{"title":"iOS移动开发周报-第37期","date":"2015-01-31T01:34:58.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"archive/2015-01-31-ios-weekly-37.html","permalink":"https://blog.devtang.com/archive/2015-01-31-ios-weekly-37.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，地址是这里。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 本期 iOS 移动开发周报带来如下内容：iOS大V的技术进阶之路、ARC 对 self 的内存管理、Method Swizzling 和 AOP 实践、使用 iMovie 和 Keynote 制作 App Preview等。 新闻 《唐巧访谈： iOS大V的技术进阶之路》：文章来自于 CocoaChina 的访谈，采访对象是唐巧，他的新书《iOS开发进阶》已经和大家见面.采访中唐巧表达了他对于技术学习、建设技术影响力等方面的经验和看法。 《Moke 2014 以及 1 元应用效应》：Moke 作者分享了他的应用在 2014 年的销售额以及他对于 1 元应用的看法。 《王巍访谈：关于 Swift 学习和 AppleWatch 开发的一些建议》：文章来自于 CocoaChina 的访谈，采访对象是王巍，微博 ID“onevcat”，圈儿内人称喵神，知名 iOS&#x2F;Unity 开发者，现居日本，就职于 LINE。喵神是 objc 中国项目发起人，开源过广受开发者喜爱的 Xcode 插件 VVDocumenter，主创或参与开发《姬骑士和最后的百龙战争》、《英雄 Slash》、《冒险谜题王国》以及《小熊推金币》等多款游戏，个人应用代表有《番茄工作法》(Pomodoro Do) 和《云端记账》(Our Money)。 《2014 年 Oh My Star 总结》：Oh My Star 是一款由国人 @Sumi-iYu 开发的管理 Github 上 star 项目的工具。笔者使用过，对于 star 功能的重度用户来说，非常好用。本文分享了作者在开发该软件的过程以及收货。 教程 《ARC 对 self 的内存管理》：文章从 YTKNetwork 的几行代码出发，讨论了 LLVM 编译器在传递 self 参数时，对 self 的引用计数的特殊处理。 《AutoLayout 布局技巧－等宽子视图》：所谓等宽子视图，也就是对一个有 n 个子视图的父视图来说，无论父视图的宽度怎么变化，所有子视图的宽度是相等的。文章介绍了这一类排版需求的 AutoLayout 布局技巧。 《Objective-C Runtime》：Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。本文讲解了 Runtime 的核心 - 消息传递 （Messaging）。 《Method Swizzling 和 AOP 实践》：利用 Objective-C 的 Runtime 特性，我们可以给语言做扩展，帮助解决项目开发中的一些设计和技术问题。这一篇，我们来探索一些利用 Objective-C Runtime 的黑色技巧。这些技巧中最具争议的或许就是 Method Swizzling 。文本介绍了利用 Method Swizzling，结合 AOP 来做一些打 Log 的工作。利用 objective-C Runtime 特性和 Aspect Oriented Programming ，我们可以把琐碎事务的逻辑从主逻辑中分离出来，作为单独的模块。它是对面向对象编程模式的一个补充。 《CocoaPods 最佳实践探讨》：作者在文章中表达了对目前常见的 CocoaPods 使用方法的意见。希望大家根据自己的经验，一起讨论出一份真正的 “最佳实践”。 《使用 iMovie 和 Keynote 制作 App Preview》：App Preview 就是一段 15-30 秒的短视频，用来展示你的应用的特性、用户界面、交互方式等内容。在 App Store 你的应用的详细信息页面里，放在原来的截图之前。体验上会比截图更有冲击力，也能够表现更多的东西。茫茫的 App 海洋之中，如何脱颖而出，卖相至关重要。本文作者分享了他使用 iMovie 和 Keynote 制作 App Preview 的经验，并且提供了相关的效果视频和 Keynote 源文件。 《要你命三千：老代码中的那些坑》: 最近在给以前的老项目维护，说起来工作很简单，一个字：改 Bug。这看起来平淡无常的工作，实际上凶险无比，藏坑无数。时至今日，感觉整个人都得到了升华。在睡觉前抽空写篇博客，和各位分享一下踩坑经历，一起品味其中的种种酸苦辣 (没甜)。 《Unit Testing in Swift: Dependency Injection》：文章介绍了在 Swift 实现的单元测试中实现依赖注入，不过实际写起来还是比较麻烦。 工具 ship.io：ship.io 是一个持续集成服务。现在所有套餐免费，支持 Xcode 6.1.1。 Crowdin: Crowdin 是一个多语言翻译服务。可以便于开发者将应用改成支持多语言。类似的服务还有：Transifex。 开源项目 BreakOutToRefresh：BreakOutToRefresh 是一个有趣的项目，它利用 SpriteKit 在下拉刷新过程中做了一个打砖块游戏。 RAMAnimatedTabBarController：RAMAnimatedTabBarController 是一个让 TabBar 上的元素能够显示动画效果的开源库。"},{"title":"iOS移动开发周报-第39期","date":"2015-03-01T05:46:28.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"archive/2015-03-01-ios-weekly-39.html","permalink":"https://blog.devtang.com/archive/2015-03-01-ios-weekly-39.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，文章地址是这里。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：Core Image 介绍、写 iOS SDK 注意事项、利用 CocoaLumberjack 搭建自己的 Log 系统、KSHObjcUML 等。 新闻 《Google 宣布淘汰 SPDY》：Google 宣布计划淘汰该公司在 2009 年推出的 SPDY 协议，SPDY 原本定位为替代 HTTP 协议的新协议，Google 原本打算以它来加速 HTTP 的传输速度并推动成为标准，不过现在决定将支持 HTTP&#x2F;2，并逐渐淘汰 SPDY，预计 2016 年就会完全从 Chrome 中移除对 SPDY 协议的支持。 教程 《Core Image 介绍》：这篇文章为初学者介绍了 Core Image，一个 OS X 和 iOS 的图像处理框架。 《Builder Pattern 在 Objective-C 中的使用》：作者从一个真实场景出发，介绍了结合 block 使用工厂模式的实践方式。 《写 iOS SDK 注意事项》：我发现即使是像腾讯、小米这样的大厂提供的 SDK，在质量和规范上也有很多问题，文本分享了写 iOS SDK 注意事项。 《CoreData 与 ReactiveCocoa 混用时要注意的线程问题》：作者从一个 Crash 出发，分享了查找和修复问题的整个过程。 《iOS 开发如何快速成长 ?》：作者分享了自己的一些心得，包括：做有难度的项目、尽量少抱大腿、多读源码、多读国外的 iOS 开发网站和 blog、要孜孜不倦的学习。 《久违的的 LLDB 篇一，让 lldb 提升你的效率》：作者分享了一些 LLDB 使用小技巧。 《利用 CocoaLumberjack 搭建自己的 Log 系统》：CocoaLumberjack 最早是由 Robbie Hanson 开发的日志库，可以在 iOS 和 MacOSX 开发上使用。其简单，快读，强大又不失灵活。本文介绍了利用 CocoaLumberjack 搭建自己的 Log 系统的过程。 《Let’s Build @synchronized》：本文讲解了 synchronized 关键字的内部实现原理。 ##视频 《Controlling Complexity in Swift》：本视频的作者来自 Andy Matuschak，他曾在苹果 UIKit 组工作，在本视频中，他分享了用 Swift 来控制复杂度的经验。 工具 KSHObjcUML：KSHObjcUML 是一个 Objective-C 类引用关系图的 Xcode 插件。作者是：@kimsungwhee。 Xliffie：Xliffie 是 @ 汤圣罡 推荐的一个本地化必备工具，它对 Xcode 生成的 Xliff 文件支持较好。 广告：亚马逊上正在销售我的《iOS开发进阶》签名版，输入优惠码`JXBEGSGKUV`，可在结帐时减7元，点击查看：[购买链接](http://www.amazon.cn/b?node=1474130071)。"},{"title":"iOS移动开发周报-第38期","date":"2015-02-05T13:36:03.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"archive/2015-02-05-ios-weekly-38.html","permalink":"https://blog.devtang.com/archive/2015-02-05-ios-weekly-38.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，文章地址是这里。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：Facebook 推出 React Native、Swift 小技巧、RunLoop 主题的分享、使用蒲公英来做 iOS 测试应用的分发等。 新闻 《分析师称 14 年四季度 iPhone 销量达 7300 万台》：1 月 25 日上午消息，凯基证券分析师郭明池称，2014 年四季度 iPhone 销量达 7300 万台，iPad 销量达 2140 万台；并预计 2015 年一季度 iPhone 销量为 6160 万台，iPad 销量为 1010 万台。 《2014 年 iOS 应用开发者收入超好莱坞美国票房》：市场研究公司 Asymco 分析师霍拉斯·德迪乌 (Horace Dediu) 本周发布研究报告称，iOS 应用经济的规模已经超过了好莱坞电影在美国的票房。2014 年全年，开发者通过苹果获得的收入为 100 亿美元。 教程 《objc 中国 Issue 20：访谈》：objc 中国 Issue 20 完成了三位传奇开发者的访谈，很有意思。从天才少年 Andy Matuschak ，到两次创业的 Loren Brichter，以及俄国妹子 Natasha Murashev，篇篇精彩。希望通过了解他们的经历，你会有所收获。 《Swift 怎样更优雅地处理网络返回数据》：我们在 iOS 开发中进行网络请求的时候，一般是获取到服务器返回的 data 后，再根据我们的需要转换成 JSON，图像等信息。但如果你的应用中存在各种类型的返回数据，那么你可能就要在各个网络请求的中进行重复的处理了。本文介绍了如何使用 Swift 中的泛型和 extension 让你的数据解析工作更优雅。 《OS X 10.10 Yosemite: The Ars Technica Review》：由 图拉鼎 推荐：这篇从 CPU 指令集、编译器来剖析 Swift 的文章，对其的设计越来越肯定了。简单的说，Swift 是一门使用 High Level 语言的语法及特性，同时仍有 Low Level 效能的一门语言。 《Swift 小技巧（三）：如何用 Swift 思维设计网络请求》：近来在用 Swift 开发 App 的过程中，最大的心得就是：我开始渐渐用「Swift 思维」来思考了。回顾刚开始我用 Swift 时，只是套用它的语法而已，脑子里依然是 Objective-C 思维。这段时间，随着对 Swift 基本特性的掌握，我开始有意识地学习并尝试一些 Swift 才有的特性，此谓「Swift 思维」。Swift 有很多专有（Objective-C 没有的）的模式，今天我就从一个很简单的例子讲起，那就是：如何用 Swift 思维设计网络请求。 《wift 小技巧（五）：正确地启用 Logging 机制》：文章介绍了如何在 Swift 项目里正确地设置 Logging 。 《The Death of Cocoa》：Cocoa 实际就是 Objective-C 的标准库，包含了许多用语言编写程序最需要的一些框架，例如 Foundation、AppKit 和 Core Data。即使 Swift 才开始被使用几个月，Cocoa 已经开始失去它原有的光芒了。在语言方面，我们都见到了 Swift 是终结 Objective-C 的开始，但是作为基本库的 Cocoa 呢？(这已经不是苹果第一次把它的标准库淘汰了，记得 Carbon 么)？如果我们用 Swift 基本库重新建立一套 Foundation 会怎么样？让我们来看看一些 Cocoa 做过的具体的例子，并看看一个新的 Swift 基本库在哪些地方可以提高。 《Core Location in i​OS 8》：自从 iPhone 存在以来，位置服务就一直处于非常重要的位置。Core Location API 也在 iPhone OS SDK 最初的公开版本里就存在了。iOS 8 ，Core Location 被改动了不少，不管是允许开发者做之前并不被允许的开发，还是帮助维护用户隐私。更特别的是，iOS 8 给 Core Location 带来了三个主要的改进：更分化的权限，室内定位以及访问监控。本文对此改进做了详细的介绍。 《Apple Watch: WatchKit 应用程序要点》：本文介绍了在开发 Apple Watch 应用程序时需要注意的要点。包括 WatchKit 应用程序和 WatchKit 扩展，以及 WatchKit 应用程序的生命周期。此系列的文章还有：《WatchKit 框架: 将应用程序从裤兜里取出来》。 ##视频 《RunLoop 主题的分享 by 孙源 @sunnyxx》：来自百度的孙源组织了一次关于 Objective-C RunLoop 的技术分享。 《React.js Conf 2015 Keynote - Introducing React Native》：这是 Facebook 出品的 react.js 的视频介绍。Facebook 打算用它来统一移动端的编程语言，react.js 把界面全部用 native 控件实现，js 只作为后端逻辑层。Facebook 也打算开源该框架，如果这个框架成功，将改变整个业界的移动开发效率，因为 iOS 和 android 代码可以大部分复用。注：视频来自 youtube。 工具 《使用蒲公英来做 iOS 测试应用的分发》： “蒲公英” 是一个应用的免费分发服务，它帮助开发者能够方便地做 iOS 应用的测试分发工作。本文介绍了蒲公英的基本使用方法。 开源项目 Developing iOS 8 Apps with Swift：《Developing iOS 8 Apps with Swift》是 Stanford 公开课，本项目是其中文字幕翻译。"},{"title":"iOS移动开发周报-第40期","date":"2015-03-10T12:48:50.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"archive/2015-03-10-ios-weekly-40.html","permalink":"https://blog.devtang.com/archive/2015-03-10-ios-weekly-40.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，文章地址是这里。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：iOS 开发者收入调查报告、如何自己动手实现 KVO、QQ 中未读气泡拖拽消失的实现分析、InfoQ 上移动端话题汇总、UIResponder 等。 新闻 《iPhone 6 再立功：中国区 iOS 份额历史新高》：据来自 Kantar Worldpanel ComTech 的最新数据，截止至 2015 年一月的前三个月内，苹果 iOS 系统份额在中国区创历史新高，卖出的每四台智能手机就有一个是 iPhone。 《iOS 开发者收入调查报告（一）：个人开发者篇》：2014 年 12 月，CocoaChina 以网上调查问卷形式发起了 “2014 iOS 开发者收入调查报告” 活动，得到了广大开发者的支持。在对问卷数据进行了整理分析后形成了本次调查报告，从而让我们对国内 iOS 开发者的收入和生存状态有一个大概的了解。本文是该调查的最终报告。 教程 《如何自己动手实现 KVO》：KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知。本文探究了 KVO (Key-Value Observing) 实现机制，并去实践一番：利用 Runtime 自己动手去实现 KVO 。 《QQ 中未读气泡拖拽消失的实现分析》：QQ 中针对强迫症有个很棒的交互，对于那些暂时不想理会的未读信息气泡，可以直接手指拖拽去掉。本文介绍了其实现方法。 《UITextView 编辑时插入自定义表情-简单的图文混编》：在 iOS 开发中，经常需要用 UITextView 作为编辑文本的输入控件。但是如何在编辑时插入自定义表情呢？本文简单的用 NSTextAttachment、NSAttributedString 的特性，实现了在 UITextView 中编辑文字时插入自定义表情图片，同时可以返回带有表情 “替换符” 的纯文本字符串。 《提升 UITableView 性能-复杂页面的优化》：随着 App 的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的 UI 界面和保证流畅的体验。本文分享了一些提升 UITableView 性能的技巧。 《InfoQ 上移动端话题汇总》：@ 移动开发小冉 整理了一下 InfoQ 上关于移动方面的分享内容，涉及移动端架构、测试、流程优化等多方面的内容。 《 在非越狱的 iPhone 6 (iOS 8.1.3) 上进行钓鱼攻击 (盗取 App Store 密码)》：iOS 逆向工程的一大应用场景是 iOS 安全。它既可以作为攻击的矛，也可以作为防御的盾。由蒸米带来的本文就是一则典型的以逆向工程为矛的案例，他对 CoreFoundation 里私有函数的运用画龙点睛，值得学习。 《UIResponder》：在 UIKit 中，IApplication、UIView、UIViewController 这几个类都是直接继承自 UIResponder 类。另外 SpriteKit 中的 SKNode 也是继承自 UIResponder 类。因此 UIKit 中的视图、控件、视图控制器，以及我们自定义的视图及视图控制器都有响应事件的能力。本文详细介绍了一个 UIResponder 类提供的基本功能。 《实现一个 TODO 宏》：文章介绍了如何实现一个能产生编译器警告的 TODO 宏，用于在代码里做备忘。 ##视频 《First Impressions using React Native》：作者介绍了他使用 Facebook 即将开源的 React Native 的感受。 工具 iOS-Universal-Framework：iOS-Universal-Framework 是一个方便你将第三方 SDK 编译成 Framework 的开源工具。 Origami：Origami Live 支持在 iOS 设备上预览 Quartz Composer 项目，Origami 2.0 添加了导出 Objective-C、Java、JS 代码的功能，以后做原型效率更高了。由 @ 汤圣罡 推荐。 开源项目 NativeScript：NativeScript 是一个类似 React Native 的开源框架，使用 JavaScript 调用原生 API，构建原生应用，支持 iOS、 Android 和 WP 等多平台。"},{"title":"iOS移动开发周报-第42期","date":"2015-04-09T14:15:52.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"archive/2015-04-09-ios-weekly-42.html","permalink":"https://blog.devtang.com/archive/2015-04-09-ios-weekly-42.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：Facebook 正式开源 React Native、React 入门实例教程、React Native 通信机制详解等。 新闻 用 JavaScript 开发移动原生应用，Facebook 正式开源 React Native：Facebook 正式开源了 React Native，不过目前，只有 iOS 版，Android 版还需再等一段时间，这是最新的用 JavaScript 语言开发原生 App 的尝试。Facebook 同时还为 React Native 开发了一款基于 Atom 的 IDE：Nuclide，也已开源。 谷歌发现用于中间人攻击的证书：根据谷歌官方安全博客报道，谷歌发现 CNNIC 颁发了多个针对谷歌域名的用于中间人攻击的证书。该证书冒充成受信任的谷歌的域名，被用于部署到网络防火墙中，用于劫持所有处于该防火墙后的 HTTPS 网络通信，而绕过浏览器警告。 教程 《轻松学习 Objective-C 消息转发》：作者在文章中通过一个小例子来讲解什么是消息转发，以及如何消息转发，希望看完这篇文章时大家会彻底的明白 OC 的消息转发机制。 《React 入门实例教程》：React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。本文是阮一峰原创的入门教程。 《React Native 通信机制详解》：React Native 是 facebook 刚开源的框架，可以用 javascript 直接开发原生 APP，先不说这个框架后续是否能得到大众认可，单从源码来说，这个框架源码里有非常多的设计思想和实现方式值得学习，本文介绍了它最基础的 JavaScript-ObjectC 通信机制。 《跨平台开发时代的 (再次) 到来？》：这篇文章主要想谈谈最近又刮起的移动开发跨平台之风，并着重介绍和对比一下像是 Xamarin，NativeScript 和 React Native 之类的东西。 《iOS 开发中的争议（二）》：本文作者分享了 iOS 中的一个争议话题：对于 UI 界面的编写工作，到底应该用 xib&#x2F;storyboard 完成，还是用手写代码来完成？ 《正确使用 Block 避免 Cycle Retain 和 Crash》：Block 作为 C 语言的扩展，并不是高新技术，和其他语言的闭包或 lambda 表达式是一回事。需要注意的是由于 Objective-C 在 iOS 中不支持 GC 机制，使用 Block 必须自己管理内存，而内存管理正是使用 Block 坑最多的地方，错误的内存管理 要么导致 return cycle 内存泄漏要么内存被提前释放导致 crash。本文介绍了从 Block 实现原理切入，介绍了使用 Block 需要注意的地方。 《为 GCD 队列绑定 NSObject 类型上下文数据-利用 __bridge_retained(transfer) 转移内存管理权》：本文介绍了如何合理运用 __bridge_retained(transfer) 关键字转换对象的内存管理权，让我们自己控制对象的生命周期。 《Don’t React》：本文作者从多方面分享了他对于 React 框架的负面看法。通过此文，大家可以更加客观地了解 React 这个框架。 开源项目 Lister：Lister 是苹果提供的官方 Demo。包含了 iOS、Mac 和 Apple Watch 版本，并且为这个 demo 分别用 Objective-C 和 Swift 实现了一遍，最后还包括了 30 页的文档。 HackerNews-React-Native：HackerNews-React-Native 是用 React Native 完成的 HackerNews 客户端。 RMPZoomTransitionAnimator：RMPZoomTransitionAnimator 是一个放大缩小的动效开源库，可以实现图片的放大缩小效果。 MMTweenAnimation：MMTweenAnimation 是一个基于 POP 的扩展，提供了 10 种自定义的动效。"},{"title":"iOS移动开发周报-第41期","date":"2015-03-24T08:22:45.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"archive/2015-03-24-ios-weekly-41.html","permalink":"https://blog.devtang.com/archive/2015-03-24-ios-weekly-41.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：如何评价 React Native、用纯代码构建一个 Widget、FastImageCache 解析等。 新闻 苹果推出 Apple Watch：3 月 10 日，苹果公司 2015 年春季发布会在美国旧金山芳草地艺术中心召开。苹果在会上宣布推出 Apple Watch，续航时间为 18 小时。Apple Watch 将于 4 月 10 日开始预售，4 月 24 日开始发货。首批发售区域包含中国。 CocoaPods 0.36 正式发布，实现 Swift 和 iOS 8 动态框架支持：CocoaPods 于近日发布了 CocoaPods 0.36 正式版，其最大的改动便是为 iOS 引入了动态框架，并增加了对 AlamoFire、SwiftyJSON 等使用 Swift 所编写的库的支持，此举将影响包括 CocoaPods&#x2F;Xcodeproj 在内的所有 CocoaPods gems。 苹果开始整治 iMessage 垃圾信息：苹果在最新的 iOS 更新中，集成了更加方便的举报 iMessage 垃圾信息的功能。这将使得用户可以更方便地举报垃圾信息。 2014 iOS 开发者收入调查报告（二）：企业开发者篇：本次调研以 CocoaChina 网站用户为基础，总样本数量为 3591，调研时间为 2014 年 12 月 16 日-2015 年 1 月 31 日。调查报告的内容涉及开发经验、工作年限、待遇和工资满意度。 教程 《如何评价 React Native？》：来自知乎的这个回答详细介绍了 Facebook 即将开源的 React Native 的相关知识，包括核心实现、设计考虑、以及 React Native 的优势和劣势。 《iOS 开发的一些小技巧篇一》：@ 武蕴牛 x 总结了 iOS 开发中的一些小技巧。 《iOS 开发的一些小技巧篇二》：@ 武蕴牛 x 总结了 iOS 开发中的关于截图的技巧。 《如何用纯代码构建一个 Widget(today extension)》：随着 iOS8 的发布，各种 iPhone 的新玩法出现了，其中最引人关注的就是 today extension(也叫做 widget)。网上有很多相关的文章教你如何编写一个简单的 widget，但是却没有一篇适合我们这种纯代码的拥趸。本文介绍了如何用纯代码的方式来构建一个 widget。 《iOS 图片加载速度极限优化—FastImageCache 解析》：FastImageCache 是 Path 团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，本文分析了它的实现方式。 《Swift 语言 iOS 开发：CALayer 十则示例》：我们在 iOS 应用中看到的都是视图，包括按钮视图、表视图、滑动条视图，还有可以容纳其他视图的父视图等。但你或许不知道在 iOS 中支撑起每个视图的是一个叫做 “ 图层（layer）” 的类，确切地说是 CALayer。本文中您会了解 CALayer 及其工作原理，还有应用 CALayer 打造酷炫效果的十则示例，比如绘制矢量图形、渐变色，甚至是粒子系统。 《iOS 开发中的争议（一）》：作者在文章中讨论了关于 Objective-C 语言中如下问题的争议：类的成员变量应该如何定义？ 工具 QLImageset：QLImageset 是一个 QuickLook 插件：快速预览 imageset 文件夹包含的图片及其尺寸。 开源项目 Persei：Persei 是一个在顶部显示或隐藏菜单的 Swift 开源库。 BLKFlexibleHeightBar：BLKFlexibleHeightBar 是一个使导航栏高度可以动态变化的 UI 库。 Form：Form 是一个方便开发者创建表单填写工作的 UI 库。"},{"title":"iOS移动开发周报-第44期","date":"2015-05-06T11:59:09.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"archive/2015-05-06-ios-weekly-44.html","permalink":"https://blog.devtang.com/archive/2015-05-06-ios-weekly-44.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：Apple Watch 产品体验报告、苹果推出了官方的分析工具、iOS 图形性能进阶与测试、iOS 应用架构谈等。 新闻 《Apple Watch 产品体验报告》：文章从各个维度对 Apple Watch 进行了体验总结，包括外观感受、交互设计、功能场景分析、差异化分析等。 《苹果推出了官方的分析工具》：苹果在五月一号这天，向开发者发送邮件，邀请参与他自家的分析工具的试用。从苹果的介绍中看出这个工具的特点是：无需额外操作，相关功能是直接集成进 iOS 系统中的，对应用来说没有任何其它的代价。另外由于苹果的限制，一些功能是第三方工具是无法提供的（例如统计运营活动效果、统计查看 AppStore 页面效果等）。苹果提供这样的工具，有助于开发者更加有效地开展市场推广和运营相关的工作。 教程 《Increasing Performance by Reducing Dynamic Dispatch》：来自苹果官方博客的文章，介绍了通过减少动态分发，来提高 Swift 程序的执行效率的办法。具体做法上，文章分享了使用 final 关键字，使用 private 关键字，以及使用 Whole Module Optimization 编译参数来进行深度优化。 《Mac OS X 上逆向 Dash v2.2.0 过程分析》：不知不觉，http://iosre.com/ 已经成为国内著名的 iOS 安全方面的网站了。本文在逆向 Dash 的同时，也揭露了 Dash 使用的防逆向手段，学习本文可以了解到常见的逆向攻击手段和防范方法（例如：二进制的校验），提高大家的安全意识。 《Scrapy+Flask+Mongodb+Swift 开发全攻略（1）》：本文试图实现一个人完成获得资源、编写服务端、iOS 客户端、服务端部署上线、客户端上 AppStore 的完整过程。其中，Flask 是 python 写的一个非常有名的 web 开发框架，Mongodb 是一个非关系型数据库。 《iOS 图形性能进阶与测试》：这篇文章主要是学习完 Advanced Graphics and Animations for iOS Apps 这个 session 后的总结和相应细节的延伸和细化。主要内容为图形性能与测试工具这两个章节。 《Auto Layout 使用心得（六）—— 制造炫酷的下拉刷新动画》：本文中，我们将一起使用 Auto Layout 技术制造一个炫酷的下拉刷新动画。Auto Layout 除了在布局的时候比较繁琐以外，还有一个经常被人吐槽的点：让许多 UIView.animateWithDuration 失效，甚至在界面上出现 “反方向动画” 的视觉效果。本文中我们将主要讲述制造下拉刷新动画的过程，关于 Auto Layout 与动画的详细配合我们以后再一起仔细探究。 《Apple Watch 和 iPhone 通信实践》：本文主要从实践的角度分析 iPhone 和 Watch 的通信框架。 《iOS 应用架构谈 - view 层的组织和调用方案》：文章比较长，介绍了涉及 view 的各方面的经验。分享作者最后的总结：要做一个 View 层架构，主要就是从以下三方面入手：制定良好的规范、选择好合适的模式（MVC、MVCS、MVVM、VIPER）、根据业务情况针对 ViewController 做好拆分，提供一些小工具方便开发。 《CocoaPods 建立私有仓库》：个人或公司在开发过程中，会积累很多可以复用的代码包，有些我们不想开源，又想像开源库一样在 CocoaPods 中管理它们，那么通过私有仓库来管理就很必要。文章介绍了建立私有仓库的具体操作方法。 《实时显示 iOS 的编写 UI 代码效果》：编写 iOS 应用 UI 的方式大概有两种，一种是 Storyboard&#x2F;Xib，另一种是手写代码。采用 Storyboard&#x2F;Xib 方式组织 UI，由于提供可视化的特性，只要从 UI 库中拖动 UI 控件，便可以显示结果，极大地提高开发速度。但面临一个问题就是多人协作开发，由于所有的 UI 都放在同一个 Storyboard 文件中，使用 Git&#x2F;SVN 合并代码就会出现冲突。多人协作开发还不是主要问题，有人提出可以创建多个 Storyboard 来分开 UI 编写，而 Storyboard&#x2F;Xib 最主要问题是代码复用性比较差。所以有些人就选择手写 UI 代码，这样不仅可以解决多人协作开发问题，而且通过自定义控件在多个 View 使用。但每次手写 UI 代码后都要编译、构建和运行，最后在模拟器显示，这样会拖慢开发速度。如果每次修改 UI 控件后，保存修改便实时在模拟器显示修改后结果，就可以极大的提高编写 UI 的速度。本文介绍了一种办法可以实时显示 iOS 编写的 UI 代码效果。 工具 《Which Clang Warning Is Generating This Message》：Clang 的警告与语义对照表。通过它可以更加方便地知道 Clang 的警告所表达的意思。 PPEtcHosts：PPEtcHosts 是一个小工具，可以在应用内实现域名 Host 绑定，可以解决真机无法修改 /etc/hosts 的问题。 开源项目 KYGooeyMenu：KYGooeyMenu 是一个具有 Gooey Effects 带粘性的扇形菜单控件。 DKNightVersion：DKNightVersion 是一个支持夜间模式切换的框架。 UITableView-FDTemplateLayoutCell：UITableView-FDTemplateLayoutCell 是一个方便缓存 UITableViewCell 的高度的框架。 IOS-Categories：IOS-Categories 是一个收集各种有用的 Objective-C 语言的 Category 的项目。"},{"title":"iOS移动开发周报-第43期","date":"2015-04-24T12:59:43.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"archive/2015-04-24-ios-weekly-43.html","permalink":"https://blog.devtang.com/archive/2015-04-24-ios-weekly-43.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期 iOS 移动开发周报带来如下内容：WWDC 2015 将于 6 月 8 日在旧金山开幕、react-native 之布局篇、iOS 应用架构谈、iOS 证书及 ipa 包重签名探究、开源项目Kingfisher和samurai-native等。 新闻 《WWDC 2015 将于 6 月 8 日在旧金山开幕》：苹果于 4 月 14 日宣布，将于 6 月 8 日至 6 月 12 日在旧金山召开第 26 届年度全球开发者大会 (WWDC)。预计大会上将会发布 iOS 9 新版移动系统及用于 Mac 电脑的新版 OS X 系统。鉴于 Apple Watch 的重要性，这次也许苹果会将更多精力放在自己的智能手表生态建设上。苹果每次邀请函设计或多或少都有隐藏含义，本次方圆融合也许就体现了手表的特点。 《iOS 8.3 阻止了 iFunBox, iExplorer 等软件》：苹果对 iOS 8.3 加强了安全性，阻止了 iFunBox, iExplorer 等软件来连接到 iOS 设备进行相应的管理操作。 教程 《react-native 之布局篇》：来自天猫的 @sysu_ 学家 同学实践并整理了一篇关于 React Native 的文章，详细丰富的介绍了 React Native 布局的知识。 《iOS 应用架构谈：开篇》：对于 iOS 客户端应用的架构来说，复杂度不亚于服务端，但侧重点和入手点却跟服务端不太一样。本系列文章作者会主要专注在 iOS 应用架构方面，很多方案也是基于 iOS 技术栈的特点而建立的。本文是该系列第一篇。 《我是怎么慢慢变懒的 : Jenkins + 蒲公英》：任何工具出现的最初目的都是为了提高生产效率，很庆幸在 iOS 开发的这个圈子中有一大批的先驱者，他们创造并开源了很多优秀的工具，为这个环境奠定了一个良好的基础。本文作者 @answer-huang 介绍了使用 Jenkins 和蒲公英来完成自动打包和分发测试包的工作。 《iOS 证书及 ipa 包重签名探究》：本文重点在于介绍 ios8.1.3 系统 ipa 包重签名 (如企业证书) 无法安装的问题。苹果在 iOS8.1.3 系统以后加强了对 ipa 安装包签名的验证，主要区别在于 ipa 唯一标识在原有 Bundle Identifier 的基础上增加了证书 ID，也就说安装包和手机上已安装 APP 的 Bundle Identifier 即使一致，如果两者签名的证书 ID 不相同，那么安装包也无法正常安装。 《iPhone 目标分析及使用 UDID 实施入侵》：iPhone 有一些强大而实用的功能，例如定位追踪和远程数据擦除。这其实都得益于它的唯一设备识别符 UDID（Unique Device Identifier）。本文描述了发掘 iPhone 目标终端设备、利用量子计划（QUANTUM）直接植入目标的标准分析技术，说明 iPhone 唯一设备识别符（Unique Device Identifier，简称 UDID）可以用于追踪目标或与终端设备及目标电话相关联，强调该入侵技术目前可以实现并实施进一步定位的 CNE 过程。 《录屏技巧》：本文介绍了用 Swift 打开 QuickTime Player 录制指定区域的奇技淫巧。 工具 XcodeSwiftSnippets：XcodeSwiftSnippets 提供了很多可在 Xcode 上使用的 Swift 语言的代码片段 , 通过自动补全的方式，可以极大的提高开发效率。 开源项目 Kingfisher：Kingfisher 是一个用于图片缓存的开源库，类似 SDWebImage，但是完全基于 Swift 语言开发。 samurai-native：samurai-native 是 @ 老郭为人民服务 开源的一套新的构建 App 框架，可以使用 HTML 和 CSS 来生成原生的应用界面。 BCMagicTransition：BCMagicTransition 是一个动效框架，用于自定义 UINavigationController 的切换动画，效果类似 Keynote 软件中 Magic Move 切换。它可以用于任意两个 UIViewController 之间，只需指定两个 VC 中的相同元素即可。 Refresh Plugins After Xcode Upgrading：每当 Xcode 升级之后，都会导致原有的 Xcode 插件不能使用，这是因为每个插件的 Info.plist 中记录了该插件兼容的 Xcode 版本的 DVTPlugInCompatibilityUUID，而每个版本的 Xcode 的 DVTPlugInCompatibilityUUID 都是不同的。如果想让原来的插件继续工作，我们就得将新版 Xcode 的 DVTPlugInCompatibilityUUID 加入到每一个插件的 Info 文件中，手动添加的话比较费时间还可能出错，所以作者写了一个脚本来做这件事。 ResearchKit：ResearchKit 是苹果开源的方便科研机构创建 App 的框架。"},{"title":"结束撰写 iOS 开发周报","date":"2015-05-31T12:59:12.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"archive/2015-05-31-the-end-of-ios-weekly.html","permalink":"https://blog.devtang.com/archive/2015-05-31-the-end-of-ios-weekly.html","excerpt":"","text":"开始2014 年 2 月份，当时正值春节，InfoQ 的编辑水羽哲找到我，说希望让我给 InfoQ 的「iOS 开发周报」供稿。当时周报类的文章比较有名的是国外的由 Dave Verwer 编辑的「iOS Dev Weekly」，国内的周报偶尔有一些，但是质量都一般。所以考虑之后，我答应了下来。 从此之后，我开始每周一期给 InfoQ 撰写「iOS 开发周报」，并且转载到我的个人博客上，现在算下来，已经坚持了一年多，我总共完成了 44 篇周报。有些时候当周国内并没有特别多的技术文章，所以我有时会两周出一次周报。 编写「iOS 开发周报」是一个苦活，每个周末，我需要将平时看到的不错的文章整理出来，并且再浏览一遍自己通过 RSS 阅读器定阅的国内外博客文章，精选出一些好文章。然后我会再去 Github 上浏览一遍当周上升比较快的项目，选一些合适的推荐给大家。有时间还会整理一些新闻或开发工具给大家。 有一些时候因为周末偶尔加班或者家里有事，回到家都很晚了，但是由于答应了这份工作，所以还是会强迫自己打开电脑，坚持把周报写完再睡觉。其实我当初答应写周报，部分原因这是想给自己一些压力，强迫自己每周定期进行学习总结。最终效果还是不错的，我在这一年多的周报撰写过程中，在技术上成长了很多。 改变 Everything that has a beginning has an end. — 《黑客帝国》 就像《黑客帝国》里面的那句台词一样，所有事情都会有它结束的时候。 去年底，我所在的创业公司启动了「小猿搜题」http://www.yuansouti.com/ 这个新项目，我除了做小猿搜题的 iOS 版本开发外，也开始做一些产品和技术的管理工作。刚开始我还能抽身做一些开发，但是自从招到了 iOS 端的新人后，我就开始只做 code reivew 的工作了。 其实对于互联网公司来说，管理人的事情并没有很多，特别是我们采用适合打造「自组织」团队的 Scrum 的敏捷开发方式来做项目管理。但是对于小猿搜题这个项目，相对于 iOS 开发来说，有更多更重要的问题需要解决，所以我还是把精力放在了非 iOS 技术上。 那对于我来说，继续再坚持拿周末的时间写「iOS 开发周报」是一个很尴尬的事情，因为写周报花费了我很多时间，但是我并不能将自己周报中的学习成果「学以致用」，所以在纠结了很久之后，我还是想放弃撰写「iOS 开发周报」。 寻找新的撰写者为了让大家能够继续看到高质量的「iOS 开发周报」，我想办法找了很多人。最后，人称喵大的 @onevcat 答应了接替我负责 InfoQ 的「iOS 开发周报」栏目。并且，我征得 InfoQ 和 onevcat 的同意，后续会继续将「iOS 开发周报」转发到我的「iOS 开发」微信公共帐号上。 喵大现在在日本的 Line 工作，他的技术和文笔都相当好，我相信他会比我做得更好，也是比我更合适的周报撰写人。 新的开始我个人从来都是 10000 小时理论的实践者，所以从工作到现在，我都会利用周末和晚上的时间来学习充电。由于负责「小猿搜题」的产品技术，所以我会在周末学习更多相关的知识，包括产品、技术和一些管理相关的知识。这些方面涉及的内容会很多，所以我应该会分阶段地来一件一件做，我应该也会将相关的学习总结分享到博客上。 关于 「iOS 开发」微信公众号对于 iOS 开发技术，我应该会继续关注和学习，但是可能不会像以前那样把自己的全部学习时间都投入到上面了。为了帮助我继续学习 iOS 开发技术，我也会读以后 onevcat 写的 iOS 开发周报。 另外，我的 「iOS 开发」微信公众号现在已经有 16000 的关注，也有一些广告收入。我打算将广告收入用来支付原创作者的转载稿费（每篇 50-100 元），另外结合微信的打赏功能，鼓励优秀的、原创高质量 iOS 技术文章。欢迎大家扫如下的二维码关注我的「iOS 开发」微信公众号，上周的尝试结果是，每个投稿的作者都获得了超过 300 元以上的打赏。 我们都在努力生活着，愿大家都找到属于自己的精彩，玩得开心～"},{"title":"Reveal 中国特惠活动","date":"2015-05-25T15:46:16.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"archive/2015-05-25-can-we-buy-time.html","permalink":"https://blog.devtang.com/archive/2015-05-25-can-we-buy-time.html","excerpt":"","text":"你买过的最贵的软件是什么？对于我来说，就是 Reveal。Reveal 和 Charles 是我用得最多的应用，我在我的《iOS 开发进阶》一书中也用了整整两个章节分别介绍它们。 因为太喜欢这两个 App 了，所以我都试图向原作者联系组织团购。好消息是，一年前，Charles 的作者成功给了我 6 折的团购优惠码，我在我的「iOS 开发」微信公众号里组织团购了 120 多个 Charles License。但是坏消息是，Reveal 一直没有回复我的任何邮件。 在苦等无果的情况下，几年前我还是买了 Reveal，为什么呢？其实很简单，我算了一笔帐。假如我的月薪是2万元，那么每一天的工资是差不多 1000 元，而我有许多手写 UI 代码以及调试界面的需求。在没有 Reveal 的时候，我可能需要花费数倍的时间才能完成界面的编写工作。而只要 Reveal 给我带来的时间节省超过半天工作时间（500 元），这笔买卖我就赚了。 事实上，我不但赚了，而且是大赚。我记得一次周末在家写一个小 Demo 程序，界面上的一个控件不见了，由于是一个 Demo，我就随意地试验，总是没有找到原因。折腾了半小时后，我突然想起可以用 Reveal 看看，于是我当用 Reveal 连上 App 后，马上就发现这个控件被另一个控件 “挡住了”，于是我调整了一下界面元素的层次关系，就搞定了。事后我回想了一下，虽然这是一个相当小的 Bug，但是由于比较难想到出问题的地方，在没有 Reveal 的情况下，我很可能耗费一整天还摸不到头绪。 现在，我 30 岁了，我更加珍惜时间了。用金钱可以买生命吗？很多人觉得这不可能。但是事实上，给自己买一些提高自己工作效率的工具，就是在给自己延长生命。因为有了这些工具，我们的生命不再浪费在一些无趣的事情上，我们做的事情更高效了，省下来的时间我们可以用来学习，可以用来游戏，可以用来休息，某种意义上说——因为你体验的有效事情更多了，你的生命就是被延长了。 同样的道理也可以用在买书上，很多人觉得书太贵。但事实上，《iOS开发进阶》只要有哪怕一小块知识让你节省了一个小时的时间，你都是赚的。 让我们说回Reveal。好事多磨，几天前 Reveal 的团购终于起了转机。LYcHEE 联系到了我，想和我联系发起 Reveal 的中国区特惠，价格比 Reveal 官方的教育优惠还便宜，于是我毫不犹豫地答应了下来。该中国区特惠只需 249 元即可购买原价 560 元的个人版 License。 如果你因为工作原因需要手写 UI 代码，如果你需要有比较多的界面调试工作，那么你真得值得试试用 Reveal 给你的工作提效，从而节省时间。也许你从来没有买过这么贵的正版软件，但是大家可以像我一样算算自己每个小时值多少钱，几个小时值 249 元，我想你就不会那么犹豫了。 需要说明的是，因为付出了时间和精力，LYcHEE 和我都会从这次 Reveal 中国特惠价中得到少量回报，希望你能理解。另外由于这个价格在全球都是最低的，所以为了防止倒卖，每个淘宝 ID 最多只能购买 2 个 License。 最后，附上 Reveal 的中国特惠 购买地址 （注：该特惠价已经于 2015 年 8 月结束）。 愿大家玩得开心～"},{"title":"Mac 应用出现「已损坏」问题，苹果到底犯了什么傻逼错误？","date":"2015-11-21T14:22:42.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"archive/2015-11-16-apps-damaged-bug.html","permalink":"https://blog.devtang.com/archive/2015-11-16-apps-damaged-bug.html","excerpt":"","text":"事件回顾据国外多名网友反映，从 11 月 13 号开始，打开一些 Mac App Store 中下载的软件时，会出现 “已损坏”（Damaged）的提示。受此问题影响的软件较多，包括广为人知的 1Password、Dash、Byword 和 Tweetbot 等。Tweetbot 开发者 Paul Haddad 在 Twitter 上表示这个问题看起来与认证证书到期有关，并猜想目前证书使用 SHA256 加密，或许会和 OS X 老版本不兼容。 问题原因微博上的 @webfrogs 分享的这篇文章中详细解答了这个问题产生的原因。我仔细读了一下，给大家分享一下。 每一个 Mac AppStore 下载的软件都有一个证书，证明该软件是合法购买并且没有被篡改的。在以前，该证书是通过 SHA-1 来进行散列验证的，SHA-1 是一种类似 MD5 的散列算法，比 MD5 更安全，但是计算起来更耗费 CPU 。 最近，苹果更改了证书的算法，使用 SHA-2 来进行散列验证的。这本来应该是对用户透明的，但是，苹果的质量部门却没有发现这个大 Bug。于是影响了大范围的用户。 具体影响的过程是： 首先，过期的证书在缓存中没有被清除，系统会要求用户重启来清除证书或重新获得新证书。 然后，一些应用明显地使用的是旧版的 OpenSSL 来验证购买凭证，然后你猜怎么着？旧版的 OpenSSL 不！支！持！SHA-2 算法！ 由此我们就可以知道应该如何解决该问题了： 方案一：类似 XcodeGhost 事件那样，可以将那些使用旧版 OpenSSL 应用被苹果下架，要求它们升级到最新版的 OpenSSL，但是这个至少需要几天时间。 方案二：苹果将算法退回到 SHA-1。 于是，在愤怒的用户面前，苹果想了想，还是怂了，将算法退回（Roll back）到了 SHA-1。当然，想必他也会要求以后的应用必须使用新的 OpenSSL 库，然后确保没问题后再升级加密算法。 总结总结起来就是：苹果傻逼了，搞了一个大 bug，然后自己回退代码了。这次事故苹果的质量保证部门应该犯有不可推卸的责任。 另外，我居然没受影响，原因是我没有升级 OS X 到最新版，所以逃过了一劫。不过我的一些搞 iOS 开发的小伙们可惨了，好多人挨个把软件重新下载了一遍。 乔布斯离世之后，苹果的软件质量变得越来越不稳定，加上创业太累，这让我这个不喜欢折腾的人越发喜欢等大家测试稳定之后再升级，希望这是我的错觉吧。"},{"title":"iOS移动开发周报-第45期","date":"2016-09-26T14:15:15.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"archive/2016-09-26-ios-weekly-45.html","permalink":"https://blog.devtang.com/archive/2016-09-26-ios-weekly-45.html","excerpt":"","text":"前言是的，我又开始写周报了！主要是因为喵神不写周报了，加上我发现大家对写 iOS 技术周报这件事情似乎没什么兴趣。其实我觉得这是一个挺好的学习总结的办法，所以要不就继续我来吧。 我会每周从国外的周报，微博，GitHub，QQ &#x2F; 微信群里收集各种 iOS 的信息，然后挑选一些有价值的分享给大家。 MDCCMDCC 大会刚刚结束，这次大会请来了在日本的喵神王巍，滴滴的孙源，LeanCloud 的陈宜龙等众多 iOS 开发者。会议的所有 iOS 讲稿都会更新到这个地址，感兴趣的同学请一定关注更新：https://github.com/MDCC2016/iOS-Session-Slides 王巍提前已经将他的讲稿和 Demo 代码公布在微博上了，地址是：http://weibo.com/1708947107/E9JHnoNtS 苹果加强应用标题审核力度你的应用最近因为起名字的原因被拒过吗？在以前，由于标题文字在搜索中的排序权重较高，所以有一些应用会把一些热门关键词写在标题中。苹果对此行为一直管得不严，有些审核员管，有些审核员不管。不过最近似乎每个审核员都更加严格执行这项标准了，那些稍长的名字，都被要求进行进一步的精简。详见：http://www.gupowang.com/app/5057.html 适配 iOS 10Xcode 10 发布以后，编译器开始不支持 iOS 7，所以很多应用在适配完 iOS 10 以后，都不再支持 iOS 7 了。我的同事看了一下，包括网易新闻，滴滴出行这些大应用也都选择了不再兼容 iOS 7 的方法。但是也有一些应用选择适配 iOS 10 同时支持 iOS 7，这些应用有 QQ，美团 等。由于 AppStore 支持 iOS 7 的设备下载旧的版本，所以我个人觉得即便不支持 iOS 7，所以不支持 iOS 7 或许是最省事的办法。 Swift 3Swift 3 推出之后，Ray 出了一个迁移到 Swift 3 的视频教程，感兴趣的同学可以看看，不过据说，Alarmfire 网络库在适配 Swift 3 后，只支持 iOS 9 以上的版本。这对于国内系统升级缓慢的应用来说，似乎是一个很尴尬的事情。另一个尴尬的事情是迁移 Swift 3 还需要各种第三方库的配合，当前看起来，还需要一些时间。所以，建议大家还是继续使用 Swift 2.3 的版本。https://videos.raywenderlich.com/screencasts/ios-10-swift-3-in-3-minutes Push Notifications苹果最近改进了它的 Push Notifications 使用方式，除了可以使用以前的证书验证方式外，增加了一种名为 Token Authentication 的方式。苹果原话说： A token is easy to generate, doesn’t expire, and can be used to send notifications to all of your apps. 感兴趣的读者可以试试，相关链接：https://developer.apple.com/news/?id=09222016a VaporVapor 1.0 正式发布了，这是一个基于 Swift 的服务器端框架，感兴趣的朋友可以玩玩。http://vapor.codes/ 有趣最近 AppStore 的热门搜索出现了奇怪的词条，详见下面第三条，看不懂的别问我，我也不懂！请向老司机请教！"},{"title":"iOS 移动开发周报 - 第 47 期","date":"2016-10-16T15:34:22.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"archive/2016-10-16-ios-weekly-47.html","permalink":"https://blog.devtang.com/archive/2016-10-16-ios-weekly-47.html","excerpt":"","text":"新闻苹果解释 Dash 下架的原因上周关于 Dash 被苹果下架的事情有了来自 苹果的解释，苹果说 Dash 进行了刷榜，具体来说，是在 Dash 的评价中发现了一些明显带有欺骗性的评分。苹果同时说这个决定是最终的，并且不可申述（final and can’t be appealed），所以这件事情可能最终的结果就是这样了。 我们从这件事情中可以看出，苹果对于刷榜的行为变得越来越严厉了。但是在国内，刷榜的行为还是普遍存在，而且大多数都没有受到惩罚。例如，我们公司的三款产品都没有刷榜，但是我们的竞争对手其实都有明显的刷榜行为。希望苹果能够有机会也整治一下国内的环境，让大家都在一个公平的环境中竞争。 Swift 4是的，Swift 4 开始开发了，在 Swift 4 在 GitHub 的主页上，苹果公布了 Swift 4 的 主要目标。时间上，苹果计划在 2017 年晚些时候正式发布 Swift 4。苹果希望将 Swift 4 的开发分为两个阶段： 第一阶段：关注于核心的一些需求，以及 ABI 的稳定性。苹果不希望在 Swift 4 中引入 ABI-breaking 的改变。 第二阶段：该阶段希望在 2017 年春能够开始讨论，在第一阶段的任务完成后，可以增加一些或大或小的新特性。 iDev 大会​iDev 大会是一场由开发者自己办的技术会议，会议内容主要面向苹果的开发者，我是这次会议的出品人。 今年 iOS 的话题其实集中在 Swift 语言、函数式编程、跨平台方案，所以这方面的话题本次大会都有涉及。另外 iOS 安全一直是被人们较为忽视的一个方面，本次大会我在这方面也特别有设计议题讨论。 考虑到 iDev 大会希望涉及苹果全平台的技术，所以本次大会我们也安排了关于 macOS、watchOS 和 HomeKit 的议题。 对了，购票时输入我的优惠码：tangqiao，可以获得折扣票价再打 85 折哟。你也可直接访问以下网址获得优惠过的价格：http://www.bagevent.com/event/207773?discountCode=tangqiao 文章闭包的 escaping 与 non-escapingOptional Non-Escaping Closures： 本文讨论了 Swift 中的闭包的 escaping 的情况。所谓 escaping，就是指闭包在作为参数，传递给相应函数之后，相应函数执行完成了，但是闭包可能还需要被调用。所以，这个闭包似乎是逃离（escaping）了函数的作用时间。因为按理说函数执行完了，相应的参数应该就没用了，但是对于 escaping 的闭包，却不是这样。 什么情况下会出现这种情况呢？最常见的场景就是异步调用。比如我们发起一个网络请求，传入了一个闭包作为回调参数。这个闭包显然需要在网络请求结束时，才会被调用，这就是一个 escaping 的闭包。类似的还包括：我们把一些闭包放到 GCD 提供的 Dispatch Queue 中，也会造成 escaping 的闭包。 在本文中，作者讨论了一种比较特别的现象：只要一个闭包是 Optional 的，则它一定会是一个 escaping 的闭包。作者讨论了产生此问题的原因，并且提供了一些解决方案。 把第三方 iOS 应用转成动态库《黑科技：把第三方 iOS 应用转成动态库》，本文介绍了一个自己写的工具，能够把第三方 iOS 应用转成动态库，并加载到自己的 App 中，文章最后会以支付宝为例，展示如何调用其中的 C 函数和 OC 方法。另外，本文首发在我的微信公众号：iOSDevTips 中，如果你还没有关注过，请扫码关注哟： 视频本周视频推荐 objc.io 出的一期视频：手写一个 Parser。 工具本周推荐的工具，是一个 Xcode 8 的效率工具。它可以方便你在任何时候输入需要 import 的内容。其实这类工具在别的平台都是 IDE 自动提供的，以前我在用 Eclipse 写后台的时候，用了一个需要 import 的库的类，只需要按 cmd + shift + o，IDE 就会自动把这些需要 import 的头文件帮你填上，以节省时间。Xcode 在这方面，还有挺多需要加强的。Anyway，Xcode 的 extension 这个机制也让我们能够自己动手丰衣足食了。 该工具在 GitHub 上的地址是 Import，以下是使用起来的效果动画： 有趣本周的趣图来自 汤圣罡，由苹果的各种配件组成的一个笑脸，愿大家都有一个愉快的一天。"},{"title":"iOS 移动开发周报 - 第 46 期","date":"2016-10-10T13:08:08.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"archive/2016-10-06-ios-weekly-46.html","permalink":"https://blog.devtang.com/archive/2016-10-06-ios-weekly-46.html","excerpt":"","text":"前言大家国庆节过得如何？我反正是整个人的作息都变了，估计要调整过来得花不少时间。 国庆节期间开车还经历了人生第一次剐蹭，倒车时方向盘转得过猛，车头把停在旁边的一台宝马 5 系给蹭到了，吓得我赶紧报了保险。结果最后定损的维修费用也就几百块钱，用交强险就 cover 住所有费用了。人生就是不停地经历，有了这次出险，以后估计开车会更加小心。 好了，言归正传，我们来看看本周的 iOS 新闻。 新闻Search Ads 上线苹果的 AppStore 搜索广告终于 正式上线了，不过现在仅支持 iPhone 平台和美国区。AppStore 搜索广告类似于百度搜索关健词的竞价排名机制，该平台未来在中国区上线之后，我估计会使得一部分刷榜行为转移到正常的广告投放上。另外各个公司其实也需要及时介入，对自己的商标或产品关键词进行提前保护，以避免被恶意投放广告。关于 Search Ads 的详细介绍，今年的 WWDC 有专门的介绍视频，建议大家都看看。 Dash 被 AppStore 下架Dash 是一款优秀的 Mac 效率工具，恰当的使用它，可以极大地提高你的输入速度。最近，作者被 Apple 告知其帐户「因涉嫌诈欺」而被停权。作者提供了授权迁移工具，便于大家将授权转移出来。详情：阅读原文。 关于 Dash 被下架的原因，大家众说纷纭，其中有一个说法是：Dash 在将其的个人帐户转成企业帐户时，涉及的邓白氏码（DUNS）的代理公司可能提供的信息有问题，牵连了 Dash。 春雨医生创始人张锐去世我和张锐有过在网易门户的短暂共事经历，不曾想到张锐正值创业上升时期 离世，令人唏嘘不已。国内互联网公司虽然有着远高于别的行业的平均薪水，但是也同时伴随着极高的工作强度，不管是创业公司，还是已经上市的 BAT，加班就犹如家常便饭。但是，身体总归还是我们自己的，希望大家都能平衡好事业和身体。 文章Swift 3Swift 3 的迁移工作并不轻松，喵神说他的开源库 Kingfisher 大概花了 200 个提交，才完成了迁移工作。 最近，Glow 技术团队分享了 Swift 3 带来的改变，感兴趣的可以点这里阅读。 国庆前，图拉鼎也分享了适配 Swift 3 的一点小经验和坑，点这里阅读。 Let’s Talk About project.pbxprojproject.pbxproj 文件被包含于 Xcode 工程文件 *.xcodeproj 之中，存储着 Xcode 工程的各项配置参数。它本质上是一种旧风格的 Property List 文件，历史可追溯到 NeXT 的 OpenStep。其可读性不如 xml 和 json，苹果却一直沿用至今，作为一家以创新闻名的公司可能这里剩下的就是情怀吧。 本文谈了下 project.pbxproj 的知识，并总结了一些操作工程文件的优秀轮子，并在最后给出了自己的解决方案 pbxprojHelper。 阅读请戳：http://t.cn/Rcg8jUc Swift 算法Ray Wenderlich 上有一个算法系列的专题，叫做《Swift Algorithm Club》，每个月会出一篇文章，介绍如何用 Swift 实现一些基本的算法，最新的一期文章是《Swift Linked List Data Structure》，感兴趣的点这里阅读。 会议&#x2F;dev&#x2F;world&#x2F;2016 大会在澳大利亚举办的 &#x2F;dev&#x2F;world&#x2F;2016 大会结束后，主办方公开的相关的大会演讲视频。视频内容涉及跨平台开发、UI 设计、自动化测试、Swift、函数式编程，欢迎围观：http://t.cn/RcucyX2。注意地址在 youtube 上，需要翻墙。 开源项目本周开源项目推荐的是 HYFileManager，HYFileManager 一个基于 NSFileManager的文件操作类，它提供一系列的静态方法，只用少量的代码，来处理经常需要处理的文件操作，使得工作更加方便快捷。 有趣据说下图表示的是「断点调试」的场景："},{"title":"iOS移动开发周报-第27期","date":"2014-10-12T08:33:21.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"archive/2014-10-12-ios-weekly-27.html","permalink":"https://blog.devtang.com/archive/2014-10-12-ios-weekly-27.html","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言欢迎国内的iOS同行或技术作者向我提交周报线索，线索可以是新闻、教程、开发工具或开源项目，将相关文章的简介和链接在微博上发布并 @唐巧_boy 即可。 【摘要】：本期iOS移动开发周报带来如下内容：国内iOS6比例已经低于5%，Apple 发布 Swift 语言和 Xcode 入门视频，Facebook’s iOS Infrastructure等。 新闻 《国内iOS6比例已经低于5%》：来自国内友盟的统计以及笔者开发的应用（猿题库）统计结果都显示，国内的iOS6用户比例已经低于5%。 《苹果关闭iOS 7.1.2验证：iOS 8将无法降级》：在发布iOS 8的两个更新之后，苹果停止了为iOS 7.1.2固件提供签名。这意味着，已经升级至新版iOS 8的用户将无法再降级回iOS 7.1.2。 《新恶意软件iWorm已感染全球1.7万台Mac电脑》：信息安全研究人员近期发现，全球超过1.7万台Mac电脑已经感染了一种名为“iWorm”的新的OS X恶意软件。这种恶意软件曾使用Reddit网站作为传播媒介，能窃取用户数据，触发多种系统操作，并执行Lua脚本。用户可以通过测试路径/Library/Application Support/JavaW是否存在，在判断是否中病毒。如果OS X找不到这一文件夹，那么Mac电脑就是安全的。 教程 《iOS8 Swift Cheat Sheet and Quick Reference Guide》：这份速查表列出了Swift的常见的基本用法。 《 获取当前安装的所有App》：作者介绍了利用私有API在非越狱的iOS 7和8机器上，获取iOS中安装的所有App的办法。 《iOS8企业应用部署Bug》：作者发现使用iOS企业部署（In-HouseDistribution）方式进行应用升级时，在iOS8下无法成功，删除应用再重新安装也不行。经过调研，作者发现这个是Apple的bug，并且提供了临时解决办法。 《The best resources for learning iOS design and Xcode》：作者整理了一系列关于iOS 设计和 Xcode 方面的学习资源，并提供邮件订阅。 《基于Core Animation的KTV歌词视图的平滑实现》：文章介绍了唱吧歌词视图的技术实现细节。 《10 Swift IOS open-source projects you cannot ignore》：文章介绍了10大不能错过的 Swift 开源项目。 《iOS 8 Custom Keyboard Tutorial: How to Create A Third-Party Keyboard Extension》：文章介绍了如何在iOS8下自定义键盘。 ##视频 《Apple 发布 Swift 语言和 Xcode 入门视频》：Apple 在 Swift 官方博客上发布了一段6分钟多的视频，介绍如何从零开始使用 Xcode 套件开发 iOS 应用，非常值得想现在开始学 iOS 开发的朋友一看。 《Facebook’s iOS Infrastructure》：Facebook在视频中分享了他们的iOS端架构。 开源项目 SwiftSSL：SwiftSSL 是一个基于CommonCrypto的Swift语言的加密库。 SwiftHTTP：用Swift语言实现的HTTP网络库。 SQLite.swift：SQLite.swift是一个将SQLite3封装成Swift语言的包装库。 Slidden: Slidden是一个老外开源的开发自定义键盘的库，利用这个开源库，可以方便的配置键位、颜色以及键位对应的图片。"},{"title":"美国，你又耍流氓了！","date":"2020-03-08T11:35:52.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"archive/2020-03-08-americans-unfair-competition.html","permalink":"https://blog.devtang.com/archive/2020-03-08-americans-unfair-competition.html","excerpt":"","text":"新闻先说我前天看到的新闻（Bloomberg链接）： 美国以国家安全为由强制要求北京中长石基信息技术股份有限公司，在 120 天内将其在 StayNTouch 的股份完全转让。StayNTouch 是一家为美国酒店提供 SAAS 服务的软件公司。2018 年北京中长石基以全资收购美国移动端云 PMS 厂商 StayNTouch。现在美国政府要求中长石基转让股份强制退出。在收购前，石基从 16 年就开始投资 StayNTouch 公司。 石基信息是一家 A 股上市公司，我查到它的市值约 450 亿人民币，是中国的民营企业 500 强。它主要的业务是为酒店、餐饮、零售和休闲娱乐行业提供软件解决方案。 我看到这个新闻感觉特别生气，因为我又一次看到了美国的流氓行为。因为如果担心安全，美国完全可以要求 StayNTouch 提供私有化部署或者甚至退出美国市场，但是美国却选择了强行要求出售自己。这背后无非是想以极低的成本，把 StayNTouch 的客户，技术，服务全部获得。 你想想，石基公司从 16 年就投资，18 年收购 StayNTouch。这就是自己的亲生儿子啊！还不把自己关于酒店 SAAS 服务的从管理到渠道，从运营到技术方方面面的能力进行输入。现在孩子养大了，却被要求强行卖掉。 这卖掉的背后是什么？不光是客户，还包括企业核心数据，战略，运营方案，技术解决方案以及渠道。 我实在没有见过吃相这么难看的特朗普。 自从特朗普上台，我就见识到了美国的贸易保护主义的政策越来越强，并且美国为了达成自己的利益，会不择手段。这些不择手段包括以下这些。 如果规则不利，就退出规则美国加入了很多世界组织，随着组织的发展，如果出现与美国自己的利益冲突，美国就会退出这样的组织。这些年美国退出了： 跨太平洋战略经济伙伴关系协议（TPP） 《联合国巴黎气候协定》 联合国教科文组织 联合国人权理事会 伊朗核协议 其中退出伊朗核协议，就是为了全面打压伊朗经济而做的。 如果规则有利，就用来打压对手美国的法律和规则是管全世界的。 美国自己搞了一个《反海外腐败法》，这个法律是管全世界的，这就是说：即使你不是美国的公司，你开展的业务不在美国，只要你违反了这个法律，美国也可以把你抓到美国受审。 美国如果要制裁哪个国家，如果你和那个国家做生意，美国就可以把你抓起来审理。华为和中兴就是这样的例子。 美国当世界警察这件事情，似乎大家都已经默认接受了，但是这合理么？你想想： 如果一个穆斯林国家说，所有国家的人都不准吃猪肉，如果吃就抓起来。这合理么？ 如果法国的某个企业在澳大利亚做生意犯了法，法国和澳大利亚都没管，美国把这个企业的人抓起来了，你觉得合理么？这个企业就是法国的阿尔斯通公司。美国为什么干这个事情？因为阿尔斯通和美国的通用电气是竞争对手。这就是《美国陷阱》里面的故事，最终通用电气以极低的价格完成了对阿尔斯通的收购。 这样的故事，还在华为身上上演。 如果找不到规则，就用国家安全国家安全真是一个万金油规则，你说一个国家的衣食住行，哪一个不能上升到「国家安全」的高度？用一句国家安全，就可以打压非美国的资本和企业。 就在前天，美国强制让中国上市公司石基在 120 天内出售自己旗下的 StayNTouch 公司，理由就是「国家安全」。 中国也有涉及国家安全的担心，我们看看中国是怎么做的呢？苹果手机的 iCloud 服务可能收集到全国人民的数据，于是我们让苹果将数据保存在中国，并由一家叫 “云上贵州” 的公司存储。这不就解决了？ 对于 StayNTouch 存储的酒店数据，美国可以有无数种方式来更合理的解决，比如： 要求 StayNTouch 将数据存储在第三方有监管的公司。类似于苹果的 iCloud 服务。 提供独立部署运营方案。类似于私有化部署的网盘服务、文档协作服务。 要求第三方审计公司来审计数据安全性。 如果万一泄漏用户隐私，采取巨额的罚款。 最差最差，美国可以强制要求酒店不能使用 StayNTouch 提供的服务，就像强迫很多国家不使用华为的 5G 技术一样。但是美国选择了强制收购！ 美国代表正义么为什么美国的法律和规则就可以管全世界，别的国家的法律和规则只能管自己呢？我想到了一种情况，就是美国的法律代表着公平，代表着正义，代表着世界人民的利益。那么，美国代表正义么? 美国代表正义么? 沙特是美国的好朋友，18 年，沙特记者卡舒吉在沙特领事馆被肢解。我不知道哪个国家的领事馆能够做到一个活生生的人被肢解，自己领事馆的人还不知情。事情很明显，卡舒吉是被沙特政府暗杀的。 结果特朗普说： “很有可能王储事先知道这起悲剧事件——也许他知道，也许他不知道！” “我们可能永远也无法知道关于贾迈勒·卡舒吉被谋杀的全部事实，” “无论如何，我们的关系是和沙特阿拉伯王国的关系。” 你看，在国家利益面前，特朗普能够接受一个无辜的人被通过肢解的方式夺去性命，也愿意和这种暴权政府继续维持友好关系。 美国代表正义么? 2020 年一月，美国通过无人机暗杀了伊朗将军，政权二号人物苏莱曼尼。一个世界大国的政权高官，被通过暗杀的方式夺去生命，这是一种正义的行为？ 试想一下，我们国家如果对某一个国家元首不满，能不能也直接派个特务把对方元首暗杀了？ 事后从美国的反应来看，这似乎是他意料之外的事情，但是美国也没有道歉，只是希望对方如果要报复，希望报复是对等的。 结语我们中国讲一句大国担当，美国作为世界上毫无争议的最强大的经济体，当前是毫无大国担当的，一切都只是为了自己的利益。 各个国家维护自己的利益，其实也无可厚非，但是也得建立在最基本的公平，公正的基础上吧。但美国为了自己的利益，可以做任何事情。这些事情： 有一些事情是有违公平的，例如针对华为和阿尔斯通的打压； 有一些事情是有违道义的，比如在暗杀卡舒吉事情上，维护沙特的利益； 有一些事情是恐怖组织才做的，比如暗杀苏莱曼尼。 我希望本文能够让那些鼓吹美国自由民主的朋友们认清现实，国际间的竞争很残酷，中国要和平崛起得面对美国的各种打压。 参考资料 https://www.bbc.com/zhongwen/simp/world-45941844 https://zhuanlan.zhihu.com/p/47449091 https://www.bloomberg.com/news/articles/2020-03-06/trump-blocks-chinese-deal-for-hotel-management-software-company https://www.shijigroup.com/china-press-news/125 https://cn.nytimes.com/usa/20181121/trump-saudi-khashoggi/ http://www.xinhuanet.com/world/2019-05/27/c_1124547080.htm http://pdf.dfcfw.com/pdf/H3_AP201801301083886634_1.pdf"},{"title":"iOS 移动开发周报 - 第 48 期","date":"2016-11-01T15:26:06.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"archive/2016-11-01-ios-weekly-48.html","permalink":"https://blog.devtang.com/archive/2016-11-01-ios-weekly-48.html","excerpt":"","text":"新闻CocoaPods由于众所周知的原因，国内并不能访问到官方的 Ruby 源，所以大部分朋友可能都是使用的国内的镜像源。而这里面，使用的最多的，可能就是淘宝提供的镜像源了。不过最近淘宝的镜像源 ruby.taobao.org 停止更新了，所以使用 CocoaPods 的同学，请更新到 ruby china 的源。详细的内容，请参见：https://ruby-china.org/topics/29250。 另一方面 , CocoaPods 最近也升级到了 1.1.0 版本，主要是增加了对 Xcode 8 的支持。 苹果发布会苹果在不久前发布了新款 MacBook Pro，库克对 Vim 党痛下杀手，取消了 ESC 键。另外增加了酷炫的 Touch Bar。有小伙伴已经尝试了 Touch Bar 对外的编程接口，说是和 「watchOS 很像」。一向前位的苹果也取消了包括 USB 在内的众多接口，只保留了 Thunderbolt 3 接口。 Swift Server Api苹果在 Swift 官方网站上新建了一个基于 Swift 的 API 项目，该项目用于支持将 Swift 用于服务器端开发的基础设施的构建。 UniBeastUniBeast 是一个能够将 macOS Sierra 安装到任何基于 Intel CPU 的电脑上。 文章 《iOS 安装包瘦身指南》： 本文介绍了包括资源优化，编译选项优化，可执行文件优化等 IPA 文件的瘦身方法。 《Xcode8调试黑科技：Memory Graph实战解决闭包引用循环问题》：Xcode8 的调试技能又增加了一个黑科技：Memory Graph。简单的说就是可以在运行时将内存中的对象生成一张图，这样检查循环引用问题将更加方便。 有趣本周趣图，是苹果公司在 2008 年生产的一款黑色 MacBook，看久了银白色的 MacBook 的你，是否感到耳目一新？"},{"title":"码农们，你一小时值多少钱？","date":"2018-03-25T14:37:57.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"archive/2018-03-25-job-choices.html","permalink":"https://blog.devtang.com/archive/2018-03-25-job-choices.html","excerpt":"","text":"每小时回报最近春季招聘旺季，我所在的猿辅导公司也在招人，遇到了不少优秀的候选人。在和候选人沟通的过程中，我发现了一个问题，候选人极度看重工资的绝对数量，但是不看重每小时的工资回报。 举个简单的例子，我们公司整体的工作作息时间都是比较克制的，通常情况下是早上 10 点到晚上 7 点，周末不加班，除去中午吃饭和午休的时间，就是标准的每天 8 小时，工作 5 天。 但是很多公司，或者 HR 明说，或者其实可以打听到，工作时间有的是早上 10 点到晚上 9 点，有些是早上 10 点到晚上 10 点，算下来比我们每天会多 2~3 小时的工作时间。 多 23 小时，其实是每天多了 2537% 的工作时间。所以，假设我们开一个 20w 的年薪，有每天加班的公司开一个 25w 的年薪，二者的工资每小时回报是一样的。但是，几乎所有人都会选择加班。 程序员这个行业，真的就像我们俗话说的「码农」那样，一小时一小时出卖自己的时间，希望趁自己还年轻，加得起班，榨干自己的每一个小时，尽可能多挣一点钱。 这种行为决策方式，一方面可能受到了北京生活压力大的影响，毕竟大家都想多挣一点钱。另一方面，其实也反应出这个群体在焦虑下的无规划。 也就是说，或许很多人认为：即使我每天多出来这几个小时，我可能也不知道该如何花掉。即：大家不知道应该如何利用工作之外的时间成长，如何使自己变牛逼。 关注成长说起成长，我们大部分人最关注自己成长的时候，都是在学校读书的时候。那个时候大家每天的「工作」就是学习，每年花费了大量的精力和金钱在学习上。但是毕业工作之后，很多人却进入了另一个极端，几乎不花一分钟投资自己，几乎不花一点精力额外学习。 其实一个人进入职场后，他的学习和成长才刚刚进入下半场。学校里面教的知识实在是太脱节了，只有真正进入企业，你才知道哪些知识是有用的。这个时候如果不学习，那么真的只能是一辈子做码农了。哦，不，只能年轻的时候做码农了，因为你老了之后就加不动班了。 如果你能关注自己的成长，那么你就会意识到，每天工作完了，还能有额外的几个小时自由安排是多么的美好。因为你可以好好的想想自己在工作上哪些地方还需要提高和积累，进而把这些时间利用起来。 人本身就像一个企业一样，你需要不停地投资自己，才能让自己每小时产生的价值越来越大。否则，你的工资就只能随着年龄的增大而线性增长，等到 40 岁到达顶峰以后，又只能随着年龄的增大而线性减少。 我的故事说说我的故事吧。 我之前做 iOS 开发，白天上班完成公司的需求，晚上就自己研究一些技术细节，写一些总结的博客。每年的 WWDC 视频，我都坚持看完并且写一些总结笔记。我还用 RSS 订阅了很多 iOS 国内外的博客，平时和周末没事就翻来学习。 创业的时候，我甚至在工作之余，完成了一本《iOS 开发进阶》图书的编写。这就是我投资自己的方式。 另外，我的这些学习和提高其实都和工作高度相关，这些学习使得我在完成公司的 iOS 工作的时候也更加高效了。 后来，我负责小猿搜题的产品技术。我又开始学管理、产品、设计相关的知识。我看德鲁克的书，看格兰德威尔的书，看产品相关的书。最终这些都使得我在管理团队上成长得更加快速。 上班时间说回上班时间。我现在上班差不多每天在公司待 12 个小时。我早上不到 10 点到公司，晚上常常接近 10 点才离开。是公司让我这么做的吗？其实不是。 晚上大家都下班了，我会自己翻翻书，或者写写总结，想想业务。因为我已经不在乎工作时长了，我看重的是个人成长。我认为工作的内容本身就是一个巨大的挑战，所以其实工作时长也没那么重要了，因为我在意的是工作本身带来的成长。 我身边也有一些朋友，周末会自己主动来公司，其实也是这个道理。他们已经早已不在意工作的每小时回报了，他们在意的是工作本身的意义。 但是关键在于，这些加班都是自愿的，都是因为工作本身的乐趣和成长带来的。如果一个公司强制加班，很难保证工作本身一定就是有成长的。 结语我有时候在想，候选人在找工作的时候，应该有两个目的：一个是财务上的回报，即工资收入。另一个是个人成长，即未来自己能多挣多少钱。 我们除了提供不错的薪资外，其实也提供了不错的个人成长机会，比如快速增长的业务、每周例行的技术分享，细心指导的 Mentor，以及留给大家学习充电的充足时间。 但是，似乎对于大部分人来说，只要钱给得多，什么都可以没有，这让我有时候又很失望。 各位读者，假如别的都一样，一边是年薪 30 万的不加班工作，一边是年薪 35 万的加班的工作，你会如何选择？ 如果是我，我会选择那 30 万的工作，然后利用自由时间努力让自己的未来能力值 60 万。而不是选择 35 万的工作，把自己的能力成长机会完全交给工作。 One more thing ~其实我们公司虽然不加班，但是给的薪资待遇远超 BAT一类的公司。如果你毕业于 985&#x2F;211 学校，或者在估值 10 亿美金以上的公司工作过，欢迎勾搭我们的 HR：&#x77;&#97;&#110;&#x67;&#x68;&#120;&#x40;&#x66;&#x65;&#110;&#98;&#x69;&#x2e;&#x63;&#111;&#x6d; 。 985&#x2F;211 学校的实习生岗位同样开放，研发实习生提供高达 500 一天的实习薪资！ 这里也有我们的职位介绍：http://hr.yuanfudao.com/ ，不看也无所谓，你所知道的岗位我们都招 ~"},{"title":"mac 下的 top 命令","date":"2011-12-27T05:30:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"archive/2011-12-27-mac-top.html","permalink":"https://blog.devtang.com/archive/2011-12-27-mac-top.html","excerpt":"","text":"以前只是在 linux 机器上使用 top 命令。常用的快键键是: p 键 - 按 cpu 使用率排序 m 键 - 按内存使用量排序 这 2 个快捷键在 mac 上都不一样。对应的是，先输入 o，然后输入 cpu 则按 cpu 使用量排序，输入 rsize 则按内存使用量排序。 如果记不清了，可以在 top 的界面上按 ?，在弹出的帮助界面中即可看到。"},{"title":"使用Privoxy做智能代理切换","date":"2012-12-08T08:47:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"archive/2012-12-08-use-privoxy.html","permalink":"https://blog.devtang.com/archive/2012-12-08-use-privoxy.html","excerpt":"You take the blue pill, the story ends, you wake up in your bed, and believe whatever you want to believe. You take the red pill, you stay in Wonderland, and I show you just how deep the rabbit hole goes. – 《黑客帝国》 如果你不知道什么是“墙”，那么应该祝福你继续活在美丽的Matrix里。但如果你选择服用红色药丸，那么在享受了墙外的信息流畅之后，你就再也无法忍受墙内的世界了。","text":"You take the blue pill, the story ends, you wake up in your bed, and believe whatever you want to believe. You take the red pill, you stay in Wonderland, and I show you just how deep the rabbit hole goes. – 《黑客帝国》 如果你不知道什么是“墙”，那么应该祝福你继续活在美丽的Matrix里。但如果你选择服用红色药丸，那么在享受了墙外的信息流畅之后，你就再也无法忍受墙内的世界了。 GoAgentGoAgent是一个基于Google App Engine的翻墙工具。关于GoAgent的安装教程，网络上已经有很多了，大家可以随便搜索一下就可以找到，当然，记得用google搜索。 SwitchySharp拿GoAgent直接作代理服务器地址不太合适，因为如果全部走代理的话，国内的访问太慢了，所以我们需要给Chrome浏览器配置SwitchySharp插件，SwitchySharp插件加上自动更新的“墙”List（地址见下图），我们就可以在浏览器中享受无墙的世界了。 Privoxy因为虽然SwitchySharp搞定了访问网页时的代理智能切换，但是我们在使用诸如Dropbox, twitter客户端等软件时，还是无法智能切换到代理。而使用Privoxy就能解决这个问题。 Privoxy是一个智能代理切换软件，它的使用必须基于GoAgent或其它已部署好的代理服务。下面介绍如何安装和配置privoxy。 安装使用brew就可以一键安装： brew install privoxy 自动启动设置好自动启动后，我们就不用管它了。方法如下： 切换到&#x2F;Library&#x2F;LaunchAgents目录，用sudo vim新建一个名为local.privoxy.plist的文件，文件内容如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;local.arcueid.privoxy&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/sbin/privoxy&lt;/string&gt; &lt;string&gt;--no-daemon&lt;/string&gt; &lt;string&gt;/usr/local/etc/privoxy/config&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/usr/local/Cellar/privoxy/3.0.19/sbin/privoxy.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/usr/local/Cellar/privoxy/3.0.19/sbin/privoxy.log&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 编辑完成后，执行如下命令，就可以把privoxy设置成开机自动启动了： sudo launchctl load /Library/LaunchAgents/local.privoxy.plist 可以用如下2条命令验证privoxy已经启动了。一是用ps查看是否有privoxy进程，二是查看privoxy默认监听的8118端口是否已经打开。如下所示： [tangqiao LaunchAgents]$ps aux | grep privoxytangqiao 25641 0.3 0.0 2436516 492 s001 U+ 5:31下午 0:00.00 grep --color=auto privoxyroot 17984 0.0 0.2 2477764 17452 ?? Ss 10:13上午 0:50.28 /usr/local/Cellar/privoxy/3.0.19/sbin/privoxy --no-daemon /usr/local/etc/privoxy/config[tangqiao LaunchAgents]$netstat -an | grep 8118tcp4 0 0 127.0.0.1.8118 *.* LISTEN 配置我们需要配置Provixy才能使用它。配置步骤如下： 一. 用vim打开privoxy的配置文件：vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;config在最后增加如下内容： actionsfile wall.action 二. 在&#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;目录下新建一个名为 wall.action的文件，然后在上面添加如下内容： &#123;+forward-override&#123;forward 0.0.0.0:8087&#125;&#125;.google.com.hk.facebook.com.google.com.fbcdn.net.gstatic.com.gmail.com.twitter.com.youtube.com 该内容第一行表示接下来的内容会智能走端口为8087的代理，后面每行一个地址。你可以随时将你想增加的内容添加进去。该配置文件的官方详细说明文档在这里。 三. 打开mac的代理设置，将“Web代理”和”安全Web代理”都设置成127.0.0.1，端口为8118。如下图所示： Tips 如果你的GoAgent监听在8087端口，而Privoxy监听在8118端口，那么到这一步，你就可以让你的所有应用正常翻墙了。需要注意的是SwitchySharp默认会忽略系统代理直接连接网络，你可能需要选择它的“使用系统代理设置”这一项，如下所示： 用浏览器访问 config.privoxy.org，即可用Web界面管理自己的provixy配置文件。不过，事先需要在config文件中启用Web管理功能，方法是编辑&#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;config 文件，将enable-edit-actions的值设置为1即可。 访问 http://config.privoxy.org/show-url-info 可以查询某一个特定的URL是否会走代理服务。我们可以随时在这儿查询，结合上面的第2步，将一些URL Pattern加入到代理列表文件 wall.action 中, 我们就可以方便地管理Privoxy。 证书是个麻烦事儿，由于GoAgent的证书是自己生成的而不是权威机构颁发的，所以需要把GoAgent的证书加到钥匙串访问的可信证书里面，如下图所示。另外GoAgent的默认带的证书因为是公开的，所以有潜在被中间人攻击的危险，所以更安全的做法是把默认的证书删掉再重启GoAgent，这样GoAgent就会重新另外生成一个证书了，再把这个新证书加到钥匙串访问中，会更安全一些。 参考文章 http://venmos.com/blog/2012/09/20/mac-autossh-privoxy/ http://y-zh.net/archives/77"},{"title":"在iOS中使用ZXing库","date":"2012-12-23T09:03:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"archive/2012-12-23-use-zxing-library.html","permalink":"https://blog.devtang.com/archive/2012-12-23-use-zxing-library.html","excerpt":"前言ZXing(Github镜像地址)是一个开源的条码生成和扫描库（开源协议为Apache2.0)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。 我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。","text":"前言ZXing(Github镜像地址)是一个开源的条码生成和扫描库（开源协议为Apache2.0)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。 我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。 集成步骤首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示： 接着我们继续裁剪，对于cpp这个目录，只保留cpp&#x2F;core&#x2F;src&#x2F;zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示： 接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。 下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖： a. AVFoundation b. AudioToolbox c. CoreVideo d. CoreMedia e. libiconv f. AddressBook g. AddressBookUI 完成之后如下图所示： 最后一步，在设置中增加如下2个header search path: .&#x2F;zxing&#x2F;iphone&#x2F;ZXingWidget&#x2F;Classes .&#x2F;zxing&#x2F;cpp&#x2F;core&#x2F;src 需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示： 恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。 二维码识别ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。 使用方法一ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖： #import &lt;ZXingWidgetController.h&gt;#import &lt;QRCodeReader.h&gt; 然后在需要扫描的时候，调用如下代码即可： - (IBAction)scanPressed:(id)sender &#123; ZXingWidgetController *widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO]; NSMutableSet *readers = [[NSMutableSet alloc ] init]; QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init]; [readers addObject:qrcodeReader]; [qrcodeReader release]; widController.readers = readers; [readers release]; [self presentModalViewController:widController animated:YES]; [widController release];&#125; 在ZXing扫描有结果时，会调用如下回调函数： @protocol ZXingDelegate- (void)zxingController:(ZXingWidgetController*)controller didScanResult:(NSString *)result;- (void)zxingControllerDidCancel:(ZXingWidgetController*)controller;@end 使用方法二方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。 使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下： #import &quot;Decoder.h&quot;#import &quot;TwoDDecoderResult.h&quot;#import &quot;QRCodeReader.h&quot;- (void)viewDidLoad &#123; // setup QR reader self.qrReader = [[NSMutableSet alloc ] init]; QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init]; [self.qrReader addObject:qrcodeReader]; self.scanningQR = NO; self.step = STEP_QR;&#125;// AVFoundation的回调函数- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; // 第一步，将sampleBuffer转成UIImage UIImage *image= [self getCaptureImage:sampleBuffer]; // 第二步，用Decoder识别图象 Decoder *d = [[Decoder alloc] init]; d.readers = self.qrReader; d.delegate = self; self.scanningQR = [d decodeImage:image] == YES ? NO : YES;&#125; ZXing的Decoder类提供了以下回调函数获得识别结果： @protocol DecoderDelegate&lt;NSObject&gt;@optional- (void)decoder:(Decoder *)decoder willDecodeImage:(UIImage *)image usingSubset:(UIImage *)subset;- (void)decoder:(Decoder *)decoder didDecodeImage:(UIImage *)image usingSubset:(UIImage *)subset withResult:(TwoDDecoderResult *)result &#123; NSLog(@&quot;result = %@&quot;, [result text]);&#125;- (void)decoder:(Decoder *)decoder failedToDecodeImage:(UIImage *)image usingSubset:(UIImage *)subset reason:(NSString *)reason;- (void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;@end Trouble Shoot &amp; Tips我在使用中遇到了一些问题，主要是编译的问题。 一个是找不到 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。 报错：Undefined symbols for architecture armv7s，解决方法：把ZXingWidget的一个build target参数：”Build Active Architecture Only” 修改成 “NO”. 报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。 如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：http://cli.im/ ZXing和OpenCV的兼容问题ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考这个贴子。 希望本文对大家有用，Have Fun~"},{"title":"粉笔网iPhone端使用的第三方开源库","date":"2012-10-09T07:30:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"archive/2012-10-09-3rd-libs-used-in-fenbi-app.html","permalink":"https://blog.devtang.com/archive/2012-10-09-3rd-libs-used-in-fenbi-app.html","excerpt":"前言最近有朋友问我粉笔网 iPhone 端使用了哪些第三方的开源库。我在这儿整理了一下，分享给大家。","text":"前言最近有朋友问我粉笔网 iPhone 端使用了哪些第三方的开源库。我在这儿整理了一下，分享给大家。 ASIHttpRequestASIHttpRequest 是一个被广泛使用的第三方网络访问开源库。用于提供更加友好的网络访问接口。相信很多搞 iOS 开发的朋友都用过它。ASIHttpRequest 的主要使用文档可以 参考这里。 另外，由于 ASIHTTPRequest 的作者已经公开说明不再维护这个开源项目，并且该项目已经一年多没有更新了，所以我一直在寻找替代的开源库。不过现在暂时还没有找到更好的。 RegexKitRegexKit 是一个正则表达式工具类。提供强大的正则表达式匹配和替换功能。我们主要使用它来对类似微博的正文替换工作。例如将 @ 某某 换成带链接的，将图片的 URL 换成 img 标签等。 同时，开源库 MGTemplateEngine 也依赖于此库。附上 RegexKit4.0 的官方文档教程。 MGTemplateEngineMGTemplateEngine 是一个模版引擎。我们主要使用它来生成单条微博页的内容。我们的单条微博页打算用 UIWebView 来显示，所以内容需要用模版渲染成 HTML 格式。MGTemplateEngine 的模版语言比较象：Smarty, FreeMarker 和 Django 的模版语言。 MGTemplateEngine 的作者官方博客在 这里。 我们在使用时，对此开源库的 Filter 类进行了修改，主要增加了 3 个自定义的 filter，用于提供我们的格式化时间，转义 html 和过滤空头象的用户的方式。 JSONKitJSONKit 是一个比较高效的 JSON 解析库。我之前比较过各大 JSON 解析库的性能（文章在此），JSONKit 算是非常不错的，大概的使用示例如下： #import &quot;JSONKit.h&quot;NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;json&quot;];NSData *content = [NSData dataWithContentsOfFile:path];NSDictionary *kitData = [content objectFromJSONData];NSString *kitString = [kitData JSONString]; GTMNSStringGTMNSString 主要用于转义 HTML 中的特殊字符。以防止 XSS 攻击。 FMDBFMDB 是一个 sqlite 数据库封装类，需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。在使用上非常简单。如下是一个例子： NSString * docsdir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSString * dbpath = [docsdir stringByAppendingPathComponent:@&quot;user.sqlite&quot;];FMDatabase * db = [FMDatabase databaseWithPath:dbpath];[db open];FMResultSet * rs = [db executeQuery:@&quot;select * from People&quot;];while ([rs next]) &#123; NSLog(@&quot;%@ %@&quot;, [rs stringForColumn:@&quot;firstname&quot;], [rs stringForColumn:@&quot;lastname&quot;]);&#125;[db close]; BBCustomBackButtonViewControllerBBCustomBackButtonViewController 是用于在 ios4 上提供自定义的 NavigationBar 按钮的开源库。使用上异常简单，只需要让自己的 ViewController 继承它就可以了。 我对 BBCustomBackButtonViewController 进行了修改，主要是改动它的自定义的按钮的样式，使其和我们的风格一致。 MTStatusBarOverlayMTStatusBarOverlay 是一个在 iphone 的顶部 status bar 显示消息的开源库。示例代码如下： + (void)showCompletedTextOnStatusBar:(NSString *)text &#123; NSString * message = [NSString stringWithFormat:@&quot;%@ 成功 &quot;, text]; MTStatusBarOverlay *overlay = [MTStatusBarOverlay sharedInstance]; overlay.animation = MTStatusBarOverlayAnimationFallDown; overlay.detailViewMode = MTDetailViewModeHistory; [overlay postImmediateFinishMessage:message duration:2.0 animated:YES]; overlay.progress = 1.0;&#125; 但是 stackoverflow 上说，有项目因为这个审核被拒，但是新浪微博明显采用了此 UI 方案，所以我们还是大胆用了这个库。后来，我们也顺利通过了审核。 MBProgressHUDMBProgressHUD 是一个用于显示灰色的加载进度或结果的类。与系统自带的 UIAlertView 相比，MBProgressHUD 由于背影是黑色的，所以视觉上不是那么强烈。我们主要用它来显示一些加载中的提示，以及一些自已会消失的操作结果（例如网络失败等）。 NSStringWrapper因为自己有多年 Java 开发的经历，我还是不太习惯 Objective-C 连基本的字符串操作都要查文档，而我自己又记不住老长的方法名，所以我把 Objective-C 的字符串基本操作都封装成了 Java 风格的方法调用。这部分是很早前拿周末时间在家里写的，所以是开源的，源代码地址。 EGOTableViewPullRefreshEGOTableViewPullRefresh 一个开源的下拉刷新组件。我对它进行了改进，增加了强制刷新功能。 LoadMoreTableFooterViewLoadMoreTableFooterView 一个开源的上拉加载更多的组件。我做了少量修改，以便让它支持 iPhone5 的分辨率。 zepto.jszepto 是一个类似 JQuery 的 javascript 开源库，用于实现 css 选择器和一些 dom 操作。它的 api 几乎和 JQuery 完全一样，优点是体积小巧。 ejsejs 一个 js 端的模版库。我们主要用于渲染一些 UIWebview 中异步加载的内容。例如笔记的评论，问题的答案。 总结希望上面的开源库能对你有用。最后分享一张粉笔网全站用到的所有开源项目的图片。"},{"title":"使用Crashlytics来保存应用崩溃信息","date":"2013-07-24T12:56:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"archive/2013-07-13-use-crashlytics.html","permalink":"https://blog.devtang.com/archive/2013-07-13-use-crashlytics.html","excerpt":"本文首发于 InfoQ，版权归 InfoQ 所有，转载请保留 原文链接。 简介Crashlytic 成立于 2011 年，是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。Crashlytics 的使用者包括：支付工具 Paypal, 点评应用 Yelp, 照片分享应用 Path, 团购应用 GroupOn 等移动应用。 2013 年 1 月，Crashlytics被 Twitter 收购，成为又一个成功的创业产品。被收购之后，由于没有了创业公司的不稳定因素，我们更有理由使用它来分析应用崩溃信息。","text":"本文首发于 InfoQ，版权归 InfoQ 所有，转载请保留 原文链接。 简介Crashlytic 成立于 2011 年，是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。Crashlytics 的使用者包括：支付工具 Paypal, 点评应用 Yelp, 照片分享应用 Path, 团购应用 GroupOn 等移动应用。 2013 年 1 月，Crashlytics被 Twitter 收购，成为又一个成功的创业产品。被收购之后，由于没有了创业公司的不稳定因素，我们更有理由使用它来分析应用崩溃信息。 使用 Crashlytics 的好处有： 1、Crashlytics 不会漏掉任何应用崩溃信息。拿我的应用举例来说，在 iTunes Connect 的后台查看不到任何崩溃信息。但是用户确实会通过微博或者客服电话反馈应用崩溃的情况。而这些在 Crashlytics 中都可以统计到。如下截图分别显示了我的某应用在苹果 iTunes Connect 后台和 Crashlytics 中的差别： 2、Crashlytics 可以象 Bug 管理工具那样，管理这些崩溃日志。例如：Crashlytics 会根据每种类型的 Crash 的出现频率以及影响的用户量来自动设置优先级。对于每种类型的 Crash，Crashlytics 除了会像一般的工具提供 Call Stack 外，还会显示更多相关的有助于诊断的信息例如设备是否越狱，当时的内存量，当时的 iOS 版本等。对于修复掉的 Crash 日志，可以在 Crashlytics 的后台将其关掉。下图所示的是一个我的早期应用的崩溃记录，在我修复后，我将其更新为已修复状态。 3、Crashlytics 可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。 下面我就给大家介绍如何使用 Crashlytics。 使用介绍申请帐号Crashlytics 的服务是免费提供的，但是并不能直接注册使用，需要先申请，打开 Crashlytic 的官网 ，输入自己的邮箱申请使用。如下图所示： 提交完邮箱之后，你的申请会放在 Crashlytics 的申请队列中，网页跳转到如下界面。在这个界面的右侧，你可以提供更多有效信息来让 Crashlytics 优先处理你的申请，建议大家都填上更多自己的信息。 如果顺利，通常 1-2 天左右，你就会收到 Crashlytics 发来的申请通过邮件，如下图所示，通过邮件链接跳转到注册界面，填写密码即可完成注册。 设置工程在使用 Crashlytics 前需要对原有的 XCode 工程进行配置，在这一点上，Crashlytics 做得比其它任何我见过的 SDK 提供商都体贴。因为 Crashlytics 专门做了一个 Mac 端的 App 来帮助你进行配置，所以，在配置前你先需要去 这里 下载该应用。 应用下载后，运行该应用并登录帐号。然后选择应用中的 “New App” 按钮，然后选择自己要增加 Crashlytics 的工程，然后 Crashlytics 的应用会提示你为工程增加一个 Run Script，如果你不知道如何添加，这里有一个 帮助的文档。添加好之后的工程截图如下所示 接着，Crashlytics 的本地应用会提示你将 Crashlytics 相关的 framework 拖到工程中。如下所示： 按照提示做完之后，就到了最后一步了，在AppDelegate的didFinishLaunchingWithOptions方法中加入如下代码： #import &lt;Crashlytics/Crashlytics.h&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [Crashlytics startWithAPIKey:@&quot;your identify code&quot;];&#125; 之后，运行一下程序，Crashlytics 就会检测到你设置成功。如果你感兴趣，可以自己手工触发一个崩溃记录，看 Crashlytics 能否帮你收集到。使用如下代码即可 [[Crashlytics sharedInstance] crash]; 如果你想测试一个 Exception 导致的崩溃，可以使用如下代码： [NSObject doesNotRecognizeSelector];[arrayWithOnlyTwoElements objectAtIndex:3]; 应用对外发布后，就可以在 Crashlytics 后台查看和修改相关的记录。另外，Crashlytics 还支持将数据导入到其它项目管理工具（例如 Redmine 或 Jira）如下所示，配置都非常简单。 实现原理和使用体会实现原理在原理上，Crashlytics 的通过以下 2 步完成崩溃日志的上传和分析： 提供应用 SDK，你需要在应用启动时调用其 SDK 来设置你的应用。SDK 会集成到你的应用中，完成 Crash 信息的收集和上传。 修改工程的编译配置，加入一段代码，在你每次工程编译完成后，上传该工程对应的 dSYM 文件。研究过手工分析 Crash 日志的同学应该知道，只有通过该文件，才能将 Crash 日志还原成可读的 Call Stack 信息。 使用体会为了更加方便开发者设置相应的工程，Crashlytics 提供了 mac 端的应用程序，帮助你检测相关工程是否正确设置并且提供相应的帮助信息。后来我还发现，该程序还会自动帮你升级 Crashlytics 的 SDK 文件。虽然这一点很体贴，但是我个人觉得还是不太友好。因为毕竟修改 SDK 会影响应用编译后的内部逻辑，在没有任何通知的情况下升级，我都无法确定 Crashlytics 有没有干坏事。不过国外的服务，特别是象 Twitter 这种相对较大知名度公司提供的服务要有节操得多，所以在这一点上我还是比较放心的。 使用 Crashlytics 可以让你摆脱管理应用崩溃记录的烦恼。并且帮助你找出应用的一些重大隐藏性 Bug。例如我之前写的一个应用就过一个缓存过期的问题，只有当缓存过期时才会触发这个 Bug，这样的问题在测试人员那边很难触发，因为他们不可能了解你的应用内部实现细节。通过 Crashlytics，使我清楚了解到应用 Crash 的数量和位置，结合自己的开发经验，就很容易找到问题所在了。 值得一提的是，Crashlytics 本身的 官方文档 也非常健全，如果你在使用中遇到任何问题，也可以上去查看详细的文档。 愿 Crashlytics 能让大家的应用都更加健壮～"},{"title":"iOS5中UIViewController的新方法","date":"2012-02-06T13:19:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"archive/2012-02-06-new-methods-in-uiviewcontroller-of-ios5.html","permalink":"https://blog.devtang.com/archive/2012-02-06-new-methods-in-uiviewcontroller-of-ios5.html","excerpt":"前言在苹果的 WWDC2011 大会视频的《Session 101 - What’s New in Cocoa》 和《Session 102 - Implementing UIViewController Containment》 中介绍了苹果在 iOS5 中给 UIViewController 新增加的 5 方法以及一个属性: // 方法addChildViewController: removeFromParentViewController:transitionFromViewController:toViewController:duration:options:animations:completion: willMoveToParentViewController: didMoveToParentViewController:// 属性@property(nonatomic,readonly) NSArray *childViewControllers","text":"前言在苹果的 WWDC2011 大会视频的《Session 101 - What’s New in Cocoa》 和《Session 102 - Implementing UIViewController Containment》 中介绍了苹果在 iOS5 中给 UIViewController 新增加的 5 方法以及一个属性: // 方法addChildViewController: removeFromParentViewController:transitionFromViewController:toViewController:duration:options:animations:completion: willMoveToParentViewController: didMoveToParentViewController:// 属性@property(nonatomic,readonly) NSArray *childViewControllers 原来的问题这些新增的方法和属性用于改进我们的编程方式。那么让我们先看看以前的对于 UIViewController 的使用有什么潜在的问题，认清问题，我们才能理解苹果改变的意义。 在以前，一个 UIViewController 的 View 可能有很多小的子 view。这些子 view 很多时候被盖在最后，我们在最外层 ViewController 的 viewDidLoad 方法中，用 addSubview 增加了大量的子 view。这些子 view 大多数不会一直处于界面上，只是在某些情况下才会出现，例如登陆失败的提示 view，上传附件成功的提示 view，网络失败的提示 view 等。但是虽然这些 view 很少出现，但是我们却常常一直把它们放在内存中。另外，当收到内存警告时，我们只能自己手工把这些 view 从 super view 中去掉。 改变苹果新的 API 增加了 addChildViewController 方法，并且希望我们在使用 addSubview 时，同时调用 [self addChildViewController:child] 方法将 sub view 对应的 viewController 也加到当前 ViewController 的管理中。对于那些当前暂时不需要显示的 subview，只通过 addChildViewController 把 subViewController 加进去。需要显示时再调用 transitionFromViewController:toViewController:duration:options:animations:completion 方法。 另外，当收到系统的 Memory Warning 的时候，系统也会自动把当前没有显示的 subview unload 掉，以节省内存。 参考资料关于这个，这儿 有一篇不错的文章介绍了一段 sample 代码用于演示新 API 的使用 . 我也将其代码稍加修改，增加了 view load, unload, appear, disappear 的事件 Log，以及收到 Memory Warning 时的 Log。代码放在了 github 上，地址是 这里，感兴趣的同学可以自己下载下来看看源码。 可以看到，这些 view 在没有使用时，是不会被 load 的，并且当有 Memory Warning 时，当前没有显示的 view 自动被 unload 掉了。所以新的方法确实能有效地节省内存，也能方便地处理内存不足时的资源回收。运行 Log 如下： [7397:f803] -[FirstViewController willMoveToParentViewController:][7397:f803] -[SecondViewController willMoveToParentViewController:][7397:f803] -[ThirdViewController willMoveToParentViewController:][7397:f803] -[ThirdViewController viewDidLoad][7397:f803] -[ThirdViewController viewWillAppear:][7397:f803] -[ThirdViewController viewDidAppear:][7397:f803] 生日提醒[7397:f803] -[SecondViewController viewDidLoad][7397:f803] -[ThirdViewController viewWillDisappear:][7397:f803] -[SecondViewController viewWillAppear:][7397:f803] -[SecondViewController viewDidAppear:][7397:f803] -[ThirdViewController viewDidDisappear:][7397:f803] 留言及回复[7397:f803] -[FirstViewController viewDidLoad][7397:f803] -[SecondViewController viewWillDisappear:][7397:f803] -[FirstViewController viewWillAppear:][7397:f803] -[FirstViewController viewDidAppear:][7397:f803] -[SecondViewController viewDidDisappear:][7397:f803] Received memory warning.[7397:f803] -[SecondViewController viewDidUnload][7397:f803] -[ThirdViewController viewDidUnload]"}],"posts":[{"title":"信息爆炸时代，付费信息才是最好的过滤器","slug":"pay-your-information","date":"2025-08-31T09:46:40.000Z","updated":"2025-08-31T10:35:37.501Z","comments":true,"path":"2025/08/31/pay-your-information/","permalink":"https://blog.devtang.com/2025/08/31/pay-your-information/","excerpt":"","text":"“免费的午餐往往是最贵的。为知识付费，是投资自己的认知能力，是这个时代每个人都应该认真考虑的选择。 序前几天刷抖音，看到一个财经博主在讲”普通人如何实现财富自由”，视频里充满了夸张的表情和煽动性的文案。视频末尾，他推荐了一个”0元理财训练营”，声称能教你”三个月内资产翻倍”。 我想起了自己订阅《财新》时的犹豫。为什么我们对免费的低质量内容习以为常，却对高质量的付费内容如此吝啬？ 这个信息爆炸的时代，我们真的需要为知识付费。 免费内容的陷阱质量之殇免费的内容最大的问题，就是它根本就不免费。 当我们在抖音上看到那些”三招教你理财”、”这样做就能年入百万”的短视频时，我们以为自己没有付出成本。但事实上，我们付出的是注意力，付出的是判断力，付出的是被误导的风险。 这些内容利用了人性中最原始的弱点：贪婪和猎奇。它们用夸张的标题吸引眼球，用简化的逻辑迎合认知懒惰，最终的目的不是传播知识，而是引流变现。 我记得罗振宇在《逻辑思维》中说过：”免费是世界上最昂贵的东西”。当时不理解，现在想想，免费内容的真实成本往往比付费内容更高，只是这个成本被巧妙地隐藏了。 注意力的谋杀短视频平台更可怕的地方在于，它们正在系统性地破坏我们的专注力。 抖音上的财经内容，往往用夸张的配音、快节奏的剪辑，以及故意制造的冲突感来抓取注意力。”震惊！这家公司竟然…”、”你绝对想不到的赚钱方式”，这样的文案充斥着整个平台。 长期消费这样的内容，就像吃快餐一样，看似填饱了肚子，实际上营养不良。我们的大脑习惯了这种高刺激、低思考的信息输入方式，逐渐失去了深度阅读和独立思考的能力。 更要命的是，算法推荐让我们陷入信息茧房。平台为了让用户停留更长时间，会推送用户喜欢的内容，而不是用户需要的内容。结果是，重要的时政新闻、深度的社会分析被娱乐化的内容所淹没。 广告的毒药隐藏的商业动机最近几年，我观察到一个现象：几乎所有的免费财经内容，最终都指向商业变现。 公众号上那些分析经济形势的文章，看似专业，细读之后会发现，作者往往会推荐某个理财产品或者某个投资平台。文章的逻辑链条是这样的：经济形势不好 → 需要理财 → 推荐我的产品。 抖音上更直接。那些所谓的”财经大V”，视频内容是免费的，但最终目标是让你扫码进群，然后推销各种理财课程、股票软件，甚至是可疑的投资项目。 这种商业模式本身没有问题，但它扭曲了内容的客观性。当内容创作者的收入来源是推广费而不是内容质量本身时，内容质量必然会让位于商业转化。 算法的偏见算法推荐进一步加剧了这个问题。 算法关心的是用户停留时间和点击率，而不是信息的准确性和重要性。一条耸人听闻的假新闻往往比一篇严谨的深度报道有更高的传播率。 结果是什么？真正重要的政治、经济、社会议题被娱乐化、碎片化的内容所遮蔽。当所有人都在关注某个网红的恋情时，有多少人知道最新的货币政策调整？当大家都在讨论某个段子时，有几个人了解正在发生的地缘政治变化？ 这不是危言耸听。信息质量的下降最终会影响整个社会的决策质量。 付费的价值面对这样的信息环境，我选择了用钱投票。 我的付费清单去年开始，我陆续为以下内容付费： 《财新》杂志：每年几百块钱，但能获得相对客观、深度的财经报道 财经类每日新闻：每天需要花 1 块钱，信息密度高，没有广告干扰 《三联生活周刊》：优质的长篇报道，帮我理解复杂的社会现象 小宇宙上的访谈节目：深度对话，远比短视频更有营养 请一些行业专家咨询，事后发微信红包感谢 付费内容的优势付费内容最大的优势在于，它的商业模式相对纯粹。 当我为《财新》的内容付费时，我就是《财新》的客户。《财新》需要对我的钱负责，需要提供有价值的内容来留住我。这种直接的商业关系，比那种”免费内容+广告变现”的模式要健康得多。 付费内容的第二个优势是质量控制。 以《三联生活周刊》为例，它的记者往往需要花费数月时间来调查一个选题，采访几十个相关人员，查阅大量资料，最终呈现出一篇万字长文。这样的内容制作成本很高，只有付费模式才能支撑这样的投入。 而免费的自媒体内容呢？往往是一个人坐在电脑前，花几个小时搜集网上的资料，拼凑出一篇文章。质量的差距是显而易见的。 一点反思诚然，付费内容也不是万能的。 《财新》有时也会有立场偏见，《三联》有时也会有不够深入的报道。付费不能保证内容的完美，但它至少能保证内容制作者的基本动机是提供有价值的信息，而不是引流变现。 另外，并不是所有人都有条件为信息付费。这涉及到信息公平的问题，也是整个社会需要思考的问题。 但至少对于有条件的人来说，为高质量内容付费，不仅是为了获得更好的信息，也是在用消费选择来支持优质内容的生产，推动整个信息生态的良性发展。 结语这是一个最好的时代，也是一个最坏的时代。 说它是最好的时代，是因为获取信息从来没有像现在这样便利。说它是最坏的时代，是因为信息质量从来没有像现在这样参差不齐。 在这样的环境下，为知识付费不是一种消费，而是一种投资。投资自己的认知能力，投资自己的判断力，投资自己的未来。 毕竟，在这个瞬息万变的时代里，唯一不变的就是变化本身。而应对变化的最好方式，就是保持持续学习的能力。 免费的午餐往往是最贵的。为知识付费，是这个时代每个人都应该认真考虑的选择。","categories":[],"tags":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/tags/summary/"}]},{"title":"GESP 202506 5级真题「奖品兑换」题解","slug":"gesp-level5-202506-1","date":"2025-07-01T14:29:46.000Z","updated":"2025-07-01T15:02:04.659Z","comments":true,"path":"2025/07/01/gesp-level5-202506-1/","permalink":"https://blog.devtang.com/2025/07/01/gesp-level5-202506-1/","excerpt":"","text":"题目描述 分析此题首先是不能暴力枚举的，因为 n 和 m 最大情况下是 10^9，这个数据规模，暴力枚举肯定会超时。 然后我们可能想到贪心，但实际可落地的贪心的策略总是有特殊情况。 最后，假如我们可以检查一个答案是否可行，我们就可以用二分答案+判定的方法求解。 二分还有一个要求，就是答案是单调递增的。我们可以想像，随着兑换券的递增，如果限定 n 的值不变，那 m 的值肯定是递增的。所以此题符合单调递增的条件。 解法那么，对于一个可能的答案 k，我们怎么检查答案是否可行呢？ 我们先把 n 和 m 排序，让 n 是较大者，a 和 b 排序，让 a 是较大者 对于一份奖品，可以是 n-a, m-b 来获得，也可以是 n-b, m-a 来获得，我们让 d=a-b 因为 a 是较大者，所以当更换兑换方式的时候，n 的值从n-a变成了n-b，相对来说，增加了 d，m 的值减少了 d 所以： 我们可以先用第一个兑换方法，把 k 个奖品换成 c1=a*k 张课堂优秀券, c2=b*k 张作业优秀券 如果 c1 &lt;=n, c2 &lt;= m 那这个答案 k 显然就是可以的。 但如果 c1 &gt; n，我们可以想到，把超额出来的兑换换成第二个兑换方法 具体如何换呢？ 我们先计算超额的值，为 c1-n 每次兑换可以让这个值少 d，所以需要换 r=(c1-n)/d (向上取整) 即 r=(c1-n+d-1)/d个 经过如上的兑换，c1 的值减少了 d*r，c2 的值增加了 d*r 最后需要注意，因为 a*k 的范围可能超过 int，所以需要把计算过程都用 long long 来保存。 总结此题考查了： 二分+判定的解法 向上取整的写法 数据范围的预估 时间复杂度的预估 这还是非常综合的一道题。对于没想到二分的学生，也可以用贪心或者暴力枚举骗到不少分（估计 10-15 分），所以此题也有相当的区分度，各种能力的学生都可以拿到部分分数。 详细代码12345678910111213141516171819202122232425262728293031323334353637383940/* * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;long long n, m, a, b, d, ans;bool test(long long k) &#123; long long c1 = a*k; long long c2 = b*k; if (c1 &gt; n) &#123; long long r = (c1 - n + d - 1) / d; c1 -= r*d; c2 += r*d; &#125; if (c1 &lt;= n &amp;&amp; c2 &lt;=m) return true; else return false;&#125;int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; if (n &lt; m) swap(n, m); if (a &lt; b) swap(a, b); d = a - b; long long l = 0; long long r = n; while (l &lt;= r) &#123; long long m = (l+r)/2; if (test(m)) &#123; ans = max(ans, m); l = m+1; &#125; else &#123; r = m-1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"构建你的“多巴胺”系统","slug":"build-your-own-dopamine-system","date":"2025-06-22T14:08:32.000Z","updated":"2025-07-12T15:28:54.885Z","comments":true,"path":"2025/06/22/build-your-own-dopamine-system/","permalink":"https://blog.devtang.com/2025/06/22/build-your-own-dopamine-system/","excerpt":"","text":"什么是“多巴胺”系统“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&#x2F;正向情绪的事情。之所以用这个隐喻，一方面是想让大家更容易理解、记忆和传播这个系统。 这个系统对我来说非常重要，它就相当于我人生的“第一性原理”一样。人类看起来是自己的主人，但人类对自身行为动机的理解很多时候并不清楚。 马斯洛把人类的需求按层次来分，在他的理论中提到的各种需求：性，安全，食物，社交，自我实现等等。但是其实，这些其实本质上，都是在为人类提供“多巴胺”。 当人类失去了“多巴胺”系统，很多时候就宁愿放弃生命：比如在战争中，很多人为了信仰而牺牲自己。这是因为他内心的目标大于活着的意义。 在实际生活中，虽然不至于放弃生命，但冒着生命危险做的事情，也不鲜见。比如消防队员救人、警察和歹徒搏斗、或者体育健儿在赛场上带伤为荣誉而战。 这些行为虽然有可能失去生命，但是换来的荣誉与成就是非常让人自豪的，可以为自己提供终身的多巴胺来源。 有人说，这个世界上只有两种生意：让人爽的生意和让人牛逼（学习、健身等）的生意。但我觉得，这都是多巴胺的生意，差别只是一个是提供短期多巴胺，一个是提供长期多巴胺。学习这种事情虽然短期很辛苦，但是收获的成就是可以提供长期的回报，从而提供长期的多巴胺。 为什么“多巴胺”系统很重要1、人对生活的意义有需求看看全世界有多少人信教就明白了。大部分人都需要精神上为生命的存在赋予意义。意义感会驱使人们面对挑战和困难、提供情绪支撑、获得幸福感。 在中国，很少有人信教，但是我们每一个普通人也有自己对生命的追求，哪怕是更好一点的生活，或者一个遥不可及的理想，又或者是简单地照顾好家人和孩子。 人生的目标带动着每一个人在各种重大决策的十字路口上做选择。韩寒为了赛车辍学；赵心童为了台球远赴英国；崔永远为了自由表达离开了央视；而我身边，一个亲人为了更好的照顾孩子而放弃了工作上的晋升机会。 “多巴胺”系统就是为人生的意义提供基础能量的仓库，守护好多巴胺系统，人生之路就会走得更加从容。 2、“多巴胺”系统不容易构建我们随便看看身边，就会发现无论是学习、工作，还是退休安排和日常生活。“多巴胺”系统的构建都是非常不容易的。 2.1 学习拿学习来说，如果将孩子的“多巴胺”系统和学校排名、升学挂钩，那么很多孩子是无法构建学习的“多巴胺”系统的。因为每个班几十个孩子，必然有排在后面 50% 的孩子。这些孩子从排名上是无法获得正向激励的。 另外，整个学习是一个不断淘汰对手的游戏。中考会淘汰 50% 的学生分流到中专，高考又会分流 50% 的人到职高，大学又会分流 90% 的学生到非重点大学。研究生考试又会分流 2&#x2F;3 的本科生，只剩下 1&#x2F;3。 按上面的通过率，就算你是全中国前 1% 的学生，那大概也会止步于 985&#x2F;211 的研究生入学考试。 所以，在学习上，你总会有一天会遇上身边的对手都比你强，你在这个小圈子里面排在后面，如果你和同学比的话，你能收获的只有负面的情绪，感觉自己像个废物。 后面我会提到如何构建学习的多巴胺系统。 2.2 工作也许你是一个优秀的员工，不断获得奖励和提拔，但是随着环境和年龄变化，工作中持续获得正反馈是困难的。原因如下： 第一个原因：正向激励的比例太低。只有前 20% 的员工才能获得超过其他人的回报，大部分人只能拿到普通的绩效和待遇。 第二个原因：很多工作的经验积累并不是线性的。在积累 3-5 年后，新增加的经验不足以带来相应比例产出提升，这就造成老员工工资过高，性价比不足。拿 iOS 开发来说，工作 10 年和工作 30 年的开发者的经验差异在大部分情况下表现得并不明显，这就可能造成某些工作 10 年以上的老员工薪资涨幅变慢。 第三个原因：人在 30 岁以后，体力和学习速度逐渐下降。我今年 41 岁，熬夜的能力明显变差。而我在 30 岁的时候，经常熬夜加班。工作中的一些内容如果需要的是堆时间才能完成，老员工的完成速度就不及年轻的员工。 第四个原因：岗位架构是金字塔形的。越往上需要的人越少，所以一个员工很容易最终就停在某一个岗位无法获得上升机会，背后的原因可能仅仅是因为上面已经有人了，不需要更多管理者。 2.3 退休退休是每个人必须面对的事情，如果不做好准备，“多巴胺”系统根本就不会自己产生。因为每个人退休后，日常生活的节奏就会有巨大变化。而人的时间是需要被填满的，否则就会因为意义感缺失而产生各种问题。 2.4 其它其它的部分还包括，生活、家庭、理财等等： 对于生活：兴趣能否持续，影响“多巴胺”系统的稳定。 对于家庭：如何处理夫妻关系，亲子关系，婆媳关系，都关系到多巴胺系统的稳定。 对于理财：如果你买在顶峰，不但需要很长时间回本，也会承受巨大的账面亏损压力，给自己的多巴胺系统带来巨大冲击 对于伤痛：个人对伤痛，特别是心理层面上的伤痛处理也很重要，心理上的伤痛如果处理不好，就像应激的小猫一样，会给身体带来严重的伤害。 如何构建“多巴胺”系统接下来，我就讲讲我对各种情况下构建“多巴胺”系统的心得。 1、对于学习对于学习，我们需要刻意设计“多巴胺时刻”。让原来可能没有的多巴胺变得有，让原来分泌得少的多巴胺，变得分泌多。具体来说，我们可以： 一、定期回顾，肯定自己的进步。我每年都会写年度总结，之前觉得每年没有什么变化，但是总结的时候，发现还是有挺多进步的，这样就让自己更有成就感。 二、设立奖励，自我颁奖。不管是小的学习还是大的学习，都可以设立奖励。我在做竞赛题的时候，之前做完我就继续做下一题。但后来我发现，如果我每次做对，都挥舞一下手臂小小庆祝一下，就会开心很多。所以，即便是很小的自我肯定，都可以让多巴胺给我们更多激励。 三、适当分享，获得亲朋鼓励。人是社会动物，自己的成就还是要适当分享出来。但是对自己友谊不深的朋友就没太有必要，有可能会造成人家妒忌，或者人家会认为你是一个喜欢炫耀的人，没必要。 四、构建无限游戏，不要设置终点和上限。学习无止境，如果我们可以一直设立目标，就可以无限玩下去。对于生命来说，能够无限玩的游戏不多，学习算是一个。 2、对于工作刚刚说过，随着环境和年龄变化，工作中持续获得正反馈是困难的。所以，对于工作，我们首先需要做的是降低预期。工作首先你是获得持续现金流的谋生手段；它如果能够给你持续的正向激励，当然很好，但是如果有一天，工作无法给你带来正反馈，那么你也可以就把它当作一份工作即可。 在工作上不要讲太多回报，公平。很多事情做了没有结果，但是公司付你钱了，所以你认真把事情做好，就很好，也很专业。 另外，在工作上，我们也需要尊重规律，做累进的事情。坚持在自己的专业领域积累经验，如果自己的年龄大了或者行业发展不好，也要接受工资不再上涨这些现实。 在工作上，我们还可以尝试杠铃策略，即：同时拥有两个不太相关的专业技能。通过在业余时间利用自己的爱好或者特长来发展副业，如果万一出现什么变动，自己的副业就可以成为主业，保证自己不至于失业。 3、对于退休退休是人一辈子重要的规划之一，也是人生活法的重大转换。 对于退休，最重要的事情就是让提前规划好兴趣，让兴趣填满自己的时间。否则，人生一下子多了那么多时间，很容易觉得无聊。 这个兴趣最好是无限挑战游戏。这样可以几十年也做不完。 这个兴趣也最好可以锻炼到身体（例如：广场舞、摄影、骑行之类）。 最后，退休还有一个很重要的事情：要管好自己的钱，不冒大的风险，不折腾高风险的投资。因为挣太多钱自己也不一定能花完，但是如果亏很多就会影响自己的退休生活。 4、日常生活日常生活中，有这些技巧可以带来更多的多巴胺： 一、主动给生活带来变化 我自己的经验是，主动做一些以前没做过的事情，会给生活带来新鲜感。比如： 我家每过几年就会尝试换个房子租，每次都有不同的体验。 每年出游几次，每次去不同的地方，让自己开眼界。 购物，看上什么东西就买买买。 庆祝。为自己的成绩庆祝，为朋友的成绩庆祝，为家人的成绩庆祝。 二、自立 不要太依赖别人，或者太依赖于某个工作，或者将自己放到一个困境，或者太陷入一个目标。这不是说我们应该不努力。对于生活，我们应该全情投入，把过程做好；但是对于结果，我们应该顺其自然。 三、终身学习 学习是少有的，可以持续给人带来获得感的事情。而且这个事情是没有终点的，属于一种“无限游戏”，这就让我们永远不会觉得无聊。 我最近因为兴趣又开始学习编程，遇到一个算法没看懂，我就慢慢想，可能想个一周，甚至两周，我感觉这才是一个学习的状态，就是慢慢的，不紧不慢的，学完一个再学下一个。 相对来说，学校的学习更像是一个工业化的人才产出器，每个人需要像机器一样在指定的时间学习完指定的内容，但是每个人的学习能力是不一样的，其实对每个人来说，匹配自己的学习速度才是最佳的学习方案。 四、关注过程，弱化结果 人生是一场体验，并非要留下什么，也留不下什么。 如果我们想想 100 年后谁能记得我们，我们会发现结论是：没有人。即使是自己的亲人，过了三代你可能也不会记得。大家可以想想，你知道你的爷爷的爷爷叫什么名字，长什么样，做过什么成绩吗？就算你记得，你的孩子以后会记得吗？ 所以，如果人生到最后不会有任何人记得我们，那么我们人生的意义是什么？我认为核心的意义就是人生本身。就像《活着》中写道：活着就是最大的意义。 对于人生这种重过程，无结果的“游戏”，我们活在当下，关注过程，把自己的人生过好，就是一个非常棒的事情了。别的更多的结果，我们做不到，也没有什么意义。 5、对于家庭对于家庭，最简单的获得多巴胺的方式是：低预期。比如： 对于家人，不要指望家人一定要为自己付出。家人能够不让你付出，就是超预期。有这样的心态，你每天都是超预期。 对于孩子也一样，低预期，不鸡娃。 孩子小的时候，我们只需要尽量培养孩子兴趣，兴趣是最大的老师，对于结果，则需要看孩子的天赋和运气，所以我们只能静待花开。 当孩子成年后，她会有自己的生活，作为父母也应该降低预期，孩子能活成什么样，最主要的还是靠孩子自己。 当我们老了后，也别指望孩子给自己养老，不啃老就不错了。有这样的低预期，也容易每天获得超预期的结果。 6、对于朋友我认为有三种朋友，可以给我们提供持续的多巴胺。 一种朋友是相互帮助、支持的人。显然你们相互会收获很多。 一种是可以给你提供指导的前辈，牛人。你可以收获到成长。 一种是你可以给别人提供指导的后辈。你可以收获到成就感。 那哪些是消耗你多巴胺的朋友呢？ 每次需要你的时候找你，但你需要他的时候总逃避的人。 和你话不投机，没有共同语言的人。 无法平等对话的人，有可能是对方太过强于你，懒得和你对话；也可能是对方太弱于你，你懒得和他对话。 让你感觉到有压力，但是除了消耗你多巴胺外，并不能给你带来任何其他好处的人。 你讨厌的人。 你嫉妒的人。 我有些时候，有点讨好型人格，就是不喜欢一个人，也不愿意和人家起冲突，很多时候碍于面子还是淡淡地交往。后来我发现这样不对，这完全是一种对多巴胺系统的伤害，想到这些我就主动断开了一些不喜欢的朋友的来往。其实有一些人是很优秀的，但是多巴胺系统为先的决策，让我还是会坚决断开联系。 7、对于伤痛小孩子如果反复盯着糖果看，最后就会忍不住吃掉糖果。如果有人伤害了你，你反复回忆这个伤害的过程，你就会受到更多的内心部分的伤害。 著名作家蔡澜最近去世了，别人问他，他的爱人离他而去了，他是如何克服下来的。蔡澜说：你如果老去想这件事情，你就会发疯，所以我尽量让自己不去想这件事情。 芒格和巴菲特的公司之前特别看好一个接班人，后来这个接班人做了一些违背公司原则的事情，在收购一家公司前，自己私下提前买了这家公司的股票，自己获利了几百万美元。事情暴露之后，这个接班人辞职了。别人问芒格怎么看这个事情。 面对欺骗与背叛，芒格说：永远不要责备自己，永远不要有受害者心态。当你产生这种心态的时候，只会让你自己难受，不会带来任何其它正面的影响，因此你不应该花时间去感受它，哪怕是一秒钟。所以，更应该的心态是应对这种情况，为未来的不确定性做好准备。 芒格最后总结道：“I am not a victim. I am a survivor.” 所以，站在建立“多巴胺”系统的角度，任何只有负面效果的情绪都是不值得去强化和感受的。如果你忍不住，你可以尽量不去想它。更好的办法是像芒格那样，有一个更加强大的幸存者视角来看待所有的坏运气、灾难、欺骗与背叛。让这些负面情绪不影响自己的多巴胺系统。 8、不内耗和自恰我后来发现，其他人讲的一些行事原则，在表达角度上虽然不一样，其实也是一样的道理。比如我们讲的“不内耗”原则。 内耗就是一种持续消耗“多巴胺”的心理行为。如果以构建“多巴胺”系统作为人生准则的话，我们会发现内耗没有任何效果。当我们面对不如意的时候，要么改变，要么适应，要么淡化，而内耗是一种既不改变，又不适应，又反复强化负反馈的行为。百害而无一利。 自恰的底层含义是：所有事情能够自圆其说，不矛盾，不冲突，自然也就不内耗了，不消耗多巴胺。 所以，人需要活得“自恰”，只有自恰才能睡好觉，持续获得多巴胺。 主观与客观“多巴胺”系统有主观的部分，也有客观的部分。 一、主观部分 “多巴胺”系统对于个人内心是一种主观行为和感受，而不是一种客观描述和标准。所以，对于芒格来说，一个重要朋友的背叛不是对“多巴胺”系统的冲击；但换一个人，可能觉得天塌了，一辈子再难信任他人。 因此，我们更应该调整的是自我的行事方式和思考问题的角度，而不是改变其他人。我们可以远离那些影响我们“多巴胺”系统的人和事，但是当坏运气到来的时候，我们只能接受。 二、客观部分 当然，“多巴胺”系统在指导我们行为的时候，是让我们客观上在做具体的行为选择。通过行为选择让我们尽可能构建有利于我们产生多巴胺的外界环境。比如我刚刚提到的：提前规划退休生活、选择终身学习、多搞庆祝活动等。这些有利的环境不但不会消耗我们主观意志来维护多巴胺，还会给我们提供愉悦，贡献多巴胺。 小结“多巴胺”系统是一种隐喻，是指能够给你带来持续正反馈&#x2F;正向情绪的事情。我们通过： 主观上，调整自己的思考和看待事情的方式 客观上，搭建好能够持续供养自己多巴胺的外部环境 利用“多巴胺”系统，让自己的人生少一点内耗，少一点纠结，多一点平静，多一点快乐。 愿每个读者都能过好当下的每一天，谢谢！","categories":[],"tags":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/tags/summary/"}]},{"title":"GESP 核心考点","slug":"gesp-notes","date":"2025-06-06T14:12:03.000Z","updated":"2025-08-24T16:18:09.982Z","comments":true,"path":"2025/06/06/gesp-notes/","permalink":"https://blog.devtang.com/2025/06/06/gesp-notes/","excerpt":"","text":"GESP 1 级大题核心考点1 级主要考查分支和循环结构，所以大题的解法一般都是一个 for 循环，然后循环里面用 if 之类的条件判断做一些事情，最后再输出结果。其代码框架为： 123// 循环结构, 例如 for ... // 判断条件// 输出结果 拿 GESP202309 一级题目：小明的幸运数 来说，其核心代码是： 12345678910// 循环for (int i = l; i &lt;= r; ++i) &#123; // 判断条件 if (isLucky(i)) &#123; // 累加 ans += i; &#125;&#125;// 输出结果cout &lt;&lt; ans &lt;&lt; endl; 另外一个例子，GESP202503 一级题目：四舍五入，核心代码： 1234567891011// 循环for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a; b = a%10; a = a/10; // 判断条件 if (b &lt;= 4) a = a*10; else a = a*10 + 10; // 输出结果 cout &lt;&lt; a &lt;&lt; endl;&#125; GESP 2 级大题核心考点考点一：双重循环GESP 2 级相对 1 级，对循环结构的考查进行了加强，一般需要用双层嵌套的循环才能完成大题。有一类双层嵌套循环需要特别关注，就是模拟输出类，这一类题过去考过多次，包括： GESP202309，小杨的 X 字矩阵 GESP202312，小杨的 H 字矩阵 GESP202403，小杨的日字矩阵 GESP202409，小杨的 N 字矩阵 GESP202503，等差矩阵 GESP202303，画三角形 样题，画正方形 以等差矩阵为例，其关键代码为嵌套的 for 循环，参考如下： 12345678910111213141516171819/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;int tu[55][55];int main() &#123; cin &gt;&gt; n &gt;&gt; m; // 嵌套的 for 循环 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; i*j &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 如果学生还是不熟悉，可以考虑如下更多的练习： 模仿 小杨的 X 字矩阵，输出 “又” 字，倒 “N” 字，“工” 字矩阵，“口”字矩阵 模仿 画三角形，输出 左对齐、右对齐的正三角形，倒三角形 模仿 等差矩阵，输出求和的矩阵，输出只有偶数的等差矩阵（奇数位填 *） 有一些时候，双重循环也不一定以输出图案的方式来进行考查，比如题目 B4356 202506 二级 数三角形 就是一个案例，参考代码如下： 12345678910111213141516171819/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; int ans = 0; cin &gt;&gt; n; for (int a = 1; a&lt;=n; ++a) &#123; for (int b = a; b&lt;=n; ++b) &#123; if (a*b%2 == 0) ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 更多的练习题目如下： https://www.luogu.com.cn/problem/B3994 https://www.luogu.com.cn/problem/B3995 https://www.luogu.com.cn/problem/B3986 https://www.luogu.com.cn/problem/B3988 考点二：常用函数2 级还会考一些我们经常会实现的函数。包括： 求素数函数参考题目：GESP202306 找素数 12345678bool isPrime(int a) &#123; for (int i = 2; i*i &lt;=a; i++) &#123; if (a%i == 0) &#123; return false; &#125; &#125; return true;&#125; 求闰年函数参考题目：GESP202503 时间跨越 关键代码： 1234bool isLeapYear(int year) &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);&#125; 把一个数的每一位数字拆分的写法参考题目：GESP202406 计数 关键代码： 12345678int count(int a, int k) &#123; int ret = 0; while (a) &#123; if (a%10 == k) ret++; a/=10; &#125; return ret;&#125; 练习题目： GESP202409 数位之和 含 k 个 3 的数 GESP 3 级选择、判断题核心考点 原码，返码，补码的表示 进制转换（二进制、八进制、十进制、十六进制） 位运算 字符串相关的操作 大题核心考点考点一：字符串操作3 级对字符串的操作要求非常高，需要考生灵活掌握字符串的变换、拼接、求子串、判断回文等操作。 求子串可以用 string 类的 substr(int pos, int len) 函数。需要注意该函数的两个参数分别是起始下标和长度。 其中，判断回文的写法如下： 123456789bool isReverse(string &amp;s) &#123; int len = s.length(); for (int i = 0; i &lt; len/2; ++i) &#123; if (s[i] != s[len-i-1]) &#123; return false; &#125; &#125; return true;&#125; 以真题 GESP202409 回文拼接 为例，考生需要对字符串进行切分，然后分别判断是否是回文串。 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n;string s;bool isReverse(string &amp;s) &#123; int len = s.length(); for (int i = 0; i &lt; len/2; ++i) &#123; if (s[i] != s[len-i-1]) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; bool ans = false; if (s.length() &gt;= 4) &#123; for (int i = 2; i &lt; s.length() - 1; i++) &#123; string s1 = s.substr(0, i); string s2 = s.substr(i); if (isReverse(s1) &amp;&amp; isReverse(s2)) &#123; ans = true; break; &#125; &#125; &#125; if (ans) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 该考点的相关真题： GESP202306 密码合规 GESP202403 字母求和 GESP202406 移位 GESP202412 打印数字 GESP202309 进制判断 其中 GESP202309 进制判断 看起来是考进制的规则，实际上也是考字符串的查找。参考代码如下： 123456789101112131415161718192021222324252627282930313233/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int isRange(string s, string range) &#123; for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s[i]; int j = 0; for (j=0; j&lt;range.length(); ++j) &#123; if (ch == range[j]) &#123; break; &#125; &#125; if (j == range.length()) return 0; &#125; return 1;&#125;int main() &#123; int n; string s; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; cout &lt;&lt; isRange(s, &quot;01&quot;) &lt;&lt; &quot; &quot; &lt;&lt; isRange(s, &quot;01234567&quot;) &lt;&lt; &quot; &quot; &lt;&lt; isRange(s, &quot;0123456789&quot;) &lt;&lt; &quot; &quot; &lt;&lt; isRange(s, &quot;0123456789ABCDEF&quot;) &lt;&lt; endl; &#125; return 0;&#125; 考点二：前缀和前缀和的计算技巧是：用一个累加变量来不停地更新前 N 个数的和，这样我们只需要用 O（N）的时间复杂度，就可以把所有的前缀和求出来。 参考题目：GESP202409 平衡序列 此题解法是：暴力测试，先计算出总和 tot ，然后看前缀和的两倍有没有可能等于 tot。 参考代码： 123456789101112131415161718192021222324252627282930/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, v[10010], tot;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; tot = 0; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v[i]; tot += v[i]; &#125; int cnt = 0; bool ans = false; for (int i = 0; i &lt; n &amp;&amp; cnt*2&lt;tot; ++i) &#123; cnt += v[i]; if (cnt*2 == tot) &#123; ans = true; &#125; &#125; if (ans) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 考点三：位运算考生需要熟悉二进制，以及数的位运算操作。 典型考题为：GESP202503 2025 此题的思路如下：因为 x 最大是 2025，而如果 y 需要影响 x 的运算，只能与 x 的 bit 位是 1 的位进行操作。所以 y 如果存在，则必定小于 2048。因为 2048 的二进制 1 的 bit 位已经超过 2025 的最高位了。所以直接枚举 1～2048 之间的答案即可。 参考代码： 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int ans = -1;int x;int main() &#123; cin &gt;&gt; x; for (int i = 1; i &lt; 2048; ++i) &#123; if ((x &amp; i) + (x | i) == 2025) &#123; ans = i; break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; GESP 4 级大题核心考点考点比较散，以下是历次考题的考点。 GESP-202306 幸运数：模拟 GESP-202309 进制转换：进制转换 GESP-202309 变长编码：位操作 GESP-202312 小杨的字典：字符串操作 GESP-202312 田忌赛马：排序，模拟 GESP-202403 相似字符串：字符串操作 GESP-202403 做题：贪心 GESP-202406 黑白方块：枚举 GESP-202406 宝箱：枚举，二分 GESP-202409 黑白方块：枚举 GESP-202409 区间排序：排序 GESP-202412 Recamán：枚举 GESP-202412 字符排序：排序 GESP-202503 荒地开垦：枚举 GESP-202503 二阶矩阵：枚举 其中，比较常考的考点： 枚举：考了 6 次。 排序：考了 3 次。 字符串操作：考了 2 次。 GESP 5 级大题核心考点待补充 GESP 6 级大题核心考点最近公共祖先 P10109 GESP-202312 六级 工作沟通 P13016 GESP-202506 六级 最大因数 动态规划包括 01 背包和完全背包： B3873 202309 六级 小杨买饮料 P13015 202506 六级 学习小组 P10721 202406 六级 计算得分 基础动态规划： P10108 202312 六级 闯关游戏 P10376 202403 六级 游戏 P11246 202409 六级 小杨和整数拆分 记忆化搜索： P10250 GESP样题 六级 下楼梯 复杂贪心： P11247 202409 六级 算法学习 其它树状数组： B3874 202309 六级 小杨的握手问题 暴力枚举： P10377 202403 六级 好斗的牛 模拟+高精度： P11375 202412 六级 树上游走 GESP 7 级大题核心考点动态规划背包： P13018 202506 七级 调味平衡","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学总结：树状数组","slug":"teaching-notes-of-bit","date":"2025-04-26T12:12:23.000Z","updated":"2025-07-06T06:14:15.932Z","comments":true,"path":"2025/04/26/teaching-notes-of-bit/","permalink":"https://blog.devtang.com/2025/04/26/teaching-notes-of-bit/","excerpt":"","text":"引言有些时候，题目给我们 N 个元素的序列，然后让我们求前缀和或者区间和。并且，题目还会动态地修改这个序列的值。如果我们每次暴力求解前缀和，时间复杂度会是 O（N），而使用树状数组，可以将查询前缀和的复杂度降低到 O(LogN)。 树状数组是挺不好教学的一个知识点。它需要以下前置知识： 二进制表示法及熟练的位操作 前缀和的知识 树的基础知识 时间复杂度的估算 在教学的时候，我们的教学顺序如下： 先引入问题 lowbit 函数讲解 树状数组的结构特点 利用树状数组求前缀和的方法 怎么修改树状数组的值 如何初始化树状数组 增加值或替换值 二维的树状数组 那么让我们来开始。 问题的引入P3374 树状数组 1 是一道标准的树状数组问题：该题目给我们了一个数列，我们需要解决以下两个问题： 数列的区间求和 更新某一个数（加上 x） 我们很容易想到用暴力的方法来做此题。于是我们可以估计一下暴力的时间复杂度： 数列的区间求和，时间复杂度 O（N） 更新某一个数，时间复杂度 O（1） 题目中提到，求和的次数最多为 M 次，所以最坏情况下，时间复杂度为 O(M*N)。而由于 M 和 N 的最大范围为 5*10^5，所以最大运算次数高达 (5*10^5) * (5*10^5) = 2500亿次，而竞赛中估算 1000 万次的运算时间就接近 1 秒了，这个时间肯定会超时。 数列的区间求和有一个 O（1）的办法，就是提前求出前缀和。假如 Sum(i) 表示前 i 个数的和，那么区间 (i,j] 的和就可以通过 Sum(j) - Sum(i) 来得出。可惜的是，本题还有一个操作是更新某一个数。如果更新的是第一个数，那么整个前缀和数组 Sum 都需要更新，这样更新的时间复杂度会变成 O（N），最坏情况下会有 O(M*N)次更新，造成运算同样超时。 由此，我们需要一个更优秀的数据结构来解决这类问题，这就是树状数组。 lowbit 函数在讲解树状数组前，我们先学习一下 lowbit 函数。 lowbit 函数实现的功能是：求 x 的二进制最低位 1 以及后面的 0 组成的数。例如： 8 (10 进制) &#x3D; 1000 (2 进制) ，则 lowbit(8) &#x3D; 8 9 (10进制）&#x3D; 1001（2 进制），则 lowbit(9) &#x3D; 1 10（10 进制）&#x3D; 1010（2 进制），则 lowbit(10) &#x3D; 2 所以，我们需要找到目标数的二进制中的最后那个 1 的位置。有两种实现方式： 方法一：x^(x-1) &amp; x方法一相对比较好理解，我拿二进制数 1100 举例解释如下： (x-1)的效果，相当于把二进制的最后一个1变成 0，比如某数 1100 减 1之后，就变成了 1011 这个时候，如果我用 x^(x-1),就会得到 1100^1011=0111 最后，用 x&amp; 刚刚的 x^(x-1)，就相当于把x的最后一个1留下来了，前面的1都抹掉了：1100 &amp; 0111 = 0100 方法二：x&amp;-x我们还是拿二进制数 1100 举例，由于负数是用补码表示，所以对于 1100，它的负数： 原码为：11100(最高为 1 为符号位) 反码为：10011(反码符号位不变，其余位取反) 补码为：10100（补码&#x3D;反码+1） 这样一操作，x&amp;-x 就等于 01100 &amp; 10100 = 0100，同样把最后的 1 取出来了。 在实现中，我们用方法二的更多，因为更短。参考代码如下： 123int lowbit(int x) &#123; return x &amp; -x;&#125; 树状数组的定义对于一个长度为 N 的序列，为了满足上面提到的更快的区间求和和更新的需求，我们可以构造一个树状数组。 树状数组（Binary Index Tree，简称 BIT）通过构造另一个长度为 N 的数组，来做到： 区间求和，时间复杂度 O(log N) 更新某一个数，时间复杂度 O(log N) 因为树状数组需要另外创建一个长度为 N 的数组，所以它的空间复杂度为O(N)。 我们先创建出这个数组 b ，然后再引入它的元素间的树状逻辑关系。 我们有了数组 b，我们让数组 b 相对于原始序列 a，按如下的关系来保存范围和： b[1] 保存 a[1]的值 b[2] 保存区间 [a[1], a[2]] 的和 b[3] 保存 a[3]的值 ….省略若干行 b[8] 保存区间 [a[1], a[8]] 的和 我们先不管如何做到的，先假设我们按上面的逻辑，初始化好了这个数组，那么它怎么能快速求出前缀和呢？ 树状数组求和我们假设要求 a[1] ~ a[7]的和，如下图所示，我们知道这段和满足：Sum(7) = b[4] + b[6] + b[7] 那么，我们观察一下 b[4],b[6],b[7] 这几个下标有什么特点： 4 的二进制：0100 6 的二进制：0110 7 的二进制：0111 如果结合上我们刚刚教的 lowbit 函数，我们就可以发现如下规律： 4 的二进制：0100，4 = 6 - lowbit(6) 6 的二进制：0110，6 = 7 - lowbit(7) 7 的二进制：0111 于是，如果我们要求 Sum(7)，就可以用 b[7] 开始累加，然后用 7 - lowbit(7) 得到 6，再用 6 - lowbit(6) 得到 4，最后 4 - lowbit(4) = 0，就结束整个求和累加过程。 把以上逻辑转换成代码，是这样的： 12345678int query(int range) &#123; int ret = 0; while (range &gt; 0) &#123; ret += b[range]; range -= lowbit(range); &#125; return ret;&#125; 有人可能要问了，这个求和都是从序列开头开始的，如果我们想求序列中间一段，比如从 x 到 y 的区间和，应该怎么办呢？这种情况，我们可以： 用 query(y) 把从头到 y 位置的和求出来 用 query(x-1) 把从头到 x-1 位置的和求出来 然后相减 query(y) - query(x-1) 得到区间 [x,y] 的和 更新数据树状数组也支持更新数据，像P3374 树状数组 1题目中要求的那样，我们可以将某个数加上 x，这种情况应该如何更新数组呢？ 我们以更新 a[1]为例，通过观察，我们发现涉及 a[1] 的数组有：b[1],b[2],b[4],b[8]，如下图所示： 你有观察出来规律吗？这刚好是我们构建的这个树从叶子结点到根结点的一条路径。 那同样的问题来了，我们如何求解出b[1],b[2],b[4],b[8]这个路径呢？我们来观察一下： 1 的二进制是：0001 2 的二进制是：0010, 2 = 1 + lowbit(1) 4 的二进制是：0100, 4 = 2 + lowbit(2) 8 的二进制是：1000, 8 = 4 + lowbit(4) 我们再验证一个中间结点的更新，比如更新 a[5]，如下图所示： 我们看看规则是不是一样： 5 的二进制是 0101， 6 的二进制是 0110，6 = 5 + lowbit(5) 8 的二进制是 1000，8 = 6 + lowbit(6) 至此，我们总结出更新方法：从数列的下标 idx 开始，不停地更新，并且用 idx += lowbit(idx) 获得下一个更新的下标，直到更新到下标超过上界（N）为止。 123456void add(int idx, int val) &#123; while (idx &lt;= n) &#123; b[idx] += val; idx += lowbit(idx); &#125;&#125; 初始化最暴力的初始化方法是：我们假设原序列全是 0，这样树状数组的初始状态也全是 0 即可正常表达上面的树型关系。然后，我们把每一个 a 序列中的数用更新的方式来放入树状数组中。 至此，我们完成了例题P3374 树状数组 1中的所有细节讨论，完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN (int)(500000+10)int n, m;int a[MAXN], b[MAXN];int lowbit(int x) &#123; return x &amp; -x;&#125;void add(int idx, int val) &#123; while (idx &lt;= n) &#123; b[idx] += val; idx += lowbit(idx); &#125;&#125;int query(int range) &#123; int ret = 0; while (range &gt; 0) &#123; ret += b[range]; range -= lowbit(range); &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;=n; ++i) &#123; cin &gt;&gt; a[i]; add(i, a[i]); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) &#123; add(x, y); &#125; else &#123; cout &lt;&lt; query(y) - query(x-1) &lt;&lt; endl; &#125; &#125; return 0;&#125; 但是，以上的这种初使化方法，时间复杂度为 O(N*logN)，如果数据刚好卡在初始化中，我们可以用以下这种方法来将初始化时间复杂度优化到 O(N)。 初始化（优化）为了讲明白这种初始化，我们需要观察树状数组 b 中的每个元素代表的数据范围有什么规律。为什么 b[5] 只代表 a[5] 一个元素，但是 b[8]代表的是[a[1],a[8]] 区间的 8 个元素的和 ？ 最终我们可以发现，一个数组元素代表的区间范围大小就是它的 lowbit 函数求出来的值。 例如： lowbit(5) &#x3D; 1，所以它只代表 a[5] 一个元素 lowbit(8) &#x3D; 8，所以它代表 [a[1],a[8]] 共 8 个元素 一个十进制数 88，其二进制为 01011000，lowbit(88)=8，所以它代表的区间为 8 个元素。 进一步的，我们可以观察出，对于一个 b[x]，它代表的区间为[x-lowbit(x)+1, x]。 这对初始化有什么用呢？ 我们如果构建了数组 a 的前缀和数组 s，s[i]表示前 i 个数的和。 那么，我们就可以用前缀和数组 s 来初始化 b[x]。 因为 b[x] 代表的区间和是[x-lowbit(x)+1, x],所以：b[i] = s[i] - s[i-lowbit(i)] 至此，我们可以将例题P3374 树状数组 1的代码更新如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN (int)(500000+10)int n, m;int a[MAXN], b[MAXN], s[MAXN];int lowbit(int x) &#123; return x &amp; -x;&#125;void add(int idx, int val) &#123; while (idx &lt;= n) &#123; b[idx] += val; idx += lowbit(idx); &#125;&#125;int query(int range) &#123; int ret = 0; while (range &gt; 0) &#123; ret += b[range]; range -= lowbit(range); &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;=n; ++i) &#123; cin &gt;&gt; a[i]; s[i] = s[i-1] + a[i]; &#125; // 初始化 for (int i = 1; i&lt;=n; ++i) &#123; b[i] = s[i] - s[i-lowbit(i)]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) &#123; add(x, y); &#125; else &#123; cout &lt;&lt; query(y) - query(x-1) &lt;&lt; endl; &#125; &#125; return 0;&#125; 管辖区间上面讲到，树状数组中的元素 b[x] 管辖的区间和是[x-lowbit(x)+1, x]，因此，我们更能理解树状数组的更新逻辑： 所谓的更新a[x]，就是把管辖区间涵盖 a[x] 的所有 b[x]都更新一遍。 那哪些 b[x]的管辖区间涵盖 a[x]呢？就是从二进制看，就是范围中有 lowbit(x) 的数。 举例来说，如果我们要更新 a[2] 的值，lowbit(2) 的值是 0010，所以，我们要更新： b[2], 因为 2 的二进制是 0010，管辖区间是 [1, 2]，宽度是 2 b[4], 因为 4 的二进制是 0100，管辖区间是 [1, 4]，宽度是 4 b[8], 因为 8 的二进制是 1000，管辖区间是 [1, 8]，宽度是 8 再举一个例子，如果我们要更新 a[5] 的值，lowbit(5) 的值是 0001，所以我们要更新： b[5]，因为 5 的二进制是 0101，管辖区间是 [5, 5]，宽度是 1 b[6]，因为 6 的二进制是 0110，管辖区间是 [5, 6]，宽度是 2 b[8]，因为 8 的二进制是 1000，管辖区间是 [1, 8]，宽度是 8 再举一个例子，如果我们要更新 a[7] 的值，lowbit(7) 的值是 0001，所以我们要更新： b[7]，因为 7 的二进制是 0111，管辖区间是 [7, 7]，宽度是 1 b[8]，因为 8 的二进制是 1000，管辖区间是 [1, 8]，宽度是 8 通过上面的例子，我们可以看到，管辖区间在更新的过程中宽度是不断扩大的。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。 我们再从另一个角度来看管辖区间：我们把数状数组的第 1 个到第 56 个元素的二进制列出来，如下所示： 我们可以观察到：bit 为 1 的位置越低，管辖的区域越小，所以： 有一半管辖区域大小为 1 的数（图中为粉色） 剩下的一半，有一半管辖区域大小为 2 的数（图中为绿色） 再剩的一半，有一半管辖区域大小为 4 的数（图中为紫色） 再剩的一半，有一半管辖区域大小为 8 的数（图中为黄色） 再看这些数的间隔： 粉色的间隔是 2-1，每 2 个出现一次 绿色的间隔是 4-1，每 4 个出现一次 紫色的间隔是 8-1，每 8 个出现一次 黄色的间隔是 16-1，每 16 个出现一次 所以，其实树状数组是把区间和数据按分治的思想进行了切分，这样可以快速求和。 另外，从管辖区域的角度考虑，每一个数在进行 lowbit 减运算的时候，得到的新数，一定和之前的区间不是重叠的。我们可以这样证明： 每个元素 b[x] 管辖的区间和是[x-lowbit(x)+1, x] 我们令 y = x - lowbit(x), 则 b[y] 的管辖区间就是：[y-lowbit(y)+1, y],即：[y-lowbit(y)+1, x - lowbit(x)] 可以看到，这两个区间 [y-lowbit(y)+1, x - lowbit(x)] 和 [x-lowbit(x)+1, x]其实是相邻的。 所以，每次减 lowbit(x) 的运算，其实是获得了其左侧相邻的一块区间的和。 我们来看一个查询和的例子，如果我们要求前缀和 sum(7)： 我们先计算 b[7]，7 的二进制是 0111，管辖区间是 [7, 7]，宽度是 1 我们再计算 b[6]，6 的二进制是 0110，管辖区间是 [5, 6]，宽度是 2 我们再计算 b[4]，4 的二进制是 0100，管辖区间是 [1, 4]，宽度是 4 我们从上面的例子可以看到：由于每次减掉的都是最小的一个 lowbit 位，所以左侧相邻的新区间一定更宽。所以求和过程中， b[7],b[6],b[4] 对应的管辖宽度从 1 到 2 再到 4. 我们再看一个前缀和 sum(9) 的例子： 我们先计算 b[9], 9 的二进制是 1001，管辖区间是 [9, 9]，宽度是 1 我们再计算 b[8], 9 的二进制是 1000，管辖区间是 [1, 8]，宽度是 8 和我们刚刚得到的结论相同：求和过程中，随着不断地减 lowbit(x)，获得的新区间更宽。 小结： 树状数组中的元素 b[x] 管辖的区间和是[x-lowbit(x)+1, x] 每次加 lowbit(x) 的过程，相当于在不断扩展管辖区间。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。 每次减 lowbit(x) 的过程，相当于在查找紧临 b[x] 管辖区间的一块新区间。这个新区间，宽度也是不断扩大的。不同的数，宽度扩大的倍数不同。但至少是每次翻倍的方式来扩大。 差分数组有些时候，题目会让我们一次更新一段区间，这个时候，我们可以引入差分数组来替代原数组。 差分数组中的每一个元素，是原数组相邻两个数的差。 例如： 原数组： 1,2,3,4,5,6 差分数组：1,1,1,1,1,1 我们对差分数组求前缀和，就可以还原出原数组。 这个时候，如果我们把原数组的第 3 个数到第 5 个数都加上 2，我们看看效果： 原数组： 1,2,5,6,7,6 差分数组：1,1,3,1,1,-1 我们观察到，原数组的一个区间都加上 2 之后，在差分数组那里，只有第 3 个数和第 6 个数有变化，其它都没有变化。所以，如果我们用差分数组来代替原数组，就可以只更新两个数值来代表原来的范围更新。 P3368 【模板】树状数组 2此题可以很好地练习差分数组与数状数组的结合运用，相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 差分： * - 假设 A 序列为原序列 * - 差分数列 C 为原序列每两个数之间的差 * - 即：c[i] = a[i] - a[i-1] * c[1] = a[1] * c[2] = a[2] - a[1] * c[3] = a[3] - a[2] * - 所以： * - a[i] = sum(c[1]+c[2]+...c[i]) * * 对于本题，如果把数组变成差分数组： * - [x,y] 每个数加上 k，等价于: * - c[x] += k * - c[y+1] -= k * - 求第 a[x] 的值，等价于： * - sum(c[1]+c[2]+...c[x]) * - 即求前缀和 * * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN (int)(500000+10)int n, m;int a[MAXN], c[MAXN], b[MAXN];int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int idx, int v) &#123; while (idx &lt;= n) &#123; b[idx] += v; idx += lowbit(idx); &#125;&#125;int query(int range) &#123; int ret = 0; while (range) &#123; ret += b[range]; range -= lowbit(range); &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; c[i] = a[i] - a[i-1]; add(i, c[i]); &#125; while (m--) &#123; int op, x, y, k; cin &gt;&gt; op; if (op == 1) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; add(x, k); add(y+1, -k); &#125; else &#123; cin &gt;&gt; x; cout &lt;&lt; query(x) &lt;&lt; endl; &#125; &#125; return 0;&#125; 二维的树状数组刚刚讲到，对于一个 b[x]，它代表的区间为[x-lowbit(x)+1, x] 那么对于一个二维的树状数组 b[x, y]，它代表的区间就是 a(x-lowbit(x)+1, y-lowbit(y)+1) - a(x, y) 形成的矩阵的总和。如下图所示： 对于二维的树状数组，更新就需要用两层的循环了。示例代码如下： 1234567void add(int x, int y, int v) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; for (int j = y; j &lt;= m; j += lowbit(j)) &#123; c[i][j] += v; &#125; &#125;&#125; 查询前缀和同样需要用循环，示例代码如下： 123456789int query(int x, int y) &#123; int res = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) &#123; for (int j = y; j &gt; 0; j -= lowbit(j)) &#123; res += c[i][j]; &#125; &#125; return res;&#125; 如果题目要求区间和，则需要用容斥原理来求解，这里不再展开介绍。 用树状数组求逆序对什么是逆序对？逆序对是指一个序列中，a[i] &gt; a[j] 且 i &lt; j 的有序对。 比如一个序列是 3 2 1，它的逆序对就有：3 2,3 1,2 1 三组。 树状数组如何和逆序对的数量扯上关系呢？ 拿序列 3 2 1 举例，我们知道，树状数组是可以用前缀和的。如果我们： 假设序列初始情况下为全 0 当处理第一个数 3 的时候，我们让树状数组的下标 3 加 1：update(3, 1)，同时记录插入了 1 个数 当处理第二个数 2 的时候，我们统计小于等于 2 的前缀和：query(2)，然后拿总数减 query(2)，得到大于 2 的数字数量 这个数量，就是当 2 被处理的时候，前面有一共多少个数大于 2，即与 2 能够组成逆序对的数量 例题：P1908 逆序对 在此题中，我们先要解决两个问题，才能借用上面的思想： 问题1、题中的数据范围太大，我们如何解决? 答案：我们可以用离散化的思想，把 2 10000 1 变成 2 3 1，因为逆序对是统计相对大小，所以这样更改之后，逆序对的数量是不变的。 具体如何离散化呢？我们可以将数据依次标记上编号，然后排序。例如： 原始序列为 100 200 50, 我们把它分别标上编号 (100,1), (200,2), (50,3) 然后我们将数值排序，得到：(50,3), (100,1), (200,2) 然后，我们再将新的序列赋上从 1 开始的编号：(50,3,1), (100,1,2), (200,2,3) 然后，我们再将序列按原来的编号(第 2 个数字）排序，得到 (100,1,2), (200,2,3), (50, 3, 1) 至此，我们转换得到了新的编号 2,3,1 因为 N 最多是 5*10^5，所以离散化之后，树状数组的大小也缩减到了 5*10^5 在实现的时候，我们可以用结构体来保存上面的三元组。 12345struct Node &#123; int v; int origin_idx; int next_idx;&#125;; 问题2、如果有两个相等的元素，会不会计算错误？ 我们假设元素是 200 300 200,按我们刚刚的操作： 先标号，得到 (200,1) (300,2) (200,3) 再排序，得到 (200,1) (200,3) (300,2) 再标号，得到 (200,1,1) (200,3,2) (300,2,3) 再排序，得到 (200,1,1) (300,2,3) (200,3,2) 最后序列是 1,3,2 这种是没问题的，但是，如果我们排序的时候不是用的稳定排序，把第二个 200 排到了前面，就会得到 2,3,1，这样逆序对就会多一个 2 1，而这本来是不存在的。 所以，为了解决这个问题，我们可以用稳定排序stable_sort，或者保证排序的时候，值相同的情况下，标号大的在后面。 以下是完整的参考程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN (int)(5*1e5+10)struct Node &#123; int v; int origin_idx; int next_idx;&#125;;Node a[MAXN];int n,c[MAXN];long long ans;bool comp1(const Node &amp;a, const Node &amp;b) &#123; return a.v &lt; b.v;&#125;bool comp2(const Node &amp;a, const Node &amp;b) &#123; return a.origin_idx &lt; b.origin_idx;&#125;int lowbit(int x) &#123; return x&amp;-x; &#125;void add(int a, int v) &#123; while (a&lt;=n) &#123; c[a]+=v; a+=lowbit(a); &#125;&#125;int query(int a) &#123; int ret = 0; while(a) &#123; ret += c[a]; a -= lowbit(a); &#125; return ret;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;=n; ++i) &#123; cin &gt;&gt; a[i].v; a[i].origin_idx = i; &#125; stable_sort(a+1, a+1+n, comp1); for (int i = 1; i&lt;=n; ++i) a[i].next_idx = i; stable_sort(a+1, a+1+n, comp2); for (int i = 1; i &lt;=n; ++i) &#123; add(a[i].next_idx, 1); ans += i - query(a[i].next_idx); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 相关练习题目文章中涉及的例题： P3374 树状数组 1 P3368 树状数组 2 P1908 逆序对 练习题： 题目 描述 B3874 小杨的握手问题 GESP 202309 六级真题 - - B3874 小杨的握手问题解题思路： 把学号为 a 的学生进入教室的行为，转化为第 a 个序列元素的值加 1。 这样，找出小于 a 的学生数量，就等价于求序列前 a-1 个元素的前缀和。 利用数状数组，就可以快速求前缀和了。 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 数状数组求逆序对。 * * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN int(3e5+10)int n, b[MAXN];long long ans;int lowbit(int a) &#123; return a&amp;-a;&#125;void add(int idx, int v) &#123; while (idx &lt;= n) &#123; b[idx] += v; idx += lowbit(idx); &#125;&#125;int query(int range) &#123; int ret = 0; while (range) &#123; ret += b[range]; range -= lowbit(range); &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; int a; cin &gt;&gt; a; // 将学号下标从 0 开始改到 1 开始 a = a + 1; ans += query(a - 1); add(a, 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学总结：深度优先搜索（DFS）","slug":"teaching-notes-of-dfs","date":"2025-04-13T07:27:30.000Z","updated":"2025-05-20T14:52:22.139Z","comments":true,"path":"2025/04/13/teaching-notes-of-dfs/","permalink":"https://blog.devtang.com/2025/04/13/teaching-notes-of-dfs/","excerpt":"","text":"深度优先搜索（DFS）是学生学习算法的第一道门槛，因为它的主要形式是递归。而递归中需要将搜索的相关信息通过参数传递，这一点需要学生深刻理解 DFS。 模版DFS 有比较标准的模版，如下所示： 1234567891011121314void dfs(int pt) // pt 表示层数&#123; if (终止条件) &#123; // 处理 return; &#125; for (枚举这个层的所有可选项) &#123; if（这个选项是合法的）&#123; 标记这个选项（保存现场） dfs(pt+1); 取消标记（恢复现场） &#125; &#125;&#125; 我们将运用该模版，完成后面的题目。 递归的深度递归的时候，程序会占用栈空间来保存函数的环境变量。根据编译器以及编辑参数的不同，栈空间的大小也不同。通常情况下，竞赛中的编译器设定的栈空间为 8M 或者 16M。 假如，我们在一个递归函数中使用了 10 个 int 变量，那么每个递归函数就需要 4*10=40字节的栈空间。8M 一共可以支持 8*1000*1000/40=200000层调用。考虑到栈空间还需要保存当前函数执行的地址等变量，可供支持的调用层数会更小一点。 同学们也可以做如下的递归函数栈空间的测试： 1234567891011121314151617/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int dfs(int x) &#123; int test[9] = &#123;0&#125;; cout &lt;&lt; x &lt;&lt; endl; dfs(x + 1); return 0;&#125;int main() &#123; dfs(0); return 0;&#125; 在我的本地，以上程序调用了约 13 万次后栈溢出。为了保险，我们在比赛中如果调用深度小于 1 万层，那应该是稳妥的；否则我们需要考虑是否用别的解法来解题。 教学和练习题目 题目名 说明 P1036 选数 NOIP 2002 普及组 P1219 八皇后 Checker Challenge USACO 1.5 P1596 Lake Counting S USACO10OCT P2036 PERKET COCI 2008&#x2F;2009 #2 P12139 黑白棋 蓝桥杯 2025 省 A，写起来较繁琐 P1605 迷宫 标准的 DFS P2404 自然数的拆分问题 P1019 单词接龙 NOIP 2000 提高组 P7200P10483 P1219 八皇后 Checker Challenge这是八皇后的变种，N 皇后问题。可以作为基础练习。具体解法是： 我们用变量 v[15] 表示每个皇后的列值。 对于新放入的皇后，我们依次检查它与前面的皇后是否在一条斜线上。检查方法是看其“横坐标差”与“纵坐标差”是否相同。检查函数如下： 123456bool check(int pt) &#123; for (int i = 0; i &lt; pt; i++) &#123; if (abs(v[i] - v[pt]) == abs(i - pt)) return false; &#125; return true;&#125; 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n;int v[15], ans;bool flag[15];bool check(int pt) &#123; for (int i = 0; i &lt; pt; i++) &#123; if (abs(v[i] - v[pt]) == abs(i - pt)) return false; &#125; return true;&#125;void dfs(int pt) &#123; if (pt == n) &#123; ans++; if (ans &lt;= 3) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (flag[i]==false) &#123; flag[i] = true; v[pt] = i; if (check(pt)) dfs(pt + 1); flag[i] = false; &#125; &#125; &#125;int main() &#123; cin &gt;&gt; n; dfs(0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1036 选数此题需要从小到大取数求和，然后再判断是否是素数。用递归的方式来进行枚举。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, k, tot, ans;int a[22], p[22];bool isPrime(int v) &#123; for (int i = 2; i*i &lt;= v; ++i) &#123; if (v%i == 0) &#123; return false; &#125; &#125; return true;&#125;void dfs(int pt) &#123; if (pt == k+1) &#123; if (isPrime(tot)) &#123; ans++; &#125; &#125; else &#123; // 每一层都必须取比前一层更大的下标，防止重复取 for (int i = p[pt-1]+1; i &lt;= n; ++i) &#123; p[pt] = i; tot += a[i]; dfs(pt+1); tot -= a[i]; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1596 Lake Counting S此题既可以用 DFS，也可以用 BFS。考虑到 N 和 M 最大值为 100，所以递归的层次最多为 1 万层，所以我们可以试试 DFS。 以下是参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;char tu[105][105];int ans;int movex[8] = &#123;0, 0, 1, -1, 1, 1, -1, -1&#125;;int movey[8] = &#123;1, -1, 0, 0, 1, -1, 1, -1&#125;;void dfs(int x, int y) &#123; tu[x][y] = &#x27;.&#x27;; for (int i = 0; i &lt; 8; i++) &#123; int nx = x + movex[i]; int ny = y + movey[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || tu[nx][ny] != &#x27;W&#x27;) continue; dfs(nx, ny); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; tu[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (tu[i][j] == &#x27;W&#x27;) &#123; dfs(i, j); ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2036 PERKET因为 N 最多为 10，每种食材可以选或者不选两种情况，所以最多情况数为 2^10=1024 种。搜索时间满足要求。 所以，此题用 DFS 可以非常方便解决。在搜索的时候，我们可以将食材的相关信息带到 DFS 函数的参数中，方便最后答案的求解。 12345678910111213141516171819202122232425262728293031323334353637/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n;int s[11], b[11], v[11];int ans = INT_MAX;/** * pt: 当前处理到的食材 * cnt: 当前选中的食材数量 * ss: 当前选中的食材的总酸度 * bb: 当前选中的食材的总甜度 */void dfs(int pt, int cnt, int ss, int bb) &#123; if (pt == n) &#123; if (cnt &gt; 0) &#123; ans = min(ans, abs(ss - bb)); &#125; return; &#125; v[pt] = 1; dfs(pt + 1, cnt + 1, ss * s[pt], bb + b[pt]); v[pt] = 0; dfs(pt + 1, cnt, ss, bb);&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i] &gt;&gt; b[i]; &#125; dfs(0, 0, 1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P12139 黑白棋此题是搜索题，需要在中间尽可能检查状态来剪枝，以节省搜索次数。 题目有三类限制，分别可以用在不同的剪枝环节。 限制一：在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（即为 3）。 我们可以对每一行记录黑子和白子的数量，如果某一行或某一列的一种颜色达到 3，后面则不能用这个颜色。 限制二：不能有超过两个相同颜色的棋子连续排列。 我们可以在当前落子的时候，检查它的左边和上面连续的几个格子，看是否有 3 个相同的子。 限制三：行列唯一性 可以放到最后检查。 另外，这个棋盘有几个位置已经设定了值，我们需要标记下来，搜索的时候跳过对这些位置的尝试，但需要在这些位置做合法性检查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int row_cnt[6][2], col_cnt[6][2];char tu[7][7], mark[7][7];bool check(int r, int c) &#123; // 在每一行和每一列中，黑色棋子和白色棋子的数量必须相等（即为 3） if (row_cnt[r][1] &gt; 3 || row_cnt[r][0] &gt; 3 || col_cnt[c][1] &gt; 3 || col_cnt[c][0] &gt; 3) return false; // 不能有超过两个相同颜色的棋子连续排列 if (r &gt;= 2) &#123; if (tu[r][c] == &#x27;1&#x27; &amp;&amp; tu[r-1][c] == &#x27;1&#x27; &amp;&amp; tu[r-2][c] == &#x27;1&#x27;) return false; if (tu[r][c] == &#x27;0&#x27; &amp;&amp; tu[r-1][c] == &#x27;0&#x27; &amp;&amp; tu[r-2][c] == &#x27;0&#x27;) return false; &#125; if (c &gt;= 2) &#123; if (tu[r][c] == &#x27;1&#x27; &amp;&amp; tu[r][c-1] == &#x27;1&#x27; &amp;&amp; tu[r][c-2] == &#x27;1&#x27;) return false; if (tu[r][c] == &#x27;0&#x27; &amp;&amp; tu[r][c-1] == &#x27;0&#x27; &amp;&amp; tu[r][c-2] == &#x27;0&#x27;) return false; &#125; return true;&#125;// 行列唯一性检查bool final_check() &#123; set&lt;int&gt; row_set, col_set; for (int i = 0; i &lt; 6; i++) &#123; int v = 0; for (int j = 0; j &lt; 6; ++j) &#123; v = v * 10 + (tu[i][j] - &#x27;0&#x27;); &#125; row_set.insert(v); &#125; if (row_set.size() != 6) return false; for (int j = 0; j &lt; 6; ++j) &#123; int v = 0; for (int i = 0; i &lt; 6; ++i) &#123; v = v * 10 + (tu[i][j] - &#x27;0&#x27;); &#125; col_set.insert(v); &#125; if (col_set.size() != 6) return false; return true;&#125;void dfs(int r, int c);void try_dfs(int r, int c) &#123; char ch = tu[r][c]; row_cnt[r][ch - &#x27;0&#x27;]++; col_cnt[c][ch - &#x27;0&#x27;]++; if (check(r, c)) &#123; int nr = r; int nc = c + 1; if (nc == 6) &#123; nr++; nc = 0; &#125; dfs(nr, nc); &#125; row_cnt[r][ch - &#x27;0&#x27;]--; col_cnt[c][ch - &#x27;0&#x27;]--;&#125;void dfs(int r, int c) &#123; if (r == 6) &#123; if (final_check()) &#123; for (int i = 0; i &lt; 6; i++) &#123; for (int j = 0; j &lt; 6; j++) &#123; cout &lt;&lt; tu[i][j]; &#125; &#125; cout &lt;&lt; endl; // 因为只有一个合法解，所以找到答案就退出 exit(0); &#125; return; &#125; if (mark[r][c] == 0) &#123; tu[r][c] = &#x27;1&#x27;; try_dfs(r, c); tu[r][c] = &#x27;0&#x27;; try_dfs(r, c); &#125; else &#123; tu[r][c] = mark[r][c]; try_dfs(r, c); &#125;&#125;void init() &#123; memset(mark, 0, sizeof(mark)); mark[0][0] = &#x27;1&#x27;; mark[0][1] = &#x27;0&#x27;; mark[0][3] = &#x27;0&#x27;; mark[1][3] = &#x27;0&#x27;; mark[2][4] = &#x27;0&#x27;; mark[2][5] = &#x27;0&#x27;; mark[4][2] = &#x27;1&#x27;; mark[4][5] = &#x27;1&#x27;; mark[5][1] = &#x27;0&#x27;; mark[5][4] = &#x27;1&#x27;;&#125;int main() &#123; init(); dfs(0, 0); return 0;&#125; P1605 迷宫用 DFS 来枚举，但需要标记走过的路。 因为最多只有 5x5&#x3D;25 个格子，所以递归的深度最大只有 25，不存在溢出情况。 因为有陷阱（不能走）和起点终点（不能重复走），所以我们假设平均每次有 2 条支路，整个的最坏情况估计只有 2^23=8388608 次，所以也不会超时。 一些陷阱： 终点可能也有障碍物，这个时候始终就到不了。 起点在走之前需要标记，否则会重复走。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;// 0 - 空地// 1 - 障碍物int tu[6][6], n, m, t, sx, sy, ex, ey, ans;int movex[]=&#123;1,-1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;void dfs(int x, int y) &#123; if (x == ex &amp;&amp; y == ey) &#123; ans++; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox &gt;=1 &amp;&amp; tox&lt;=n &amp;&amp; toy&gt;=1 &amp;&amp; toy&lt;=m &amp;&amp; tu[tox][toy]!=1)&#123; tu[tox][toy]=1; dfs(tox, toy); tu[tox][toy]=0; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey; while (t--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; tu[x][y] = 1; &#125; tu[sx][sy] = 1; dfs(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2404 自然数的拆分问题DFS，有两个技巧： 保证后面的数 &gt;&#x3D; 前面的数。 让每个数必须小于 n，这样不会出现 n=n 这种等式。 1234567891011121314151617181920212223242526272829303132/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, tot, v[10];void dfs(int pt) &#123; if (tot == n) &#123; cout &lt;&lt; v[1]; for (int i = 2; i &lt; pt; ++i) &#123; cout &lt;&lt; &quot;+&quot; &lt;&lt; v[i]; &#125; cout &lt;&lt; endl; return; &#125; for (int i = v[pt-1]; tot + i &lt;=n &amp;&amp; i &lt; n ; ++i) &#123; tot += i; v[pt] = i; dfs(pt+1); tot -= i; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; v[0] = 1; dfs(1); return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学总结：STL","slug":"cspj-notes-of-stl","date":"2025-04-12T14:00:46.000Z","updated":"2025-08-09T22:42:31.754Z","comments":true,"path":"2025/04/12/cspj-notes-of-stl/","permalink":"https://blog.devtang.com/2025/04/12/cspj-notes-of-stl/","excerpt":"","text":"STL 库是 C++ 语言的标准库，我们在比赛中主要用到的有如下内容。 string 类 substr find replace insert erase c_str 容器 pair vector deque list stack queue priority_queue map unordered_map set unordered_set 算法库 函数 调用示意 说明 sort sort(v.begin(), v.end()) 快速排序 stable_sort stable_sort(v.begin(), v.end()) 稳定排序 unique unique(v.begin(), v.end()) 去重，返回的是去重后的元素末地址。可以结合 erase 函数来把多余数据删除。参考代码：v.erase(unique(v.begin(), v.end()), v.end()); next_permutation next_permutation(v, v+n) 返回全排列的下一个值，当没有下一个排列时，函数返回 false prev_permutation prev_permutation(v, v+n) 返回全排列的上一个值，当没有上一个排列时，函数返回 false nth_element nth_element(v.begin(), v.begin() + k, v.end()), 函数执行后，v.begin()+k 位置的数为排序后的最终位置，即左边的数都小于它，后面的数都大于它 lower_bounds lower_bounds(v, v+n, a) 查找大于或等于 a 的第一个位置，如果没找到则返回 end() upper_bounds upper_bounds(v, v+n, a) 查找大于 a 第一个位置，如果没找到则返回 end() equal_range equal_range(v, v+n, a) equal_range 返回一个 pair，first 元素是查找到的匹配 a 值的左边界，second 元素是匹配到的 a 值的右边界，边界为左闭右开原则。当 first == second 的时候，相当于没找到目标值 __gcd __gcd(a, b) 返回 a 和 b 的最大公约数 reverse reverse(v.begin(), v.end()) 将原序列逆序 min_element min_element(v.begin(), v.end()) 返回的是地址，如果想要值，可以用 * 获得对应下标的值，如果想获得下标，可以让它减去 v.begin() max_element max_element(v.begin(), v.end()) 返回的是地址，如果想要值，可以用 * 获得对应下标的值，如果想获得下标，可以让它减去 v.begin() accumulate accumulate(v.begin(), v.end(), 0); 第三个参数是初始值 练习 题号 说明 P1996 约瑟夫问题 适合用 list P3613 寄包柜 适合用 map 和 pair P4387 验证栈序列 适合用 stack P1540 机器翻译 NOIP 2010 提高组，适合用 vector 以及 STL 的 find 算法 P1449 后缀表达式 适合练习 stack P2058 海港 NOIP 2016 普及组，练习桶和队列 P2234 营业额统计 练习 set 和 lower_bound 函数 P4305 不重复数字 可以练习 unordered_map 以及对比 cin 和 scanf 的速度差别 P1571 眼红的Medusa 练习 map 或 set P4387 验证栈序列解法：把 A 数组中的元素住栈里面 push，然后如果栈顶元素和 B 数组的当前元素相同，就 pop，同时 B 数组的当前元素后移。 12345678910111213141516171819202122232425262728293031/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, a[100010], b[100010];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; b[i]; stack&lt;int&gt; q; int idx = 0; for (int i = 0; i &lt; n; ++i) &#123; q.push(a[i]); while (!q.empty() &amp;&amp; q.top() == b[idx]) &#123; q.pop(); idx++; &#125; &#125; if (q.empty()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; P1540 机器翻译参考代码： 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int m, n, t, ans = 0; cin &gt;&gt; m &gt;&gt; n; vector&lt;int&gt; v; while (cin &gt;&gt; t) &#123; if (find(v.begin(), v.end(), t) == v.end()) &#123; // 如果不在内存中 v.push_back(t); ++ans; &#125; if (v.size() &gt; m) v.erase(v.begin()); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; P1449 后缀表达式表达式计算: 不停读入。 如果读到数字，就和之前的数字拼接：a = a * 10 + ch - &#39;0&#39; 如果读到 . 就压栈 如果读到运算符，就出栈两个数进行运算，结果再压栈 如果读到 @ 结束 1234567891011121314151617181920212223242526272829303132333435/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; s;int a, v1, v2;int main() &#123; char ch; while (cin &gt;&gt; ch) &#123; if (ch == &#x27;@&#x27;) break; if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;=&#x27;9&#x27;) &#123; a = a*10 + ch - &#x27;0&#x27;; &#125; else if (ch == &#x27;.&#x27;) &#123; s.push(a); a = 0; &#125; else if (ch == &#x27;+&#x27;) &#123; v1 = s.top(); s.pop(); v2 = s.top(); s.pop(); s.push(v1 + v2); &#125; else if (ch == &#x27;-&#x27;) &#123; v1 = s.top(); s.pop(); v2 = s.top(); s.pop(); s.push(v2 - v1); &#125; else if (ch == &#x27;*&#x27;) &#123; v1 = s.top(); s.pop(); v2 = s.top(); s.pop(); s.push(v1 * v2); &#125; else if (ch == &#x27;/&#x27;) &#123; v1 = s.top(); s.pop(); v2 = s.top(); s.pop(); s.push(v2 / v1); &#125; &#125; cout &lt;&lt; s.top() &lt;&lt; endl; return 0;&#125; P2058 海港解法：用一个队列记录所有 24 小时内的船。用一个桶记录每个国家的乘客数量。 每次有新船入队列的时候，更新桶。如果桶更新前是 0，则 ans++ 每次新船入队列后，检查最早的队列，如果超24 小时，则出队 出队的时候，更新桶，如果桶的数量减为 0，则 ans-- 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; int t; int len; vector&lt;int&gt; v;&#125;;// 桶，记录每个国家的乘客数量int cnt[100010], n, t, ans;// 队列queue&lt;Node&gt; q;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; Node a; cin &gt;&gt; a.t &gt;&gt; a.len; a.v.resize(a.len); for (int j = 0; j &lt; a.len; ++j) &#123; cin &gt;&gt; a.v[j]; if (cnt[a.v[j]] == 0) ans++; cnt[a.v[j]]++; &#125; q.push(a); int min_t = a.t - 86400; // 检查出列 a = q.front(); while (a.t &lt;= min_t) &#123; for (int j = 0; j &lt; a.len; ++j) &#123; cnt[a.v[j]]--; if (cnt[a.v[j]] == 0) ans--; &#125; q.pop(); a = q.front(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; P2234 营业额统计把营业额往 set 里面放，这样数据就是有序的。然后用 lower_bound 查找大于等于 x 的值。 如果找到了，那么波动就是 0 如果没找到，比较当前位置和上一个位置与 x 的差，取较小那个；同时插入 x 取上一个位置的时候要处理一下边界，如果是在 s.begin()位置的话就不用处理了。 取当前位置的时候要处理一下，看看是不是在 s.end()。 1234567891011121314151617181920212223242526272829303132333435363738/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;int n, x, ans;bool debug = false;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; cin &gt;&gt; x; ans = x; s.insert(x); for (int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; x; set&lt;int&gt;::iterator it; it = s.lower_bound(x); if (it != s.end() &amp;&amp; *it == x) &#123; continue; &#125; else &#123; int diff = INT_MAX; if (it != s.end()) &#123; diff = min(diff, abs(*it-x)); &#125; if (it != s.begin()) &#123; it--; diff = min(diff, abs(*it-x)); &#125; ans += diff; s.insert(x); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：数学题","slug":"cspj-notes-of-math-problems","date":"2025-04-12T13:40:39.000Z","updated":"2025-06-22T02:07:25.809Z","comments":true,"path":"2025/04/12/cspj-notes-of-math-problems/","permalink":"https://blog.devtang.com/2025/04/12/cspj-notes-of-math-problems/","excerpt":"","text":"数学题是信息学竞赛中重要的一类题目，通常包括几何、数论、容斥原理等。 本文将相关的题目归纳整理，用于教学。 质数相关判断一个数是否为质数此算法是很多数学相关题目的基础，在 GESP 二级中也有涉及。例如：B3840 找素数。 其核心代码是： 123456bool isPrime(int a) &#123; for (int i = 2; i*i &lt;=a; i++) &#123; if (a%i == 0) return false; &#125; return true;&#125; 初学者在写的时候，要注意 i*i 与 a 的比较是小于等于。 质因数分解质因数分解的方法是从 2 开始试商，如果发现能整除，就把被除数中该因数去掉，关键代码是： 1while (N % i == 0) N /= i; 这样经过几轮下来，N 的值会变得很小，最后 N 如果不为 1，N 就是最后一个质因数。 完整代码如下： 12345678910111213vector&lt;int&gt; prime_facs(int N) &#123; vector&lt;int&gt; result; for (int i = 2; i * i &lt;= N; i++) &#123; if (N % i == 0) &#123; while (N % i == 0) N /= i; result.push_back(i); &#125; &#125; if (N != 1) &#123; // 说明再经过操作之后 N 留下了一个素数 result.push_back(N); &#125; return result;&#125; 练习题： B3969 GESP202403 五级 B-smooth 数 P10720 GESP202406 五级 小杨的幸运数字 B3969 GESP202403 五级 B-smooth 数 的参考代码： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int n, b, ans;int getMaxPrime(int v) &#123; int ret = 0; for (int i = 2; i*i &lt;= v; i++) &#123; if (v%i == 0)&#123; ret = max(ret, i); while (v%i == 0) v/=i; // 把 v 的值缩小 &#125; &#125; ret = max(ret, v); return ret;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; b; for (int i = 1; i &lt;=n; ++i) &#123; int t = getMaxPrime(i); if (t &lt;= b) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 几何P2241 统计方形本题解法：每个矩形（包括正方形）都可以由一段左边线段和一段上边线段确定。因此，我们只需要枚举所有可能的线段。 对于一个长是 N 宽是 M 的棋盘。 左边的线段长度为 1 的有 N 个，长度为 2 的有 N-1 个，…长度为 N 的有 1 个。 上边的线段长度为 1 的有 M 个，长度为 2 的有 M-1 个，…长度为 M 的有 1 个。 所以: 左边的线段一共有 （1+2+3+...+N）= N*(N+1)/2 个。 上边的线段一共有 （1+2+3+...+M）= M*(M+1)/2 个。 因此，总共有 N*(N+1)/2 * M*(M+1)/2 个矩形。 用相同的办法可以推导正方形的数量，方法如下： 对于左边长度为 1 的线段有 N 个，相应的上边长度为 1 的线段有 M 个。 所以可以构造出 N*M 个边长为 1 的正方形。 同理： 对于左边长度为 2 的线段有 N-1 个，相应的上边长度为 2 的线段有 M-1 个。 所以可以构造出 (N-1)*(M-1) 个边长为 2 的正方形。 以此类推，可以构造出 N*M + (N-1)*(M-1) + (N-2)*(M-2) + (N-M+1)*1 个正方形(N&gt;M)。 另外，需要注意使用 long long 来保存结果。完整的代码如下： 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;unsigned long long n, m, ans1, ans2;int main() &#123; cin &gt;&gt; n &gt;&gt; m; ans1 = n*(n+1)/2 * m*(m+1)/2; while (n &gt; 0 &amp;&amp; m &gt; 0) &#123; ans2 += n*m; n--; m--; &#125; cout &lt;&lt; ans2 &lt;&lt; &quot; &quot; &lt;&lt; ans1 - ans2 &lt;&lt; endl; return 0;&#125; 数论P1044 栈这道题可以先用暴力的办法把前面几个数打出来，然后我们能发现数的规律是：1,1,2,5,14,42,132,429,1430,…. 这是计算组合中很常见的卡特兰数，卡特兰数有两种公式，第一种公式是： f(n) = f(n-1) * (4 * n - 2) / (n + 1) 我个人觉得这个公式不太好记。另一个公式是： 这个递推式相对好记一点：即C(n) = C(0)*C(n-1) + C(1)*C(n-2) ... C(n-1)*C(0) 以下是用该递推式实现的答案： 12345678910111213141516171819/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;long long ans[19];int main() &#123; int n; cin &gt;&gt; n; ans[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; ++j) &#123; ans[i] += ans[j] * ans[i-1-j]; &#125; &#125; cout &lt;&lt; ans[n] &lt;&lt; endl; return 0;&#125; P3612 USACO17JAN Secret Cow Code S这是一道 USACO 的题目，需要我们先找出规律，然后再试图求解。 此题找规律的技巧是分析坐标每次在折半还原时的变化规律。为了分析规律，我们可以看每次翻倍时，坐标的关系变化。 对于一个长度为 N 的字符串S，每次其长度变为 2*N。所以，我们对每一位进行标号： 1 2 3 4... N N+1 N+2 N+N 其中，除 S[N] == S[N+1] 外（按题意，此项为特殊项），其它位置都符合如下规律： S[1] &#x3D;&#x3D; S[N+2] S[N-1] &#x3D;&#x3D; S[N+N] 所以，将右边的坐标减去 N 再减 1，就得到左边的坐标。 所以，设总长为 L, 如果 a 的位置在右半侧，则对应到左半侧的坐标关系是： if (a == L/2+1) a = 1; else a = a - L/2 - 1; 如此递归下去，直到位置落在最初的长度上。因为字符下标是从 0 开始，所以下标最后要减 1. 最后注意用 long long 来转换坐标。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;string s;long long a, n;bool debug = false;long long di(long long a, long long L) &#123; if (debug) &#123; // 可用 debug 查看坐标变化过程 cout &lt;&lt; &quot;test a = &quot; &lt;&lt; a &lt;&lt; &quot;, L = &quot; &lt;&lt; L &lt;&lt; endl; &#125; if (a &lt;= n) &#123; return a; &#125; else &#123; // 如果 a 的位置在右半侧，则调整到左半侧 if (a &gt; L/2) &#123; if (a == L/2 + 1) a = L/2; else a = a - L/2 - 1; &#125; return di(a, L/2); &#125;&#125;int main() &#123; cin &gt;&gt; s &gt;&gt; a; n = s.length(); // 求出开始往回递归时，字符串拼起来的长度 L long long L = n; while (L &lt; a) L *= 2; // 寻找 L 这个长度下，第 a 个字符相当于哪个位置 int ans = di(a, L); cout &lt;&lt; s[ans-1] &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：枚举","slug":"teaching-notes-of-brute-force","date":"2025-04-06T03:20:47.000Z","updated":"2025-04-16T15:01:53.634Z","comments":true,"path":"2025/04/06/teaching-notes-of-brute-force/","permalink":"https://blog.devtang.com/2025/04/06/teaching-notes-of-brute-force/","excerpt":"","text":"枚举就是把所有情况都尝试一遍。比较简单的用 for 循环即可，较复杂的枚举，需要用到递归。 P1304 哥德巴赫猜想此题直接枚举每个合数拆解成两个质数和的所有可能性。为了避免重复计算质数，我们用一个 map 将其运算结果保存下来。 123456789101112131415161718192021222324252627282930/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, bool&gt; rec;bool isPrime(int n) &#123; if (rec.find(n) != rec.end()) &#123; return rec[n]; &#125; for (int i = 2; i*i &lt;= n; ++i) &#123; if (n % i == 0) return rec[n] = false; &#125; return rec[n] = true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 4; i &lt;= n; i+=2) &#123; for (int j = 2; j &lt;= i; ++j) &#123; if (isPrime(j) &amp;&amp; isPrime(i-j)) &#123; printf(&quot;%d=%d+%d\\n&quot;, i, j, i-j); break; &#125; &#125; &#125; return 0;&#125; P2089 烤鸡此题初看起来 N 很大，但是每种配料最多 3 克，一共 10 种，总克数最多为 30 克。所以超过 30 克的情况答案都为 0。 每种配料 3 种情况，一共 10 种配料，所以暴力枚举的时间复杂度 3^10 约为 59000，不会超时。 枚举的参考代码如下： 1234567891011121314151617181920212223242526272829303132/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt; &gt; ans;vector&lt;int&gt; a(10);int n;void dfs(int pt, int tot) &#123; if (pt == 10) &#123; if (tot == n)ans.push_back(a); return; &#125; if (tot &gt;= n) return; for (int i = 1; i&lt;=3; i++) &#123; a[pt] = i; dfs(pt+1, tot+i); &#125;&#125;int main() &#123; cin &gt;&gt; n; dfs(0, 0); cout &lt;&lt; ans.size() &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) &#123; for (int j = 0; j &lt; ans[i].size(); j++) &#123; cout &lt;&lt; ans[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; P1706 全排列问题全排列的问题有多种写法，此题可以直接用 STL 中的 next_permutation 函数。 123456789101112131415161718192021/** * P1706 全排列问题 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, v[11];int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; v[i] = i+1; &#125; do &#123; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%5d&quot;, v[i]); &#125; printf(&quot;\\n&quot;); &#125; while (next_permutation(v, v+n)); return 0;&#125; P1157 组合的输出其实组合也可以用 next_permutation 来实现。以 n&#x3D;5,r&#x3D;3 为例，具体方法是： 构造一个只有 0 和 1 的数组，0 表示选中，1 表示未选中。 数组初始状态：0 0 0 1 1，这样对应输出的是 1, 2, 3 下一个状态： 0 0 1 0 1， 输出 1, 2, 4 结束状态： 1 1 0 0 0，输出 3, 4, 5 以下是实现代码： 12345678910111213141516171819202122/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, r;int v[25]=&#123;0&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; r; for (int i = r; i &lt; n; ++i) &#123; v[i] = 1; &#125; do &#123; for (int i = 0; i &lt; n; ++i) &#123; if (v[i] == 0) printf(&quot;%3d&quot;, i+1); &#125; printf(&quot;\\n&quot;); &#125; while (next_permutation(v, v+n)); return 0;&#125; 更多全排列的练习： P1088 NOIP 2004 普及组 火星人 P3392 涂条纹 这道题可以枚举蓝色色块开始的行号和结束的行号，时间复杂度为 O(N^2)。 对于每一种情况，我们需要 N 的时间复杂度来检查。 所以一共的时间复杂度是 N^3。 我们先预保存下来每行的各种颜色的色块数量，这样检查的时候就可以快速求解。 1234567891011121314151617181920212223242526272829303132333435/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int cnt[55][128];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; char ch; cin &gt;&gt; ch; cnt[i][ch]++; &#125; &#125; int ans = INT_MAX; // 枚举蓝色行的起止 for (int i = 1; i &lt; n; ++i) &#123; for (int j = i; j &lt; n-1; ++j) &#123; int cost = 0; for (int k = 0; k &lt; i; ++k) cost += m - cnt[k][&#x27;W&#x27;]; for (int k = i; k &lt;= j; ++k) cost += m - cnt[k][&#x27;B&#x27;]; for (int k = j+1; k &lt; n; ++k) cost += m - cnt[k][&#x27;R&#x27;]; ans = min(ans, cost); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P3654 First Step直接枚举每个起点。但是 k==1 时需要特判，因为 k==1 意味着向下和向右重复计算，需要除以 2。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * 陷阱： * k=1时需要特判，因为k=1意味着向下和向右重复计算，需要除以2。 * * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, k, ans;char tu[110][110];bool check(int x, int y, int dx, int dy) &#123; int nx = x, ny = y; for (int i = 0; i &lt; k; i++) &#123; if (nx &gt;= n || ny &gt;= m) return false; if (tu[nx][ny] == &#x27;#&#x27;) return false; nx += dx; ny += dy; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; tu[i][j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (check(i, j, 1, 0)) ans++; if (check(i, j, 0, 1)) ans++; &#125; &#125; if (k == 1) ans /= 2; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1149 火柴棒等式NOIP 2008 提高组第二题。推导如下： n 最大为 24。 24 减去加号（2根火柴）和等号（2 根火柴），还剩 20 根。 20 根分配到 3 个数字（A+B&#x3D;C）上，平均每个数字 7 根，但也可能一个数特别大（10 根），另一个数特别小（2 根）。 每个数字最少用量为 2 根火柴（数字 1）。 枚举办法： 第 1 个数字 A 从 0 - 10000，计算出 A 用的火柴数 t1 第 2 个数字 B 从 A - 10000，计算出 B 用的火柴数 t2 算出来 A+B 的和 C，检查 C 用的火柴数是不是刚好是 n-t1-t2-4 每找到一种，如果 A!&#x3D;B，则计算两次答案，因为 B+A&#x3D;C 是另一个对称的答案。 用以上的枚举之后，我们将所有答案输出，发现 A 其实在 N 最大（N&#x3D;24）的时候也不会超过 1000，测试如下（只输出了 A&lt;&#x3D;B 的情况）。所以我们就可以将 A 的范围改小，或者直接打表输出答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263640+8=80+12=120+13=130+15=150+21=210+31=310+47=470+51=510+74=740+117=1170+171=1710+711=7111+20=211+30=311+42=431+47=481+50=511+112=1131+117=1181+170=1711+710=7112+8=102+10=122+19=212+41=432+72=742+77=792+111=1133+10=133+13=163+44=473+114=1174+43=474+57=614+70=744+113=1174+117=1215+10=155+16=215+17=226+15=217+15=227+27=347+40=477+41=487+54=617+72=797+77=847+110=1177+111=1187+114=1219+12=2111+13=2411+14=2511+16=2711+31=4211+41=5211+61=7214+27=4114+77=9117+24=4117+57=7417+74=9141+71=112 完成的程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 把 A 和 B 的范围改成 10000，同时把 debug 改成 true 可以输出所有可能的组合。 * 经过测试发现 A和 B的答案范围小于 1000，所以可以改成 1000。 * * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int num[] = &#123;6,2,5,5,4,5,6,3,7,6&#125;;unordered_map&lt;int, int&gt; record;int n, ans;bool debug = false;int main() &#123; cin &gt;&gt; n; // 初始化 for (int i = 0; i &lt; 20000; i++) &#123; int tmp = i; int cnt = 0; do &#123; cnt += num[tmp % 10]; tmp /= 10; &#125;while (tmp &gt; 0);; record[i] = cnt; &#125; n -= 4; for (int i = 0; i &lt; 1000; i++) &#123; for (int j = i; j &lt; 1000; j++) &#123; int c = i + j; if (record[i] + record[j] + record[c] == n) &#123; if (i != j) ans+=2; else ans++; if (debug) &#123; cout &lt;&lt; i &lt;&lt; &quot;+&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; c &lt;&lt; endl; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P3799 小 Y 拼木棒思路如下： 4 根木棒，先选出三根。肯定是有两根的和等于第三根。 最后一根显然是和第三根一样长。 所以，问题转换成：选两根木棒，同时再选两根他们的和，一共有多少种。 在选两根木棒的时候，我们又可以转化为：选一根木棒，然后选另一根大于等于它的木棒。 因为 a 的值在 5000 以内，而 N 最大是 10 万，所以可以把值放到一个计数的桶里面。这样枚举的时候效率更高。 解法： 拿一个 cnt[] 数组保存每个数字出现的次数，同时记录最大值 maxv。 从 1 到 maxv 枚举 a 和 b（其中保证 b 大于等于 a） 计算两个数字的和 c，然后取 c 的次数。 计算一共的组合数，结果对 10^9+7 取模。 参考代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MOD (int)(1e9 + 7)unordered_map&lt;int, int&gt; cnt;int n, x, maxv;long long ans;// 从 a 个数中选 2 个数的组合数long long C(long long a) &#123; return a * (a - 1) / 2;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; cnt[x]++; maxv = max(maxv, x); &#125; for (int a = 1; a &lt;= maxv; a++) &#123; for (int b = a; b &lt;= maxv; b++) &#123; if (a == b &amp;&amp; cnt[a] &lt; 2) continue; int c = a + b; if (cnt[c] &gt;= 2) &#123; long long base = C(cnt[c]) % MOD; if (a == b) base = base * C(cnt[a]) % MOD; else base = base * ((cnt[a] * cnt[b]) % MOD) % MOD; ans = (ans + base) % MOD; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1028 数的计算NOIP 2001 普及组 题目。在暴力枚举的时候，需要记住重复的计算。 参考代码： 123456789101112131415161718192021222324/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, ans, record[1010];int dfs(int a) &#123; if (record[a] != 0) return record[a]; int ret = 1; for (int i = 1; i &lt;= a/2; ++i) &#123; ret += dfs(i); &#125; record[a] = ret; return ret;&#125;int main() &#123; cin &gt;&gt; n; ans = dfs(n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 更多练习 P1464 Function P2437 蜜蜂路线 P2437 蜜蜂路线需要用到高精度。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;string record[1001][1001];string add(string a, string b) &#123; int len_a = a.length(); int len_b = b.length(); int len_max = max(len_a, len_b); int carry = 0; string ret = &quot;&quot;; for (int i = 0; i &lt; len_max; i++) &#123; int num_a = i &lt; len_a ? a[len_a - i - 1] - &#x27;0&#x27; : 0; int num_b = i &lt; len_b ? b[len_b - i - 1] - &#x27;0&#x27; : 0; int sum = num_a + num_b + carry; ret = to_string(sum % 10) + ret; carry = sum / 10; &#125; if (carry &gt; 0) ret = to_string(carry) + ret; return ret;&#125;string dfs(int n, int m) &#123; if (n &gt; m) return &quot;0&quot;; if (n == m) return &quot;1&quot;; if (record[n][m] != &quot;&quot;) return record[n][m]; return record[n][m] = add(dfs(n+1, m), dfs(n+2, m));&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; dfs(n, m) &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：模拟","slug":"teaching-notes-of-simulation","date":"2025-03-29T15:06:22.000Z","updated":"2025-06-08T09:17:13.477Z","comments":true,"path":"2025/03/29/teaching-notes-of-simulation/","permalink":"https://blog.devtang.com/2025/03/29/teaching-notes-of-simulation/","excerpt":"","text":"模拟是最有效的练习编程熟练度的基础算法，也是有效的掌握各种编程技巧的练习方式。 本文将把各种模拟技巧与题目结合，用题目带着学生掌握这些模拟技巧。 二维数组包边有些时候，我们在处理二维数组的时候，需要处理 x，y 坐标的边界。这样写起来会比较麻烦，但是，如果我们将数据从下标 1 开始保存，那么就人为在数据外面留了一圈缓冲带。这个时候，在处理 x，y 周围坐标的时候，就不会出现数据下标越界的情况了。 例题：P2670 NOIP 2015 普及组 扫雷游戏该题如果正常写，需要判断每个格子周围 8 个格子的状态。如果我们把数据从 1 开始读入，在判断的时候就容易很多。以下是参考代码。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * P2670 [NOIP 2015 普及组] 扫雷游戏 * * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;char tu[110][110];int movex[] = &#123;-1, -1, -1, 0, 0, 1, 1, 1&#125;;int movey[] = &#123;-1, 0, 1, -1, 1, -1, 0, 1&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; tu[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (tu[i][j] == &#x27;*&#x27;) continue; int cnt = 0; for (int k = 0; k &lt; 8; ++k) &#123; int x = i + movex[k]; int y = j + movey[k]; if (tu[x][y] == &#x27;*&#x27;) cnt++; &#125; tu[i][j] = cnt + &#x27;0&#x27;; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; cout &lt;&lt; tu[i][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 例题：B4248 语言月赛 202503 数字棋盘本题也可以用包边的技巧，保证数据在检查的时候不会越界。参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;int a[1001][1001];int x, y;bool check(int i, int j) &#123; // 检查上方格子 if (i &gt; 1 &amp;&amp; a[i-1][j] == y) return true; // 检查下方格子 if (i &lt; n &amp;&amp; a[i+1][j] == y) return true; // 检查左侧格子 if (j &gt; 1 &amp;&amp; a[i][j-1] == y) return true; // 检查右侧格子 if (j &lt; m &amp;&amp; a[i][j+1] == y) return true; return false;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; cin &gt;&gt; x &gt;&gt; y; int count = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (a[i][j] == x &amp;&amp; check(i, j)) &#123; count++; &#125; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; P10719 GESP202406 五级 黑白格此题需要求枚举从坐标(x,y)到坐标(a,b)的 1 的个数。我们先用将从(0,0)到(a,b)的 1 的个数保存在一个数组 s[110][110]中，然后再通过容斥原理来进行快速求(i,j)到(a,b)中 1 的个数。具体方法如下： 第一步：对于每一个 s[i][j]，满足：s[i][j] = s[i-1][j] + cnt，其中 cnt 为第 i 行前 j 个数中 1 的个数。于是，我们就可以递推求出所有的 s[i][j]，代码如下： 1234567for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; for (int j = 1; j &lt;= m; j++) &#123; cnt += (tu[i][j] == &#x27;1&#x27;); s[i][j] = s[i-1][j] + cnt; &#125;&#125; 以上代码使用了“包边”的技巧，因为我们下标是从 1 开始的，所以下标 i-1 不会越界。 第二步：根据容斥原理。从坐标(i,j)到坐标(a,b)的 1 的个数为：s[a][b] - s[i-1][b] - s[a][j-1] + s[i-1][j-1]。如下图所示： 以上公式如果使用“包边”技巧，让有效坐标从 1 开始，也会帮助 i-1 的值不会越界。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, k, ans;int s[110][110]; // 表示从(0,0)到(a,b)的 1 的个数char tu[110][110];int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tu[i]+1; &#125; // 从第二行递推 for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; for (int j = 1; j &lt;= m; j++) &#123; cnt += (tu[i][j] == &#x27;1&#x27;); s[i][j] = s[i-1][j] + cnt; &#125; &#125; ans = INT_MAX; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; for (int a = i; a &lt;= n; a++) &#123; for (int b = j; b &lt;= m; b++) &#123; int cnt = s[a][b] - s[i-1][b] - s[a][j-1] + s[i-1][j-1]; if (cnt &gt;= k) &#123; int tmp = (a-i+1) * (b-j+1); if (tmp &lt; ans) ans = tmp; &#125; &#125; &#125; &#125; &#125; if (ans == INT_MAX) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 围圈数数有一种模拟题，要求我们把人围成一个圈，在圈上数数，然后问你数到的是谁。类似于小时候玩的“点兵点将”游戏，可能是顺时针数，也可能是逆时针数。 对于这种数数题目，最简单的做法是：直接用加减来进行目标的选择。加减之后，下标可能变负数或者超过总数，这个时候进行简单的取模调整，就可以将下标调整正常。 例题：P1563 玩具谜题此题我们： 用 idx = (idx + b) % n; 来完成顺时针数 用 idx = (idx - b + n) % n; 来完成逆时针数 通过这样的简单的加减和取模，保证能够快速跳到目标位置，完成模拟操作。完整代码如下： 1234567891011121314151617181920212223242526272829303132/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN int(1e5 + 10)int n, m;int face[MAXN];string name[MAXN];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; face[i] &gt;&gt; name[i] ; &#125; int idx = 0; for (int i = 0; i &lt; m; ++i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; // 圈内向左 == 圈外向右 if ((face[idx] == 0 &amp;&amp; a == 0) || (face[idx] == 1 &amp;&amp; a == 1)) &#123; idx = (idx - b + n) % n; &#125; else &#123; idx = (idx + b) % n; &#125; &#125; cout &lt;&lt; name[idx] &lt;&lt; endl; return 0;&#125; 例题：B4246 环形游走此题有个技巧：就是走的时候可能绕多圈，这个时候我们先把要走的步数模 n: step % n, 这样就把前面的多圈跳过了，也不会把坐标减成特别特别小的负数。 参考代码如下： 123456789101112131415161718192021/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int current = 0; for (int i = 0; i &lt; m; i++) &#123; int step = a[current] % n; current = (current - step + n) % n; &#125; cout &lt;&lt; current + 1 &lt;&lt; endl; return 0;&#125; 更多练习： P1914 小书童——凯撒密码 例题：B3921 小杨的考试绕圈一类的问题不止是以上那种真实的圈，也可能是像星期几这样逻辑上的圈（日期就像是一个圈，从星期一到星期日，然后又回到星期一）。 B3921 GESP202312 一级 小杨的考试这道题让我们计算日期。最简单的办法，是让星期几先落到 0-6 的表示法（0 表示星期一，6 表示星期日）。然后我们就可以用简单的加 N 天，然后模 7，快速定位到未来是星期几。对于过去，我们也可以简单通过减 N%7 天，然后减掉差的天数后 +7 再模 7，让结果落到 0-6 上。 参考代码如下： 12345678910111213/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int x, n;int main() &#123; cin &gt;&gt; x &gt;&gt; n; x = (x - 1 + n) % 7 + 1; cout &lt;&lt; x &lt;&lt; endl; return 0;&#125; 矩阵操作矩阵操作这类模拟题，会要求我们在一个二维（或三维）的数组上进行各种操作，包括填充，旋转，查找，合并等。需要我们熟悉各种矩阵操作的技巧。 例题：P5725 求三角形此题是一道基础的填充题。 对于第一种要求，我们用在二维数组上填充实现。 对于第二种要求，我们直接输出结果，在合适的位置加上一些空格。 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int tu[11][11];int n;int main() &#123; cin &gt;&gt; n; // 处理第一种要求 int cnt = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; tu[i][j] = cnt++; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; printf(&quot;%02d&quot;, tu[i][j]); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); // 处理第二种要求 cnt = 1; int bk = n-1; for (int i = 1; i &lt;= n; ++i, bk--) &#123; for (int j = 1; j &lt;= bk; ++j) printf(&quot; &quot;); for (int j = 1; j &lt;= i; ++j) &#123; printf(&quot;%02d&quot;, cnt++); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 例题：P5461 赦免战俘此题我们需要熟练使用递归来进行标记。参考代码如下： 123456789101112131415161718192021222324252627282930313233343536/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;char v[1100][1100];void mark(int x, int y, int size) &#123; if (size == 1) return; int half = size/2; for (int i = x; i &lt; x+half; ++i) &#123; for (int j = y; j &lt; y+half; ++j) &#123; v[i][j] = &#x27;0&#x27;; &#125; &#125; mark(x, y+half, half); mark(x+half, y, half); mark(x+half, y+half, half);&#125;int main() &#123; cin &gt;&gt; n; m = 1&lt;&lt;n; memset(v, &#x27;1&#x27;, sizeof(v)); mark(0, 0, m); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cout &lt;&lt; v[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 例题：P5731 蛇形方阵蛇形方阵是一道基础题，用于练习二维数组上的操作。我使用的模拟技巧是： 定义一个 order 变量，表示当前方向 与 order 变量配合，定义一个 movex 和 movey 数组，表示当前方向的移动 相关代码是： 123int order;int movex[] = &#123;0, 1, 0, -1&#125;;int movey[] = &#123;1, 0, -1, 0&#125;; 每次移动，先判断是否越界或者已经填充过值： 如果越界或已经填充过值，则改变方向再移动 如果没越界，则移动 关键代码如下： 12345if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; n || tu[nx][ny] != 0) &#123; order = (order + 1) % 4; nx = x + movex[order]; ny = y + movey[order];&#125; 因为要填充 n*n 个数，所以循环一共执行 n*n 次。 完整的参考代码如下： 123456789101112131415161718192021222324252627282930313233343536/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, y, order;int tu[15][15];int movex[] = &#123;0, 1, 0, -1&#125;;int movey[] = &#123;1, 0, -1, 0&#125;;int main() &#123; cin &gt;&gt; n; memset(tu, 0, sizeof(tu)); x = 1; y = 0; order = 0; for (int i = 1; i &lt;= n*n; i++) &#123; int nx = x + movex[order]; int ny = y + movey[order]; if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; n || tu[nx][ny] != 0) &#123; order = (order + 1) % 4; nx = x + movex[order]; ny = y + movey[order]; &#125; x = nx; y = ny; tu[x][y] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; printf(&quot;%3d&quot;, tu[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 例题：P4924 魔法少女小Scarlet本题涉及矩阵的旋转，实际操作起来还是有点麻烦。这里我们按旋转的中心来重建坐标系的话，可以观察到如下规律： 顺时针旋转：(a, b) -&gt; (b, -a) 逆时针旋转：(a, b) -&gt; (-b, a) 这样，我们就可以构建关键的旋转代码了，假如我们是基于中心点 (x, y) 半径是 r 的顺时针旋转的话，那么，对于坐标 (a, b)，我们： 首先：把它移动到以 (x, y) 为中心：(a-x, b-y) 然后：我们把坐标按上面的规则变换成 (b-y, x-a) 最后：我们把坐标加上 (x, y) 的偏移，还原成原始坐标：(b-y+x, x-a+y) 以上逻辑写成代码是：g[b-y+x][x-a+y]=f[a][b] 同理，如果是逆时针旋转： 首先：把它移动到以 (x, y) 为中心：(a-x, b-y) 然后：我们把坐标按上面的规则变换成 (y-b, a-x) 最后：我们把坐标加上 (x, y) 的偏移，还原成原始坐标：(y-b+x, a-x+y) 以上逻辑写成代码是：g[y-b+x][a-x+y]=f[a][b] 本题保证了数据不会在旋转时越界，整体的参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 510int f[MAXN][MAXN], g[MAXN][MAXN];int n, m;int main() &#123; cin &gt;&gt; n &gt;&gt; m; int cnt = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = cnt++; &#125; &#125; for (int i = 1; i &lt;=m; ++i) &#123; int x, y, r, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; z; if (z == 0) &#123; for (int a = x-r; a &lt;= x+r; ++a) for (int b = y-r; b &lt;= y+r; ++b) g[b-y+x][x-a+y]=f[a][b]; &#125; else &#123; for (int a = x-r; a &lt;= x+r; ++a) for (int b = y-r; b &lt;= y+r; ++b) g[y-b+x][a-x+y]=f[a][b]; &#125; for (int a = x-r; a &lt;= x+r; ++a) for (int b = y-r; b &lt;= y+r; ++b) f[a][b] = g[a][b]; &#125; // end of m for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 例题：P1205 USACO1.2 方块转换 Transformations此题需要推导矩阵旋转的规律。我们可以把原坐标和新坐标写下来，做成一个表格。 然后，我们把坐标的变化写成下面的表格形式： 通过观察，我们发现： 黄色和红色的坐标在变换前后刚好相等，即： 新 x = 原 y 两侧的白色的坐标加和刚好等于 n-1，即：原 x + 新 y = n - 1 &#x3D;&gt; 新 y = n - 原 x - 1 综上，坐标变换公式为：新(y, n-x-1)=原(x, y) 。 所以，坐标变换相关代码为： 12345for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp[y][n-x-1] = ori[x][y]; &#125;&#125; 与此类似，我们可以推出“反射”的代码关系是 新(x,n-y-1)=原(x,y)，相关变换代码为： 12345for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp[x][n-y-1] = ori[x][y]; &#125;&#125; 完整的参考代码如下（可以把 debug 变量设置成 true 来查看执行过程）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;char ori[12][12], dest[12][12];char tmp[12][12], tmp2[12][12];int n;bool debug = false;bool match(char a[12][12], char b[12][12]) &#123; for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; if (a[x][y] != b[x][y]) return false; &#125; &#125; return true;&#125;void print(char a[12][12]) &#123; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; ori[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; dest[i]; &#125; // 方案一 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp[y][n-x-1] = ori[x][y]; &#125; &#125; if (debug) &#123; cout &lt;&lt; &quot;debug 1: &quot; &lt;&lt; endl; print(tmp); &#125; if (match(tmp, dest)) &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; return 0; &#125; // 方案二 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp2[y][n-x-1] = tmp[x][y]; &#125; &#125; if (match(tmp2, dest)) &#123; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; return 0; &#125; // 方案三 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp[y][n-x-1] = tmp2[x][y]; &#125; &#125; if (match(tmp, dest)) &#123; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; return 0; &#125; // 反射 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp[x][n-y-1] = ori[x][y]; &#125; &#125; if (match(tmp, dest)) &#123; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; return 0; &#125; // 反射+旋转90 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp2[y][n-x-1] = tmp[x][y]; &#125; &#125; if (debug) &#123; cout &lt;&lt; &quot;debug 5-1: &quot; &lt;&lt; endl; print(tmp2); &#125; if (match(tmp2, dest)) &#123; cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; return 0; &#125; // 反射+旋转180 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp[y][n-x-1] = tmp2[x][y]; &#125; &#125; if (debug) &#123; cout &lt;&lt; &quot;debug 5-2: &quot; &lt;&lt; endl; print(tmp); &#125; if (match(tmp, dest)) &#123; cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; return 0; &#125; // 反射+旋转270 for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; tmp2[y][n-x-1] = tmp[x][y]; &#125; &#125; if (debug) &#123; cout &lt;&lt; &quot;debug 5-3: &quot; &lt;&lt; endl; print(tmp2); &#125; if (match(tmp2, dest)) &#123; cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; return 0; &#125; // 不改变 if (match(ori, dest)) &#123; cout &lt;&lt; &quot;6&quot; &lt;&lt; endl; return 0; &#125; cout &lt;&lt; &quot;7&quot; &lt;&lt; endl; return 0;&#125; 更多练习： P5729 深基5.例7 工艺品制作 P5732 深基5.习7 杨辉三角 P5730 深基5.例10 显示屏 P1789 我的世界-插火把 P1319 压缩技术 P1320 压缩技术 续集版 P2615 NOIP 2015 提高组 神奇的幻方 B3940 GESP样题 四级 填幻方 游戏模拟游戏模拟类的题目通常会告诉你一个相对复杂一点的游戏规则，然后让你用程序将这个游戏规律实现，最终将游戏的结果输出出来。 这种题目一方面考查了读题能力，需要对游戏规则的理解清楚，另一方面则是要对游戏规则进行建模，用合适的数据结构实现游戏中的模拟。 以下是一些相关的题目。 题号 描述 P1042 NOIP 2003 普及组 乒乓球 P1328 NOIP 2014 提高组 生活大爆炸版石头剪刀布 P1518 USACO2.4 两只塔姆沃斯牛 The Tamworth Two P1089 NOIP 2004 提高组 津津的储蓄计划 P1161 数组标记 滑动窗口例题：P1614 爱与愁的心痛此题的解法是：构造一个“滑动的窗口”。先求出前 m 个数的和，这相当于窗口的原始位置。之后每次让窗口往右移动一格。每次移动的时候，会将最左侧的数字剔除，同时纳入一个新数字。如下图所示： 我们在滑动窗口的时候，需要用这个变量，分别指向： 当前窗口最左的数字 p1 当前窗口下一个要加入的数字 p2 在滑动的时候，不断更新当前窗口的值 tot 以下是关键代码： 12345678p1 = 0;p2 = m;while (p2 &lt; n) &#123; tot -= v[p1]; tot += v[p2]; ans = min(ans, tot); p1++; p2++;&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, tot, ans;int p1, p2;int v[3300];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; v[i]; &#125; // 初使化滑动窗口 tot = 0; for (int i = 0; i &lt; m; ++i) &#123; tot += v[i]; &#125; ans = tot; p1 = 0; p2 = m; // 滑动窗口，更新值 while (p2 &lt; n) &#123; tot -= v[p1]; tot += v[p2]; ans = min(ans, tot); p1++; p2++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 模拟输入输出有一些模拟需要我们有比较复杂的输入和输出操作技巧。在模拟输入和输出的时候，常用的两个函数是 sscanf 和 snprintf，其中： sscanf 允许我们从一个字符串中读入内容。 snprintf 允许我们将输出内容先输出到一个字符串中。 以下我们用例题来演示其用法。 例题：P1957 口算练习题此题的输入长度不固定，我们需要先判断输入的长度。同时，输出的时候，我们还需要输出“输出内容”的长度。这对我们处理输入和输出都带来了挑战。 我们可以把表达式整行整行读入，再用 sscanf 和 snprintf 来进行分析处理。以下是相关的示意： 1234int a, b;char s[100], out[100];sscanf(s, &quot;%d%d&quot;, &amp;a, &amp;b);snprintf(out, sizeof(out), &quot;%d+%d=%d&quot;, a, b, a + b); 另外，我们还需要一次读入一整行，我用的方法是用 scanf, 代码如下： 12scanf(&quot;%[^\\n]&quot;, s);getchar(); 需要注意，以上代码每读入一行，需要用 getchar() 将行末的换行给读掉。 我们也可以用 cin.getline(s, sizeof(s)); 来读取数据。 以下是完整的示意代码： 12345678910111213141516171819202122232425262728293031/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int T, a, b;char ch, s[100], out[100];int main() &#123; scanf(&quot;%d&quot;, &amp;T); getchar(); while (T--) &#123; scanf(&quot;%[^\\n]&quot;, s); getchar(); if (s[0] &gt;=&#x27;0&#x27; &amp;&amp; s[0] &lt;= &#x27;9&#x27;) &#123; // 也可使用函数： isdigit(s[0]) sscanf(s, &quot;%d%d&quot;, &amp;a, &amp;b); &#125; else &#123; sscanf(s, &quot;%c%d%d&quot;, &amp;ch, &amp;a, &amp;b); &#125; memset(out, 0, sizeof(out)); if (ch == &#x27;a&#x27;) &#123; snprintf(out, sizeof(out), &quot;%d+%d=%d&quot;, a, b, a + b); &#125; else if (ch == &#x27;b&#x27;) &#123; snprintf(out, sizeof(out), &quot;%d-%d=%d&quot;, a, b, a - b); &#125; else if (ch == &#x27;c&#x27;) &#123; snprintf(out, sizeof(out), &quot;%d*%d=%d&quot;, a, b, a * b); &#125; printf(&quot;%s\\n&quot;, out); printf(&quot;%lu\\n&quot;, strlen(out)); &#125; return 0;&#125; 以上的 scanf 部分如果替换成 cin，示意代码如下： 123456789int main() &#123; cin &gt;&gt; T; cin.getline(s, sizeof(s)); while (T--) &#123; cin.getline(s, sizeof(s)); // 省略 &#125; return 0;&#125; 例题：P1067 多项式输出此题是 NOIP 2009 普及组的题目。此题练习了 snprintf 的使用。同时，此题用 printf 的 %+d 可以保证正数输出带+号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n;string ans;char outs[100];int main() &#123; ans = &quot;&quot;; cin &gt;&gt; n; for (int i = n; i&gt;=0; i--) &#123; int a; cin &gt;&gt; a; // 系数为0，跳过 if (a == 0) continue; // 指数为0，单独处理 if (i == 0) &#123; memset(outs, 0, sizeof(outs)); snprintf(outs, sizeof(outs), &quot;%+d&quot;, a); ans += outs; &#125; else &#123; // 先处理系数 if (a == 1) &#123; snprintf(outs, sizeof(outs), &quot;+x&quot;); &#125; else if (a == -1) &#123; snprintf(outs, sizeof(outs), &quot;-x&quot;); &#125; else &#123; snprintf(outs, sizeof(outs), &quot;%+dx&quot;, a); &#125; ans += outs; // 再处理指数 memset(outs, 0, sizeof(outs)); if (i == 1) &#123; snprintf(outs, sizeof(outs), &quot;&quot;); &#125; else &#123; snprintf(outs, sizeof(outs), &quot;^%d&quot;, i); &#125; ans += outs; &#125; &#125; if (ans[0] == &#x27;+&#x27;) &#123; ans = ans.substr(1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1010 NOIP 1998 普及组 幂次方此题的技巧是利用递归来循环处理。特殊情况是 2^1 写作 2，而不是 2(0)。参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637/* * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;string conv(int n) &#123; if (n == 0) return &quot;0&quot;; else if (n == 1) return &quot;2(0)&quot;; else if (n == 2) return &quot;2&quot;; else &#123; string ret = &quot;&quot;; int base = 1; int cnt = 0; while (n &gt;= base) &#123; if (n &amp; base) &#123; string sub = &quot;&quot;; if (base == 2) sub = &quot;2&quot;; else sub = &quot;2(&quot;+conv(cnt)+&quot;)&quot;; if (ret == &quot;&quot;) ret = sub; else ret = sub + &quot;+&quot; + ret; &#125; base &lt;&lt;= 1; cnt++; &#125; return ret; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; conv(n) &lt;&lt; endl; return 0;&#125; 更多练习： P5734 深基6.例6 文字处理软件 P1308 NOIP 2011 普及组 统计单词数 P1098 NOIP 2007 提高组 字符串的展开 P1065 NOIP 2006 提高组 作业调度方案 字符串操作B3927 GESP202312 四级 小杨的字典此题需要操作字符进行替换操作，是比较复杂的字符串模拟。此题我们可以用 map 来简化字符串的映射关系管理。map 的 find 函数可以返回一个迭代器，该迭代器的值： 当查找失败时，值为 end() 当查找成功时，值为一个 pair，分别是对应查询的 key 和 value。 123456789101112131415161718192021222324252627282930313233343536373839/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n;map&lt;string, string&gt; m;map&lt;string, string&gt;::iterator it;string a, b, s;void process(string&amp; s) &#123; if (s.length() != 0) &#123; it = m.find(s); if (it!=m.end()) cout &lt;&lt; it-&gt;second; else cout &lt;&lt; &quot;UNK&quot;; s = &quot;&quot;; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a &gt;&gt; b; m[a] = b; &#125; char ch; s = &quot;&quot;; while (cin &gt;&gt; ch) &#123; if (ch&gt;=&#x27;a&#x27; &amp;&amp; ch &lt;=&#x27;z&#x27;) s = s + ch; else &#123; process(s); cout &lt;&lt; ch; &#125; &#125; process(s); return 0;&#125; 其它模拟题目 题号 描述 P1241 括号序列 考查语文能力，容易读错题意 P1241 括号序列此题纯考读题。在找小括号对应的左括号的时候，找到 ( 或 [都算找到。只是找到后，如果不匹配，就算匹配失败。否则算匹配成功。 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;// 原串string s;// 匹配成功标记bool flag[110];bool match(char a, char b) &#123; return (a == &#x27;(&#x27; &amp;&amp; b == &#x27;)&#x27;) || (a == &#x27;[&#x27; &amp;&amp; b == &#x27;]&#x27;);&#125;string change(char a) &#123; if (a == &#x27;(&#x27; || a == &#x27;)&#x27;) return &quot;()&quot;; else return &quot;[]&quot;;&#125;int main() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; s.length(); ++i) &#123; // 如果它是一个右括号 if (s[i] == &#x27;]&#x27; || s[i] == &#x27;)&#x27;) &#123; // 考察它与它左侧离它最近的未匹配的的左括号 for (int j = i-1; j &gt;=0; --j) &#123; // 如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号）， // 则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。 if (!flag[j] &amp;&amp; (s[j] == &#x27;(&#x27; || s[j] == &#x27;[&#x27;)) &#123; if (match(s[j], s[i])) &#123; flag[i] = flag[j] = true; &#125; break; &#125; &#125; &#125; &#125; for (int i = 0; i&lt;s.length(); ++i) &#123; if (flag[i]) cout &lt;&lt; s[i]; else cout &lt;&lt; change(s[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"斑马思维机的详细调研","slug":"zebra-logic-introduction","date":"2025-03-09T09:39:07.000Z","updated":"2025-03-11T21:17:16.760Z","comments":true,"path":"2025/03/09/zebra-logic-introduction/","permalink":"https://blog.devtang.com/2025/03/09/zebra-logic-introduction/","excerpt":"","text":"一、产品介绍 斑马思维机是针对 2-8 岁儿童的全科启蒙学习机。由在线教育集团“猿辅导”旗下的斑马品牌在 2022 年 11 月推向市场，并在 2023 年 8 月升级为二代产品：斑马思维机 G2。 它包含语文、思维、英语、音乐等学科内容，通过纸质的题卡结合点触交互的形式，让孩子在不同情景主题场景下互动，通过互动答题的形式，完成内容的教学。插卡自动出题，孩子通过点触答题。答对有鼓励，答错会有提醒，孩子可以自主完成从插卡到答题的整个过程。 相比别的早教学习机，斑马思维机的核心特点是没有传统的屏幕。它用纸质题卡来完成学习交互，在完成学习的同时可以有效保护低幼孩子的眼睛，防止过早接触电子屏幕产生沉迷。 产品上线后累计销量突破 100 万台，2023 年和 2024 年连续两年全国销量第一。 斑马思维机主要具备如下产品优势： 1、专业教研团队邀请了三位行业专家共同参与内容研发，分别是： 曹立宏教授：中国传媒大学的脑科学专家。 刘嘉教授：清华大学心理学专家。同时也是“最强大脑”节目的科学总顾问。 蔡可教授：首都师范大学教育学专家。同时也是语文新课标的制定者。 在以上专家参与的同时，斑马结合自己斑马 AI 学产品的 3000 万用户的 100 亿次线上作答数据，为题卡的编制提供大数据支撑。 斑马思维机题卡构建了科学合理的分级进阶体系，分设 S0、S1、S2、S3 4 个难度级别。这种设置充分考虑了 2-8 岁儿童不同阶段的认知水平和思维发展能力。题卡难度逐阶递增、螺旋上升，能够循序渐进地开发儿童大脑潜能。 2、纸屏护眼不同于传统有屏幕的学习机，斑马思维机通过插卡+点触的方式来学习，可以有效减少孩子接触电子屏幕的时间，防止孩子过早接触屏幕，影响视力。 每张题卡上都有丰富的主题元素，帮助孩子建立起学习的兴趣。 每张纸质题卡都用了食品级白卡和大豆油墨印刷，保证对孩子安全。 3、全科启蒙斑马思维机的题卡包含语文、思维、英语三大核心题卡，相关的内容体系分为 S0、S1、S2、S3 4 个难度级别，且难度分级科学合理，充分满足不同年龄段孩子的学习需求。其中： 级别 针对年龄 培养重点 S0 2-3 习惯养成 S1 3-4 兴趣培养 S2 4-5 知识积累 S3 5+ 应用拓展 4、无限扩展斑马思维机的题卡支持无限扩展，随着产品研发不断的持续，斑马思维机在语文、思维、英语题卡的基础上，又逐步上新了迪士尼、鲨鱼宝宝、音乐、专注力、故官等主题题卡。其中： 2023 年 12 月，与迪士尼官方合作上新迪士尼题卡。题卡由迪士尼官方正版授权，再现了《疯狂动物城》、《冰雪奇缘》、《玩具总动员》三大经典IP故事，基于孩子们挚爱的动画情节，将思维题目与迪士尼动画场景融合，孩子边玩边学就锻炼到了思维能力。 2024 年 7 月，与“打开故宫”合作上新故宫题卡。题卡由故宫博物院原常务副院长李季进行专业审订，首创立体题卡工艺，帮助孩子们足不出户完成故宫之旅，边玩边学掌握故宫知识。 2024 年 10 月，与 Pinkfong 联名推出鲨鱼宝宝题卡。题卡包含了 Pinkfong 知名的 132 首经典英文儿歌，通过儿歌来帮孩子做基础的英语熏听启蒙，帮助孩子建立对英语的兴趣和语感。其中的儿歌 《Baby shark》为全球播放量第一的儿歌（吉尼斯世界记录认证）。 2024 年 12 月，推出音乐题卡。内容包括 38 组乐理知识、52 种乐器探索、16 种音乐文化和 48 首儿歌鉴赏，帮助孩子完成音乐启蒙。 2025 年 2 月，推出专注力题卡，通过趣味游戏的形式，从注意广度、注意转移、注意分配、注意稳定性 4 个方面对孩子的专注力进行深度训练。 二、内容体系语文斑马思维机语文题卡共 265 张，包括 6 个知识模块：汉字、词语、成语常言、古诗歌谣、表达结构、国学常识。另外在 S3 级别中，额外增加了拼音专题。 知识模块 内容量 识字 372字，情景交互式学习，一页学 1-3 个字 成语 81 个 日常表达 36 个 古诗 72 首 传统文化 36 个 歌谣 12 首 拼音 12 张卡，认识+认读 思维斑马思维机思维题卡共 241 张，包括 6 个知识模块：视听与记忆、数感与模型、图形与空间、逻辑与规律、实践与规划、动手与益智。 英语斑马思维机英语题卡共 265 张，包括 5 个知识模块：字母与发音、单词、句型、儿歌、拓展应用。 知识模块 内容量 字母认知 26 个字母 自然拼读 30 个自然拼词规则 核心词汇 518 个词汇 日常表达 78 组句型表达 韵律儿歌 48 首经典儿歌 拓展应用-开口 36 个日常情景应用 音乐音乐题卡共 72 张，内容包括 38 组乐理知识、52 种乐器探索、16 种音乐文化和 48 首儿歌鉴赏，帮助孩子完成音乐启蒙。 专注力专注力题卡共 72 张，内容从注意广度、注意转移、注意分配、注意稳定性 4 个方面对孩子的专注力进行深度训练。 鲨鱼宝宝题卡鲨鱼宝宝共 36 张，题卡包含了 Pinkfong 知名的 132 首经典英文儿歌。通过儿歌共熏听了 1400+ 单词，包含了 81% 的小学新课标二级核心词汇。 市场表现与竞争分析竞争壁垒斑马思维机为思维机品类开创者，拥有 6 项思维机专利和 8 项国际大奖。 斑马思维机专利情况： 专利名称 专利公告 机器专利1 http://epub.cnipa.gov.cn/cred/CN219533902U 机器专利2 http://epub.cnipa.gov.cn/cred/CN219609810U 结构专利 http://epub.cnipa.gov.cn/cred/CN219831980U 外观专利 http://epub.cnipa.gov.cn/cred/CN307609057S 立体题卡专利 http://epub.cnipa.gov.cn/cred/CN221766203U 滑动交互专利 http://epub.cnipa.gov.cn/cred/CN221613415U 斑马思维机获奖情况： Tillywig Toy Awards（堤利威格玩具奖），美国玩具行业最顶级的奖项之一 Creative Child Awards（儿童创意大奖），儿童创造力培养领域享有盛誉的国际大奖 K Design Award（K设计大奖），享誉全球的国际专业设计大奖 Mom’s Choice Awards（妈妈之选），国际母婴产品领域标杆奖项 The National Parenting Center Seal of Approval，美国国家育儿中心专业认证 Contemporary Good Design Award，当代好设计奖 TOY AWARD，中外玩具大奖 IDEA，国际卓越设计奖 以上专利和奖项为斑马思维机提供了不少竞争优势，帮助它持续提升产品端的用户体验。 市场销量上市以来，斑马思维机市场销量表现出色，受到众多家长青睐。在各大电商平台，其销售数据持续增长，斑马思维机连续两年稳居思维机品类的销量和销售额第一。 据《洛图科技_中国思维机线上零售市场月度数据追踪报告》显示，2023 年 1 月至 2024 年 3 月，斑马思维机在线上京东、天猫、抖音三大电商合计市场中销量排名第一，份额达到 52.8%; 销额排名第一，份额达到 66.8%。 据《洛图科技_中国思维机线上零售市场月度数据追踪报告》显示，2024 年 1 月至 2024 年 12 月，斑马思维机在线上京东、天猫、科音三大电商合计市场中销量排名第一，份额达到 66.6%; 销额排名第一，份额达到 72.9% 。 由以上数据可知，斑马思维机的市场占有率进一步扩大，从 2024 年初的 52.8% 上升到 2025 年初的 66.6%，进一步巩固了市场第一的地位。 在京东平台提供的 2025 年思维机热卖榜上，斑马思维机已连续占据榜首 131 天（数据截至 2025.03.09 ）。 在天猫平台提供的 2025 年学习机热卖榜上，斑马思维机占据 2000 元以下学习机热卖榜第一（数据截至 2025.03.09 ）。 同类思维机产品比较斑马思维机的主要竞争产品为学而思旗下的摩比思维机（又名：学而思思维机）。斑马思维机和摩比思维机哪个好呢？以下是一些多维度的比较数据。 1、发布时间从发布时间上看，斑马思维机较早，具有较大的先发优势： 斑马思维机 G1 在 2022 年 11 月正式发布，而摩比思维机正式发布的时间为 2023 年 5 月，落后斑马思维机 6 个月。 斑马思维机随后在 2023 年 8 月发布二代机型，而摩比思维机的二代机型同样落后半年多，在 2024 年 4 月发布。 较早的发布使斑马获得了更多的销量，并从销量中获得了更多的用户反馈，也积累了更多的用户迭代数据。这些数据和反馈帮助斑马思维机做到了更好的产品体验。用户普遍反馈斑马思维机点触灵敏；而摩比思维机点触通常不太灵敏，孩子点不准容易受到挫折，从而打击学习积极性。所以，从机器点触灵敏度角度，更推荐大家使用斑马思维机。 2、题卡设置斑马思维机的题卡设置结合了心理学、脑科学、教育学的专家经验和 3000 万孩子的行为大数据，难度设置更加科学合理，孩子不容易受到挫折。 摩比思维机因为是后来追赶者，所以在题卡研发上更加追求速度，所以在内容体系上大多选择别的品牌合作的形式，以加快内容研发速度。摩比在语文题卡上与“四五快读”合作，在英语题卡上与“剑桥英语”及“RAZ”合作，低龄题卡与小猪佩奇合作。 但是合作的形式使得摩比的题卡体系性和衔接性较差。例如： 斑马的语文分为 S0-S4 4 个级别，难度螺旋上升，对各个年龄段的孩子都很适配。摩比的语文因为“四五快读”只有识字，所以无法分级，只能提供识字包、古词包、拼音包这种专题形式。同时“四五快读”的趣味性较低，不太适合 2-4 岁的孩子启蒙，降低了低龄孩子家长的好感度和选购意愿。 斑马的英语为全美语体系。但是摩比的英语题卡分为英式英语的“剑桥英语”系列和美式英语的“RAZ”系列。两个系列混合提供不利于孩子建立标准的英语发音环境，家长会担心孩子练成既不英式也不美式的奇怪发音。 小猪佩奇题卡依赖于小猪佩奇的 IP，但近年来小猪佩奇的热度降低，进一步影响了摩比思维机的售卖。 所以，斑马思维机的题卡更受大部分的家长和孩子的喜爱。 3、硬件配置两者都是 Type-C 口的充电款机器。 斑马思维机的机器重量为 400g，较为轻便，方便携带，无需联网即可使用。 摩比思维机的机器重量为 500g，较为厚实，需要下载 App 连接 Wifi 才可激活使用。 在升级时，斑马思维机通过 U 盘升级，摩比思维机通过连接 Wifi 升级。 4、销量排名据公开数据，斑马思维机销量排名第一。其它思维机销量排名未知。","categories":[],"tags":[]},{"title":"CSPJ 教学思考：并查集","slug":"teaching-notes-of-union-query-set","date":"2025-02-09T13:20:27.000Z","updated":"2025-02-09T15:08:31.242Z","comments":true,"path":"2025/02/09/teaching-notes-of-union-query-set/","permalink":"https://blog.devtang.com/2025/02/09/teaching-notes-of-union-query-set/","excerpt":"","text":"并查集在引入之前，需要先教会学生集合的概念。 集合集合是数学中的一个基本概念，它是由一些确定的、彼此不同的对象所组成的整体。集合有两个特点： 集合中的元素是互不相同的。 集合中的元素没有顺序之分。比如集合 {1, 2, 3} 和 {3, 2, 1} 是同一个集合。 生活中的集合有很多，比如：班级，家庭成员，朋友等等。所以，学生还是比较容易理解的。 并查集并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。 并查集支持两种操作： 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合 合并（Merge）：合并两个元素所属集合（合并对应的树） 在教学并查集的时候，画示意图可以很好地让学生理解并查集的操作。 并查集的初始化我们用数组来表示并查集，用数组的值表示当前结点的父亲。如下图所示： 所以，初始化的代码如下： 12345678#define MAXN 1010int p[MAXN], n;void init() &#123; for (int i = 0; i &lt;= n ; ++i) &#123; p[i] = i; &#125;&#125; 并查集的查询操作并查集在查询时，从初始结点开始，判断自己是不是根结点。根结点的特征是自己是自己的父亲。如果自己不是根结点，则继续递归往上找。示例代码如下： 1234int find(int a) &#123; if (p[a] == a) return a; return find(p[a]);&#125; 我们在这儿，也顺便引入路径压缩的优化，告诉学生在返回值的时候，如果更新结点，就可以把下图中的长路径“拍扁”，使得下次查询的时候速度更快。 那么如何更新呢？只需要在上面的代码基础上做一点点改动，如下： 1234int find(int a) &#123; if (p[a] == a) return a; return p[a] = find(p[a]); // 在返回值之前，更新结点值&#125; 以上代码可以简化成一行：return p[a]==a ? a : (p[a] = find(p[a]));。但是教学的时候，还是展开让学生理解清楚后，再提供简化的写法比较好。 并查集的合并操作 合并的时候，像上图那样，我们把一个结点的根结点的父亲，指向另外一个根结点即可。 12345void merge(int a, int b) &#123; int pa = find(a); int pb = find(b); p[pa] = pb;&#125; 以上代码可以简化成一行：p[find(a)]=find(b);。但是教学的时候，还是展开让学生理解清楚后，再提供简化的写法比较好。 判断并查集中集合的个数因为有一个根结点，就代表有一个集合，所以我们可以数根结点的个数来得到集合的个数。 根结点的特点是：它的父结点就是自己。相关代码如下： 123456int cnt = 0;for (int i = 1; i &lt;=n; ++i) &#123; if (p[i] == i) &#123; cnt++; &#125;&#125; 并查集的练习题完成以上的基础教学，就可以练习了。并查集的考查主要就是两个： 判断两点是否联通 计算连通块（集合）的个数 以下是基础的练习题目。 题目 说明 P1551 亲戚 基础题 P1536 村村通 基础题 P1892 团伙 提高题，需要用反集 P3144 Closing the Farm S USACO 16 OPEN P1197 星球大战 JSOI 2008 P2024 食物链 NOI 2001 P1196 银河英雄传说 NOI 2002 反集当题目中引入了敌人关系，并且定义：“敌人的敌人是朋友”的时候，就可以用反集来求解了。 反集专门用于表示敌对关系，并且敌人的敌人是朋友。反集的思路是再构造一个集合（称之为反集），然后将“敌人”关系通过原集和反集表示出来。 我们看个例子： 比如假设有 3 个元素，1, 2, 3。我们称他们的反集元素分别为 1&#39; , 2&#39;, 3&#39;; 分别表示 1, 2, 3 的敌人。 这个时候，如果 1 和 2 是敌人，则： 因为 1&#39; 也是 1 的敌人, 所以 1&#39; 和 2 是朋友 因为 2&#39; 也是 2 的敌人, 所以 2&#39; 也是 1 的朋友 结果表示如下： 这个时候，如果 2 和 3 是敌人，则 2 和 3&#96; 是朋友 3 和 2&#96; 是朋友 结果表示如下： 我们可以看到，在这种操作下，1 和 3 自然就在一个集合中了（成为朋友了）。 以上逻辑在并查集中如何实现呢？我们将并查集的下标扩展一倍，用 n+1 ~ 2n 来表示反集元素。其中，元素 a 的反集是 a+n。 这个时候，如果 a 与 b 是敌人，则需要在并查集中做如下操作： 因为 a 与 b 是敌人，所以 a 与 b+n 就是朋友，需要 merge(a, b+n); 因为 a 与 b 是敌人，所以 b 与 a+n 就是朋友，需要 merge(b, a+n); P1892 团伙 是反集的典型例题，可以拿此题练习。 需要特别注意的是，因为此题需要判断集合数量，所以需要让 1~n 的元素当根结点，涉及合并操作的时候，不要让 1~n 的元素当反集元素的孩子。关健代码如下： 123456void merge(int a, int b) &#123; int fa = find(a); int fb = find(b); // b 有可能是反集，所以始终让 fb 在合并的时候当子结点 p[fb] = fa; &#125; P1892 团伙 的完整参考代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;int p[2010], n, m;int find(int a) &#123; if (p[a] == a) return a; return p[a] = find(p[a]);&#125;void merge(int a, int b) &#123; int fa = find(a); int fb = find(b); // b 有可能是反集，所以始终让 fb 在合并的时候当子结点 p[fb] = fa; &#125;int main() &#123; for (int i = 0; i &lt; 2010; ++i) &#123; p[i] = i; &#125; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; char ch[3]; int a, b; scanf(&quot;%s%d%d&quot;, ch, &amp;a, &amp;b); if (ch[0] == &#x27;F&#x27;) &#123; merge(a, b); &#125; else &#123; merge(a, b+n); merge(b, a+n); &#125; &#125; int cnt = 0; for (int i = 1; i &lt;=n; ++i) &#123; if (p[i] == i) &#123; cnt++; &#125; &#125; printf(&quot;%d\\n&quot;, cnt); return 0;&#125; 练习题参考代码P1551 亲戚标准的并查集，没有陷阱。 1234567891011121314151617181920212223242526272829303132333435363738/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,q;int p[5010];int find(int a) &#123; if (p[a] == a) return a; return p[a] = find(p[a]);&#125;void merge(int a, int b) &#123; int pa = find(a); int pb = find(b); p[pa] = pb;&#125;int main() &#123; int a, b; // 初始化 for (int i = 0; i &lt; 5010; ++i) &#123; p[i] = i; &#125; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); merge(a, b); &#125; for (int i = 0; i &lt; q; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (find(a) == find(b)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; P1536 村村通用并查集操作，然后数一下一共有多少个不同的集合，答案就是 集合数-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int p[1010], n, m;int find(int a) &#123; if (p[a] == a) return a; return p[a] = find(p[a]);&#125;void merge(int a, int b) &#123; int pa = find(a); int pb = find(b); p[pa] = pb;&#125;void init() &#123; for (int i = 0; i &lt;= n ; ++i) &#123; p[i] = i; &#125;&#125;int main() &#123; while (1) &#123; scanf(&quot;%d&quot;, &amp;n); if (n == 0) break; init(); scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); merge(a, b); &#125; int cnt = 0; for (int i = 1; i &lt;=n ; ++i) &#123; int pa = find(i); if (pa == i) &#123; cnt++; &#125; &#125; printf(&quot;%d\\n&quot;, cnt-1); &#125; return 0;&#125; 更多并查集还有更多的优化，比如在合并的时候，把高度小的树往高度大的树上合并，以尽可能减少树的高度，这样可以使得未来查询的时候效率更高。因为大多时候用不上，所以这些知识可以放在课后阅读中让学生自行掌握。 参考文档 https://oi-wiki.org/ds/dsu/ https://zhuanlan.zhihu.com/p/93647900 反集","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：二分查找","slug":"teaching-notes-of-binary-search","date":"2025-01-25T14:19:44.000Z","updated":"2025-08-09T22:52:24.350Z","comments":true,"path":"2025/01/25/teaching-notes-of-binary-search/","permalink":"https://blog.devtang.com/2025/01/25/teaching-notes-of-binary-search/","excerpt":"","text":"概述二分查找的基础逻辑很简单：我们小时候都玩过猜数字游戏，心里想一个数字（ 数字范围是 1-100），让对方猜，如果没猜对，就只告诉对方猜大了还是小了，看看最快几次能猜到。 这个游戏的最佳策略就是二分。先猜 50，如果大了，就猜 25。这样最多 7 次就可以猜到答案。 基础模版对于猜数字这个游戏来说，二分的模版最简单的就是如下形式： 1234567891011121314151617// 二分查找int left, right, mid, ans;left = 1;right = n;ans = -1;while (left &lt;= right) &#123; mid = left + (right-left) / 2; if (v[mid] &gt; a) &#123; right = mid - 1; &#125; else if (v[mid] &lt; a) &#123; left = mid + 1; &#125; else &#123; ans = mid; break; &#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot; &quot;; 以上代码需要注意的有以下几点： 查徇范围是 [left, right]，即 left 和 right 都是闭区间。 循环条件是left &lt;= right，即当 left == right时，还需要进行一次测试。 mid = left + (right-left) / 2其实等价于 mid = (left + right) / 2只是后者可能超界，用前者可以避免。 这种思路其实比较简单，写起来基本上不会犯错。但是，如果有多个目标值时，我们可能要多次更新 ans 变量。 P2249 查找就是一道例题，此题需要找到目标值第一次出现的位置，如果用上面的模版，我们需要多次更新 ans，参考代码如下： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int v[1000010];int n, m, a;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, v+i); while (m--) &#123; scanf(&quot;%d&quot;, &amp;a); int left, right, mid, ans; left = 1; right = n; ans = -1; while (left &lt;= right) &#123; mid = left + (right-left)/2; if (v[mid] &gt; a) &#123; right = mid - 1; &#125; else if (v[mid] &lt; a) &#123; left = mid + 1; &#125; else &#123; // 如果找到，则比较 ans 的值，更新它 if (ans == -1 || ans &gt; mid) ans = mid; right = mid - 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 另一种模版除了刚刚的模版外，我们还可以用另外一种写法来写二分：我们用 [l,r)来表示目标查找区间，注意这里是左闭右开的区间。然后，我们不停地尝试缩小这个区间： 情况 1：当目标值比 mid 值大的时候，新区间在 [mid+1, r) 情况 2：当目标值比 mid 值小的时候，新区间在 [l, mid) 情况 3：当目标值与 mid 值相等的时候，因为我们要找最小值，所以新区间在 [l, mid)。 以上的情况 2 和情况 3 是可以合并的。结果就是只需要写一个 if 就可以了，核心代码如下： 12345while (l &lt; r) &#123; mid = l + (r-l)/2; if (a &gt; v[mid]) l = mid + 1; else r = mid;&#125; 有同学可能会问：如果只有一个值相等，并且在 mid 位置，那以上做法不是把结果就跳出区间了？其实这种情况下，l 的值会一步步右移，最后的循环结束的结果会是 [mid,mid)。所以我们还是可以从循环结束的 l 值中读到目标值。 对于这种写法，我们的二分判断会少很多，只需要最后判断一下 l 的值是否是目标值，即可知道是否查找成功。 以下是参考代码（从以前的 32 行缩短为 24 行）： 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int v[1000010];int n, m, a;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, v+i); while (m--) &#123; scanf(&quot;%d&quot;, &amp;a); int l, r, mid; l = 1; r = n+1; while (l &lt; r) &#123; mid = l + (r-l)/2; if (a &gt; v[mid]) l = mid + 1; else r = mid; &#125; if (l &lt; n+1 &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; &quot; &quot;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 如果记不清楚，就分开写： 如果猜对了但要找最小值，就更新 r 如果 mid 大了，则答案在 mid 左侧，就更新 r 如果 mid 小了，则答案在 mid 右侧，就更新 l 另外，以上这种代码其实是不停在[l,mid) 和 [mid+1, r)之间做选择，所以： l 只会更新成 mid+1 r 只会更新成 mid 最后答案如果有，则在 l 位置，当然 l 位置也可能不是答案： 如果目标极小，没找到，则 l 位置为查找的范围最左侧下标 如果目标极大，没找到，则 l 位置为最初的 r 的位置（那个位置是最后一个元素的下一个位置，直接读取会数组越界） lower_bound其实上面那个写法就是 C++ STL 里面的 lower_bound 函数，所以我们可以直接用 lower_bound 函数来实现 P2249 题。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int v[1000010];int n, m, a;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, v+i); while (m--) &#123; scanf(&quot;%d&quot;, &amp;a); int l = lower_bound(v+1, v+n+1, a) - v; if (l &lt; n+1 &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; &quot; &quot;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 函数 lower_bound 在 [first,last) 中的前闭后开区间进行二分查找，返回大于或等于目标值的第一个元素位置。如果所有元素都小于目标值，则返回 last 的位置。 这种函数行为初看很奇怪，因为它： 当找到目标值时，它返回达找到的值的第一个位置 当没有目标值时，它返回第一个大于目标值的位置 当所有元素都小于目标值时，它返回 last 的位置 这实际上就是它的内部实现所致（可以理解为这种写法的side effect），它内部实现就是我们刚刚提到的写法，所以才会这么返回目标值。 如果我们想把查找结果转换成数组下标，只需要让它减去数组首地址即可，像这样： 1int idx = lower_bound(v, v+n, a) - v; upper_bound除了 lower_bound 函数之外，C++还提供了 upper_bound 函数。lower_bound 在 [first, last) 中的前闭后开区间进行二分查找，返回第一个比目标值大的位置。如果没找到，则返回 last 的位置。 upper_bound 的内部实现逻辑是： 如果猜对了但要找最大值，就更新 l 如果 mid 大了，则答案在 mid 左侧，就更新 r 如果 mid 小了，则答案在 mid 右侧，就更新 l 为了方便对比，我把 lower_bound 的逻辑再写一下： 如果猜对了但要找最小值，就更新 r 如果 mid 大了，则答案在 mid 左侧，就更新 r 如果 mid 小了，则答案在 mid 右侧，就更新 l 你看出来了吗？只是第一个更新的逻辑不一样。所以，其实两者的代码很像，我自己分别写了二者的一个实现，大家可以对比看一下，实际上二者实现部分只差了一个字符： 12345678910111213141516171819202122232425// 如果目标值等于或者小于 mid，则 r = m// 如果目标值大于 mid，则 l = m+1int lower_bound(int a) &#123; int l, r; l = 0; r = n; while (l &lt; r) &#123; int m = l + (r-l)/2; if (a &gt; v[m]) l = m+1; else r = m; &#125; return l;&#125;// 如果 mid 值小于等于目标，就 l=m+1// 如果 mid 值大于目标，就 r=mint upper_bound(int a) &#123; int l, r; l = 0; r = n; while (l &lt; r) &#123; int m = l + (r-l)/2; if (a &gt;= v[m]) l = m+1; else r = m; &#125; return l;&#125; 我们 upper_bound 考虑几种情况： 如果目标值极小，那么一直就更新 r，结果返回的就是首地址，为正确值。 如果目标值极大，那么一直就更新 l，结果返回的就是 last。 所以 upper_bound 如果没找到，会返回 last。 我们再看 lower_bound 如果目标值极小，那么一直就更新 r，结果返回的就是首地址，为第一个大于目标值的地址。 如果目标值极大，那么一直就更新 l，结果返回的就是 last。 所以，其实这两个函数在没找到目标值的情况下，都有可能返回首地址或末地址的。只是对于 upper_bound 函数来说，首地址是有意义的。 而 lower_bound 函数返回的首地址怎么说呢？有点像 side effect。很少有需求是求这个地址，所以很多时候要特殊处理一下，就像我们刚刚例题里面又判断了一下一样(如下所示) 1if (l &lt; n+1 &amp;&amp; v[l] == a) cout &lt;&lt; l &lt;&lt; &quot; &quot;; 二分答案二分不但能用于查找数值，还可以用来暴力尝试答案。因为即便是 0-20 亿这么大的范围的猜数字游戏，也只需要 30 多次就可以猜到，所以如果某个问题可以像猜大小一样，每次获得答案是大了还是小了，就可以用二分的办法来“二分答案”。 对于二分答案一类的题目，最常见的题目描述特征是求某某值的最大值最小，或者最小值最大。这个特征可以作为我们选择二分解题的小提示。我们在练习题目 P2678 跳石头 和 P1182 数列分段 Section II 中就可以看到这种提示。 教学和练习题目教学题目： 题目 说明 P2249 查找 可用 lower_bound 函数 P1102 A-B 数对 也可使用 STL map P1873 砍树 二分答案 P3853 路标设置 天津省选，二分答案 P1678 烦恼的高考志愿 二分查找，可用 upper_bound 函数 P2440 木材加工 二分答案 P2678 跳石头 二分答案，NOIP2015 提高组 P1182 数列分段 Section II 二分答案 练习题目： 题目 说明 P1296 奶牛的耳语 用 upper_bound 二分 B4305 物品分组 蓝桥杯青少年组省赛 2024，二分答案 P1258 小车问题 二分答案 P1824 进击的奶牛 Aggressive Cows G USACO05FEB, 二分答案 P3853 路标设置二分答案+判定。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int L, N, K;int v[100010];bool check(int mid) &#123; int ans = 0; for(int i=1; i&lt;N; i++)&#123; if(v[i]-v[i-1] &gt; mid)&#123; ans += (v[i]-v[i-1]-1)/mid; &#125; &#125; if(ans&lt;=K)&#123; return true; &#125; return false; &#125;int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;L, &amp;N, &amp;K); for (int i = 0; i &lt; N; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; int left, right, mid, ans = INT_MAX; left = 1; right = L; while (left &lt;= right) &#123; mid = (left + right) / 2; if (check(mid)) &#123; right = mid - 1; ans = min(ans, mid); &#125; else &#123; left = mid + 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1678 烦恼的高考志愿123456789101112131415161718192021222324252627/** * 二分查找。 * 用 upper_bound 找到第一个大的位置 idx，然后取 idx 和 idx - 1, 分别试一下。 * idx 可能是 0 或者末尾（idx == m），要特殊处理一下。 */#include &lt;bits/stdc++.h&gt;using namespace std;int m, n, vm[100010], a;long long ans = 0;int main() &#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (int i = 0; i &lt; m; ++i) scanf(&quot;%d&quot;, vm+i); sort(vm, vm+m); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;a); int diff = INT_MAX; int idx = upper_bound(vm, vm+m, a)-vm; if (idx != m) diff = min(diff, abs(vm[idx]-a)); if (idx - 1 &gt;=0 ) diff = min(diff, abs(vm[idx-1]-a)); ans += diff; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2440 木材加工123456789101112131415161718192021222324252627282930313233343536/** * 二分答案 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;int v[100010];bool check(int mid) &#123; int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; cnt += v[i]/mid; if (cnt &gt;= k) return true; &#125; return false;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; int left = 1; int right = (int)1e8; int ans = 0; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (check(mid)) &#123; left = mid + 1; ans = max(ans, mid); &#125; else &#123; right = mid - 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2678 跳石头二分答案：用 mid 去试跳，如果间距小于 mid，则去掉那个石头，如果去掉个数超过 k 个，则失败。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int ed, n, k;int v[50010];// 用 mid 去试跳，如果间距小于 mid，则去掉那个石头，如果去掉个数超过 k 个，则失败。bool check(int mid) &#123; int cnt = 0; int diff = 0; for (int i = 1; i &lt;= n+1; ++i) &#123; int dis = v[i] - v[i-1] + diff; if (dis &lt; mid) &#123; cnt++; diff = dis; if (cnt &gt; k) return false; &#125; else &#123; diff = 0; &#125; &#125; return true;&#125;int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;ed, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; v[0] = 0; // 起点 v[n+1] = ed; // 终点 int left = 1; int right = ed; int ans = 0; while (left &lt;= right) &#123; int mid = left + (right-left)/2; if (check(mid)) &#123; ans = max(ans, mid); left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; P1182 数列分段 Section II二分答案。对目标答案每 mid 分一段，如果分出来的段数 &lt;&#x3D; m 即为真。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, v[100010];bool check(int mid) &#123; int tot = 0; int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; cnt += v[i]; if (v[i] &gt; mid) return false; if (cnt &gt; mid) &#123; tot++; cnt = 0; i--; &#125; &#125; if (cnt != 0) tot++; if (tot &lt;= m) return true; else return false;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; int left = 1; int right = (int)(1e9 + 1); int ans = INT_MAX; while (left &lt;= right) &#123; int mid = (left+right)/2; if (check(mid)) &#123; ans = min(ans, mid); right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1258 小车问题此题也可以列方程，但是也是一道很有技巧的二分答案的题目，适合用来练习二分的使用技巧。 二分答案，需要二分的值与判定的结果有一个单调关系。如果我们假设一开始把甲载到的位置是 C 点，如果简单二分位置 C，那么得到的两人到达的总时长，并不是单调的。 但是，如果我们二分位置 C，但是判断的是甲与乙的时间差 t1-t2，就会发现：随着 C 的值变大，t1-t2 会单调变小。这就形成了一个单调关系。而我们要找的答案，就是 t1-t2 最接近 0 的位置。 所以，我们就可以二分了，每次二分位置 C: 如果 t1-t2 大于零，则可以增大 C，让 left&#x3D;mid 如果 t1-t2 大于零，则可以减小 C，让 right&#x3D;mid 这样，C 的值最终会无限趋近于 t1-t2 等于零的位置。 另外，我们可以较容易推算出甲乙分别的用时公式： 甲的总用时 t1 = 开车时间 c/b + 步行时间 (s-c)/a 乙的总用时 t2 = 开车送甲的时间c/b + 相遇问题时间 + 开车时间 开车送甲的时间: m1 = c/b 相遇问题时间: m2=(c-c/b*a)/(a+b) 开车时间: m3= (s-m1*a-m2*a)/b 那终止条件是什么呢？我们的答案是要求精度达到小数点后 6 位。所以，我们让 t1-t2 的差小于小数点后 7 位即可。为什么是 7 位而不是 6 位呢？因为如果我们只保证他们的差小于小数点后 6 位，那第 7 位就会涉及四舍五入的问题，这样会造成第 6 位输出的时候有影响。 小结一点，这道题比较难想到的有： 二分的单调性函数 终止条件 精度要多求一位 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;double s, a, b, ans;double get_t1(double c) &#123; return c/b + (s-c)/a;&#125;double get_t2(double c) &#123; double m1 = c/b; double m2 = (c-c/b*a)/(a+b); double m3 = (s-m1*a-m2*a)/b; return m1+m2+m3;&#125;int main() &#123; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b; double left = 0; double right = s; while (left &lt;= right) &#123; double mid = left + (right-left)/2; double t1 = get_t1(mid); double t2 = get_t2(mid); double diff = t1 - t2; if (diff &gt; 0) &#123; left = mid; if (diff &lt; 1e-7) &#123; ans = t1; break; &#125; &#125; else &#123; right = mid; &#125; &#125; printf(&quot;%.6lf\\n&quot;, ans); return 0;&#125; 教学思考因为lower_bound 和 upper_bound的写法相比传统写法还是有点复杂，在教学中还是适合用最初的那个易懂的版本。易懂的版本虽然执行起来多几次判断，但是在比赛中这一点多的时间并不影响整体的时间复杂度，所以不会因此扣分。同时，简单易于理解的代码，在学习和解题时，也更加不容易犯错。 待学生理解基础二分的写法后，再把系统的实现拿出来，作为增强的补充练习题目。这么补充练习并不是要学生一定掌握，而是借由实现系统的函数，学会在比赛中调用 C++ 的 lower_bound 和 upper_bound 库函数，这样可以加速解题的速度。 二分答案的思路很好理解，但是实际写起来还是很容易晕，所以需要多加练习。另外利用题目特征来获得提示，帮助自己快速解题。 小结 lower_bound 和 upper_bound 都是极简二分查找的 C++ 内部实现。 因为它们都有 side effect，所以在查找目标不存在时，均可能返回首地址和末地址（取决于目标是极小还是极大）。 因为以上的 side effect，所以我们给 lower_bound 赋予了额外的功能：返回第一个大于或等于目标值的位置；如果不存在返回 last。 upper_bound 在目标值极小的时候，返回首地址（正好符合要求）；在目标值极大的时候，返回 last。 因为 lower_bound 有可能返回的不是目标值，所以最后要判断一下。","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：动态规划","slug":"teaching-notes-of-dp","date":"2025-01-05T10:03:48.000Z","updated":"2025-07-06T14:44:05.819Z","comments":true,"path":"2025/01/05/teaching-notes-of-dp/","permalink":"https://blog.devtang.com/2025/01/05/teaching-notes-of-dp/","excerpt":"","text":"引言动态规划是 CSPJ 拉分的关键知识点。 之所以这样，是因为动态规划不像 DFS、BFS、二分那样有固定的模版格式。学生要在动态规划问题上融汇贯通，需要花费大量的练习，也需要足够的聪明。 笔者自己在高中阶段，也是在动态规划问题上困扰许久。我自己的学习经验是：动态规划还是需要多练，练够 100 道题目，才能够熟悉动态规划的各种变型。之后在比赛中看到新的题目，才会有点似曾相识的感觉，进一步思考出状态转移方程。 所以，我打算写 100 道动态规划方程的题解，希望有志攻破此难关的学生和家长一起加油！ 动态规划解题的核心问题虽然动态规划没有模版可以套，但是动态规划有三个核心问题： 状态的定义 状态转移方程 初始状态的设置 一般思考动态规划就是思考以上三个问题，这三个问题解决了，动态规划的程序也可以写出来了。 教学题目推荐的教学题目如下： 题目名 说明 P2842 纸币问题 1 基础 DP，记忆化搜索 P1216 数字三角形 基础 DP，记忆化搜索 【经典 DP】 P2840 纸币问题 2 基础 DP P2834 纸币问题 3 基础 DP，有多处可优化的点 P1048 采药 NOIP2005 普及组第三题。01 背包问题。【经典 DP】 P1616 疯狂的采药 完全背包问题。【经典 DP】 P2196 挖地雷 NOIP1996 提高组第三题。涉及输出路径技巧。 P1434 滑雪 上海市省队选拔 2002 P1115 最大子段和 最大子段和。【经典 DP】 适合的作业： 题目名 说明 P4017 最大食物链计数 记忆化搜索 P2871 Charm Bracelet S USACO 07 DEC，01 背包 P1802 5 倍经验日 01 背包 P1002 过河卒 NOIP2002 普及组，记忆化搜索 P1049 装箱问题 NOIP2001 普及组，01 背包 P1064 金明的预算方案 01 背包变型，NOIP2006 提高组第二题 P1077 摆花 NOIP2012 普及组 P1164 小A点菜 与摆花一题类似 P2392 考前临时抱佛脚 01 背包变型 B3873 小杨买饮料 01 背包变型, GESP202309 六级 P13015 学习小组 无穷背包，GESP 202506 六级 ｜ P10721 计算得分 ｜ 背包问题变种，GESP 202406 六级 ｜ 更多的题单： 背包精选 例题代码P2842 纸币问题 1此题可以带着孩子一步步推导和演进。具体步骤如下。 先引导孩子用最暴力的 DFS 的方式来做此题，建立基础的解题框架，虽然会超时，但是也帮助我们后面引导孩子学会记忆化搜索。代码如下： 1234567891011121314151617181920212223242526272829/** * DFS，超时 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, w;int v[1100];int dfs(int pt) &#123; if (pt == 0) return 0; int ret = 1e9; for (int i = 0; i &lt; n; ++i) &#123; if (pt&gt;=v[i]) &#123; ret = min(ret, dfs(pt-v[i]) + 1); &#125; &#125; return ret;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; int ans = dfs(w); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 有了上面的代码，通过分析，发现大部分的超时是因为有重复的计算过程。以下是一个以 10,5,1 为例的示意： 所以，我们可以将重复计算的过程保存下来，以后再次需要计算的时候，直接读取保存的结果即可。在此思想下，我们只需要在上面改动三行，即可将超时的程序改为通过。具体代码如下： 1234567891011121314151617181920212223242526272829303132/** * DFS，记忆化搜索 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, w;int v[1100];int r[10010]; // 改动 1int dfs(int pt) &#123; if (pt == 0) return 0; if (r[pt] != 0) return r[pt]; // 改动 2 int ret = 1e9; for (int i = 0; i &lt; n; ++i) &#123; if (pt&gt;=v[i]) &#123; ret = min(ret, dfs(pt-v[i]) + 1); &#125; &#125; return (r[pt]=ret); // 改动 3&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; int ans = dfs(w); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 有了以上两段代码的尝试，我们能够发现： dfs(pt) 只与 dfs( 0 ~ pt-1) 有关,与 dfs(pt+1~w)无关。 如果我们知道了 dfs(0~pt)，就可以推出 dfs(pt+1) 那么，我们就可以思考，如果我们用 dp[i] 来表示钱币总额为 i 的结果数。那么，dp[i] 的计算过程（即：状态转移方程）为：dp[i] = min( dp[i-v[j]] )+1，其中j=0~N。 这样，我们就可以引导学生写出第一个动态规划程序。 1234567891011121314151617181920212223242526/** * dp[i] = min( dp[i-v[j]] ) + 1 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, w;int v[1100], dp[11000];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; memset(dp, 0x3f, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;=w ; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (i-v[j]&gt;=0) &#123; dp[i] = min(dp[i], dp[i-v[j]]+1); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[w]); return 0;&#125; P1216 数字三角形P1216 数字三角形同样可以用记忆化搜索引入。先写记忆化搜索的代码有助于我们理解动态规划的状态转移方程。 搜索的代码为： 1234567891011121314151617181920212223242526272829/** * DFS，记忆化 */#include &lt;bits/stdc++.h&gt;using namespace std;int n;int v[1010][1010];int r[1010][1010];int dfs(int x, int y) &#123; if (r[x][y] != -1) return r[x][y]; if (x == n-1) return r[x][y] = v[x][y]; else return r[x][y] = v[x][y]+max(dfs(x+1,y), dfs(x+1,y+1));&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; scanf(&quot;%d&quot;, &amp;v[i][j]); &#125; &#125; memset(r, -1, sizeof(r)); printf(&quot;%d\\n&quot;, dfs(0, 0)); return 0;&#125; 由搜索代码可知，每一个位置的最价结果由它下面两个结点的最价结果构成。于是，我们可以构造出状态转移方程：dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1]) 另外，我们可以引导学生：上层的依赖于下层的数据，那应该怎么推导呢？让学生想到用倒着 for 循环的方式来从下往上推导。 最后，我们再引导学生构建一下初始值。由此，我们建立起动态规划解题的三个核心问题： 状态的定义 状态转移方程 初始状态的设置 1234567891011121314151617181920212223242526272829303132/** * 动态规划： * dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1]) */#include &lt;bits/stdc++.h&gt;using namespace std;int n;int v[1010][1010];int dp[1010][1010];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; scanf(&quot;%d&quot;, &amp;v[i][j]); &#125; &#125; // 初始状态 for (int j = 0; j &lt; n; ++j) &#123; dp[n-1][j] = v[n-1][j]; &#125; // dp for (int i = n-2; i&gt;=0; --i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; dp[i][j] = v[i][j] + max(dp[i+1][j], dp[i+1][j+1]); &#125; &#125; printf(&quot;%d\\n&quot;, dp[0][0]); return 0;&#125; P2840 纸币问题 2状态转移方程为：dp[i] = sum(dp[i- v[j]]), j = 0~N，结果需要每次模 1000000007。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int n, w;int v[1010], dp[10010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; dp[0] = 1; for (int i = 1; i &lt;= w ; ++i) &#123; dp[i] = 0; for (int j = 0; j &lt; n; ++j) &#123; if (i &gt;= v[j]) &#123; dp[i] = (dp[i] + dp[i-v[j]])%1000000007; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[w]); return 0;&#125; P2834 纸币问题 3此题不能像之前的题目那样，用金钱数为阶段。因为此题是计算的组合数，所以 1,5 和 5,1 是一种答案。如果以金钱数为阶段，就无法方便将这种重复计算的排除掉。 那么，以什么为阶段，可以保证每个阶段可以基于过去的阶段推导出来？可以用不同的钱币种类为阶段！ 接下来就是思考这种情况下的状态转移方程。可以得出，状态转移方程如下： dp[i][j] 表示用前 i 种钱币组成金额 j 的组合数 dp[i][j] = dp[i-1][j-v[i]] + dp[i-1][j - v[i]*2] + …. dp[i-1][j-v[i]*n]; (j &gt;= v[i]*n) 初始状态：dp[1][0] = 1; dp[1][v[1]] = 1; dp[1][v[1]*2] = 1; 参考程序如下： 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int MOD = 1000000007;int n, w;int v[1010], dp[1010][10010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; memset(dp, 0, sizeof(dp)); // dp[0][0] = 1; dp[0][v[0]] = 1;dp[0][v[0]*2] = 1;…. int cnt = 0; while (cnt &lt;= w) &#123; dp[0][cnt] = 1; cnt += v[0]; &#125; for (int i=1; i&lt;n; ++i) &#123; for (int j=0; j&lt;=w; ++j) &#123; cnt = 0; while (j - cnt &gt;= 0) &#123; dp[i][j] = (dp[i][j]+dp[i-1][j-cnt]) % MOD; cnt += v[i]; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[n-1][w]); return 0;&#125; 此题还有另外一种状态转移方程，把阶段分为没有用过 a，和至少用过一张 a。 这样的话，状态转移方程优化为：dp[i][j] = dp[i-1][j] + dp[i][j-v[i]] 这样，代码的复杂度进一步降低，代码如下： 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int MOD = 1000000007;int n, w;int v[1010], dp[1010][10010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; memset(dp, 0, sizeof(dp)); int cnt = 0; while (cnt &lt;= w) &#123; dp[0][cnt] = 1; cnt += v[0]; &#125; for (int i=1; i&lt;n; ++i) &#123; for (int j=0; j&lt;=w; ++j) &#123; if (j-v[i]&gt;=0) &#123; dp[i][j] = (dp[i-1][j]+dp[i][j-v[i]])% MOD; &#125; else &#123; dp[i][j] = dp[i-1][j]; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[n-1][w]); return 0;&#125; 此题还可以进一步简化，因为 dp[i] 那一层算完之后 dp[i-1] 层就没有用了。有没有可能我们将 dp[i]层和 dp[i-1]都合并在一起呢？ 答案是可以的。我们可以将关键代码进一步简化如下，把 dp 改成一个一维数组。状态转移方程变为了:dp[j] = dp[j] + dp[j-v[i]] 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int MOD = 1000000007;int n, w;int v[1010], dp[10010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; memset(dp, 0, sizeof(dp)); int cnt = 0; while (cnt &lt;= w) &#123; dp[cnt] = 1; cnt += v[0]; &#125; for (int i=1; i&lt;n; ++i) &#123; for (int j=0; j&lt;=w; ++j) &#123; if (j-v[i]&gt;=0) &#123; dp[j] = (dp[j]+dp[j-v[i]]) % MOD; &#125; else &#123; dp[j] = dp[j]; //此行可以删除，但为了教学示意保留 &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[w]); return 0;&#125; P1048 采药P1048 采药这题是经典的 01 背包问题。为了方便教学，我们还是从最简单的动态规划思路开始推导。 我们把每个草药是一个阶段，这样： dp[i][j] 表示前 i 个草药，花费 j 时间可以得到的最大价值 状态转移方程为：dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]]) 这样写出来的参考程序如下： 12345678910111213141516171819202122232425262728/**dp[i][j] 表示前 i 个草药，花费 j 时间可以得到的最大价值dp[i][j] = max(dp[i-1][j], dp[i-1][j-t[i]] */#include &lt;bits/stdc++.h&gt;using namespace std;int T, M;int t[110], v[110];int dp[110][1010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;T, &amp;M); for (int i = 1; i &lt;= M; ++i) &#123; scanf(&quot;%d%d&quot;, t+i, v+i); &#125; // 下标从 1 开始，这样不用考虑 i-1 越界了 for (int i = 1; i &lt;= M; ++i) &#123; for (int j = 1; j &lt;= T; ++j) &#123; dp[i][j] = dp[i-1][j]; if (j - t[i] &gt;= 0) &#123; dp[i][j] = max(dp[i][j], dp[i-1][j - t[i]]+v[i]); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[M][T]); return 0;&#125; 与上一题一样，通过分析，我们发现 dp[i][j] 中的 i 一层可以优化掉，变成只有 dp[j]。 这样，状态转移方程被优化成：dp[j]=max(dp[j],dp[j-t[i]]+v[i])。 但是，因为每一个草药只能用一次，如果我们正着循环 j 的话，会出现多次使用第 i 个草药的情况。所以，我们倒着进行递推，就可以避免这种情况。 最终实现的代码如下： 123456789101112131415161718192021222324/**dp[j] 花费 j 时间可以得到的最大价值dp[j] = max(dp[j], dp[j-t[i]]) */#include &lt;bits/stdc++.h&gt;using namespace std;int T, M;int t[110], v[110];int dp[1010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;T, &amp;M); for (int i = 1; i &lt;= M; ++i) &#123; scanf(&quot;%d%d&quot;, t+i, v+i); &#125; for (int i = 1; i &lt;= M; ++i) &#123; for (int j = T; j &gt;= t[i]; --j) &#123; dp[j] = max(dp[j], dp[j - t[i]]+v[i]); &#125; &#125; printf(&quot;%d\\n&quot;, dp[T]); return 0;&#125; P2196 挖地雷P2196 挖地雷 是 NOIP1996 提高组第三题。这道题的解法有点类似于P1216 数字三角形。 但是，这道题更难的是：它需要我们输出路径。 我们先说状态转移方程： dp[i] 表示第 i 个地窖能够挖到的最多地雷数。 w[i] 表示第 i 个地窖的地雷数。 转移方程：dp[i] = max(dp[i+1~N]中能够与 dp[i] 连通的地窖) + w[i] 与 dp[i] = w[i]中的较大者。 我们再说说如何输出路径。因为计算之后 dp 数组中保存了每个结点能够挖的最大地雷数。所以，我们从答案 dp[ans]开始，找哪一个地窖与当前相连，同时值又等于 dp[ans] - w[ans],则表示那个地窖是下一个点。 参数代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int n;int w[30];int v[30][30];int dp[30];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;, w+i); &#125; for (int i = 1; i &lt;=n ; ++i) &#123; for (int j = i+1; j&lt;=n; ++j) &#123; scanf(&quot;%d&quot;, &amp;v[i][j]); &#125; &#125; int ans = 0; for (int i = n; i&gt;=1; --i) &#123; dp[i] = w[i]; for (int j = i+1; j&lt;=n; ++j) &#123; if (v[i][j]) &#123; dp[i] = max(dp[i], dp[j]+w[i]); &#125; &#125; if (dp[ans] &lt; dp[i]) ans = i; &#125; int cnt = dp[ans]; int idx = ans; while (cnt) &#123; printf(&quot;%d &quot;, idx); cnt -= w[idx]; for (int i = idx + 1; i&lt;=n; ++i) &#123; if (v[idx][i] &amp;&amp; cnt == dp[i]) &#123; idx = i; break; &#125; &#125; &#125; printf(&quot;\\n%d\\n&quot;, dp[ans]); return 0;&#125; P1434 滑雪这道题的麻烦点是如何定义状态转移的阶段，因为没有明显的阶段。 可以考虑的办法是：将点按高度排序，这样从高度低的点开始，往高的点做状态转移。 所以： 定义：dp[i][j] 表示从 (i,j) 这个位置开始滑的最长坡。 转移方程： dp[x][y] = max(dp[x&#39;][y&#39;])+1 dp[x&#39;][y&#39;] 为上下左右相邻并且高度更低的点 初始化：无 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;int r, c;int tu[110][110];int dp[110][110];int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;bool debug = false;struct Node &#123; int x, y, h; Node(int _x, int _y, int _h) &#123; x = _x; y = _y; h = _h; &#125;&#125;;bool operator&lt;(Node a, Node b) &#123; return a.h &lt; b.h;&#125;vector&lt;Node&gt; v;int main() &#123; scanf(&quot;%d%d&quot;, &amp;r, &amp;c); v.reserve(r*c); for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; scanf(&quot;%d&quot;, &amp;tu[i][j]); v.push_back(Node(i, j, tu[i][j])); &#125; &#125; sort(v.begin(), v.end()); memset(dp, 0, sizeof(dp)); int ans = 0; for (int i = 0; i &lt; r*c; ++i) &#123; Node node = v[i]; int x = node.x; int y = node.y; for (int j = 0; j &lt; 4; ++j) &#123; int tox = x + movex[j]; int toy = y + movey[j]; if (tox &gt;=0 &amp;&amp; tox &lt;r &amp;&amp; toy &gt;=0 &amp;&amp; toy&lt;c &amp;&amp; node.h &gt; tu[tox][toy]) &#123; dp[x][y] = max(dp[x][y], dp[tox][toy]); &#125; &#125; dp[x][y] += 1; ans = max(ans, dp[x][y]); if (debug) &#123; printf(&quot;dp[%d][%d]=%d\\n&quot;, x, y, dp[x][y]); &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 此题更容易想到的写法还是记忆化搜索：对每一个点作为开始点进行一次 DFS，同时在进行递归调用的时候，如果当前点处理过，则返回上次的结果。 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * DFS, 记忆化 */#include &lt;bits/stdc++.h&gt;using namespace std;int r, c;int tu[110][110];int rem[110][110];int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;int dfs(int x, int y) &#123; if (rem[x][y] != 0) return rem[x][y]; int mm = 0; for (int i = 0; i &lt; 4; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox &gt;=0 &amp;&amp; tox &lt;r &amp;&amp; toy &gt;=0 &amp;&amp; toy&lt;c &amp;&amp; tu[x][y] &gt; tu[tox][toy]) &#123; mm = max(mm, dfs(tox, toy)); &#125; &#125; return (rem[x][y] = mm + 1);&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;r, &amp;c); for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; scanf(&quot;%d&quot;, &amp;tu[i][j]); &#125; &#125; int ans = 0; for (int i = 0; i &lt; r; ++i) &#123; for (int j = 0; j &lt; c; ++j) &#123; ans = max(ans, dfs(i, j)); &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; P1115 最大子段和P1115 最大子段和 是最经典的一类动态规划问题。思路如下： dp[i] 表示包含 i 这个数，并且以 i 结尾的最大子段和。 状态转移方程： 如果 dp[i-1] 为负数，那么 dp[i] = v[i] 如果 dp[i-1] 为正数，那么 dp[i] = dp[i-1]+v[i] 因为 dp[i] 在转移方程上只与 dp[i-1]相关，所以它最终结构上被可以被化简成类似贪心的策略，即： 用一个变量记录当前的累加值，如果当前累加值为负数，则重新计算。 在累加过程中随时判断，记录最大的累加值为最终答案。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int n;int v[200100];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; int cnt = 0; int ans = -1e9; for (int i = 0; i &lt; n; ++i) &#123; cnt += v[i]; ans = max(ans, cnt); if (cnt &lt; 0) cnt = 0; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 作业代码P4017 最大食物链计数P4017 最大食物链计数最佳的做法是做记忆化的搜索。 记录下出度为 0 的结点，从这些结点开始去寻找，把各种可能的路径加总。同时在 DFS 的时候，记录下搜索的结果。 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 记忆化搜索 */#include &lt;bits/stdc++.h&gt;using namespace std;#define MOD 80112002int n, m;vector&lt;vector&lt;int&gt; &gt; v;int r[5010], out[5010];int dfs(int a) &#123; if (r[a] != -1) return r[a]; // 如果是头部，算一种情况 if (v[a].size() == 0) return (r[a]=1); // 如果不是头部，则求和 int cnt = 0; for (int i = 0; i &lt; v[a].size(); ++i) &#123; cnt = (cnt + dfs(v[a][i])) % MOD; &#125; return r[a] = cnt;&#125;int main() &#123; memset(r, -1, sizeof(r)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); v.resize(n+1); for (int i = 0; i &lt; m; ++i) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); v[a].push_back(b); // a 被 b 吃 out[b]++; // b 的出度+1 &#125; int ans = 0; for (int i = 1; i &lt;=n ; ++i) &#123; // 如果 i 出度为 0，就表示只能被吃，为底部 if (out[i] == 0) &#123; ans += dfs(i); ans %= MOD; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; P2871 Charm Bracelet SP2871 Charm Bracelet S 是最最标准的 01 背包问题。可以作为基础练习。 参考代码： 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;int w[3500], v[3500], dp[14000];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d%d&quot;, w+i, v+i); &#125; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = m; j&gt;=w[i]; --j) &#123; dp[j] = max(dp[j], dp[j-w[i]] + v[i]); &#125; &#125; printf(&quot;%d\\n&quot;, dp[m]); return 0;&#125; P1802 5 倍经验日经典的 01 背包问题： dp[i] 表示 i 容量可以获得的最大的经验值增量。 w[i] 表示第 i 个药的数量。 t[i] 表示第 i 个药贡献的经验值增量。 状态转移方程：dp[j] = max(dp[j], dp[j-w[i]]+t[i])。 需要注意答案最大超过了 int，需要用 long long。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int dp[1010], w[1010], t[1010];int base = 0, n, x;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;x); for (int i = 0; i &lt; n; ++i) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); base += a; t[i] = b-a; w[i] = c; &#125; for (int i=0; i&lt;n; ++i) &#123; for (int j=x; j&gt;=0; --j) &#123; if (j-w[i]&gt;=0) &#123; dp[j] = max(dp[j], dp[j-w[i]]+t[i]); &#125; &#125; &#125; //最大结果为 5*1e9，需要用 long long printf(&quot;%lld\\n&quot;, 5LL*(dp[x] + base)); return 0;&#125; P1002 过河卒P1002 过河卒此题是标准的记忆化搜索。有两个陷阱： 马所在的位置也不能走。 long long。 相关代码： 1234567891011121314151617181920212223242526272829/** * 记忆化搜索。 */#include &lt;bits/stdc++.h&gt;using namespace std;int bx, by, hx, hy;long long r[22][22];bool block(int x, int y) &#123; int v = abs(x-hx)*abs(y-hy); return (v == 2 || x==hx &amp;&amp; y == hy);&#125;long long dfs(int x, int y) &#123; if (x&gt;bx || y&gt;by) return 0; if (x == bx &amp;&amp; y == by) return 1; if (r[x][y]!=-1) return r[x][y]; if (block(x,y)) return r[x][y] = 0; long long ans = dfs(x+1,y) + dfs(x,y+1); return r[x][y] = ans;&#125;int main() &#123; memset(r, -1, sizeof(r)); cin &gt;&gt; bx &gt;&gt; by &gt;&gt; hx &gt;&gt; hy; printf(&quot;%lld\\n&quot;,dfs(0, 0)); return 0;&#125; P1064 金明的预算方案P1064 金明的预算方案 是一道 01 背包的变型题。题目增加了附件的概念，初看起来没法下手，但是题目增加了一个限制条件：附件最多只有 2 个。 所以，我们可以将 01 背包的“选或不选”两种情况扩充成以下 5 种情况： 不选 选主件，不选附件 选主件 + 附件 1 选主件 + 附件 2 选主件 + 附件 1 + 附件 2 然后就可以用 01 背包来实现该动态规划了。我们把每种物品的费用当作背包的体积，把每种物品的价格*权重当作价值。 转移方程是：dp[i]=max(dp[i], 5 种物品选择情况)，每种选择情况下，dp[i]=max(dp[i], dp[i-该选择下的花费]+该选择下的收益) 。 另外，需要注意，输入数据的编号可能不按顺序提供，有以下这种情况： 1234100 31000 5 310 5 350 2 0 以下是参考程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;struct Node &#123; int m; int w; int t;&#125;;int n, m;vector&lt;Node&gt; va;vector&lt;vector&lt;Node&gt; &gt; vb;int dp[40000];void updateDP(int i, int m, int w) &#123; if (i-m &gt;= 0) &#123; dp[i] = max(dp[i], dp[i-m] + w); &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); va.resize(m); vb.resize(m); for (int i = 0; i &lt; m; ++i) &#123; Node node; scanf(&quot;%d%d%d&quot;, &amp;node.m, &amp;node.w, &amp;node.t); node.w = node.w*node.m; va[i] = node; if (node.t != 0) &#123; vb[node.t - 1].push_back(node); &#125; &#125; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; m; ++i) &#123; // 只处理主件，附件与主体一并处理 if (va[i].t == 0) &#123; for (int j = n; j &gt; 0; j--) &#123; // 选主件，不选附件 updateDP(j, va[i].m,va[i].w); // 选主件+附件 1 if (vb[i].size() &gt; 0) &#123; int money = va[i].m + vb[i][0].m; int weight = va[i].w + vb[i][0].w; updateDP(j, money, weight); &#125; // 选主件+附件 2 if (vb[i].size() == 2) &#123; int money = va[i].m + vb[i][1].m; int weight = va[i].w + vb[i][1].w; updateDP(j , money, weight); &#125; // 选主件+附件 1+附件 2 if (vb[i].size() == 2) &#123; int money = va[i].m + vb[i][0].m + vb[i][1].m; int weight = va[i].w + vb[i][0].w + vb[i][1].w; updateDP(j, money, weight); &#125; &#125; &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125; P1077 摆花P1077 摆花 一题是 NOIP2012 普及组的第三题。 dp[i][j] 表示前 i 种花，摆在前 j 个位置上的种数。 状态转移方程： 1234dp[i][j] = dp[i-1][j] 不放第 i 种花 + dp[i-1][j-1] 放 1 个第 i 种花 + dp[i-1][j-2] 放 2 个第 i 种花 ... 这道题的难点：没有想到 dp[0][0]=1。因为后面推导的时候，dp[i-1][j-k] 中 j==k 的时候，也是一种可能的情况，要统计进来。 参考代码： 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;int a[110];int dp[110][110];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;, a+i); &#125; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= m; ++j) &#123; for (int k = 0; k &lt;= a[i]; ++k) &#123; if (j - k &gt;= 0) &#123; dp[i][j] += dp[i-1][j-k]; dp[i][j] %= 1000007; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[n][m]); return 0;&#125; P1164 小A点菜P1164 小A点菜一题阶段比较明显。每一道菜点不点是一个明显阶段。所以： dp[i][j]表示前 i 道菜，用 j 的价格，能够点的方案数 对于每道菜，有点或不点两种方案，所以： 转移方程：dp[i][j] = dp[i-1][j]+dp[i-1][j-a[i]] 由于 i 阶段只与 i-1 阶段相关，所以可以把阶段压缩掉，只留一维。最后压缩后的方案是： dp[j] 表示用 j 的价格可以点到的点的种数 初始条件 dp[0] = 1，因为这样才可以把后面的结果递推出来 dp[j] = dp[j] + dp[j-a[i]] 因为和 01 背包类似的原因，压缩后需要倒着用 for 循环，否则每道菜就用了不止一次了。 参考代码： 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;int a[110];int dp[10010];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;, a+i); &#125; memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j&gt;=a[i]; --j) &#123; dp[j] += dp[j-a[i]]; &#125; &#125; printf(&quot;%d\\n&quot;, dp[m]); return 0;&#125; P2392 考前临时抱佛脚P2392 考前临时抱佛脚 此题可以用动态规划，也可以用搜索，因为每科只有最多 20 个题目，所以搜索空间最大是 2^20 等于约 100 万。 以下是搜索的代码： 1234567891011121314151617181920212223242526272829303132333435/** * 搜索 */#include &lt;bits/stdc++.h&gt;using namespace std;int s[4], v[25];int ans, tot, ret;void dfsAns(int pt, int n, int cnt) &#123; if (pt == n) &#123; int tmp = max(cnt, tot-cnt); ret = min(ret, tmp); return; &#125; dfsAns(pt+1, n, cnt); dfsAns(pt+1, n, cnt+v[pt]);&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;, s, s+1, s+2, s+3); for (int i = 0; i &lt; 4; ++i) &#123; memset(v, 0, sizeof(v)); tot = 0; for (int j = 0; j &lt; s[i]; ++j) &#123; scanf(&quot;%d&quot;, v+j); tot += v[j]; &#125; ret = tot; dfsAns(0, s[i], 0); ans += ret; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 用动态规划解题时，此题可以把每次复习看作一次 01 背包的选择。每道题的价值和成本相同。背包的目标是尽可能接近 sum&#x2F;2，因为sum 最大值为 20*60 = 1200，所以背包大小最大是 600。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int s[4];int v[25];int ans = 0;int dp[610];int dpAns(int n) &#123; int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; cnt += v[i]; &#125; int m = cnt / 2; memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = m; j&gt;=v[i]; --j) &#123; dp[j] = max(dp[j], dp[j-v[i]] + v[i]); &#125; &#125; int ret = max(dp[m], cnt - dp[m]); return ret;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;, s, s+1, s+2, s+3); for (int i = 0; i &lt; 4; ++i) &#123; memset(v, 0, sizeof(v)); for (int j = 0; j &lt; s[i]; ++j) &#123; scanf(&quot;%d&quot;, v+j); &#125; ans += dpAns(s[i]); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B3873 小杨买饮料假设第 i 种饮料的费用是 c[i], 容量是 l[i]。dp[i][j] 表示用前 i 种饮料，凑成 j 升的最小费用。则，转移方程为： dp[i][j] = min( dp[i-1][j-l[i]] + c[i] , dp[i-1][j] ) 因为 i 只与 i-1 相关，所以这一层可以取消。转移方式优化为： dp[j] = min(dp[j- l[i]] + c[i], dp[j]) 其它注意事项： 倒着 dp，因为每种饮料只能用一次 最大值检查了一下，不会超 int，就不用 long long 了 因为答案不一定是刚好 L 升，所以要取 L ~ L+max(l[i]) 这一段范围 因为是取最小值，所以初使化设置成 0x7f7f7f7f（接近 21 亿，但是又没到 INT_MAX），这样运算不会超 int，又可以是较大值 参考代码： 1234567891011121314151617181920212223242526272829/* * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int dp[1010000], c[550], l[550], N, L, maxL;int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; N &gt;&gt; L; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; c[i] &gt;&gt; l[i]; maxL = max(maxL, l[i]); &#125; maxL += L; memset(dp, 0x7f, sizeof dp); dp[0] = 0; for (int i = 0; i &lt; N; ++i) &#123; for (int j = maxL; j - l[i] &gt;= 0; --j) &#123; dp[j] = min(dp[j], dp[j - l[i]] + c[i]); &#125; &#125; int ans = *min_element(dp+L, dp+maxL+1); if (ans == 0x7f7f7f7f) cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 上面的代码有一个小缺点就是 dp 数据开得很大。因为虽然题目的 L 很小（最大值为 2000），但饮料的容量最大为 10^6。 所以我们还有一种办法就是对这种容量很大的饮料单独判断，这样 L 的范围就可以只设置到 4000 即可。之所以是 4000 而不是 2000，是因为还是有刚刚超过 2000 一点点，而凑出最小值的情况。 参考代码如下： 1234567891011121314151617181920212223242526272829303132/* * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int dp[4100], c[550], l[550], N, L;int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; N &gt;&gt; L; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; c[i] &gt;&gt; l[i]; &#125; memset(dp, 0x7f, sizeof dp); dp[0] = 0; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 4000; j - l[i] &gt;= 0; --j) &#123; dp[j] = min(dp[j], dp[j - l[i]] + c[i]); &#125; &#125; int ans = *min_element(dp+L, dp+4000); // 如果单个饮料就可以超 L，则判断一下 for (int i = 0; i &lt; N; ++i) if (l[i] &gt;= L) ans = min(ans, c[i]); if (ans == 0x7f7f7f7f) cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P13015 学习小组无穷背包问题： 人数相当于物品的重量，积极度相当于物品的价值 背包的总重量就是人数 设：人数限制是 a[i], 兴趣度是 b[i]。 dp[i][j] 表示前 i 个物品，放 j 个人数的最大价格，则转移方程为： dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i]] + b[i]) 简化 dp，去掉第一个维度后，转移方程为： dp[j] = max(dp[j], dp[j-a[i]] + b[i]) 12345678910111213141516171819202122232425/* * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[1100], b[1100], dp[1100];int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; n; for (int i = 1; i &lt;=n ; ++i) &#123; a[i] = i; cin &gt;&gt; b[i]; &#125; for (int i = 1; i &lt;=n; ++i) &#123; for (int j = 1; j&lt;=n; ++j) &#123; if (j - a[i] &gt;= 0) &#123; dp[j] = max(dp[j], dp[j-a[i]] + b[i]); &#125; &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：贪心算法","slug":"cspj-notes-of-greedy-algorithm","date":"2025-01-05T02:28:04.000Z","updated":"2025-04-12T09:10:44.474Z","comments":true,"path":"2025/01/05/cspj-notes-of-greedy-algorithm/","permalink":"https://blog.devtang.com/2025/01/05/cspj-notes-of-greedy-algorithm/","excerpt":"","text":"1、概述贪心算法讲起来容易，就是问题求解的每一步，都用一个局部最佳的策略，如果能够证明局部最佳的策略最终能够保证全局最佳，则可以用贪心算法。 在实际 CSPJ 比赛中，我们不用严谨的求解和证明，只需要尝试做一些反例，如果反例中找不到问题，就可以先用贪心求解。毕竟比赛中时间的权重因素比较高。 在教学中，我们先通过简单的题目让学生理解贪心的概念。之后就可以逐步增加难度，让学生意识到，写出贪心可能容易，但是想到贪心这种解法在比赛中并不那么显而易见。 贪心通常伴随着排序，所以对 STL 的 sort 以及 priority_queue 的熟练应用也是快速解决贪心题目的必备基础，在学习相关题目的时候，可以重点加强巩固相关知识点。 2、sort 函数sort 函数内部使用快速排序实现，时间复杂度为 O(N*log(N))。对于数据规模为 10 万左右的题目，出题人有可能是希望你用这个时间复杂度来解题的，所以可以留意一下是否需要排序。 对于普通类型，STL 自带了 greater&lt;T&gt;和less&lt;T&gt; 两个比较器，以下是相关代码： 12int v[100];sort(v, v+n, greater&lt;int&gt;); sort 函数通常和自定义的结构体排序搭配使用，以下是相关代码： 1234567891011struct Person &#123; int idx; int v;&#125;;bool operator &lt; (Person a, Person b) &#123; return a.v &lt; b.v;&#125;Person v[1100];// 使用时直接用 sortsort(v, v+n); sort 函数除了可以像上面这样通过调用 &lt; 符号来比较大小，也可以传入一个比较函数。如下所示： 1234567891011struct Person &#123; int idx; int v;&#125;;bool comp(Person a, Person b) &#123; return a.v &lt; b.v;&#125;Person v[1100];// 使用时直接用 sortsort(v, v+n, comp); 以下是练习结构体排序的题目： 题目名 说明 P5143 攀爬者 按 z 坐标排序，然后求和 P1104 生日 生日的排序 3、教学题目推荐的教学题目如下： 题目名 说明 P2240 部分背包问题 较简单的一道贪心题 P1223 排队接水 贪心进阶 P1803 凌乱的yyy 贪心进阶 P5019 铺设道路 NOIP 2018 提高组真题 B3872 巧夺大奖 GESP202309 五级 P1012 拼数 NOIP 1998 提高组 4、例题代码P2240 部分背包问题P2240 部分背包问题 是较简单的一道贪心题。唯一的陷阱是，学过动态规划的同学可能误以为这个是背包问题。但是在教学中，贪心算法的学习比动态规划更早，所以不会有这个误解。 此题的解题思路是：将金币按单位重量的价值排序，如果能放则放；放不了，则分割放部分。 我们定义了一个结构体，结构体中的 double p用于保存单位重量的价值。在排序的时候，按 p 的大小来由大到小排序。 参考代码如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;struct Gold &#123; int w, v; double p;&#125;;bool operator&lt;(Gold a, Gold b) &#123; return a.p &gt; b.p;&#125;int n, t;Gold v[110];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;t); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;v[i].w, &amp;v[i].v); v[i].p = v[i].v*1.0 / v[i].w; &#125; sort(v, v+n); double ans = 0; for (int i = 0; i &lt; n; ++i) &#123; if (t&gt;=v[i].w) &#123; ans += v[i].v; t -= v[i].w; &#125; else &#123; ans += v[i].p * t; break; &#125; &#125; printf(&quot;%.2f\\n&quot;, ans); return 0;&#125; P1223 排队接水此题的难度是需要推导出贪心的策略。具体推导过程如下： 由以上推导，我们只需要将打水时间按从小到大排序，然后加总时间即可。参考代码如下： 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;struct Person &#123; int idx; int v;&#125;;bool operator &lt;(Person a, Person b) &#123; return a.v &lt; b.v;&#125;int n;Person v[1100];int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; v[i].idx = i+1; cin &gt;&gt; v[i].v; &#125; sort(v, v+n); long long cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d &quot;, v[i].idx); cnt += v[i].v * (n-i-1); &#125; printf(&quot;\\n%.2f\\n&quot;, cnt*1.0/n); return 0;&#125; P1803 凌乱的yyy此题有两种贪心的思路，分别是： 按开始时间排序贪心 按结束时间排序贪心 按开始时间排序贪心此贪心的方法如下： 左端点排序（小的在前），左端点相同的，按右端点排序(小的在前） 比较当前区间和下一区间，如果下一区间与当前区间没有相交，则由于我们是按左端点排序的，后面的都不会相交，直接选择当前区间；否则这两个区间显然必须抛弃一个，由于我们是按左端点排序的，后面的区间左端点都是大于它们的，因此这两个的左端点已经没有意义了，为了留出更多的空间，留下右端点靠左的那一个即可。 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536/** * 按开始时间排序 */#include &lt;bits/stdc++.h&gt;using namespace std;struct Line&#123; int left, right;&#125;;bool operator&lt;(Line a, Line b) &#123; if (a.left != b.left) return a.left &lt; b.left; return a.right &lt; b.right;&#125;int n, ans;Line v[1000010];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;v[i].left, &amp;v[i].right); &#125; sort(v, v+n); ans = 0; int border = 0; for (int i = 0; i &lt; n; ++i) &#123; if (v[i].left &gt;= border) &#123; ans++; border = v[i].right; &#125; else &#123; border = min(border, v[i].right); &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 按结束时间排序贪心此贪心的方法如下： 右端点排序（小的在前），右端点相同的，按左端点排序(大的在前） 这种贪心的思路是：对于每一个结束时间，如果能排（开始时间在上一个结束时间之后），就尽量安排。如果不能排，则尝试下一个结束时间。 参考代码如下： 123456789101112131415161718192021222324252627282930313233/** * 按结束时间排序 */#include &lt;bits/stdc++.h&gt;using namespace std;struct Line&#123; int left, right;&#125;;bool operator&lt;(Line a, Line b) &#123; if (a.right != b.right) return a.right &lt; b.right; return a.left &lt; b.left;&#125;int n, ans;Line v[1000010];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;v[i].left, &amp;v[i].right); &#125; sort(v, v+n); ans = 0; int border = -1; for (int i = 0; i &lt; n; ++i) &#123; if (border &lt;= v[i].left) &#123; ans++; border = v[i].right; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; P5019 铺设道路P5019 铺设道路是 NOIP2018 提高组真题。之所以作为提高组题目，是因为很难想到这种贪心策略，不过一旦想清楚，写起来是很简单的。 贪心策略是： 第一个坑直接填满 从第二坑开始，考虑能不能被左边顺带给填上。 如果第二个坑比第一个坑小，肯定就顺带填上了。不需要任何成本。 如果第二个坑比第一个坑大，那么就只能顺带填一部分，多出来的差额，需要额外的填补。 参考代码： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int n;int v[100010];long long ans = 0;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, v+i); &#125; ans = v[0]; for (int i = 1; i &lt; n; ++i) &#123; if (v[i]&gt;v[i-1]) &#123; ans += v[i] - v[i-1]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 以上。 B3872 巧夺大奖对于本题，我们先来看一个样例，如果输入是： 12322 120 10 以上样例最佳的贪心策略是： 安排在第 2 个时间段做任务 1，得到 20 的奖励 安排在第 1 个时间段做任务 2，得到 10 的奖励 由此，我们可以得出这道题的贪心策略是： 按奖金的大小从大到小排序，每次取最大的奖金。 对于某一个具体的奖金，其对应的时限如果为 a 的话，我们应该尽可能把它安排在 [1, a] 这个区间的较大的时间段。因为越大的时间段相对来说越宽裕，如果我们把它安排在较小的时间段，如果有另外一个游戏的时间段要求更小，那就会造成冲突。 完成的参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;struct Game &#123; int time; int reward;&#125;;Game games[510];int mark[510];bool operator&lt;(const Game &amp;a, const Game &amp;b) &#123; return a.reward &gt; b.reward;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; games[i].time; &#125; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; games[i].reward; &#125; sort(games, games + n); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = games[i].time; j &gt;= 1; j--) &#123; if (!mark[j]) &#123; mark[j] = 1; ans += games[i].reward; break; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P1012 拼数此题容易想到的贪心策略是：每次用高位尽量大的数字。如果高位相同，则比较次高位。 但是如果两个涉及一个数是另一个数的前缀，则更复杂，让我们看看下面的例子： 那如果是 321 和 32 比较呢？32132 和 32321 哪个大？看起来先用短的更好。 再试一个 329 和 32 比较。32932 和 32329 哪个大？看起来先用长的更好。 所以，本题的正确解法是比较的时候将两个串“连接”起来比大小。以下是关键的比较函数： 123bool comp(const string&amp; a, const string&amp; b) &#123; return a + b &gt; b + a;&#125; 完整代码如下： 12345678910111213141516171819202122232425/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;bool comp(const string&amp; a, const string&amp; b) &#123; return a + b &gt; b + a;&#125;int main() &#123; int n; vector&lt;string&gt; a; cin &gt;&gt; n; a.resize(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a.begin(), a.end(), comp); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"2024 年个人总结","slug":"2024-summary","date":"2025-01-01T02:41:17.000Z","updated":"2025-02-14T12:15:05.995Z","comments":true,"path":"2025/01/01/2024-summary/","permalink":"https://blog.devtang.com/2025/01/01/2024-summary/","excerpt":"","text":"一、工作财务视角2024 年从财务视角，业务整体有不小的进步。 23 年虽然业务增长不错，但是整体有将将近千万的亏损，而 24 年整体的赢利是上千万的。所以业务整体健康度更高。当然，因为我们严卡利润率，我们的营收规模在 2024 年基本上没有什么增长，还是在 2 个亿左右。希望 2025 年有所增长。 海外业务在收缩为一人之后，也有不小的起色。我们在韩国还是找到了一条基于 coupang 全拖管的立足之地，可以基于这个基本盘开始做增长。虽然小，但是不至于每个月担心巨大的亏损，所以能睡得着觉。 产品视角分产品来说，2024 年我们没有交付什么成功的新产品。虽然我们在年初上线了英语闪卡机，下半年上线了斑马拼音机 G2，但是这两款产品都没能上规模。不管是达人还是直播间，这两款产品都运营得比较艰难。 斑马童书年底还有一个大的变化，就是我开始负责斑马童书。 童书是一个市场比玩教具小，同时竞争更加激烈的品类。但是对我来说，能够学习一个新的品类的玩法，也是一种成长，所以我还是很愿意投入精力在里面，看看能不能深耕出一些结果。 二、读书和写作24 年一共读了 10 本书，以下是读书笔记： 极致性价比 - 读《小米创业思考》 颠覆技术的发展 - 读《浪潮将至》 本分 - 读《段永平投资回答录》 西贝创始人贾国龙的成与败 - 读《折腾不止》 要利润的定价 - 读《定价制胜》 读《蹒跚前行 1870～2010 经济史》 人单合一 - 读《永恒的活火》 如何卖货 - 读《营销管理》 小马宋的营销总结(2) - 读《卖货真相》 小马宋的营销总结(1) - 读《营销笔记》 写作方面，整理了以下文章： 《上下同欲的几种情况》, 我思考清楚了与上级下级的关系，写了此文。 《关于私域的思考》，因为工作涉及私域售卖，总结了私域的特点。 《如何在抖音直播卖货》，一篇科普文章。 《第一性原理思考：解决问题的通用框架》 ，该文章是我今年在公众号的爆文，7 万阅读量。该文以及该文的 《续篇》 对我梳理自己的工作也有不小的帮助。 今年还写了一篇涉及农夫山泉的文章《替农夫山泉说句话》，整个过程对我的帮助也很大，让我理解了情绪的力量。虽然当时争议很大，但事后看来，我的观点是对的，这也让我很开心。 三、爱好今年开始系统性将 CSPJ 培训作为自己的爱好，我打算把这作为自己退休后的生活内容。因为目标在 20 年之后，所以我也开始慢慢总结自己在信息学竞赛上的经验，共分享了以下几篇文章： 五分钟弄懂 CSP-J CSPJ 教学思考：for 循环 CSPJ 教学思考：宽度优先搜索 除了爱好外，今年还做了一些事情来悦己： 买了一台极米 Z7X 高亮版投影仪，在床上看投屏的感受很好。 买了一台 M3 的 MacBook Air，在家用电脑的幸福感直线上升。 买了一部荣耀 Magic V3 折叠屏。在工作中看文档效率，以及读书的体验提升明显。 买了一台 Insta 360 拇指相机。发现拍的时候很爽，但剪辑视频累死人。 双 11 给家里的猫买了自动喂食器和自动喂水器。再也不用每天惦记着毛孩子的吃喝问题了。不过喂食器买完有点后悔，应该买带摄像头的，这样就可以知道有没有吃完。 今年也买了一些软件： Sublime Text，花了 99 美元。平时写博客和 CSPJ 代码都用它。 Longshot，花了大概 100 RMB。可以支持长截图。 Bartender 5，MacBook 的刘海屏下，没这个显示不了太多状态栏的东西。 四、理财今年理财在贯彻自己年初目标上执行得还可以。 年初定下来的定投目标，执行比较顺利。513500 算是一个很不错的 QDII 标的，唯一的缺点就是综合管理费是 0.91% 年初还想在合适的时候赎回指数增强产品，这个也在年底做了。之前持有了三年的金锝和九坤的 500 指数增强，发现不同的产品增强的成绩差很多，能差 10% 以上。 赎回了元盛 CTA。元盛给我的理解是：它能够在经济上行和下行的时候，都能捕捉到套利机会。但是元盛近两年的收益都是负的，我无法理解为什么这两年都没有机会。和管理团队的沟通机会也不是很好，所以赎回了。 今年整体港股和 A 股都有不错的收益。A 股整体有 19.05% 的收益。 港股里面： 腾讯 417，+11% 恒生高股息 23.9，+4% 波司登 3.88，+18% 海底捞 15.9，+27% 伟易达 52.8，-2.9% 今年在理财上也有更多的思考和成长。比如： 不懂不碰。以前是没那么遵守的，今年会更加严格。我也因此卖出了茅台。 再平衡。以前没有严格做，在建平上吃了大亏，建平曾经有 100% 的收益，那个时候没有做再平衡，心理上贪多，还是自己能力不够，今年开始认真做这个事情。 五、24 年的目标回顾 工作： 销售：搭建好销售团队，带好团队的核心成员。培养有共同价值观和长久共事意愿的同事。这一点有一些进展，团队成员今年有一些流动，我觉得是好的。 产品：推进硬件产品的创新尝试。今年没什么有效的落地，不算很好。 理财： 定投少量标普 500，建立初始仓位。今年做得不错。 在合适的时候减少 A 股的指数增强仓位。今年做得不错。 个人： 读 6 本书。完成了，最后读了 9 本。 很久没出国了，想抽空去一趟加拿大。没能完成。 每月游泳一次。完成了。 积极乐观。今年马马虎虎吧。 六、25 年的目标 工作：硬件稳中有增，童书赢亏打正。带好童书业务。 理财：做好配置，找到能拿 10 年的标的，并能坚定持有。 个人：读 6 本书。CSPJ 教学继续累进。 七、个人 Milestone 硬件业务利润过千万 开始负责童书售卖业务","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"极致性价比 - 读《小米创业思考》","slug":"xiaomi-development-notes","date":"2024-12-22T14:37:53.000Z","updated":"2024-12-24T01:15:11.530Z","comments":true,"path":"2024/12/22/xiaomi-development-notes/","permalink":"https://blog.devtang.com/2024/12/22/xiaomi-development-notes/","excerpt":"","text":"其实我以前一直不理解雷军。 原因一是我在猿辅导工作，我们做的产品都是追求创新和高品质。因为成本不低，所以我们的产品定价不那么便宜。像我们公司的学练机、月子中心、咖啡、月龄盒，以及我负责的斑马玩教具，说实话定价在行业都是比较高的。 原因二是我比较欣赏的人，不管是公司内部的同事，还是公司外部的一些人，都对 “性价比” 这个词表现出不喜欢。这种不喜欢主要是站在商业角度，这种模式做起来太辛苦，太容易失败。 原因三是我自己曾负责过一款基于微信传播的英语学习产品。在这个产品失败前，我们尝试过极致的低价，但是最后并没有带来同等回报的增长，所以我知道，低价并不好做。 最近读了根据雷军口述整理出来的《小米创业思考》，终于有那么一点点理解雷军要做什么了。 以下是一些感悟。 雷军的 “极致性价比” 逻辑雷军的 “极致性价比” 的想法来自 Costco，他在采访中说，一个在中国国内卖几千块钱的新秀丽的行李箱，在 Costco 只需要几百块钱。同时，雷军是一个有比较多社会责任感的企业家，他希望在互联网时代，大家可以用厚道的价格买到极致体验的东西，于是，小米成了他这个理想的实践地。 企业的存在，首先是因为有社会价值，即用户需求。首先因为用户需要某种服务，才会有相应的企业存在。在用户需求的基础下，企业才会有自己的经营使命和战略，战略应该围绕着自己的社会价值，去更好地满足自己的社会价值，这样的企业才能活得更久。 小米运用 “极致性价比” 逻辑，选择了一个极度差异化的经营模式，这种模式下： 小米的产品具备独特的价值：性价比高。 小米的产品总成本领先：因为量大。 小米的竞争对手难以模仿。因为这种模式太难生存了。 所以，小米其实是选了一条几乎没有人，也几乎没有人走成功的路。 所以，了解完小米的逻辑之后，我理解了雷军。其实常见的经营模式雷军都知道，也都理解，但是雷军就是想走一条不一样的路。同时他也认为这条路虽然难，但是对于开创者的回报巨大。 小米如何完成 “不可能三角”小米这种模式，需要同时做到三点：产品好、价格低，以及要有合理的利润（也就是股东回报），雷军称之为 “不可能三角”。那他是如何完成的呢？ 产品好。雷军要求团队只做高端和创新的产品，即便是做充电宝，也是将原本用在笔记本电脑上的铝外壳做到了充电宝中。除了产品好外，小米在打造新品时，首先考量的第一要素是，产品是否具备“明天属性”。“明天属性”是指代表先进趋势的体验，而且这种体验是用户一旦用过就不想放手的。比如用户一旦用了智能手机，就再也不想用非智能手机了。 价格低。雷军相信厚道的定价会带来规模效应，所以，他的很多产品是贴着成本价来定的。首款小米手机，成本 2000 块，他就定价 1999。这充分诠释了他对于价格的理解。 合理利润。这么低的价格还能有利润吗？只有向制造环节要规模效应和生产效率，同时向流通环节要效率。 在合理利润这个点上，雷军做了很多事情。比如在制造环节： 他们投资机械臂算法的公司，希望将机械臂的价格打下来，这样就可以在生产中尽可能使用机械臂。 他们将生产线做改造，将不同产线的差异装配点模块化，使得换线成本显著降低。 在向流程环节要效率这个点上，雷军遇到了很大的挑战，没有线下的渠道愿意与他合作。于是在初期，他只能和自己的售后合作伙伴来合作开店，最终把线下渠道的成本压到了 10% 左右。而传统的渠道，成本是 20% 左右。 但是，即使到了现在，小米在合理利润这个点上，也没有完全通过市场检验。在手机端，小米因为有大量应用市场广告和 App 预装等服务性收费，才使得他有足够的利润。但是在硬件端，不是每款硬件都可以靠服务收费的，比如大部分小米生态链产品就不太需要服务，小米还需要在未来回答这些问题。 小米如何做第一辆车小米切入造车行业，刚开始下属的提案有很多创新。雷军觉得不好，他觉得大公司做新业务的三个大坑：认知错位、惯性思维、偶像包袱。总觉得自己牛逼，做新业务要干件大事，但是自己在新领域很可能就是一个小学生，有很多该交的学费都还没交。 所以，雷军要求团队 “先确保做一款好车，一款能够与当下同级所有产品比拼的好车，在确保这个目标的基础上，再考虑颠覆的部分。” 当目标变成 “一款好车” 时，颠覆不颠覆就不那么重要了，什么东西好拿过来借鉴就好了。于是，小米的第一款车显得很熟悉，很多保时捷上的设计被借鉴来了，大家也被一款好的设计所吸引。 虽然入局晚了几年，但小米汽车还是获得了一个梦幻开局。 终局思维雷军在书中提到了消费电子行业的规律：当 15-20 年后行业进入成熟期，全球前 5 的品牌必将手握 80% 以上的份额。也就是说，只有最终进入全球行业前 5，做到年出货 1000 万台以上才有意义。 雷军在进入这个行业的最初，就想好了 20 年后的终局。这种终局思维才让他能够做长期主义的事情，包括投入三电等基础能力的研发，包括为造车留够足够的资金，也包括他自己的 All in 行为。 小米曾经犯的错误芒格说：如果你知道自己可能死在哪里，就永远不要去那个地方。雷军在书中提了很多小米犯的错误，这些错误让我记忆犹新。以下是一些记录： 性价比应该作用在用户价值上小米早期连 SIM 卡的卡针都要用 10 倍于同行的材质和工艺，这事后来被雷军叫停了。雷军认为，所有的产品体验成本，应该用在用户价值上，如果用户用不到，就是自嗨。SIM 卡的卡针大部分用户只会用一次，这个卡针上就没必要用 10 倍于同行的成本。 在消费品行业，一些产品包装也会有同样的问题。如果消费者收到的产品过度包装，消费者就会认为 “羊毛出在羊身上”，这反倒是一种浪费。 品牌雷军认为，自己在红米品牌上犯了错，以及之前用了很多 X 米的生态链品牌都是不对的，这些品牌模糊了小米品牌。所以，后来红米改名成为了 Redmi。 小米品牌，最终只用在了非常核心的产品上，包括：手机、电视、路由、音箱、笔记本电脑，以及后来做的汽车。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"CSPJ 教学思考：宽度优先搜索","slug":"bfs-teaching-notes","date":"2024-12-15T08:54:30.000Z","updated":"2025-04-14T14:58:27.204Z","comments":true,"path":"2024/12/15/bfs-teaching-notes/","permalink":"https://blog.devtang.com/2024/12/15/bfs-teaching-notes/","excerpt":"","text":"在学习完数据结构队列(queue)后，就可以让学生学习宽度优先搜索了。 宽度优先搜索（BFS）的形式相对固定，但是写起来代码偏长，学生在学习的时候，老是容易忘掉一些环节，所以需要加强练习。 1、模版记忆我整理了一个 BFS 的模版，每次教学前让孩子复述这个环节，通过这种方式来强化模版的记忆，帮助学生掌握这个算法。 模版如下： 1234567891011121314151617void bfs() &#123; queue&lt; ? &gt; q; q.push( ? ); 标记 ? 已经处理 while (!q.empty()) &#123; ? = q.front(); q.pop(); for(各种情况) &#123; if (可入队) &#123; q.push( ? ) 标记 ? 已经处理 &#125; &#125; &#125;&#125; 2、关于结构体的使用在教学宽度优先搜索的初期，其实并不需要将入队的数据整合成结构体。这样反而会让代码变得更复杂。可以直接将需要入队的数据成组地 push 和 pop，这样就实现了简易的类似结构体的效果。 3、教学题目推荐的教学题目如下： 题目名 说明 B3625 迷宫寻路 新手入门，没有陷阱，学习方向数组写法 P1443 马的遍历 需要求步数，需要写 8 个方向 P1135 奇怪的电梯 BFS 不仅仅可以是在地图上，也可以是另外的搜索形式 P1162 填涂颜色 学习标记技巧：将地图往外扩一圈 0 ，减少标记难度 P1825 Corn Maze S 变种的地图，可以传送 P1451 求细胞数量 多次的 BFS 标记 推荐更多练习的题目如下，可作为基础训练之用： 题目名 说明 P1746 离开中山路 比较标准的练习，无坑 P1506 拯救oibh总部 强化P1162 填涂颜色 中学到的标记技巧 P1331 海战 多次 BFS 标记的同时，如何判断标记物是矩行 以下题目难度更高一些，可以作为强化训练之用： 题目名 说明 P2895 Meteor Shower S USACO 08 FEB P1141 01迷宫 数据量很大，需要提前保存查询结果 P2802 回家 状态变为走过时的血量有没有变高 P8604 危险系数 [蓝桥杯 2013 国 C]题目，用 BFS 暴力尝试 Takahashi is Slime 2 变种的 BFS，需要用优先队列 4、例题代码以下是详细的例题代码说明。 B3625 迷宫寻路B3625 迷宫寻路 是一道非常基础的宽度优先搜索，只需要输出 YES 或者 NO，对输出的要求也较小，适合拿来入门教学。 在本例题中，我们也要开始教会学生定义 movex、movey 数组，后续在迷宫一类的宽度搜索题目中，这种技巧非常见。movex、movey 的快速定义技巧是：movex 和 movey 的结构交替，每一组都是一个 1 和一个 0，同时变换 1 的正负号。记住这样的技巧就可以快速定义出这两个数组。代码如下： 12int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;; 本例还需要一个数组标记是否走过，我们使用 flag 数组。参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * B3625 迷宫寻路，宽度优先搜索。 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;char tu[110][110];bool flag[110][110] = &#123;false&#125;;void bfs(int x, int y) &#123; bool result = false; int tox, toy; queue&lt;int&gt; q; q.push(x); q.push(y); flag[x][y] = true; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); if (x == n-1 &amp;&amp; y == m-1) &#123; result = true; break; &#125; for (int i = 0; i &lt; 4; ++i) &#123; tox = x + movex[i]; toy = y + movey[i]; if (tox &gt;= 0 &amp;&amp; tox &lt;n &amp;&amp; toy &gt;=0 &amp;&amp; toy&lt;m &amp;&amp; tu[tox][toy] == &#x27;.&#x27; &amp;&amp; flag[tox][toy]== false) &#123; flag[tox][toy] = true; q.push(tox); q.push(toy); &#125; &#125; &#125; if (result) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; tu[i]; &#125; bfs(0, 0); return 0;&#125; 迷宫寻路加强：求步数有了上面的代码，我们可以在题目上做变动，比如把输出的要求改为：如果能到达，则输出到达终点的最短步数 ，引导学生思考，现有的代码要做怎样的改造，才能实现新的要求。 于是，我们讨论得出，需要将”步数”引入到代码中，于是，原来的代码增加了两处修改： 每次入队的时候，将当前位置到达的步数也入队 如果到达终点，记录下来当时的步数 改动的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * B3625 迷宫寻路，宽度优先搜索。 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, ans;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;char tu[110][110];bool flag[110][110] = &#123;false&#125;;void bfs(int x, int y) &#123; bool result = false; int tox, toy, step; queue&lt;int&gt; q; q.push(x); q.push(y); q.push(1); // 改动 1 flag[x][y] = true; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); step = q.front(); q.pop(); // 改动 2 if (x == n-1 &amp;&amp; y == m-1) &#123; result = true; ans = step; // 改动 3 break; &#125; for (int i = 0; i &lt; 4; ++i) &#123; tox = x + movex[i]; toy = y + movey[i]; if (tox &gt;= 0 &amp;&amp; tox &lt;n &amp;&amp; toy &gt;=0 &amp;&amp; toy&lt;m &amp;&amp; tu[tox][toy] == &#x27;.&#x27; &amp;&amp; flag[tox][toy]== false) &#123; flag[tox][toy] = true; q.push(tox); q.push(toy); q.push(step+1); // 改动 4 &#125; &#125; &#125; if (result) cout &lt;&lt; &quot;Yes, step = &quot; &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; tu[i]; &#125; bfs(0, 0); return 0;&#125; 迷宫寻路加强：求路径当我们需要输出路径的时候，我们需要做两件事情： 1、把 BFS 经过的数据全部保存下来。这个时候我们就不能用队列了，只能用 vector，然后另外用一个变量 idx 来记录处理过的元素下标。于是，判断是否处理完的条件变成了如下的形式： 1while (idx != q.size()) 2、我们需要对每个元素中增加一个 parent 变量，记录它是来自哪一个下标。这样就可以把整个路径串起来。如下的形式： 123456struct Node &#123; int x, y, step, parent; Node(int _x, int _y, int _step, int _parent) &#123; x = _x; y = _y; step = _step; parent=_parent; &#125;&#125;; 最终，整体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * B3625 迷宫寻路，宽度优先搜索。 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, ans;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;char tu[110][110];bool flag[110][110] = &#123;false&#125;;struct Node &#123; int x, y, step, parent; Node(int _x, int _y, int _step, int _parent) &#123; x = _x; y = _y; step = _step; parent=_parent; &#125;&#125;;void bfs(int x, int y) &#123; bool result = false; int tox, toy, step; vector&lt;Node&gt; q; int idx = 0; q.push_back(Node(x, y, 1, -1)); flag[x][y] = true; while (idx != q.size()) &#123; Node node = q[idx]; if (node.x == n-1 &amp;&amp; node.y == m-1) &#123; result = true; // output stack&lt;Node&gt; s; s.push(node); while (node.parent != -1) &#123; node = q[node.parent]; s.push(node); &#125; while (!s.empty()) &#123; node = s.top(); s.pop(); printf(&quot;(%d, %d) -&gt;\\n&quot;, node.x+1, node.y+1); &#125; break; &#125; for (int i = 0; i &lt; 4; ++i) &#123; tox = node.x + movex[i]; toy = node.y + movey[i]; if (tox &gt;= 0 &amp;&amp; tox &lt;n &amp;&amp; toy &gt;=0 &amp;&amp; toy&lt;m &amp;&amp; tu[tox][toy] == &#x27;.&#x27; &amp;&amp; flag[tox][toy]== false) &#123; flag[tox][toy] = true; q.push_back(Node(tox, toy, step+1, idx)); &#125; &#125; idx++; &#125; if (!result) printf(&quot;No\\n&quot;);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; tu[i]; &#125; bfs(0, 0); return 0;&#125;/*3 5.##.#.#......#.*/ P1443 马的遍历有了迷宫寻路的变种练习基础，我们就可以正式练习用 BFS 来求最近的步数一类的题目了。这其中比较适合的题目是： P1443 马的遍历。 《马的遍历》一题要求我们把所有位置的最近距离都求出来，我们可以用一个数组来保存结果。 同时，马可以跳 8 个方向，有了之前的建 movex, movey 的经验，我们知道，每组数是 1 与 2 的各种组合。于是可以快速写出来这两个方向数组。 具体写法是： 先写 x 数组，把所有的负数写出来，再写所有的正数。 考虑到每个数会有正负两个 y 与此搭档，所以每个数我们写两遍。这样就写出来了 -2,-2,-1,-1,1,1,2,2 然后我们对着 movex 写 movey，凡是对应的 movex 是 2 的，我们就写 1，凡是 movex 是 1的，我们就写 2，同样的我们需要写正数和负数两遍。 写完后两个数组的字符串也应该是刚好一样的，可以帮我们作为一个检查手段。 具体如下所示： 12int movex[]=&#123;-2,-2,-1,-1,1,1,2,2&#125;;int movey[]=&#123;-1,1,2,-2,2,-2,1,-1&#125;; 完整的《马的遍历》的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * P1443 马的遍历, 宽度优先搜索 */#include &lt;bits/stdc++.h&gt;using namespace std;// 坐标是从 1,1 开始算的int n, m, x, y;int tu[410][410];bool flag[410][410]=&#123;false&#125;;int movex[]=&#123;-2,-2,-1,-1,1,1,2,2&#125;;int movey[]=&#123;-1,1,2,-2,2,-2,1,-1&#125;;void bfs(int x, int y) &#123; queue&lt;int&gt; q; q.push(x); q.push(y); q.push(0); tu[x][y] = 0; flag[x][y] = true; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); int step = q.front(); q.pop(); for (int i = 0; i &lt; 8; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox&gt;=1 &amp;&amp; tox&lt;=n &amp;&amp; toy&gt;=1 &amp;&amp; toy&lt;=m &amp;&amp; !flag[tox][toy])&#123; flag[tox][toy] = true; q.push(tox); q.push(toy); q.push(step+1); tu[tox][toy] = step+1; &#125; &#125; &#125;&#125;int main() &#123; memset(tu, -1, sizeof(tu)); cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; bfs(x, y); for (int i = 1; i &lt;=n ; ++i) &#123; for (int j = 1; j&lt;=m; ++j) &#123; printf(&quot;%d &quot;, tu[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 本题还有一个小的教学点，就是用 memset 来初始化值为 -1。可以顺便教学 memset 可以初使化的值，告诉学生不是每种值都可以用 memset 来初始化。 P1135 奇怪的电梯P1135 奇怪的电梯 一题的意义在于，用非地图的形式来教学 BFS，让学生知道 BFS 不仅仅可以是在地图上。 但从实现来说，此题的难度相对较小。此题的参考代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * P1135 奇怪的电梯 * * 宽度优先搜索 */#include &lt;bits/stdc++.h&gt;using namespace std;int N, A, B;int jump[210];char flag[210]=&#123;0&#125;;int ans = -1;struct Node &#123; int v; int step;&#125;;void bfs() &#123; Node node, up, down; queue&lt;Node&gt; q; if (A == B) &#123; ans = 0; return ; &#125; node.v = A; node.step = 0; q.push(node); flag[node.v] = 1; while (!q.empty()) &#123; up = down = node = q.front(); q.pop(); up.v += jump[node.v]; down.v -= jump[node.v]; up.step = down.step = node.step + 1; if (up.v &lt;= N &amp;&amp; flag[up.v] == 0) &#123; q.push(up); flag[up.v] = 1; &#125; if (down.v &gt;=1 &amp;&amp; flag[down.v] ==0 ) &#123; q.push( down ); flag[down.v] = 1; &#125; if (up.v == B || down.v == B) &#123; ans = node.step + 1; break; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;N, &amp;A, &amp;B); for (int i = 0; i &lt; N; ++i) &#123; scanf(&quot;%d&quot;, jump+i+1); &#125; bfs(); printf(&quot;%d\\n&quot;, ans); return 0;&#125; P1162 填涂颜色P1162 填涂颜色 可以用来学习地图标记的一个技巧：将地图往外扩一圈 0 ，减少标记难度。实际在写的时候，只需要从下标 1 开始读数据即可。 此题的参考代码如下，代码的最后用注释带了一个测试用例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * P1162 填涂颜色 */#include &lt;bits/stdc++.h&gt;using namespace std;int n;int tu[40][40] = &#123;0&#125;;bool flag[40][40] = &#123;false&#125;;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;void bfs(int x, int y) &#123; queue&lt;int&gt; q; q.push(x); q.push(y); flag[x][y] = true; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int tox = x+movex[i]; int toy = y+movey[i]; if (tox&gt;=0 &amp;&amp; tox&lt;=n+1 &amp;&amp; toy &gt;=0 &amp;&amp; toy&lt;=n+1 &amp;&amp; tu[tox][toy] == 0 &amp;&amp; flag[tox][toy]==false) &#123; q.push(tox); q.push(toy); flag[tox][toy] = true; &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;=n; ++j) &#123; scanf(&quot;%d&quot;, &amp;tu[i][j]); &#125; &#125; bfs(0, 0); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;=n; ++j) &#123; if (tu[i][j] == 0 &amp;&amp; flag[i][j] == false) &#123; printf(&quot;%d &quot;, 2); &#125; else &#123; printf(&quot;%d &quot;, tu[i][j]); &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;/*60 0 0 0 0 00 0 1 1 1 10 1 1 0 1 01 1 0 0 1 10 1 0 0 1 11 1 1 1 1 0*/ P1506 拯救oibh总部P1506 拯救oibh总部 强化上一题学到的技巧。 同时我们此题学习用 memset 将 char 数组统一设置成字符’0’： 1memset(tu, &#x27;0&#x27;, sizeof(tu)); 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * P1506 拯救oibh总部 */#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;char tu[510][510]=&#123;0&#125;;bool flag[510][510]=&#123;false&#125;;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;void bfs(int x, int y) &#123; queue&lt;int&gt; q; q.push(x); q.push(y); flag[x][y] = 1; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox&gt;=0 &amp;&amp; tox &lt;=n+1 &amp;&amp; toy&gt;=0 &amp;&amp; toy &lt;=m+1 &amp;&amp; tu[tox][toy] == &#x27;0&#x27; &amp;&amp; flag[tox][toy] == false) &#123; flag[tox][toy] = true; q.push(tox); q.push(toy); &#125; &#125; &#125;&#125;int main() &#123; memset(tu, &#x27;0&#x27;, sizeof(tu)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; char ss[510]; scanf(&quot;%s&quot;, ss); for (int j = 1; j &lt;= m; ++j) &#123; tu[i][j] = ss[j-1]; &#125; &#125; bfs(0, 0); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;=m; ++j) &#123; if (tu[i][j] == &#x27;0&#x27; &amp;&amp; flag[i][j]==false) ans++; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; P1825 Corn Maze SP1825 Corn Maze S 增加了“地图传送”这种新的玩法，使得 BFS 代码写起来会更加复杂一点。 像这种更复杂的 BFS，我们就可以引入结构体，来让代码更整洁一点。结构体定义如下： 12345struct Node &#123; int x, y; Node() &#123;x=y=0;&#125; Node(int _x, int _y) &#123;x = _x; y=_y;&#125;&#125;; 因为在 BFS 的过程中，我们还需要记录步数，所以我们用 STL 的 pair 来存储队列元素。借此题，我们完成了 pair 的教学。 pair 的关键用法如下： 123456789// 定义queue&lt;pair&lt;Node, int&gt; &gt; q;// 入队q.push(make_pair(a, 0));// 出队pair&lt;Node, int&gt; one = q.front(); q.pop();// 使用Node a = one.first;int step = one.second; 完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * P1825 [USACO11OPEN] Corn Maze S * 宽度优先搜索 * * 遇到传送的时候，把位置更新到另一个传送点。 */#include &lt;bits/stdc++.h&gt;using namespace std;int N,M;char tu[310][310]=&#123;0&#125;;bool flag[310][310]=&#123;0&#125;;struct Node &#123; int x, y; Node() &#123;x=y=0;&#125; Node(int _x, int _y) &#123;x = _x; y=_y;&#125;&#125;;Node st;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;bool operator==(Node a, Node b) &#123; return a.x == b.x &amp;&amp; a.y == b.y;&#125;Node getNode(char ch) &#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (tu[i][j] == ch) &#123; return Node(i,j); &#125; &#125; &#125; return Node(0, 0);&#125;Node getOtherNode(char ch, int x, int y) &#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (x == i &amp;&amp; y == j) continue; if (tu[i][j] == ch) &#123; return Node(i,j); &#125; &#125; &#125; return Node(0, 0);&#125;int bfs(Node a) &#123; queue&lt;pair&lt;Node, int&gt; &gt; q; q.push(make_pair(a, 0)); flag[a.x][a.y] = true; while (!q.empty()) &#123; pair&lt;Node, int&gt; one = q.front(); q.pop(); a = one.first; int step = one.second; char ch = tu[a.x][a.y]; if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;=&#x27;Z&#x27;) &#123; a = getOtherNode(ch, a.x, a.y); &#125; else if (ch == &#x27;=&#x27;) &#123; return step; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int tox = a.x + movex[i]; int toy = a.y + movey[i]; if (tox&gt;=0 &amp;&amp; tox&lt;N &amp;&amp; toy&gt;=0 &amp;&amp; toy&lt;M &amp;&amp; tu[tox][toy] != &#x27;#&#x27; &amp;&amp; !flag[tox][toy]) &#123; q.push(make_pair(Node(tox, toy), step+1)); flag[tox][toy] = true; &#125; &#125; &#125; return 0;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 0; i &lt; N; ++i) &#123; scanf(&quot;%s&quot;, tu[i]); &#125; Node st = getNode(&#x27;@&#x27;); printf(&quot;%d\\n&quot;, bfs(st)); return 0;&#125; P1451 求细胞数量P1451 求细胞数量 是一道非常基础的 BFS 题目。此题需要多次调用 BFS，参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * P1451 求细胞数量 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, ans = 0;char tu[110][110]=&#123;0&#125;;bool flag[110][110]=&#123;false&#125;;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;; void bfs(int x, int y) &#123; queue&lt;int&gt; q; q.push(x); q.push(y); flag[x][y] = true; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox &gt;= 0 &amp;&amp; tox &lt; n &amp;&amp; toy &gt;= 0 &amp;&amp; toy &lt; m &amp;&amp; tu[tox][toy]!=&#x27;0&#x27; &amp;&amp; flag[tox][toy]==false) &#123; flag[tox][toy] = true; q.push(tox); q.push(toy); &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%s&quot;, tu[i]); &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (tu[i][j] != &#x27;0&#x27; &amp;&amp; flag[i][j] == false) &#123; bfs(i, j); ans++; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; P1331 海战P1331 海战 一题的标记矩形的形式比较难想到，我个人用的是另外一个判断方法：看看所填充的坐标最小和最大值计算出来的矩形面积与标记的数量是否刚好匹配。 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 宽度优先搜索。 * * 先用 floodfill 把每组船支标记。标记的时候，记录： * - 最小 minx, miny 和最大 maxx, maxy * 然后判断是否标记的船只数量是否是正方形： * - cnt == (maxx-minx+1)*(maxy-miny+1) * */#include &lt;bits/stdc++.h&gt;using namespace std;int R, C;char tu[1100][1100] = &#123;0&#125;;bool flag[1100][1100] = &#123;false&#125;;int shipCnt = 0;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;bool debug = false;bool mark(int x, int y) &#123; int ans = 0; int minx, miny, maxx, maxy; queue&lt;int&gt; q; q.push(x); q.push(y); minx = maxx = x; miny = maxy = y; flag[x][y] = true; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); ans++; minx = min(minx, x); miny = min(miny, y); maxx = max(maxx, x); maxy = max(maxy, y); for (int i = 0; i &lt; 4; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox &gt;=0 &amp;&amp; tox &lt; R &amp;&amp; toy&gt;=0 &amp;&amp; toy&lt;C &amp;&amp; tu[tox][toy] == &#x27;#&#x27; &amp;&amp; !flag[tox][toy]) &#123; q.push(tox); q.push(toy); flag[tox][toy] = true; &#125; &#125; &#125; int cnt = (maxx-minx+1)*(maxy-miny+1); if (ans == cnt) &#123; shipCnt++; return true; &#125; else &#123; return false; &#125;&#125;void init() &#123; scanf(&quot;%d%d&quot;, &amp;R, &amp;C); for (int i = 0; i &lt; R; ++i) &#123; scanf(&quot;%s&quot;, tu[i]); &#125;&#125;void process() &#123; for (int i = 0; i &lt; R; ++i) &#123; for (int j = 0; j &lt; C; ++j) &#123; if (tu[i][j] == &#x27;#&#x27; &amp;&amp; flag[i][j] == false) &#123; if (!mark(i, j)) &#123; shipCnt = -1; return; &#125; &#125; &#125; &#125;&#125;int main() &#123; init(); process(); if (shipCnt == -1) printf(&quot;Bad placement.\\n&quot;); else printf(&quot;There are %d ships.\\n&quot;, shipCnt); return 0;&#125;/*6 8.....#.###.....###.....#.......###.....##..#...#*/ P2895 Meteor Shower S此题解法： 标记下地图每个不能行走的位置，以及它变成焦土的时间。 在 BFS 的时候，如果当前时间位置还没变成焦土，就可以继续走。 陷阱：有第 0 时刻就落下来的流星。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Author: Tang Qiao */#include &lt;bits/stdc++.h&gt;using namespace std;int m;// -1 表示可以行走，非 -1 表示在第 i 时刻变成焦土int tu[310][310];bool vis[310][310];int movex[] = &#123;0, 0, 0, 1, -1&#125;;int movey[] = &#123;0, 1, -1, 0, 0&#125;;struct Node &#123; int x, y, t; Node(int _x, int _y, int _t) : x(_x), y(_y), t(_t) &#123;&#125;&#125;;void mark(int x, int y, int t) &#123; for (int i = 0; i &lt; 5; i++) &#123; int nx = x + movex[i]; int ny = y + movey[i]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0) &#123; if (tu[nx][ny] == -1) tu[nx][ny] = t; else tu[nx][ny] = min(tu[nx][ny], t); &#125; &#125;&#125;void bfs() &#123; queue&lt;Node&gt; q; q.push(Node(0, 0, 0)); vis[0][0] = true; while (!q.empty()) &#123; Node node = q.front(); q.pop(); if (tu[node.x][node.y] == -1) &#123; cout &lt;&lt; node.t &lt;&lt; endl; return; &#125; for (int i = 1; i &lt; 5; i++) &#123; int nx = node.x + movex[i]; int ny = node.y + movey[i]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; !vis[nx][ny]) &#123; if (tu[nx][ny] == -1) &#123; cout &lt;&lt; node.t + 1 &lt;&lt; endl; return; &#125; if (tu[nx][ny] &gt; node.t + 1) &#123; vis[nx][ny] = true; q.push(Node(nx, ny, node.t + 1)); &#125; &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl;&#125;int main() &#123; memset(tu, -1, sizeof(tu)); cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int x, y, t; cin &gt;&gt; x &gt;&gt; y &gt;&gt; t; mark(x, y, t); &#125; bfs(); return 0;&#125; P1141 01迷宫P1141 01迷宫 这道题的难度在于，我们需要 BFS 之后，把结果全部保存下来，之后每次查询的时候把答案直接输出就可以了。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 此题 m 的量很大，所以要提前算出答案。 */#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;char tu[1100][1100];int flag[1100][1100];vector&lt;int&gt; ans;int movex[]=&#123;1,-1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;bool debug=true;char convert(char ch) &#123; if (ch == &#x27;0&#x27;) return &#x27;1&#x27;; else return &#x27;0&#x27;;&#125;int mark(int x, int y, int v) &#123; int cnt = 0; queue&lt;pair&lt;int,int&gt; &gt; q; q.push(make_pair(x, y)); cnt++; flag[x][y] = v; while (!q.empty()) &#123; pair&lt;int, int&gt; a = q.front(); q.pop(); x = a.first; y = a.second; char ch = convert(tu[x][y]); for (int i = 0; i &lt; 4; ++i) &#123; int tox = x + movex[i]; int toy = y + movey[i]; if (tox &gt;=0 &amp;&amp; toy &gt;=0 &amp;&amp; tox &lt;n &amp;&amp; toy&lt;n &amp;&amp;tu[tox][toy]==ch &amp;&amp;flag[tox][toy]==-1) &#123; q.push(make_pair(tox, toy)); cnt++; flag[tox][toy] = v; &#125; &#125; &#125; return cnt;&#125;void process() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j)&#123; flag[i][j] = -1; &#125; &#125; int idx = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (flag[i][j] == -1) &#123; // 标记 idx int cnt = mark(i, j, idx); // 把标为 idx 的个数放到 ans 数组中 ans.push_back(cnt); idx++; &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%s&quot;, tu[i]); &#125; process(); for (int i = 0; i &lt; m; ++i) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int idx = flag[x-1][y-1]; printf(&quot;%d\\n&quot;, ans[idx]); &#125; return 0;&#125; P1746 离开中山路P1746 离开中山路参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * P1746 离开中山路 */#include &lt;bits/stdc++.h&gt;using namespace std;int n;char tu[1100][1100]=&#123;0&#125;;char flag[1100][1100]=&#123;0&#125;;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;int fx, fy, tx, ty;int bfs(int x, int y, int step) &#123; queue&lt;int&gt; q; q.push(x); q.push(y); q.push(step); flag[x][y] = 1; while (!q.empty()) &#123; x = q.front(); q.pop(); y = q.front(); q.pop(); step = q.front(); q.pop(); if (x == tx-1 &amp;&amp; y == ty-1) return step; for (int i = 0; i &lt; 4; ++i) &#123; int tox = x+movex[i]; int toy = y+movey[i]; if (tox &gt;= 0 &amp;&amp; tox &lt;n &amp;&amp; toy &gt;= 0 &amp;&amp; toy &lt;n &amp;&amp; tu[tox][toy]==&#x27;0&#x27; &amp;&amp; flag[tox][toy]==0) &#123; flag[tox][toy] = 1; q.push(tox); q.push(toy); q.push(step+1); &#125; &#125; &#125; return -1;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%s&quot;, tu[i]); &#125; scanf(&quot;%d%d%d%d&quot;, &amp;fx, &amp;fy, &amp;tx, &amp;ty); int ans = bfs(fx-1, fy-1, 0); printf(&quot;%d\\n&quot;, ans); return 0;&#125; P2802 回家P2802 回家一题的解题技巧是：将 flag 数组用于保存走上去时的最大血量。如果走上去最大血量可以更高，也是可以再次走的。 另外，当只剩 1 格血时，下一步不管走到哪儿都是死，所以就不用扩展了。 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * P2802 回家 */#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;int tu[15][15];char flag[15][15]=&#123;0&#125;;int sx, sy, tx, ty;int movex[]=&#123;-1,1,0,0&#125;;int movey[]=&#123;0,0,-1,1&#125;;struct Node &#123; int x, y, s, t; Node(int _x, int _y, int _s, int _t) &#123; x = _x; y=_y; s=_s; t=_t; &#125;&#125;;int bfs(int x, int y) &#123; queue&lt;Node&gt; q; q.push(Node(x, y, 0, 6)); flag[x][y] = 6; while (!q.empty()) &#123; Node node = q.front(); q.pop(); if (node.x == tx &amp;&amp; node.y == ty) &#123; return node.s; &#125; // 如果没到终点，只剩 1 点血，怎么都死 if (node.t == 1) continue; for (int i = 0; i &lt; 4; ++i) &#123; int tox = node.x + movex[i]; int toy = node.y + movey[i]; if (tox &gt;= 0 &amp;&amp; tox &lt; n &amp;&amp; toy &gt;= 0 &amp;&amp; toy &lt; m &amp;&amp; tu[tox][toy] != 0 &amp;&amp; flag[tox][toy] &lt; node.t - 1) &#123; flag[tox][toy] = node.t -1; int life = node.t - 1; if (tu[tox][toy] == 4) &#123; life = 6; &#125; q.push(Node(tox, toy, node.s+1, life)); &#125; &#125; &#125; return -1;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; scanf(&quot;%d&quot;, &amp;tu[i][j]); if (tu[i][j] == 2) &#123; sx = i; sy = j; &#125; if (tu[i][j] == 3) &#123; tx = i; ty = j; &#125; &#125; &#125; int ans = bfs(sx, sy); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"将 stdc++.h 加到 Macbook M1/M2/M3 编译环境中","slug":"add-stdc-to-macbook-m1","date":"2024-12-01T03:29:19.000Z","updated":"2024-12-01T03:48:08.803Z","comments":true,"path":"2024/12/01/add-stdc-to-macbook-m1/","permalink":"https://blog.devtang.com/2024/12/01/add-stdc-to-macbook-m1/","excerpt":"","text":"查了好多资料，大多是不能 work 的。感谢这个视频教程：https://www.youtube.com/watch?v=LmR8sRcqbq0，最终帮我完成了需求。 以下是步骤概述： 1、在命令行执行：echo | g++ -v -x c++ -E -，我的运行结果如下： &gt; echo | g++ -v -x c++ -E -Apple clang version 16.0.0 (clang-1600.0.26.3)Target: arm64-apple-darwin23.6.0Thread model: posix// 此处省略若干行#include &quot;...&quot; search starts here:#include &lt;...&gt; search starts here: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1 /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/16/include /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks (framework directory)End of search list.# 1 &quot;&lt;stdin&gt;&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 439 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;&lt;stdin&gt;&quot; 2 2、在上一步的结果中，寻找 include &lt;...&gt; search starts here 那一行，在那一行后面有提供 5 个路径，找到中间那个路径，按住 cmd 点击，可以用鼠标打开那个路径。如下图： 3、找开之后，在那个路径新建名为 bits 的文件夹。 4、进入 bits文件夹，随便粘贴一个头文件进去，然后改名为 stdc++.h，修改文件内容如下： // C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2014 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;http://www.gnu.org/licenses/&gt;./** @file stdc++.h * This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif 完成以上步骤，搞定！","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"颠覆技术的发展 - 读《浪潮将至》","slug":"wave-coming","date":"2024-11-17T14:56:13.000Z","updated":"2024-12-01T15:00:54.053Z","comments":true,"path":"2024/11/17/wave-coming/","permalink":"https://blog.devtang.com/2024/11/17/wave-coming/","excerpt":"","text":"最近看了 DeepMind 联合创始人和微软人工智能 CEO 苏莱曼的 《浪潮将至》。 该书主要介绍了未来极大可能改变世界的三个技术领域，分别是人工智能、合成生物学、量子技术。 以下是一些读书感悟。 颠覆技术的对抗非对称性对抗非对称性指：拥有颠覆技术的一方可以用极小的力量对抗过去不可能对抗的力量。 这可以类比为在冷兵器时代拥有机关枪的一个人就可以对抗一整个敌人军队。 核武器的对抗也具备非对称性。拥有核武器的一方对非核国家也具备碾压性的优势。当然，后面全球努力在限制这种能力，以免被恐怖组织拥有带来全球的灭顶之灾。 人工智能的非对称性体现在对很多方面：拥有超级人工智能的组织的生产力可以是千倍于传统生产力。 书中列举了 DeepMind 公司在预测蛋白质结构上的突破，在这个技术出现之前，人类的蛋白质结构数据库中只有大概 20 万个蛋白质结构。DeepMind 公司一次性上传了 2 亿个新的蛋白质结构，几乎覆盖了所有已知的蛋白质。2 亿 vs 20 万，就是一个 1000 倍的对抗优势。 马斯克的擎天柱人形机器人如果成功大规模量产，也可能将全球制造业格局重塑。现在制造业主要还是集中于人力成本低廉的国家（例如中国，东南亚，墨西哥），到时候不需要吃饭和休息的机器的成本可能是人类的 百分之一。 现在看起来，人工智能似乎可以改变所有行业，唯一不可能替代的是人类亲自服务和沟通带来的某些情绪价值。 颠覆技术的普及性不同于核武器技术，这些颠覆性技术的获取难度非常低。现在非常多的大模型技术公司的代码和模型都是开源的，普通人可以方便地从网上获取到相关资源。GitHub 平台上已经有 1.9 亿个代码库，其中大部分都是开源的。 现在全球顶尖的研究成果论文也可以从网上免费下载。特别是预印本网站，它加速了全球获取论文的方便程度。arXiv 上已经收录了超过 200 万篇论文。 对于生物技术来说，可打印定制 DNA 链的 DNA 合成器的购买只需要几万美元，而且该机器小巧便捷。下图是我在微信公众号搜到的一款 DNA 合成器，重量为 60 公斤，尺寸为 1&#x2F;8 立方米，比一个家用洗衣机还小。 作者打了一个比方：一个邪恶的恐怖组织只需要在网上下单，就可以拥有制造出新型病原体的能力。这些病原体可以被设计成规避人类的已知对策，以无症状的方式传播，具备对抗治疗的能力。 所以，未来一个人很可能“具备杀死 10 亿人的能力”，所需的仅仅是一个动机。 “绝命毒师”如果出现在那个时代，会有这样的动机吗？ 颠覆技术的监管难度颠覆技术不像原子弹那样明显让人意识到危险，所以大众还没有对监管产生紧迫感。 作者曾经在谷歌成立了一个人工智能伦理委员会。但是最终因为委员会里面有几个人曾经发表过反对跨性别的言论，于是大家的争论变成了要求这几个人从委员会辞职。 政治正确比人工智能的伦理更重要，于是这个委员会就解散了。 顺便说一下，几年前我听说谷歌所有项目成立的时候，都需要考虑这个项目组成员有没有黑人，有没有女人，是不是政治正确的。 颠覆技术的监管连政治正确都克服不了，更别说国际社会之间的各种利益鸿沟了。 未来畅想：如何减小影响颠覆技术在未来如果把工作替代了，会产生怎样的动荡？200 年前的工业革命可以给我们一些参考。 1807 年，由于工资被消减，6000 名英国织布工人发起抗议示威。1811 年，破坏者袭击了当地的工厂，摧毁了 63 台纺织机。 颠覆技术如果让大量普通民众失业，很显然是非常危险的。我们应该在推进技术进步的同时，考虑到对现有工人的就业影响，以尽量温和的方式来推进变革。 我曾经想过如何减小自动驾驶技术对滴滴司机的就业影响。我的方法如下： 同价。通过税收调节，保证自动驾驶车和有人驾驶车同价。自动驾驶车收重税，税收用于安置被影响的司机。 控量。通过颁发牌照，慢慢减少有人驾驶车。 转移岗位。把司机转岗培训成无人驾驶车的看护员，做一些清洁保障保养等工作。 通过以上办法，慢慢把滴滴司机都安置好了，再减少税收，让自动驾驶慢慢赢得市场。 以上假想只是针对自动驾驶技术，但如果颠覆技术一次性颠覆了大部分行业，其应对方案会变得更难。 小结《浪潮将至》介绍了颠覆技术（人工智能、合成生物学、量子技术）的对抗非对称性，知识普及性，和监管的难度。 未来如何发展，我们拭目以待。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"如何控制孩子的电脑使用","slug":"time-control-of-cspj-learning","date":"2024-11-08T01:09:08.000Z","updated":"2024-11-08T01:35:43.616Z","comments":true,"path":"2024/11/08/time-control-of-cspj-learning/","permalink":"https://blog.devtang.com/2024/11/08/time-control-of-cspj-learning/","excerpt":"","text":"背景和问题小学生在学习编程的时候，我们必然需要使用电脑上机练习。但是，电脑上也充满了各种“诱惑”： 打开网页无处不在的游戏广告，很多游戏还是网页游戏 应用市场里各种各样的游戏 小红书，B 站等各种各样的网站也充满吸引力 那我们如何保证孩子能够在上机的时候一直专心练习编程呢？难道得一直在旁边盯着吗？ 为此，我做了一些功课，分享给大家。 解决方案（Windows 平台）微软的 Windows 操作系统中有一个家长控制功能。通过该功能家长可以限制小朋友对计算机功能的使用，以及规定和限制使用 Windows 的某些功能。 例如: 限制孩子的账户只能使用某个应用程序、游戏等。 使用 Windows 的家长控制功能可以在不安装其它软件的情况下，控制孩子使用Windows的绝大部分应用和功能。 具体操作方式如下。 1、为孩子创建一个单独账号 按下键盘上的“Windows”键+“I”键打开设置→点击“账户” 点击左侧的“账户&#x2F;家庭和其他用户”，并“添加账户” 在弹出的窗口中点击“为孩子创建一个”，按步骤创建新的Microsoft账户 用新建的账户登录，在“概述”里面的隐私设置里打开“共享我的活动”，如下图 2、在线管理家庭设置 用家长账户重新登录电脑 再次按下“Windows”键+“I”键打开设置→点击“账户” 点击左侧的“账户&#x2F;家庭和其他用户” 点击“在线管理家庭设置或删除账户”打开管理链接 在管理链接中就可以管理孩子的时间了。 解决方案（Mac 平台） 1、为孩子单独注册一个 Apple ID。 Mac 平台的家庭共享功能可以将孩子加入到一个家庭中。 可以在家庭共享中进入到孩子的帐户，查看孩子的屏幕使用时间，以及限制一些功能的使用。如下图： 以上。","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"CSPJ 教学思考：for 循环","slug":"teach-notes-of-for-loop","date":"2024-11-07T01:13:43.000Z","updated":"2025-05-11T11:37:01.264Z","comments":true,"path":"2024/11/07/teach-notes-of-for-loop/","permalink":"https://blog.devtang.com/2024/11/07/teach-notes-of-for-loop/","excerpt":"","text":"背景和问题小学生在学习编程的时候，像变量，赋值，输入，输出，分支这些逻辑相对容易理解。因为这与人类真实世界的很多行为相似，所以学生会很容易吸收。具体来说： 变量其实就是我们平时取的“名字”或者“外号”，用于指代一种特定物品。 赋值相当于为这种特定物品指定一种属性值，像是苹果的重量，价格一样。 输入和输出在很多电子产品中都有接触，孩子现在很小就接触手机，非常容易理解键盘就是一种输入，屏幕显示就是一种输出。 分支就是我们自然语言中的“如果…就”，非常容易类比。 但是，for 循环由于其很难与现实世界“类比”，所以成为小学生学习编程的第一个障碍。 如何理解 for 循环，并且灵活运用 for 循环，成为一个教学难点。 教学思考我在教学 for 循环的时候发现，如果我们用尽量渐进式的方式，让孩子刚开始接触到的 for 循环与现实世界数学中的数列一一对应。然后，再一步一步拔高难度，随着难度提高，最终 for 循环可以实现求解“非波拉切数列”以及“小数点后 10000 位”这类已经高度变型的题目。 因为每一步的难度提升梯度很小，所以学生虽然找不到现实世界类比，但终于还是比较容易理解整个渐进变化的过程。 这就类似于我们学立体几何前先学平面几何，学平面几何前先学点线面一样。从微小的简单事物开始，我们最终可以创造整个世界。 以下是我对 for 循环的具体教学拆解。 教学拆解1、用 for 循环输出数列输出从 1-N 的等差数列是使用 for 循环最基础形式。我们先用这个引入，让孩子先初步了解 for 循环的三段形式。 for 循环的三段式其实对初学者来说还是有点绕，借此环节把 for 的基本格式熟悉。 示例代码： 1234cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; i &lt;&lt; endl;&#125; 2、用 for 循环输出 1-N 的和累加器的写法对于初学者来说是一个小障碍，但是累加器与 for 循环的结合使用在之后的变化很常见，所以我们在这个阶段把累加器引入，帮助孩子建立累加器的使用习惯。 示例代码： 123456int sum = 0;cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; sum += i;&#125;cout &lt;&lt; sum &lt;&lt; endl; 注：对于不习惯 +&#x3D; 的学生，也可以刚开始用 sum = sum + i来教学，减少学生的陌生感。 此题对应的线上练习是：《2016：【例4.1】for循环求和》 此题也可以进一步变化为：分别求奇数和、偶数和。让学生学会在 for 里面嵌入 if 表达式。 奇偶数之和线上练习：《2018：【例4.3】输出奇偶数之和》 奇数求和的线上练习：《1065：奇数求和》 3、用 for 循环输出 1-N 的和的平均值平均值的计算涉及整除的概念，需要在除之前将被除数转化为小数，同时需要用 iomanip 头文件中的函数来控制输出格式，这一编程技巧正好在这一步引入，让学生逐步熟悉对输出的控制。 示例代码： 123456789#include &lt;iomanip&gt;// 此处省略若干行int sum = 0;cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; sum += i;&#125;cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; double(sum)/n &lt;&lt; endl; 此题对应的线上练习是：《1060：均值》 4、输入 N，接着输入 N 个数求和大部分学生以为 for 循环是 for 循环，输入是输入，却不知道for 循环里面也可以写输入。通过此题，学生可以更多了解 for 循环的用处：用来批量输入。 示例代码： 1234567int sum = 0, a;cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a; sum += a;&#125;cout &lt;&lt; sum &lt;&lt; endl; 相关练习： 《1060：均值》 《1061：求整数的和与均值》 5、输入 N 个数，求能整除 4 的个数与上一题类似，我们在这里引入 if 条件，让学生了解，for 循环里面可以放前面学过的分支结构。 另外，本题的累加器变形为“计数”。让学生对计数的操作产生基本的认知。 示例代码： 123456789int cnt = 0, a;cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a; if (a % 4 == 0) &#123; cnt++; &#125;&#125;cout &lt;&lt; cnt &lt;&lt; endl; 6、输入 N 个数，统计值为 1、5 的个数我们在上一题的基础上增加难度，让累加器可以是多个。 示例代码： 12345678int cnt1 = 0, cnt5 = 0, a;cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a; if (a == 1) cnt1++; if (a == 5) cnt5++;&#125;cout &lt;&lt; cnt1 &lt;&lt; &quot; &quot; &lt;&lt; cnt5 &lt;&lt; endl; 相关练习： 《1067：整数的个数》 《1068：与指定数字相同的数的个数》 7、输入 N 个数，求 N 个数的乘积我们学会了在 for 循环中累加，计数，那更多的变化就是求乘积了。在求乘积的时候，这个累积的变量值要从 1 开始。 示例代码： 1234567int mul = 1, a;cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a; mul = mul * a;&#125;cout &lt;&lt; mul &lt;&lt; endl; 此题对应的线上练习是：《2019：【例4.4】求阶乘》 8、输入 N 和 M，求 M 的 N 次方次方是乘积的另一种变化。线上的练习题是：《1069：乘方计算》 示例代码： 123456int mul = 1, m, n;cin &gt;&gt; m &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) &#123; mul = mul * m;&#125;cout &lt;&lt; mul &lt;&lt; endl; M 的 N 次方还有两种难度的加强，分别是： 让学生考虑数据范围，用 long long 代替 int 在数据范围超过 long long 时，取结果的末尾 5 位数 8、输入 N 个数，让你对这 N 个数做更复杂的操作《1075：药房管理》一题就展示了一种更复杂的 for 循环。 原来我们不但可以累加，计数，求积，还可以做减法。 示例代码： 12345678910cin &gt;&gt; m &gt;&gt; n;for (int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; a; if (m &gt;= a)&#123; m = m-a; &#125; else &#123; b = b+1; &#125;&#125;cout &lt;&lt; b &lt;&lt; endl; 9、求第 N 个斐波那契数《1071：菲波那契数》 要求求第 K 个斐波那契数。 我们在这个 for 循环中实现了递推算法。递推是一个对新手来说很“神奇”的计算机算法，对于初学者来说，斐波那契数是最佳的一个学习例题，因为代码可以非常短。容易理解递推的核心思想。 示例代码： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int a=1, b=1, c=1; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n-2; i++)&#123; c = b+a; a = b; b = c; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 10、有一个数 N，满足 N*(N+1)*(N+2)*(N+3) = 1680 请问 N 的值是几暴力枚举的基础代码也是 for 循环，我们用一个最简单的题目来引入枚举的思想。 示例代码：略。 11、for 的嵌套：金字塔我们可以让学生试图输出一个二维的图形，比如输入 N，输出 N 层的金字塔。 金字塔的形状可以是这样： 1234********** 也可以是这样： 1234 * ** ******* 也可以是这样： 1234 * *** ************ 借此让学生锻炼模拟的能力。 此题对应的线上练习是：《2027：【例4.13】三角形》 12、for 的嵌套：矩形输入矩形的宽高，输出下面的形状。借此更一步强化学生模拟的能力。 1234****** ** ****** 此题对应的线上练习是：《1097：画矩形》 13、for 的逆序for 循环中的三段，除了正向的写，也可以逆向的写。所以，我们可以让学生尝试把 1-N 倒着输出。 类似的，也可以提醒 for 的第三段i++其实也可以改成 i+=2之类的形式，实现各种跳着输出的情况。 for 循环的进阶for 循环在复杂的题目当中，会涉及非常复杂的循环操作，这个时候，我们可以让学生学习将 for 循环的数列与目标输出之间建立对应关系。 比如，在输出如下金字塔的时候， 1234********** 我们可以先让学生把 for 循环与每一行的*的个数建立关联。 123for (int i = 1; i &lt;= 4; ++i) &#123; cout &lt;&lt; i &lt;&lt; endl;&#125; 然后，我们再把这个个数转换成 *，变成实际的代码： 123456for (int i = 1; i &lt;= 4; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; cout &lt;&lt; &quot;*&quot;; &#125; cout &lt;&lt; endl;&#125; 教学实操单人教学在实操中，我们可以用一块白板进行代码的演示，然后不断擦写相关的关键代码，保留基础的 for 框架。这样方便学生观察到其中的变化与不变。 在没有白板的时候，也可以用电脑中的 IDE 或 PPT 来进行演示。 对于每一步的问题，可以让学生来应答。通过应答的过程，观察学生对此类问题的掌握情况，有选择的加速进度或者放慢进度，保证学生对知识的吸收到位。 多人教学在多人教学的时候，可以让大家在纸上写下自己的答案，然后待大家都完成或大部分完成后，随机选择一位学生给其他人讲解，通过互助的方式，既锻炼了学生的表达，又强化了学生对知识的理解。 对于未完成的同学，可以让他反向提问，其他人帮忙解答。老师在这个过程中只需要监督整个过程，保证知识传递是正确的即可。","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"本分 - 读《段永平投资回答录》","slug":"notes-from-duan-yong-ping","date":"2024-10-27T03:50:04.000Z","updated":"2024-12-01T15:08:26.878Z","comments":true,"path":"2024/10/27/notes-from-duan-yong-ping/","permalink":"https://blog.devtang.com/2024/10/27/notes-from-duan-yong-ping/","excerpt":"","text":"最近读了《段永平投资回答录》，分为商业逻辑篇和投资逻辑篇。一些感受深的点记录一下。 不为清单段永平说：我们之所以成为我们，很多时候不是因为我们做了什么，而是因为我们不做什么。 查理芒格说：如果知道我会死在哪里，我将永远不会去那里。 两个人的观点很相似，就是用“不做&#x2F;不去”的方式来限制自己的行为。为此，段永平为自己的企业经营制定了“不为清单”（Stop doing list）。这些不为清单确实帮助企业经营划清了一些原则和边界。 在段永平的不为清单里： 有一些是关于企业文化价值观的，比如：不攻击竞争对手、不拖付货款。 有一些是关于企业安全经营边界的，比如：不赊账、不代工、不借钱。 有一些是关于企业发展原则的，比如：不做不擅长的事情、不做没有差异化的产品。 不为清单在企业管理上具备很强的高效性。因为如果是要为清单，那么这个清单可能很长，也可能很模糊，最终大家一来记不住，二来不知道执行到什么程度。但不为清单就简单很多，遇到相似的事情，不做就可以了。 附上段永平的不为清单，如下： 专注。不做不擅长的事情。 不借钱。不负债就不会倒闭。 没有销售部。不讨价还价。 不赊账。 不拖付货款。 不晚发工资。 不做不诚信的事情。 不攻击竞争对手。 不打价格战。 不谈性价比。 不做没有差异化的产品。 不弯道超车，关注自己的进步，面对客观的事物发展和成长的规律。 不收购 不多元化 不关注市占率，不关注销量排名 不盲目扩张 不赚快钱 不虚夸产品 价值投资的逻辑段永平在书中帮我再次梳理了价值投资的逻辑，段永平说： 买股票就是买公司，买公司就是买其未来的现金流折现。 说说我个人的理解：买股票就是买公司，指的是用“长期拥有一家公司的心态来考量自己的买入交易”。怎么样才是“长期拥有”的心态呢，比如问自己： 如果这家公司退市了，你会不会紧张 如果这家公司停牌 10 年不能交易了，你会不会接受 如果这家公司股价跌了，你会不会开心（因为你可以继续买入） 有人说，退市了我怎么卖掉？但是，如果你是用拥有公司的心态在买股票，首先就不应该考虑短期买卖，也不应该用着急需要用的短期资金。 有人说，股价跌了我持仓亏损怎么办？但是，如果这家企业的内在价值（即：未来现金流）是没有变化的，那么它未来会持续给你贡献高的收益回报，股价长期而言也会在内在价值基线上下波动。所以这反而是一个好的买入机会。 所以，价值投资将股票的买卖转变为了三个方面的考量： 1、公司好不好 2、企业文化和管理层 3、价格是否划算（有安全边际） 总结下来就是：好业务、好管理、好价格。 公司好不好对于公司好不好的考查方式有很多，比如毛利率，经营壁垒，增长率等等，但段永平用他与巴菲特午餐时，巴菲特的回答总结道：最重要的是商业模式。 什么是商业模式呢？我理解为这家公司的“天赋”，即：环境变化也很难被改变的东西。不同的商业模式决定了一些公司会很辛苦才能活下来，另一些公司很轻松就可以活下来。举个例子： 斑马玩教具做的是 2-6 岁孩子的教育硬件，因为一款硬件的使用寿命大概有 3 年左右，所以，同一款产品几乎不会有复购的。但是我们看苹果手机，同样是 3 年左右的使用寿命，但是因为用户在生命期内可能每 3 年就买一次苹果手机，加上苹果手机的软硬件生态使得用户很难把它换掉，对于一个 20 岁的用户来说，他一辈子可能会用掉几十部苹果手机（3 年换一次）。这个从复购上来讲，就是一个很好的商业模式。 但是苹果手机与可口可乐比，商业模式就又会差一些。因为苹果手机需要不停迭代产品，否则就还是可能被淘汰。但是可口可乐并不需要改产品，它可以 100 年不改产品，甚至改产品对它是有害的。从产品迭代角度，可口可乐就比苹果手机要更优秀一些。 可口可乐与茅台酒比，商业模式就又会差一些。因为同样是卖水，茅台卖不掉的酒会随着年份升值，而可口可乐卖不掉的水会过期，只能倒掉。 所以，商业模式决定了公司的经营难度，商业模式好的公司，CEO 和管理层只要不犯错，公司大概率就不会有问题。 企业文化和管理层除了商业模式外，一家好的公司还应该有优秀的产品和市场团队。我个人认为： 好的产品应该消费者导向，满足用户的真实需求；尽可能做减法，不做功能的堆叠；以体验优先，而不是以成本优先。 好的市场活动应该保持克制和理性，不放大功能、不夸大承诺、不投机营销。营销的时候尽量以产品卖点为主，不讲赠品，优惠这些。 另外，公司有没有长期经营的价值导向，类似于段永平提到的不为清单。在这种文化下，管理层是否贯彻落地了相关的价值导向，而不是说一套做一套。 除了以上之外，站在股东角度，还需要看管理层是否有回报股东的意愿。这一点在 A 股上特别需要注意。 价格是否划算（有安全边际）如果前两点通过了，那么就到了第 3 点：当前的价格是否划算。 因为我们没有哪一个人能 100% 预测对未来，所以对于企业的经营风险，也是有可能出现黑天鹅事件的。当出现这类事件后，我们的安全边际就给了我们一些安全垫。另外，虽然买股票是一个长期投资行为，但我们多年以后，还是可能会有卖出的需求，有了安全边际，在卖出的时候股价偏离真实价值的可能性就会更低一些。 长期主义的毛估估段永平的价值投资特点还在于长期主义的毛估估，用定性的评估代替定量的计算。他说： 我觉得所谓未来现金流的定性分析比定量分析要重要的多，用公式的人往往会陷于细节而忽略整体。 当年段永平投资网易，就是看到游戏行业的巨大，认为网易很可能估计涨到百亿。这种长期主义的感性评估，使得段永平不必特别计算回报的年限和当前的财务水平，只需要足够多的耐心就可以收获到百倍以上的回报。 长期主义的毛估估，这种做法很容易找到当下被低估的成长型企业。而且看准之后收获是十倍百倍的，所以很值得学习。网易就是一个案例。 用长期主义的毛估估，也可以敢于对当下偏贵的股票下手，因为长期主义来看，当前贵的股票其实长期看起来并不贵。段永平对苹果公司的投资就是一个案例。 巴菲特曾经说过：“当时喜诗糖果如果再贵 500 万美元，他就不会买了，现在看起来真是太愚蠢了”。这也是同样的道理。 但是困难点就在于能够看这么远不容易，需要对某个行业有较深刻的认识，才能够拿得住股票，穿越股价的波动，不被外界影响。所以段永平说，他花两年才能看懂一家企业。 快速折现法我基于段永平的毛估估思想，想了一个快速折现的方法，仅用于那种营收相对稳定的公司计算现金流折现。 具体方法是：我们假设这家公司每年的利润是 100 元，在未来 10 年内不会有大的利润差异。快速的毛估估以 7% 的现金流折现算，因为 72 法则，所以大概 10 年后的现金 100 块，在现在就只值 50 块了。于是，我们可以用简单的等差数列求和（其实不是等差数例）来估算 10 年的现金流总和：sum = (50 + 100) * 10 / 2 = 750。 这与用等比数列求和公式sum = a1*(1-q^n)/(1-q), q=1/1.06计算出来的和 780 相差无几(误差 5% 以内）。 对股价波动的理解 市场短期看是投票器，长期看是称重机。—-格雷厄姆。 短期的股价是由供求（买卖量）决定的，长期股价是由价值决定的。因为股价如果偏离价值太多，最终会被各种行为纠正。这种纠正包括：财报数据、回购、分红、甚至私有化。 总之，纠正股价偏离行为的底层支持是价值背后的现金流。关于这个，段永平举了一个具体的例子：假如市场就是不喜欢网易，网易股价一直在几千万市值，然后如果网易一年能够赚 20 亿美金，这个时候，网易的赢利能力一定能够让股价回归。 企业价值 Enterprise value相对于 PE，段永平提出了 EE 的概念，第一个 E 指的是企业价值 Enterprise value。具体来说，企业价值 = 市值 + 负债 - 现金。段永平希望用这种方式把企业的债务也算到你拥有这家企业付出的潜在成本。当然，企业的现金就是你拥有它的直接收益，所以减掉。 整个概念还是建立在“买股票就是买公司”基础逻辑下。因为如果你买下一家公司，理论上这家公司的债务也被你买下了，所以这部分的成本不能不看。 如何能拿住百倍的增长段永平分享了他如何拿住网易，收获了超过 100 倍的回报的。 能够拿得住最主要原因还是对公司及其业务的了解，还有就是平常心，不要去想买入的成本，把焦点放在能理解的未来现金流上。 在不断 review 自己拥有的公司的赢利能力的时候，如果逻辑没有变，就可以持续持有。 投资用闲钱，晚上能睡觉段永平强调了投资要用闲钱，这样万一亏了，也不会影响生活质量。 另外，买入的资产不管怎么波动，都需要晚上能睡得着觉。 小结这本书其实不那么正式，都是段永平在雪球上的发贴，但是质量挺高的，现在很难得有经营成功的企业家写书传道，所以能通过他的贴子学到东西还是挺值的。另外，段永平的很多观点很难一下子理解，还是值得多读一读，常读常新。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"在 VS Code 中使用 cin 输入数据","slug":"use-cin-in-vscode","date":"2024-09-27T14:18:03.000Z","updated":"2024-11-07T01:14:43.425Z","comments":true,"path":"2024/09/27/use-cin-in-vscode/","permalink":"https://blog.devtang.com/2024/09/27/use-cin-in-vscode/","excerpt":"","text":"问题默认在 VS Code 中，我们无法使用 cin 输入数据。 解决方案步骤如下： 安装 Code Runner 插件 按 command + ,进入设置页面，输入 Run in Terminal 勾选上 Whether to run code in Integrated Terminal. 如下图所示：","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"第一性原理思考：解决问题的通用框架(续)","slug":"thinking-pattens","date":"2024-09-19T04:59:03.000Z","updated":"2024-09-21T13:51:33.138Z","comments":true,"path":"2024/09/19/thinking-pattens/","permalink":"https://blog.devtang.com/2024/09/19/thinking-pattens/","excerpt":"","text":"我在《第一性原理思考：解决问题的通用框架》介绍了一种思考解决问题的通用框架。其中的第 3 步：信息判断是制定解决方案的核心步骤，但我在原文中讲得比较笼统，这次再展开详细介绍一下。 信息判断有很多种方式和方法，我想先重点介绍几种我认为比较有用的判断方式，最后再介绍一些常见的信息判断的误区。 28 原理 我们在框架的第 1 步信息收集中，已经将问题相关的各种因素收集得比较全面。这个时候我们会发现，信息通常会非常丰富。而且，通常正面和反面的信息都有，这个时候信息判断决策就会比较困难。这个时候，我就需要用 28 原理，来找到最最核心的因素。 大自然其实就告诉了我们这个原理。在自然界，如果影响一个事情的因素有 10 个，那么这 10 个因素每个刚好权重占比 10%，是从来没有的现象。大部分时候，大自然的事物呈正态分布，核心的 20% 的因素对结果产生了 80% 的影响。 举几个真实的案例。 案例一：优化内容我在负责小猿搜题的时候，我们想优化题目解析的呈现。该工作最极致的优化做法，就是请老师为每一道题目录制一个 5 分钟左右的视频讲解。但是，我们有 2 亿道题目，如果全部优化一遍，我们的成本巨大，这个想法将变得不可执行。 在讨论方案的时候，我们想到这个问题或许符合 28 原理，于是我们将学生的搜索结果进行统计。结果发现，80% 的搜索结果落在了大概 500 万道题目上。于是，2 亿的工作量一下子缩减了 97.5%，我们只需要做不到 5% 的工作，就可以将题目呈现体验提升 80%。 案例二：优化硬件产品利用 28 原理做产品决策的“减法”也同样很有效果，特别是硬件产品。对于硬件产品来说，每一项功能的生产成本与功能的使用频率不成正比。核心的功能占到了 80% 以上的使用时间，但核心功能的成本占比通常不到 80%，这个时候，聚焦提升核心功能体验，减少非核心功能的开发，都是对 28 原理的应用。 案例三：填报志愿我高考完面临填报志愿选专业，我自己喜欢计算机专业，但是呢，我的分数不够上 985 学校里面计算机专业较强的大学。于是我的决策因素就有很多，要不要换专业，如果不换选哪个学校的计算机专业。这方面的考量因素很多，比如： 地域。我应该选哪个城市？ 学校。我应该选哪个学校？ 专业排名。这个学校的计算机专业排名是多少？ 竞争激烈度。其他人会抢这个专业吗？我的胜算是多大？ 就业难度。这个专业方向好就业吗？ 就业薪资。就业薪资是多少？ 兴趣。我对哪些专业有兴趣？ 风险。落榜的风险。 最后我花了很长时间，首先决定还是以兴趣做为第一导向，选择了计算机专业。然后优先挑选了北京的学校，因为我觉得北京离互联网行业近，可以有比较多的机会实习。最终我选择了北师大的计算机系，虽然这个专业在院校排名里面较为靠后。 在我的逻辑里面，“兴趣”就是占据 80% 权重的因素。因为有兴趣，才有可能付出比别人多，做得比别人好。相比兴趣，别的因素都不那么重要。事实证明，我的决策还是对的。我对计算机的兴趣帮助我在学习和工作中都保持了较高的投入度，进而获得了比较大的正面回报。我也在研究生阶段获得了 在 IBM 和网易的实习机会。当然，我的运气也不错，赶上了互联网行业的红利期。 谬误推导 “谬误推导”这个词是我生造的，因为我还没有找到合适的词语用于描述这种思维方式。 谬误推导是指：假设某个观点是真理，然后按照原本的逻辑推导演绎，现实世界应该会是什么样。如果推出一个与现实世界相反的结论，就说明之前的观点有误。 我有两次明显体会到谬误推导的实际用处，分享给大家。 案例一：民宿是不是一个好生意有一年的春节，我在京郊租了一个大院子，想体验一下退休之后的田院生活。过去之后，我发现京郊有很多人把自己的宅基地改造成这种居住体验良好的民宿，然后出租获利。然后我就很好奇这是不是一个好生意，加上当时我们有“租一个院子没事去过周末”的想法，所以我们把那个村待出租的院子都考查了一番，也问了一下价格。 最后我花了一些时间，结论是：这不是一个好的生意。里面涉及的原因有很多，但我主要测算了一下财务回报模型，发现这个事情回报率太低。另外居住的新鲜感过去之后，因为远离城市会有各种不便，整体体验也不算太好。 当我把自己的逻辑分享给 gcz 的时候，他直接用了“谬误推导”来判断，他说：如果这个事情成立，那么民宿就应该产生规模化的品牌，但现在显然没有，说明这个事情不靠谱。 我当时惊了，我想：这不符合“第一性原理”呀！看事情不应该从本源去思考吗？但是我又一想，“谬误推导”还是很有价值的，因为： “谬误推导”很快，我们在工作中的很多事情权重不高，深入研究一个事情的本质原因性价比太低。 “谬误推导”还是为第一性原理思考提供了快速的反面证据。如果要推翻这个“谬误推导”，我们容易找到那个核心问题。 案例二段永平分享过一个在步步高的案例。当时步步高每年的广告费用很大，有高管提出：我们的广告费用这么高，不如我们自己做广告公司。因为这样，我们首先不愁客户，我们自己就是自己的客户。然后别的东西我们可以学，我们也可以招成熟广告公司的人，我们很努力，假以时日，我们肯定可以做得比较优秀。 段永平用“谬误推导”拒绝了这个提议，他说：我不知道这里面有什么逻辑问题，但是我知道我们肯定做不成。因为：如果这个假设成立的话，世界上最大的广告公司应该是”可口可乐广告公司”和“宝洁广告公司”。但显然并不是，所以我们做广告公司这件事情一定不成立。 终局思维 终局思维是把一个事情的发展看长远，从而忽略掉短期因素的影响。人们天然对身边刚刚发生的事情赋予巨大的权重，而把过去很久发生的事情赋予较低的权重，但这个是不对的。终局思维可以帮助我们看到影响事情发展的核心因素。 终局思维可以帮助我们做难而正确的事情。有一些事情决策成本巨大，比如：猿辅导要投入力量做 AI 研究院，这方面的工作非常费钱，而且短期可能看不到产出。但是如果我们用终局思维想：未来的教育产品是否需要 AI 赋能？答案就会更容易一些。 又比如，一些错误决策已经做了，有一些沉没成本已经投入了，是立即纠正，还是慢慢收缩调整？如果站在终局思维，那么就应该尽快调整，因为如果未来是要调整的，那么每提前一天都是减少更一步的损失。所以段永平说：「发现错误立即改正，不管付出多大的代价，都是最小的代价；不改正错误，将付出更大的代价」。 用终局思维看待每一次失败，失败也显得不那么重要了。如果失败没有导致个人信心丧失，反而激发出更强的斗志，同时我们又从失败中吸取了教训，那么失败是个人迈向成功的必经之路。 再说两个案例。 案例一：直播带货拿直播带货来说，每一次直播带货事故都会对达人品牌产生不利影响，虽然短期的影响可能不大，但是这反映出达人团队的品质把控上的能力问题。长期来看，必将影响消费者在达人直播间购物的心智。所以这么来看，如果不有效解决带货品质问题，小杨哥直播间长期很难存活。 长期来看，如果直播带货的规模巨大，势必对人们的生活产生重大影响，规范直播带货中的各种宣传用语是必然的。在这个过程中，没有做好准备的达人都会被时代抛弃。 案例二：挑选领导&#x2F;下属&#x2F;伙伴终局思维可以用来挑选下属、上级和合作伙伴。如果你有一个合作伙伴，每次都出会一些问题，虽然没有出大事，但是长期来看，它必将影响你的生意，早日换掉他就是一个明智的选择。公司内的上下级共事也一样可以用终局思维，如果做不到上下同欲，下属必然在未来会遭遇误解，那么与其这样，不如用脚投票，离开他不欣赏的上级。 批评观点的 4 种角度这是我从《如何阅读一本书》中学到的方法，作者认为，批评别人的观点只能有 4 种： 证明观点的知识不足。 证明观点的知识错误。 证明观点不合逻辑。 证明观点的分析与理由是不完整的。 如果你不能用相关证据显示作者是知识不足、知识有误，或不合逻辑，你就不能反对他。 很多人面对一些结论的时候，表现出强烈的反对，但是如果你发现他不能按以上标准来反对的话，就说明他并不真正在反对，只是「不喜欢」这个结论，而这只是在表达一种情绪或者偏见。我们应该尽量避免陷入情绪中，或者至少应该在陷入情绪中时，知道自己当前只是在发泄，而不是在讨论问题。 我们在下结论的时候，也可以用这 4 点去检查一下，自己有没有知识不⾜、知识错误、不合逻辑等问题。 信息判断的误区再说说一些信息判断的误区。 误区一：把相关性当因果很多人把相关性归纳到因果上面。驳倒这个误区最有趣的论述就是：医院是死亡率最高的地方，所以我们应该远离医院。 作为练习，请思考下面的论述有什么问题： 统计显示，⼤部分喜欢吸烟的⼈肺癌发病率⽐不吸烟的⼈⾼ 10 倍，所以吸咽导致肺癌。 ｜｜｜｜｜｜请想一想再往下翻答案｜｜｜｜｜｜ 答案：喜欢吸烟与肺癌只能通过上面的统计证明相关，但是不能推导出因果关系。著名的统计学家 Fisher 就喜欢吸烟，他举了一个反驳的例子：有没有可能有一种基因，带有这种基因的人会喜欢吸烟，同时，这种基因会导致肺癌发病率高。这样，不管这类人抽不抽烟，他们因为带有这种基因，所以都会有较高肺癌发病率。 关于这个误区，这里还有更多的资料（需要梯子）。 误区二：从众心理 从众效应由美国社会心理学家阿施提出，是一种普遍存在的社会心理和行为，从众心理通常是由于个体受到集体的隐形或者显性的压力，而改变自己的目标，最终选择和多数人一致的意见或行为。 从众心态在广告学中最佳的应用案例，就是讲自己的产品「销量第一」。当然，咱们不能撒谎，得真的是销量第一的时候才能讲「销量第一」。斑马思维机去年卖了 30 多万台，远远超过第 2 名，我们就找咨询公司做了一下市场调研，宣布自己销量第一。我们公司兄弟部门的产品小猿学练机，也讲自己「销量第一」。 但是，销量第一的产品就一定最好吗？其实不见得。当年的手机霸主洛基亚，也是曾经的销量第一，不也被苹果超过了。所以，从逻辑上讲，「销量第一」与产品体验第一，只能说具有一定的相关性，无法产生因果推导。 但是，大家都有从众的心态。「销量第一」就是告诉你，别人都选择了我，你是跟随大众，还是与众不同？大部分人都会选择从众。 当然，购物决策对个体的影响不大，选择「销量第一」的产品大多数时候也没毛病。但是，当我们在面临重大问题做决策的时候，从众可不一定是一个好的选择。 很多系统对从众选择会有天然的抑制，比如： 股票市场，如果大家都跟着舆论买同一支股票，那么股票的价格就会高于其内在价值，造成投资的亏损。 如果大家高考都报一个专业，这个专业的录取分数就会巨高。 如果今年苹果非常贵，大家都选择种苹果，那么几年后苹果就会烂大街。“阳光玫瑰”就是一个真实的例子。 所以，做重大决策的时候，问问自己为什么？如果答案是：因为别人也这样，那就有点危险。 误区三：现状即是真理 现实的一些情况，原因可能很复杂，所以不能把现状做简单归因。 比如：一个企业家把公司做上市了，挣了上百亿的利润，他就一定很会经营吗？不一定。他也可能做了假账，他也可能吃到了时代的红利，比如恒大。 比如：中医到底有没有效果？简单认为它在中国存在了上千年就能当证据吗，肯定不能。放血疗法在西医还流行了上千年呢，咱们怎么不认为它有效？那应该怎么证明中医有效？ 比如：有个理财经理给你推荐某个产品，说它过去 5 年年化收益超过 10%。潜台词是说：未来也会这样。那过去的业绩一定能推导出未来的业绩吗？不一定吧。 对自己的现状分析也很重要，一些人获得了一些成功就很骄傲，觉得自己很厉害，做什么都可以成功。但是成功到底是因为自己的实力还是时代给的机会，如果不能理性分析，就很可能在未来栽跟头。 误区四：情绪 情绪是做决策巨大的敌人。股票市场就是贪婪情绪和恐惧情绪的集结地，稍不注意你就被情绪统治了行为，追涨杀跌。 基于情绪做信息判断和行为有利于情绪在当下的释放，但是相关的后果我们不一能在未来能够承受。所以，更加理智的办法是把情绪的处理和信息的判断分开。 情绪的问题可以用适当的方式来排解和宣泄。信息判断和决策的问题，还是交给理性。 另外，我们也需要识别他人的情绪，将他人的情绪与事实分开接收。现在网络上的一些观点，都带有强烈的情绪，我们需要有足够的智慧去分辨它们。 小结本文介绍了信息判断的几种框架思维，包括：28 原理、谬误推导、终局思维等。也介绍了一些思维误区，包括：把相关性当因果、从众心理、现状即是真理、情绪等。 以上。","categories":[],"tags":[]},{"title":"五分钟弄懂 CSP-J","slug":"cspj-introduction","date":"2024-09-17T13:51:36.000Z","updated":"2024-11-07T01:14:31.624Z","comments":true,"path":"2024/09/17/cspj-introduction/","permalink":"https://blog.devtang.com/2024/09/17/cspj-introduction/","excerpt":"","text":"本文约 1500 字，阅读需用时 5 分钟。 什么是 CSP-JCSP（Certified Software Professional）全称是中国计算机学会（CCF）主办的“软件能力认证”，它是中国计算机学会为了提高计算机软件人才的专业水平而设立的一项专业技能认证。CSP 认证分为两个级别：CSP-J（Junior，入门级）和CSP-S（Senior，提高级）。 因为该认证主要用于选拔 NOIP 选手，所以认证的报名通道仅向各中小学的计算机老师开放。 比赛在每年的 9 月开学之后进行，比赛分为两轮。第一轮为笔试，第二轮为上机。第一轮通过之后，才能参加第二轮。2023 年 CSP-J 第一轮的通过分数线为 63 分。 比赛报名的官方网站为 https://www.noi.cn/，这里有官方关于 CSP-J 的更多介绍。 信息学相关比赛的分类参加信息学比赛，按打怪升级的过程，可以是从 GESP 考级开始。GESP 每 3 个月就有一次考级，可以及时检验学习成果。平均 3 个月就可以完成一个级别的知识学习，在学习初期，正反馈的频率还比较高。 以下是各个比赛面向的人群和获奖难度。 比赛名 面向人群 获奖难度 GESP 小学生+初中生 共 8 级。GESP 7 级 80 分或 8 级 60 分，可跳过 CSP 第一轮 CSP-J 小学生+初中生 各省约前 20% 可拿省一等奖 CSP-S 高中生 各省约前 20% 可拿省一等奖 NOIP 高中生 各省约前 20% 可拿省一等奖 NOI 高中生 2024 年总获奖率为 85%，前 50 可获金奖 IOI 高中生 代表中国参加全球的比赛 大部分小学生和初中生的目标是 CSP-J，获得一等奖可以被各大重点高中点招。 大部分高中孩子的目标可能在 NOIP 的一等奖，因为有了这个奖项，就可以被保送或者自主招生降分录取，高考的压力会小很多。我当年就是有 NOIP 的奖项，获得了北师大的自主招生参考资格（当时全国只有 50 个资格），然后考试通过了北师大的自主招生。 CSP-J 的获奖难度我做了一个《北京 CSP-J 近五年比赛情况》表，如下： 从中可以看到： 初赛报名人数逐年增长，每年增长都在 10% 以上。22 年和 23 年分别增长了62% 和39% 第一轮初赛的通过率逐年下降，每年最少下降 2pp，23 年通过率为 24% 复赛获奖率非常高，即便是最低的 2023 年，也有71% 的孩子在复赛中获奖 虽然报名人数在增加，但好消息是：复赛中一等奖的获奖人数是基本按照复赛人数来计算的，得奖比例约为 20%，所以参赛人数越多，一等奖的名额就越多。 几年级可以拿到 CSP-J 一等奖获得 CSP-J 一等奖的年级分布如下，绝大多数（74%）的孩子都是在初二或者初三，才能获得 CSP-J 一等奖。 但是，也有少量的优秀小学生（约6%），可以在小学阶段就拿到 CSP-J 一等奖，这样的学生在 2022 年有 146 人。 CSP-J 的备赛准备CSP-J 的最佳备赛年龄是 4 年级的上学期。因为，CSP-J 的比赛在每年的 9 月份，如果从 4 年级上学期开始备赛，那么就可以有整整两年来准备。但如果从 5 年级开始备赛，那么备赛时间就只有 1 年了。 是 4 年级不是 3 年级或更早的原因是：孩子在 4 年级的智力水平发育程度相对比较容易接受 C++ 这种比较抽象的编程语言。更早的年龄还是以兴趣培养为主较好，编程语言也可以选择 Scratch 或者 Python。但到了 4 年级，就应该学 C++ 了。 因为 C++ 语言是官方比赛语言，所以准备的时候应该直接从 C++开始，否则后期还涉及语言的切换，会浪费更多的备赛时间。 CSP-J 的备赛分为如下 3 个阶段，总共约 600 小时（240 小时上课，360 小时练习）： C++ 语言学习。约 24 课时。 数据结构。约 24 课时。 算法。约 192 课时。 总课时约 240 小时，再加 360 小时以上的练习。 一般孩子如果从 4 年级开始，每周上 2 小时的课，完成作业 3 小时，那么就需要 120 周，差不多两年的时间还差一点。如果暑假再补一些时间进去，就刚刚够学习时长。 以上是冲着全国只有 146 人达成的“小学生阶段拿一等奖”为目标的训练方式。如果目标不那么激进，按大部分学生的学习进度，在初二获奖一等奖。那么准备时间就多了 1 倍，有 6 年级和初一整整两年。而且中间可以多次参赛，积累比赛经验。这样获奖的可能性就大大增加了。 所以，理性一点的目标是： 小学 4 年级开始准备 小学 6 年级能够进入复赛 初中 1 年级保二等奖，争一等奖 初中 2 年级争一等奖 初中 3 年级参加 CSP-S 高中 1 年级争 CSP-S 和 NOIP 二等奖 高中 2 年级争 CSP-S 和 NOIP 一等奖 其它我也在指导一个北京的五年级孩子学习编程，准备 CSP-J，现在学习完 40 课时（约 5 个月时间），已经通过了 GESP 2 级。欢迎同行和家长联系我一起交流，我的微信：tangqiaoboy 。 以上。","categories":[],"tags":[{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"}]},{"title":"西贝创始人贾国龙的成与败 - 读《折腾不止》","slug":"talking-with-xibei","date":"2024-09-17T06:01:11.000Z","updated":"2024-09-17T10:38:33.529Z","comments":true,"path":"2024/09/17/talking-with-xibei/","permalink":"https://blog.devtang.com/2024/09/17/talking-with-xibei/","excerpt":"","text":"最近读完了李翔写的《折腾不止 - 西贝创始人贾国龙的成败与蓝图》，有一些感悟，记录一下。 市场规模餐饮行业整个市场的规模非常大，中国大概有 5 万亿的市场规模。但是基本上都是很小规模的店。 从规模化角度看，现在中国最大的中餐品牌是海底捞，营收大概有 400 亿，剩下的公司都没有过百亿。几十亿营收的公司有：九毛九（旗下有太二酸菜鱼），营收 40 亿；呷哺呷哺，营收 40 亿。 西贝也属于几十亿营收这个梯队，23 年营收 62 亿。 餐饮行业的市场规模看起来是可以 “抗通胀的”，我想到的原因是： 餐饮行业的人力成本是重要的一部分支出，人力工资每年在增长。 原材料成本会通胀。 我也简单查了中国统计局数据，过去 10 年中国餐饮行业的市场规模一直在增长。其中： 2014 年餐饮收入达 29000 亿元 2017 年餐饮收入达 39100 亿元 2023 年餐饮收入达 52890 亿元 所以，餐饮行业从规模上看，是一个挺好的行业。只是能够一直坚持做好的企业不多。比如以前很火的小肥羊、俏江南，现在就已经销声匿迹。 贾国龙把西贝的成功，主要还是归因于战略选择的成功和时代机遇。其中核心的战略选择环节是：进北京、边缘开大店、进商场、全国开店。时代红利是指赶上了商业综合体的红利，很多商场给的租金比较低。 但是西贝能够持续稳定经营，还是来源于自身独特的定位（小店、小贵、儿童友好），以及对菜品品质的把控。 定位的讨论贾国龙认为：定位理论虽然对，但是国内把它教条化了。好象除了它对，其他都错。定位理论是“小山头理论”，他们认为这是企业的唯一选择。但企业还可以做草原、做大海，为什么非得做小山头呢？ 这让我想起来小米，小米用这个品牌做手机、做智能家居、也做汽车。看起来现在发展得还行。我相信雷军肯定是读过《定位》的，有一次别人问他为什么，他说小米想做“人车家全生态”，只有都用小米这个品牌，用户才能接受这样的定位。 美团也是一个案例。美团现在不停讲美好生活，大家慢慢就把美团与生活服务关联上，这样美团买药，外卖，团购，用美团这个品牌都不违和。 我认为这种“大草原”的品牌，最大的风险还是某一方面的产品投入不够，从而把整个集团的品牌损害了。记得我大学的时候是联想的无脑粉，于是第一款 MP3 买了一款联想的产品，当时其实比别的牌子要贵，但是我觉得联想这个品牌我信得过。后来我发现，这个 MP3 的产品力其实很一般，所以我的心智就变成了：“联想这家公司做 PC 还行，做别的不太行”。所以，如果不是战略选择，就不要轻易用集团品牌。 书中提到贾国龙做新的餐饮店，君智战略咨询的董事长谢伟山建议用新品牌贾国龙也采纳了。因为新品牌做失败了，大家不会因此对西贝有什么联想。 不止只是贾国龙，华与华的老板华杉也在批判定位理论（下图）。华杉认为：独特的销售主张（USP）比定位更重要。而定位理论的几个逻辑都有问题，华杉认为： 定位理论说：顾客导向的时代已经过去，竞争导向的时代来临。但其实我们现在大部分成功的公司，还是因为服务好了顾客才成功，而不是因为把竞争对手打败才成功。 定位理论要求有足够强的营销资源，但是实际上很多产品的市场规模和利润都无法支撑足够多的营销资源。 所以，关于“定位”，贾国龙说得很好：“没有对错，需要具体情况具体分析”。所以，这本书让我对定位理论「去魅」了。 定价的讨论贾国龙提到顾问孟庆祥给他的三个启发，分别是： 产品要匹配营销 应该要投入研发，增加产品竞争力 有竞争力的产品，才有定价权 我很认同以上观点。小贵的产品，才有竞争力。因为小贵才能支持研发和营销的成本。 斑马的硬件产品也一直秉承这样的理念。我们的斑马思维机、斑马拼音机等产品都是属于同行中较贵的产品。但是，这并不代表我们有着暴利。我们只是把创新的成本、产品品质的成本都放到了定价中，以便维护斑马一直以来给用户的高品质的感受。 海底捞的竞争力来自于淘汰海底捞对业务在最后 10% 的人淘汰。海底捞因为是一个个的单店模型，所以很容易横向比较。每一个层级岗位的干部，都有相对明确的业绩产出，这个时候，如果业绩产出不行，从结果上就比较好判断。 末位淘汰也给了海底捞其他干部一定程度上的危机感，避免大公司懒散的文化。 一些不好的感受贾国龙的一些话也给了我不太好的感受。 第一个：他喜欢下指标。 比如他说中国堡一年要开 365 家店，KPI 是很容易让人走偏的管理方式。又比如说，XXX 年要上市，要做到 XXX 亿。但他也有一个对这个不好习惯的“补丁”，就是会朝令夕改。比如第二次访谈的时候，他就表示贾国龙中国堡开了 50 家就暂停了，因为发现很多问题需要解决。 有了这个补丁，大家会对他说话的权威性降权，难怪他有一个高管说，对他唯一的不满就是老变。 第二个：贾国龙把“做大做强”作为经营的最顶层目标。他为了达成这个目标，选择了更容易规模化的快餐方向，选择了学习麦当劳。在中国堡这个产品上，也有着极强的麦当劳的影子。 虽然贾国龙也知道产品为王，懂得 MVP 来验证产品需求。贾国龙也懂得风险控制，一直用合适比例的利润来做这类的探索。但是，我始终认为，“消费者导向”（用户需求）才是驱动企业增长的最顶层原因。 在“做大做强”的目标下去寻找用户需求，不知道会不会更加短视，更加急功近利，又或者是提高风险，都是未知数，所以我不太喜欢。 小结贾国龙作为西贝的 100% 控股的股东、老板、创始人。一个在餐饮行业深耕 30 多年的创业者。有着异于同行的各种优秀品质。他热爱学习，懂得餐饮的经营管理，又有着强烈的成长和创新动机。 在西贝核心业务每年贡献几个亿利润的情况下，他不停地创新和成长，我从他身上看到了一个企业家对自身成就的不懈追求。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"第一性原理思考：解决问题的通用框架","slug":"problem-solving-structure","date":"2024-09-05T19:47:11.000Z","updated":"2024-10-27T03:28:56.463Z","comments":true,"path":"2024/09/06/problem-solving-structure/","permalink":"https://blog.devtang.com/2024/09/06/problem-solving-structure/","excerpt":"","text":"前言马斯克运用第一性原理成功创立了 SolarCity、特斯拉、SpaceX。我们在生活和工作中，也会涉及很多需要解决的未知问题。大多数时候我们都听从于「长辈经验」，这种决策方式大多数时候是对的，但是对于创新工作或者重要决策却可能是一个灾难。 我结合自己的工作实践，总结出一个基于第一性原理的思考框架，希望可以帮助大家重建问题分析的通用框架。 我应用这个通用框架解决以下各种工作上的问题： 如何提升 iOS 开发水平 如何优化直播间销量 如何在韩国卖斑马思维机 作为案例，我也教大家用这个框架解决以下生活问题： 减肥没效果怎么办 如何找到男&#x2F;女朋友 希望对你有帮助。 框架概述这个框架把解决问题分成 4 步： 信息收集 信息建模 信息判断 策略迭代 我们拿一个生活中的问题来举例：“有个朋友减肥一直没效果，想让你帮忙分析一下”。 第 1 步：信息收集当你的朋友给你说减肥没效果的时候，你不要着急给他下诊断出解决方案，不着急说：你一定是缺少运动，或者说一定是吃太多。因为在“减肥没效果”这件事情上的原因可能有成千上万种，你得先找到原因，才能对诊下药。所以，你应该先收集信息。 在收集信息上，得做两个大类的信息收集： 1、收集经验数据 2、收集原始数据 收集经验数据什么是经验数据？经验数据就是人们在这件事情上已经形成的方法总结。拿减肥来说，不管是小红书还是 B 站，还是微信公众号，上面已经有很多人分享减肥这件事情的经验，有成功的总结，也有常见的失败，这些都是宝贵的经验数据，你应该先收集下来。 还有哪儿有经验数据？专门的减肥书籍，应该可以找到很多。身边的减肥成功的朋友、健身房的身材管理教练，也是可以去咨询收集信息的重要来源。 对于减肥来说，以上的信息收集渠道可能就够了。对于一个通用的问题，可供寻找的经验数据源有以下这些供参考： 查阅类：搜索引擎、ChatGPT、国家统计局资料、专门书籍、知网数据库、行为研究报告 走访类：专家访谈、用户访谈、实地走访。 对于一个你完全不了解的领域，可以用 What-else 研究法。以研究 iOS 开发为例： (what) 什么是 iOS 开发？然后你可能通过查找资料发现这是一种移动开发技术。 (else) 还有哪些是移动开发。你可能找到 Android开发，Windows Mobile 开发等。 (what) Android 是什么？然后你可能查到这是 Google 出的移动开发技术。 (else) Google 家还出了哪些开发语言？然后你可能查到 Flutter。 应用 What-else 研究法，你可以快速扩展自己在该领域的知识点，从而慢慢把知识点连成线，形成经验数据的图谱。 收集原始数据 原始数据是指现场的、未经加工和解释的数据。马斯克在思考如何造火箭的时候，查阅制造火箭的基础原料成本，就是在收集原始数据。这为他进一步利用第一性原理，推测出火箭的制造成本有大幅下降空间提供了基础信息。 还是说回减肥这个案例，对于这个减肥没效果的朋友，最重要的原始数据是什么呢？ 有人说是他自己是怎么减肥的，这只说对了一半。如果你只是听他讲他是怎么减肥的，那就不是“原始数据“。因为这里面已经有了你的这个朋友的主观判断在里面。这件事情的原始数据应该是你的朋友每天的日常的生活现场和减肥的现场。你应该全程跟着这个朋友，记录下这个现场，这才是最最原始的，未经加工的数据。 我很喜欢一个美剧叫豪斯医生（Doctor House），主人公豪斯医生就从来不相信病人的口述，而是像个侦探一样，从各种现场的细节来判断真相，最终找到真实的病因，对诊下药。我想他一定是和我一样明白原始数据重要性的😁。 第 2 步：信息建模有了第 1 步的信息收集工作，我们对问题已经有了足够多的了解，接下来就可以开始第 2 步的信息建模工作了。 信息建模的工作分为 3 步，分别是： 1、拆解问题 2、找到问题的核心数据指标 3、数字化&#x2F;自动化地收集核心数据 拿减肥来说，如果你基于收集到的信息，发现你的朋友主要是运动太少，那么你就可以把减肥问题拆解成「控制摄入」和「提高代谢」两个角度。 但不同的情况下，拆解问题的角度应该不一样。如果你的朋友是因为心情抑郁暴饮暴食，那么问题就应该围绕心理健康展开拆解。如果你的朋友是因为肥胖症，那么又应该从这个病症的专业治疗角度，展开拆解。 再举一个例子：iOS 开发水平应该如何提高的？我的拆解是：输入和输出两个角度。 输入方面：我们可以拆解成阅读博客，阅读图书，看相关的视频，听相关的分享，参加相关的会议，找同事请教等。 输出方面：我们可以拆解成写总结的文章，代码练习，分享等。 代码练习又可以分成：工作上的代码优化、面试题目代码的练习、开源项目的参与等。 我之前也是基于上面的拆解，坚持写了好多年的技术分享，最终出版了《iOS 开发进阶》。 拆解完问题之后，我们需要将拆解完的指标量化。 拿减肥的案例来说，我们就应该收集每日摄入的卡路里和身体的代谢率指标。 拿 iOS 提高的案例来说，我们就应该量化输入和输出的周度、月度、年度目标。 有了量化的指标，如果我们能够将其数字化记录到系统中，甚至自动化收集它就更好了。 拿减肥的案例来说，我们用一个软件记录每天的卡路里摄入和代谢率，就很好。 拿 iOS 提高的案例来说，我们用统计工具记录自己代码练习量，就很好。 【练习】假如我们的问题是：如何找到男&#x2F;女朋友呢？如果你的信息收集发现，问题主要出在自己太害羞，应该如何拆解问题和量化指标？ 第 3 步：信息判断执行完第 1 步和第 2 步，你还不能解决问题，因为前面只是帮你分析了数据，找到了关健的一些指标，具体怎么做并没有解决。 所以，在第 3 步，你需要根据前面的信息，做判断和决策，制定自己解决问题的「执行方案」。 拿减肥的案例来说，你需要制定每日控制卡路里摄入和代谢率的具体方法。 拿 iOS 提高的案例来说，你需要制定输入和输出的具体每日任务目标，以及做合理的时间规划等。 如果我们在面对一些创新性的问题，因为可供参考借鉴的案例不多，在制定执行方案的时候，应该尽可能打开思路，用第一性原理去思考。比如：别人造电动车没有电池就放弃了，马斯克的执行方案却是用 7000 多节松下的 18650 电池拼成一个大电池包。 第 4 步：策略迭代你的执行方案不一定靠谱，当你发现过一段时间，关键数据指标并没有变好的时候，就说明你应该停下来思考一下了。在这一步应用 PDCA 环，可以很好地帮助你优化自己的方案。 PDCA 包括： 策略制定（Plan） 策略实施（Do） 检查过程，保障策略能够实施到位（Check） 获得策略数据反馈，调整（Act&#x2F;Adjust） 有关键数据做指导，你做的任何调整都能带来正反馈（指标变好）或者负反馈（指标变差），这样你很快就能从中总结经验，对问题有更加深入的理解，从而优化自己的执行方案。 本框架的局限 本框架有三个局限： 只适合解决有原始数据的问题 只能保证策略尽可能对，不能保证执行到位 个体的思考和判断是解决问题的核心 所以，没有银弹，本框架只能帮你尽可能接近真相，真正要解决问题还是得靠你自己的思考、判断和执行。 以上。更多内容请看：《第一性原理思考：解决问题的通用框架(续)》","categories":[],"tags":[]},{"title":"如何在抖音直播卖货","slug":"living-selling-101","date":"2024-09-01T06:52:02.000Z","updated":"2024-09-01T14:25:52.578Z","comments":true,"path":"2024/09/01/living-selling-101/","permalink":"https://blog.devtang.com/2024/09/01/living-selling-101/","excerpt":"","text":"引言随着抖音日活破 8 亿，短视频和直播已深入我们每一个人的生活。其中，直播电商作为抖音商业化重要的一环，成为很多品牌销售工作的重点。 我之前写过一篇科普效果广告的文章，帮助很多非广告行业从业者理解效果广告，很多人很喜欢。于是，我想接着这个主题，分享一下抖音直播卖货的基础，如果你没有从事过相关工作，本文可以让你对直播电商有一个基础认知。 核心流程直播卖货的核心流程分成两步。 第 1 步：在信息流中投放你的种草短视频素材（或直播间画面），引导用户点进你的直播间。 第 2 步：在直播间中，完成产品的介绍、答疑，并引导用户下单。 我们接下来会拆开这两个环节分开介绍。 短视频素材介绍我们日常在抖音上刷短视频，大概刷 10 条左右，就会出现一条是广告商投放的种草短视频。这个短视频会在右侧有一个直播的效果（如下图），短视频中的口播也会引导你进去直播间。 除了种草短视频外，广告商也可能将直播画面投放到你的信息流中，引导你进去直播间（如下图）。 相关指标对于一个种草短视频来说，平台会评价很多核心的过程指标，最主要的包括： 点击进直播间的转化率 进入直播间后，访问商品的转化率 支付的转化率 下图是一个案例，呈现出了某个电商直播间的转化漏斗。 除了以上指标外，我们评价一个种草短视频的好坏，还有一些过程指标，包括： 5 秒完播率。 用户点击成本。 【5 秒完播率】：指用户看完了这个视频前 5 秒的比例。在短视频信息流中，用户很没有耐心，如果不能在前 5 秒抓住用户的注意力，用户手指轻轻上滑，就会把你的视频滑走。而每一次广告的曝光都是要收费的，所以，尽可能提高前 5 秒的完播率，就可以提升进入直播间的点击率。 【用户点击成本】：通常每一个商品，都有适合自己的点击成本（具体的成本通常是经验数据）。如果点击成本太低，那么： 短视频可能过于有欺骗性，这会使得直播间的成交转化率相对下降，所以得不尝失。 用户也可能不精准，比如都是一些好奇心强，但是成交意愿弱的用户。 种草短视频的类型在我们所处的教育行业，一般种草短视频有以下几种类型： 身临其境 真实感受。例如：“最近我家孩子…” 附加身份 激发认同。例如：“作为一个海淀妈妈…” 消费观念 透传实惠。例如：“不到一顿饭的钱…” 第一人称 情节发展。例如：“直接产品使用视频…” 软蹭热点 放大痛点。例如：“最近 xxx 新闻大家都看到了…” 制造噱头 营造稀缺。例如：“不好意思，活动即将结束了…” 要做好这些短视频，有一些基础的要求： 需要符合平台和相关的法规。比如不能虚假宣传，不能恶意制造焦虑，不能诋毁竞争对手。 风格要多样。比如同样的口播文案，在车里拍可能就比在办公室拍效果好很多。但如果大家都在车里拍，你出一个在飞机上拍，效果可能又不一样。总之，风格不要雷同，不然前 5 秒的完播率会很差。 除了风格尽可能多样外，我个人认为，一个好的种草短视频还是应该尽量讲产品，把产品的核心卖点讲清楚，即便用户当下不买，那么他也会对产品有一个较为清晰的了解，这对品牌来说，可以积累长期的势能。 利润模型如果你了解广告系统，你应该能够理解。每一个种草短视频都是基于 ECPM 进行竞价，本质上你需要尽可能提高自己的广告转化效率，否则你就无法给出市场公允的一个千次展示成本。 在抖音平台上，千次展示成本大概在 50 - 200 元之间。我们假设你的平均千次展示成本是 100 元，视频点击率是 10%，直播间的支付转化率是 10%，客单价是 100。那么: 1000 次展示（成本 100 元），能够给你带来：1000 * 10% = 100 次点击。 100 次点击能够带来 100 * 10% = 10 次成交转化。 10 次转化能够带来 10 * 100 = 1000 的收入。 如果你的商品成本是 50 元，那么你每花 100 元广告费，就有 1000 元的收入，扣除 500 元的商品成本和 100 元的广告费，就还有 400 元的利润。 这就是一个极简的直播利润模型，后面我们会继续完善它。 直播间说完短视频素材，我们再说说直播间。 循环是直播带货的基本形式直播间最基本的功能，就是面对不断进入直播间的用户，完成从产品讲解到引导下单的整个流程。由于每个用户在直播间的停留时间并不长（通常为 1-5 分钟），所以我们需要在非常短的时间内完成从产品讲解到引导下单的过程。而直播间，其实就是在不断循环这个过程。 我们来看看前一段时间很火的李一舟的直播间是怎么卖人工智能课的（下图）： 李一舟为什么要讲这么简洁？因为如果你随便看一个直播间的在线人数，你就会发现，每一分钟，都有超过 20% 的人离开，又会有超过 20% 的人新进入直播间。下图是一个案例，在该案例中，实时在线只有 22 人，但是每分钟进出直播间的人数分别达到了 18 人和 15 人。 假如你在线下经营一个“超级卖场”，每 1 分钟会进来 1000 人，同时上 1 分钟进来的 1000 人会离开，你应该怎么办？如果你需要 3 分钟才能讲清楚你的产品，那么不好意思，前面进来的人等不到你讲完就走了，后面进来的人，因为只听到你讲的后一半，不知道你在讲什么。 你只能抓住这仅有的 1 分钟时间，迅速完成需求挖掘，产品介绍，引导下单的过程。从这个角度看，李一舟的直播话术还挺高效的。但是，李一舟不应该撒谎，“仅有 10 个名额”这个说法对用户是一种欺骗，其实有更好的处理方式。 流量是直播的生命之源直播间的主播讲得不管多么好，没有观众也不行。流量在很多别的平台就是付费广告，但是在抖音，还有一大部分是“自然流量”。下图是某个直播间的流量图，可以看到，它有将近一半的自然流量，这部分流量是不需要给抖音付费的。 那么如何获得自然流量呢？自然流量其实是抖音给直播间的奖励，当抖音的算法认为当前的直播间具备下面任一一个优点的时候，算法就会给与奖励。 优点一：这个直播间看起来很有趣。 优点二：这个直播间看起来很挣钱。 我们先说优点一。抖音算法认为，优质的内容应该分发给更多人。所以，如果抖音算法觉得你的直播间很有趣，被很多人喜欢，那么就会把你的直播间分发给更多人。 什么样的行为代表有趣呢？关注、互动、点赞、评论、停留。 所以，大家有没有看过这样的直播间行为： 某直播间，主播不停在说，新进直播间的朋友们，麻烦给我点个关注，送个粉丝灯牌。 某直播间，发福袋。领福袋的要求是关注+发一条指定语言的评论。 下图是小猿学练机的直播间福袋，就是一个典型的用福袋增加关注、互动、停留的例子。 我们再说说优点二：这个直播间看起来很挣钱。为了衡量挣钱的能力，抖音有一个叫做 GPM 的指标。GPM 指：平均每一千个观众下单的总金额，常用来衡量直播间卖货能力。 举个例子，如果直播间每进来 1000 个用户，就有 100 个用户下单，客单价是 200，那么你的 GPM 就是 100 * 200 = 20000。 我们知道，抖音对所有平台的交易都有抽佣的，抽佣常见的比例是 2% - 5%。所以，你的 GPM 越高，抖音得到的抽佣也就越多。如果你的 GPM 是 20000，抽佣比例是 5%，那么每 1000 个用户平台可以得到抽佣 20000*5% = 1000 元。 这样，当平台的广告流量有富余的时候，算法就会把流量给那些 GPM 高的直播间作为奖励。平台本身也会得到更多的佣金。 成本模型我们在最初的时候提到了一个极简的成本模型： 如果你的商品成本是 50 元，那么你每花 100 元广告费，就有 1000 元的收入，扣除 500 元的商品成本和 100 元的广告费，就还有 400 元的利润。 其实，实际核算下来，你还需要付出以下的成本。 退货成本商品都会有一定的退货率，当退货发生的时候，虽然你收回了商品，但是平台不会退还你已经付出的广告费的。所以，还是刚刚那个模型下，如果你的退货率是 30%，那么你的收入变成了 700，商品成本变成了 350，广告费 100，你的利润下降到了700 - 350 - 100 = 250 元。 平台佣金平台通常会抽取 5% 的交易佣金。所以，刚刚那个模型还需要减掉 700*5%=35 元。利润下降到了 215 元。 运营人员成本直播间的主播和场控，运营都是要发工资的。根据城市不同，主播的工资为 100&#x2F;小时 - 300&#x2F;小时 不等。场控的工资约为 50 元&#x2F;小时。下图是在成都的某个直播间在微信群上发的招聘的信息。 所以，如果刚刚那个 1000 的销售额是在 0.5 小时达成的业绩，主播+场控的小时工资为 200 元。那么，你还需要付出 200*0.5=100 元的成本。利润下降到了 115 元。 GMV 提点如果我们直播代运营公司，我们通常还需要支持 5% - 10% 的 GMV 提点。在本例中，如果我们支付 5% 的提点，则成本为 700*0.05=35 元。利润下降到 80 元。 税如果我们售卖的是实物商品，我们需要支付 13% 的增值税。增值税只需要交“增值”的部分，我们的售价与成本的差价是 350 元，所以我们需要交 350*13%=45.5 元的税。利润下降到 34.5 元。 其它其它成本还包括： 短视频素材的制作成本。通常情况下，一个直播间每月需要制作 40 - 80 条左右的短视频，平均每条素材的制作成本约为 500 元，月成本为 2-4 万元。 投放提点。如果我们找第三方代投公司帮我们投放，我们通常需要支付 3% - 5% 的投放提点。在本例中，我们需要支持 3-5 元。如果我们不找第三方代投公司，则需要招聘投放人员，成本可能更高。 运费险。 客服成本，提供售前和售后支持。 结束 抖音直播卖货的核心工作是短视频素材的制作和直播间的转化。 一个看起来很挣钱的直播间，在计算上退货、投流成本、商品成本、运营成本、第三方提点、税收、客服成本后，其实利润就微乎其微了。 以上。","categories":[],"tags":[]},{"title":"读《蹒跚前行 1870～2010 经济史》","slug":"history-of-1870-2010","date":"2024-06-29T15:03:29.000Z","updated":"2025-01-02T15:06:35.465Z","comments":true,"path":"2024/06/29/history-of-1870-2010/","permalink":"https://blog.devtang.com/2024/06/29/history-of-1870-2010/","excerpt":"","text":"本书的作者德龙教授是经济史学家，加州伯克利分校经济学教授，曾担任克林顿政府财政部副助理部长。 这本书以历史发展的时间线，介绍全球经济发展的过程。战争（包括一战和二战）、通胀、通缩、黄金发展期伴随着这 100 多年的历史进程，读完让人感叹发展的不易，就如本书书名：蹒跚前行。 以下是一些笔记。 1、关于通胀通胀类似于一种税收和财富调节手段。它将财富从拥有现金的人手里转移到了拥有非现金财富的手里。 如果你是借款人，因为借款人是用贬值后的货币还款，而贷款人不得不接受已经贬值的货币。所以通胀对于欠债方是利好的。 政府发行的货币最好是和 GDP 的增长匹配。如果政府因为各种原因印制了更多货币来满足一些特定需求的时候，就会推动通胀。 通胀是一个零和博弈。受益者和损失者的损益完全匹配。 2、失业率对社会的影响书中介绍了大萧条时期，就业环境如何给大家带来了巨大的伤害。乔治·奥威尔的描述是：“让我害怕并震惊的事情是，看到许多人因为失业而感到羞愧。” 在一个合理的社会中，每个人应该能够通过劳动自食其力。这让社会处于一个体面的状态。如果社会和经济制度让大量民众失去工作，那么一方面给个体会带来巨大的心理打击，另一方面也会给社会带来不稳定因素。 3、日本的终身雇佣制日本的终身雇佣制来源于 20 世纪上半叶。当时日本的制造业很依赖未婚年轻女性，但是这一劳动队伍缺乏经验，同时流失率高。为了平衡流失率，日本慢慢发展出了终身雇佣制。 同时，1930 年，日本通过放弃金本位和对外扩张，避免了欧洲传过来的大萧条，从而让企业无需解雇员工，强化了终身雇佣制的文化。 4、二战德国为什么会失败二战核心打的是经济战，虽然德国战术很强，但是从经济产出看，在 1944 年， 盟军的生产效率与德日对比为 150:24。即：德国和日本每生产出 1 架飞机，对方可以生产 6 架。 5、社会主义国家选择企业国有化的理由作者提供了 3 个主要原因： 担心垄断。领导人认为垄断企业会对社会公众进行剥削，除非国有化。 担心腐败。垄断企业可能直接收买负责监管的机构。 马克思主义信仰。认为资本市场具备剥削性质，只有公有制才能避免这种剥削。 以上理由多少可以用来理解我们的社会。 6、安全资产短缺问题当经济危机发生的时候，大家会抛售之前被认为安全的资产。这个时候就会出现安全资产短缺的问题。这个时候怎么办呢？ 作者介绍了白芝浩-明斯基策略：为应对安全资产短缺现象，政府的最优选择是立即基于平时被视为优质资产的抵押品提供充足的贷款，但收取惩罚性利率。 提供充足贷款意味着创造足够多的安全资产，使供应不再短缺。收取惩罚性利率则意味着防范投机性金融机构利用这种混乱局面来渔利。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"要利润的定价 - 读《定价制胜》","slug":"pricing-strategy","date":"2024-06-23T14:32:48.000Z","updated":"2024-09-01T14:36:39.869Z","comments":true,"path":"2024/06/23/pricing-strategy/","permalink":"https://blog.devtang.com/2024/06/23/pricing-strategy/","excerpt":"","text":"最近读完了一本叫《定价制胜》的新书，作者是赫尔曼·西蒙。该作者创办了一家咨询公司，在全球提供定价咨询服务。截止 2021 西蒙咨询年营业额 5 亿美元，拥有员工 1700 人。 以下是我的读书心得。 一、德国铁路的定价咨询作者接到了德国铁路公司的咨询需求。当时的困境是：铁路的票价高于自己开车的油费，当时铁路每公里的费用约为 0.16 美元，但是开车的每公里费用约为 0.1 美元。所以，大部分人从经济角度选择开车出行。 西蒙的解决方案是将火车出行的成本拆分为固定成本和可变成本两部分。西蒙让铁路公司推出 BahnCard 50 优惠卡，售价为 140 美元一年，拥有优惠卡的用户可以以 5 折购买车票。 这样，每公里火车的可变成本变成了 0.08 美元，低于开车出行的 0.1 美元。最终，该优惠卡每年卖出 400 多万张。 该方案类似于京东 PLUS，天猫 VIP88。用一次性的付费将用户之后每次的购买成本降低，带动用户更多消费。 二、凡勃伦效应美国经济学和社会学家凡勃伦在他的著作《有闲阶级论》中揭示了价格是身份和社会威望的标志，为消费者提供了社会心理层面的效用。这又被称为“凡勃伦效应”。 具备这类特征的一些奢侈品，在一定范围内，会出现价格越高销量越好的情况。这样的案例有很多，比如爱马仕的包，保时捷，以及一些高档手表，茅台酒等。 对于这类商品，找准自己的需求曲线，不要定价过低才可能有比较好的销量和利润。 三、品质效应大部分消费者都认为：便宜无好货家，一分钱一分货。所以，较高的价格以及与其匹配的品质，可以给到消费者安全感。 研究表明，像鼻用喷雾，连裤袜，墨水和电子产品的价格提高时，它们的销量也会提高。 书中举了一家电动剃须刀的例子，这家市场跟随者为了使产品价格更接近市场领导品牌博朗（Braun），大幅提升了售价，其产品的销量在短时间内增加了 4 倍。新的价格打消了消费者对其质量的担忧，同时对于博朗，其仍然具备足够的价格吸引力。这就是所谓的价格甜蜜点。 我认为教育产品其实也是具备这样的品质效应。因为教育产品价格背后的产品品质和服务比较复杂和专业，消费者通常不太能做到比较客观的比较，这种情况下，价格高的产品在品质也过硬的情况下，长期也是最舒服的。 四、定价应该支撑企业利润作者用一个具体的例子展示了价格折扣与利润的关系。 我们假设一个硬件产品价格为 10 元，销量为 100 万件，销售额为 1000 万。其中成本为 800 万，利润为 200 万。 现在，我们假设销量不变，我们将价格打 9 折，用 9 元的价格销售。这个时候，我们的利润会下降 50%，只有 100 万了。 如下图所示： 有人可能会说：降价会带来销量的上涨。好的，那么销量需要上涨多少才能与之前的利润持平呢？答案是销量上涨一倍。 10% 的优惠基本上是不可能带来 100% 的销量上涨的，所以最终带来的就是利润的损失。 以上还没有考虑竞争对手跟进降价的情况。如果竞争对手也跟进降价 10%，那么大家的销量应该基本保持不变。 ** 结论：9 折的销售会带来利润的大幅度损失，同时销量的上涨很难弥补这部分。 ** 同时，我们可以做另外一个假设：如果我们涨价 10%，那会怎么样？结论是：如果销量没有下滑超过 3 成，涨价就可以提供更多的利润。 所以，在面对困境的时候，涨价比降价更安全。 五、盈亏平衡分析对于一个商品，它的成本包括固定成本（销售人员工资等）以及可变成本（生产成本，营销费用），于是我们可以得出以下公式： 盈亏平衡销量 = 固定成本 / （价格-可变成本） 假如，我们的固定成本是 300 万，定价 100 块钱，可变成本是 60。那么，我们需要卖出 300 万&#x2F;40 &#x3D; 7.5 万件商品才能回本。 如果我们把价格降到 80，那么销量需要翻倍才能盈亏平衡，如果我们把价格涨到 120，那么只需要卖出 5 万件就能盈亏平衡。 六、价格弹性价格弹性是指销量变化与价格变化的关系。 价格弹性为 2 表示销量变化百分比是价格变化百分比的 2 倍。也就是说，1% 的价格下降将带来 2% 的销量增长。相反地，1% 的价格提升将会造成 2% 的销量下跌。 根据西蒙咨询对数万种商品的分析，价格弹性通常在 1.3-3 之间浮动，中等浮动大约在 2。 所以，我们可以借助这个工具估算价格变化带来的销量变化。如果价格弹性为 2，那么 9 折优惠对应的销量提升就是 20% 。 利用价格弹性规则和历史上同类产品的参数经验，我们就可以模拟分析各种定价对于销量的影响了。当然，这个假设还是建立在需求曲线是线性的情况下。真实的情况应该更加复杂。 七、危机中的利润在进行定价讨论的时候，西蒙咨询公司通常会让企业出一套选择题： 选项 A：价格下降 5%，销量保持不变 选项 B：销量下降 5%，价格保持不变 大部分企业都会选择 A。但因为全球企业的平均净利润率约为 6%，其中中国的企业平均净利润率为 5.2%，所以选择 A 意味着利润率从 5.2% 下降到基本上无利润的境地（也可以理解为利润率下降 100%）。 所以，当企业陷入困境，降价是一种危险的操作，因为降价有可能让企业陷入亏损。相对来说，减产的危害小很多。 八、一些小结巴菲特说：评估一家企业价值最重要的因素是其定价权。 西蒙说：好的价格方案需要创造价值，量化价值以及传递价值。最后，也是最重要的一点，避免价格战。 孙正义在投资 wework 失败之后说：你的梦想最好是有利可图的。 我的老板常圳说：没有哪个公司是因为盈利倒闭的。 我认为： 制定价格和营销策略的时候，首先应该关注利润，然后才是规模； 营销中应该重点为消费者传递产品的价值信息而不是优惠信息； 为团队传递利润为先的价值导向； 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"人单合一 - 读《永恒的活火》","slug":"ever-living-fire","date":"2024-05-15T14:27:35.000Z","updated":"2024-09-01T14:30:04.732Z","comments":true,"path":"2024/05/15/ever-living-fire/","permalink":"https://blog.devtang.com/2024/05/15/ever-living-fire/","excerpt":"","text":"最近读完了海尔的创始人张瑞敏的《永恒的活火》。张瑞敏从 1984 年创立海尔以来，将海尔从一个小厂变成了一家世界 500 强企业，这本书主要介绍了他的“人单合一”的管理理念。 以下是一些读书总结。 一、什么是人单合一人单分别指的是人：员工；单：用户。 人单合一的核心思想是将管理模式面向员工和用户做调整，以便调动员工最大的工作积极性，激发产品创新力。同时用市场化的方式来检验团队的成果，让大家关注点都集中在产品售卖和用户体验上。 具体来说，在人单合一的模式下，员工是以混合业务小组（书中把它称作链群合约的小微）存在的，小组内部通过自发的选拔来形成小组长，小组长背负大家认可的绩效目标，同时业务如果发展得好，小组长也可以获得更大的经济收益。 书中并没有详细介绍混合业务小组的职位构成，但强调产品和销售同事都需要为最终的售卖结果负责。 在用户方面，人单合一讲求让小组自己发现和尝试产品机会。把小组变成一个个产品创新的实验田。在评价产品的时候，组织用纯市场的方式来评估，即只有销量好的产品才是真正命中市场需求的产品。 如何评价好的产品，作者引入了很多价值维度。强调给用户的体验增值作为核心评价指标。 对于职能化的团队，张瑞敏把它变成了为小组赋能的中台单元。这种更像是服务的中台限制了职能团队对业务的话语权，使得业务小组的权力更大。 另外张瑞敏砍掉了很多中层领导，让一线员工自己做决策。 二、本书的优点作为普通人很难接触到世界 500 强的 CEO 的系统性观点。张瑞敏作为在中国成长起来的企业家，他的管理观点融入了中国的传统文化，更容易被大家理解和接受。 本书的核心管理观点“人单合一”也特别适合当下这个信息爆炸的时代。《构建网状组织架构 - 赋能》一书里面也对现代组织有类似的观点，只是角度不一样。 另外，张瑞敏在书中也提及了很多管理大师的观点和著作，可以作为补充阅读材料。 三、本书的缺点这本书虽然作者是张瑞敏，但是其实是张瑞敏和其他管理学者的访谈录。作为访谈录这本书有两个缺点： 1、全书都是张瑞敏参加线下访谈的内容，而访谈双方也都很友善，所以并没有什么特别不同的观点碰撞。 其实访谈如果像李翔那样做得很有深度也很好，但是像本书这样的访谈，由于双方都不是专业做访谈的，所以提问的结构，对受访者回答的引导和深挖都显得不够专业。 2、这本书有足足 600 页厚，最主要的观点就是“人单合一”。全书的访谈中多次重复提到这个观点，但是对观点的阐述多集中在原理层面，但在执行层面上的难度，张瑞敏虽然有多次提及，但是却没有系统的说明。 一些有助于人单合一的管理工具（例如人单合一计分卡、共赢增值表），张瑞敏在书中也是点到为止，没有从设计角度解释这些工具的产生过程和设计思路。 这就造成了张瑞敏虽然在 20 年前的 2005 年就提出了“人单合一”，但是其管理思想的讨论和实践仍然不流行。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"如何卖货 - 读《营销管理》","slug":"marketing-management-book-summary","date":"2024-03-26T02:35:19.000Z","updated":"2024-04-02T04:21:50.181Z","comments":true,"path":"2024/03/26/marketing-management-book-summary/","permalink":"https://blog.devtang.com/2024/03/26/marketing-management-book-summary/","excerpt":"","text":"最近读完了一本市场营销的教材–《营销管理》，以下是一些感悟总结。 营销不是销售我很高兴在这样一本权威的营销教材上看到这样的描述：“销售只是营销的冰山一角”。书中引用了管理大师德鲁克的话： 我们可以假定，对销售的需要总是存在的，但市场营销的目标就是让销售变得多余。市场营销的目的是很好地认识和了解顾客，让产品或服务适合顾客并实现自行销售。在理想情况下，市场营销的成果是使顾客产生购买意愿。之后所需要的就只是提供足够的产品或服务。 我非常赞同这句话，我们的销售团队大部分精力都花在了如何卖货上，他们想着如何优化售卖的话术，如何逼单，如何让消费者感受到优惠。但其实最好的营销是让产品能够实现“自行销售”。 在让产品实现自行销售这件事情上，做得最好的恐怕就是 Elon Musk 了。Musk 没有为 Tesla 打任何广告，但是他却非常懂得如何营销。他会选择在市场不成熟的情况下，从高端的豪华车 Model S 切入，先做小众市场，再过渡到大众市场。他会为 Model X 设计酷炫的鸥翼门。他也会将 Model S 发射到太空中。他不断讲述自己的理念：加速世界向可持续能源的转变。最终特斯拉成为了全球市值最高的新能源汽车公司。 4P 的不足大家都知道 4P 理论，4P 指营销中的 4 个关键因素：产品（product）、价格（price）、促销（promotion）和地点（place）。 作者在书中指出了 4P 理论的 3 个缺陷： 无法区分供应品是产品还是服务。 将品牌视为产品的一部分而非独立的属性。 对“促销”一词的界定模糊，包含了激励和沟通两种行为。 于是，作者将 4P 扩展为 7T，分别为：产品、服务、品牌、价格、激励、沟通和分销。 产品是一种商品，为目标顾客创造价值。产品可以是有形的（如食品），也可以是无形的（如软件）。购买产品将赋予顾客对产品的所有权。 服务。服务也为顾客创造价值，但并未赋予顾客所有权。如：就医流程，设备维修，理发等。 品牌。品牌的目的是识别公司提供的产品或服务，并将其与竞争对手区分开来。 价格。顾客为获得产品而支付的费用。 激励。通过降价或者加赠来提高产品价值。通常形式包括：批量折扣、降价、优惠券、赠品等。 沟通。沟通是向目标顾客告知产品细节以及购买方式的行为。 分销。分销是指向目标顾客提供产品的渠道。 从为顾客创造价值角度： 产品、服务、品牌、价格、激励都在设计层面上服务于价值； 沟通是在让消费者了解到价值； 分销是传递价值的渠道； 消费者决策流程 我们先看书中是怎么写的： 市场营销学者构建了这个决策过程的“阶段模型”，其中消费者通常经历五个阶段：问题识别、信息搜索、方案评估、购买决策和购后行为。 消费者做出购买决策的过程及其购后行为通常被称为消费者决策旅程。使用“旅程”的说法是因为消费者做出购买决策的方式并不总是线性过程，相反，它通常是一个迭代过程。 消费者并不总是经历所有的五个阶段，他们可能会跳过或逆转某些阶段。当你购买经常使用的牙膏品牌时，你会直接从问题识别阶段进入购买决策阶段，跳过信息搜索和方案评估。 我对这部分的感受是：我们的营销团队在考虑产品售卖的时候，常常会放大“赠品”对售卖的影响，但其实从消费者购买决策流程来看，赠品是其中非常小的一个环节，只是属于 7T 中的“激励”中的一部分。 过于关注赠品，会使得整个营销过程将问题识别，方案评估等这些重要环节忽视。拿直播间来说，一个好的直播间应该重点讲用户需求，讲产品的解决方案，最后再用优惠和赠品来关单。但是很多自播或者达播直播间，上来就讲这个东西多么便宜，多么优惠，错过就没有了。这种讲解法不但转化效率也是低下的，也会带来极高的退款率。 对于一个长期经营品牌的公司来说，这种讲解法也会让品牌的积累变得薄弱，因为只有强调解决方案本身的优秀才能让消费者认同产品，从而慢慢积累对产品所属品牌的认同。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"替农夫山泉说句话","slug":"talk-about-nongfu-spring","date":"2024-03-18T21:19:14.000Z","updated":"2024-03-19T02:51:31.806Z","comments":true,"path":"2024/03/19/talk-about-nongfu-spring/","permalink":"https://blog.devtang.com/2024/03/19/talk-about-nongfu-spring/","excerpt":"","text":"最近看到网上抵制农夫山泉闹得轰轰烈烈，我去翻了一下，看看大家到底在骂什么，看完觉得莫名其妙。我把大家骂农夫山泉的点摘出来给大家看看： 1、骂农夫山泉有日本资本我们现在是一个高度全球化的社会，我们身边用的很多东西，不但可能有日本资本了，甚至就是日本品牌。索尼，任天堂，佳能，尼康，这些日本品牌大部分人都见过或者用过。我们小时候看日本的动漫，灌篮高手，包括前段时间大家怀念的七龙珠，不都是日本的吗？ 一个外国资本，看好我们中国公司，买我们中国公司的股票，投资我们中国有什么问题？这不就是变相给我们中国公司的股票提高股价嘛？在国家都在鼓励外资投资的情况下，这些骂农夫山泉的人，是不是希望所有外资都撤出中国？ 我一直觉得，一个商品如果给我们带来了快乐，让人民幸福了，就是好的商品。不管他背后的资本来自哪里。我们在讨论一家公司的时候，也应该立足于他们的产品是否好，讨论产品和服务本身。 2、骂农夫山泉的产品传播日本文化 有人说这个π像靖国神社。我对这种杯弓蛇影的行为特别厌恶，因为这种可以通过想象力发散来进行的指责防不胜防。要这么说，每个人的下半段身子是不是也像一个π，也像靖国神社了？ 有人做了一张图，我感觉是比较能够代表这种想象发散力的危害的。 如果按上面这张图的对比，那华为是不是都得把 logo 改了才行？ 3、骂农夫山泉捐款少有人翻了农夫山泉的某一次捐款，说捐少了。我想说，捐款这种事情是一个企业的自愿行为，企业捐不捐捐多少都是人家自由。我们自己做过多少公益事业，捐过多少钱？不要拿道德绑架企业。 4、骂钟睒睒靠娃哈哈赚第一桶金这个事情要讲证据，人家钟睒睒已经辟谣了，也详细讲了自己第一桶金怎么来的。如果要骂，就也应该拿出证据，证明钟睒睒撒谎。 5、骂钟睒睒的孩子是美国籍我觉得这个事情根本不重要。 我身边有许多朋友，有人去了美国，有人去了加拿大，有人拿了新加披国籍，有人拿了香港身份。我的大学室友，一个在美国定居了，一个在韩国定居了，每年他们回国的时候我们还会聚聚，交流一下各国文化的差异。 我从来没有见过一个人因为他的朋友出国，骂他的朋友。我也没有见过这种事情发生。为什么我们就要求企业家或者企业家的孩子不能有外国国籍呢？ 写在最后最后我想说，我们应该给个人和企业足够的自由。 一个人如果自食其力，遵纪守法，就是一个合格的公民。如果他道德高尚，助人为乐，那么我们应该歌颂赞美这种行为。但是我们不能道德绑架每一个人必须捐款，必须留在中国。 一个企业如果遵纪守法，吸纳大量就业，持续提供受欢迎的产品满足消费者需求，创造利润并为国家纳税，那就是一个合格的企业。如果这个企业还道德高尚，通过卷款和分红回报股民和社会，那我们应该歌颂赞美这种行为，但我们也不能道德绑架企业，要求企业必须捐款，企业家的子女必须在中国。 其实一家企业做到本分已经很不容易了。 希望大家给农夫山泉一点活路，中国好的企业和企业家本来也不多。 后记在公众号发表完这篇文章后，我有了很多新的思考。 1、我加强了自我观点的认同在我的公众号发完该文章后，我的评论区遭到了谩骂，听从一些朋友的建议，我删掉了文章。但是，很多大 V 站出来表达了同样的观点。 《聊聊农夫山泉的事》- MacTalk 《别再滥用“爱国”的幌子》- caoz的梦呓 《谁想搞垮农夫山泉？》- 吴晓波频道 《暴民替宗庆后除三害》- 三表龙门阵 《谁是“网暴”农夫山泉的真正推手？》- 胡锡进观察 《从“放生”农夫山泉开始，这事算是彻底成互联网闹剧了》- 差评 以上的文章，像MacTalk、caoz的梦呓、三表龙门阵都是我非常喜欢订阅的 IT 类公众号。与他们的观点一致让我有了更多的自信，更加坚定自己的立场。 2、我理解了情绪的力量虽然这是一次在事实上没有多少争论的事情，但是在舆论上，民众的情绪却表现出极端地不理性，这里面更多是情绪的力量。在这种力量下，农夫山泉成了大家情绪的出口，于是网民并不在乎真相，在乎的只是自己的情绪宣泄。 情绪是重要的，我家孩子在闹情绪的时候，我都会让她平静下来之后再和她沟通。所以，我其实不应该在民众都带着情绪的情况下与大家辩论。这种辩论行为一方面是无效的，另一方面有可能会激发更多情绪。 我通常情况下都会尊重我的粉丝，不管是支持我还是反对我的评论，我把大家的评论都放出来了，但事后看起来，因为情绪的原因，评论区成为大家相互争吵的又一阵地，也激发了对抗。 3、如果未来还有类似的事情，我会怎么做在民众情绪被极端放大的时候，其实社会是需要理性的声音的。这个时候，站出来发表不同观点的人，肯定会是被民众网暴的。我就收到了一些人身伤害的威胁： 所以，未来如果再有一些网络上的非理性情绪表达的时候，我需要： 更加谨慎地选择表达观点的时间、方式和方法。 如果表达观点会影响到我个人的生活和工作，我应该先沉默。 不应该在评论区放出所有观点。 不应该回复非理性的留言。 4、其它我很好奇我的粉丝里有多少人是在这件事情中比较有情绪的，于是我查了一下，可能就是这 155 个取消关注的粉丝。 但我的 5 万粉丝里面，只有 0.3% 的人被极端情绪带动，我还是挺为那 99.7% 的粉丝骄傲的。是的，说的就是正在看文章的你😁","categories":[],"tags":[]},{"title":"关于私域的思考","slug":"thinking-about-private-group","date":"2024-03-08T07:36:57.000Z","updated":"2024-03-08T06:46:38.518Z","comments":true,"path":"2024/03/08/thinking-about-private-group/","permalink":"https://blog.devtang.com/2024/03/08/thinking-about-private-group/","excerpt":"","text":"最近思考了一下私域渠道，以下为自己的总结，分享给大家。 什么是私域渠道私域是指将用户以微信群，或特定分销 App（快团团、万物心选、蜂享家、京粉等）的方式来组织的渠道。 这种渠道的特点是： 渠道内部的信息相对封闭，仅私域内用户可见 私域渠道的商品售价通常会有内部的折扣，以实现对其它公域渠道的流量争夺，用优惠维持粉丝的持续聚集 私域渠道通常会带有多级分销性质，用类似传销的方式实现用户的裂变增长 虽然品牌方通常禁止，但是私域渠道的底层分销者为实现利益最大化，会将优惠信息传播到公域（小红书、微信群、闲鱼）上，以实现对公域流量的拦截 对于公域的乱价行为，私域渠道通常管控不严，因为管控动力不足&amp;管控难度大 私域渠道的价值私域渠道的价值有： 以相对低价收获价格敏感用户。 触达公域未触达的潜在购买者。 品效合一的种草渠道，私域可覆盖特定人群，引发群内讨论，有助于产品曝光。 按 CPS 结算，利润率相对确定。 私域渠道的风险私域渠道的风险主要是乱价，包括： 乱价到小红书 吃掉官方渠道的自然流量。 消费者对品牌的价格体系感到紊乱，购买决策时间拉长。 伤害品牌的长期价格认知。 除乱价外，私域渠道通常购买力容量有限，随着销量衰减，后期收益越来越小，乱价风险越来越大。 私域的策略 因为私域内部本来就有折扣体系了，所以私域渠道的合作价格，赠品价值应与官网拉齐。 限制私域售卖的时间。只在有限的时间段内做活动。比如每月有 3 天活动期。 停掉衰减的私域渠道。 赠品区分，便于识别乱价。 新品在起量之前，都不上私域。 其它虽然说停掉私域对业务的影响会是减少品牌曝光，减少价格敏感用户。但是如果私域一直无法有效管控，也可以考虑停掉所有私域合作。 整体上来看，消费者并不会只存在于单一渠道，所以不做私域对品牌的长期影响是非常小的。 以上。","categories":[],"tags":[{"name":"marketing","slug":"marketing","permalink":"https://blog.devtang.com/tags/marketing/"}]},{"title":"菜谱 - 滑肉汤","slug":"smooth-meat-soup","date":"2024-02-20T05:48:20.000Z","updated":"2024-02-23T05:48:21.007Z","comments":true,"path":"2024/02/20/smooth-meat-soup/","permalink":"https://blog.devtang.com/2024/02/20/smooth-meat-soup/","excerpt":"","text":"春节在家跟舅舅学做了滑肉汤，这个菜在我的老家四川广安市武胜县很火，是当地的特色美食。 其实四川有很多不辣的美食，滑肉汤就是其中一道，分享给大家。 一、食材准备 食材 重量 瘦肉 300g 红薯豆粉 100g 豌豆尖 200g 一些补充： 瘦肉可以用里脊肉或者别的偏瘦的肉，舅舅说最好用紧挨着排骨的那片瘦肉。 如果没有豌豆尖，也可以用丝瓜、豆芽代替。 二、烹饪步骤第一步把瘦肉切片，然后放入少量盐、胡椒、酱油调味。用手把肉片抓匀，让肉片与调料充分混合待用。 如果希望肉更嫩，也可以加入一个鸡蛋清。 如果肉比较瘦，也可以加入少量食用油。 第二步把红薯豆粉放入一个较大的盆中，加入温水化开，比较好的状态是不太稀的“非牛顿流体”态。这个时候加入第一步的肉片抓匀，让肉片裹上豆粉。 也可考虑用开水化开，这样豆粉会更黏，不易糊锅，但是会比较难抓匀。 第三步锅中加入适量水，放入姜片，猪油，少量盐和胡椒粉，待水烧开后关火。用手将肉片一片一片下锅，这样做主要是为了保证豆粉不化开糊汤。 第四步重新开火，水开 1 分钟左右加入鸡精，然后放入豌豆尖约 30 秒后关火。 一锅滑肉汤就煮好了😊","categories":[],"tags":[{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"}]},{"title":"小马宋的营销总结(2) - 读《卖货真相》","slug":"xiaomasong-notes-2","date":"2024-02-17T13:56:03.000Z","updated":"2024-02-26T03:23:39.048Z","comments":true,"path":"2024/02/17/xiaomasong-notes-2/","permalink":"https://blog.devtang.com/2024/02/17/xiaomasong-notes-2/","excerpt":"","text":"小马宋创立了自己的战略咨询公司，为元气森林、得到 App 、极米投影仪等产品做过营销咨询服务。本书是他的营销总结。 读这些一线营销公司创始人的书，内容非常接地气，很多案例就发生在身边，所以感受会更加真实一些。 以下是一些笔记。 1、渠道和推广的差别4P 理论中的渠道和推广容易被混淆。作者首先认为：4P 理论中，4 个 P 并不是完全独立的，比如价格的调整，很多时候就是一种推广活动。又比如产品的包装，其实也涵盖有推广的内容。 作者小马宋也对渠道和推广下了一个定义： 渠道是一套组织系统，构成元素是参与商品交易和交付的所有组织和个人。 推广说为了促进商品成交而做的所有决策和行动。 我的理解：对程序员来说，渠道像是面向对象的属性，推广像是对象拥有的方法。 2、腰带哥渠道创新的故事小马宋讲了一个腰带产品渠道创新的故事：故事的主人公叫“腰带哥”，他敏锐的从裤子店里面发现了腰带生意的商机。 因为顾客在挑裤子的时候，会拿腰带来搭配一下，但当时的裤子店很少卖腰带。于是腰带哥就尝试批发了一批腰带，在几个裤子店测试，把腰带放在裤子店里面，不要货款，只要老板卖出一条腰带就给 15 元的提成。最后测试的结果是他发现一家店一天可以卖 10-20 条腰带。于是他成立了自己的腰带品牌，最高的时候一年做到了 5000 万的规模。 后来他的生意迅速下滑，主要因为： 同行发现了他的这个门道，用更多佣金和他抢生意 电商的发展侵蚀了线下店的流量 年轻人不喜欢穿腰带，市场规模萎缩 腰带哥的故事告诉我们，卖货的核心是找到能发生交易的地方，并且把你的货铺到那里去。 另外，自己挣的是产品创新钱还是渠道创新的钱，长期竞争壁垒在哪里，也是让我深思的地方。 3、推广需要让消费者产生记忆、购买和传播一些同事在卖货的时候只考虑让消费者购买，为了达成目标就着重讲优惠讲赠品，这是不对的。 因为这样没有考虑到让消费者记忆和传播，这样的售卖方式对于品牌没有长期价值。我们花在渠道上的每一分钱都是要计算成本的，如果长期我们只能靠花钱来买流量，那么售卖风险是非常大的。哪一天渠道的流量费用上去了，或者渠道变化了，对我们都是巨大的灾难。 但是如果我们讲产品，让消费者记住我们的产品卖点，甚至还能够在某些情况下推荐我们，那么我们就拥有了一部分的品牌自然流量。这些流量会体现在消费者在电商网站的主动搜索行为上面，这才是长期的品牌价值。 4、品牌广告不是银弹一些同事常常问：为什么我们不上电梯广告，不投品牌广告。我常常解释说：因为我们的收入规模不够，而品牌广告需要的基础密度要足够大，否则就没有效果。 在书中，小马宋进一步给我了启发：很多行业并不需要品牌广告。比如：餐饮很少有品牌广告，他们通常只在所在的购物中心放一些吊旗。律师事务所也很少打品牌广告，但是不影响我们知道事务所里面的头部公司。 正确的做法应该是：根据企业的具体情况来设计可行的推广方案。这个方案在早期应该重点看重对售卖的直接拉动。只有当你有了足够多的利润，这个利润你拿出一部分来，没效果也无所谓的时候，才可以拿来做一些偏长期的品牌广告。 5、消费者决策 POM 模型小马宋总结了《绝对价值》一书中的消费者决策模型。这本书作者是斯坦福大学商学院市场营销学教授西蒙森。 在 POM 模型中，西蒙森把影响消费者决策的因素归结成三类： 消费者自己的喜好（personal） 品牌方的传播（marketing） 朋友，专家，KOL，评测机构等第三方（others） 小马宋把这个理论结合当下时代做了一些有价值的解读，比如： 电视时代因为广告效率高，所以品牌可以通过广告来影响消费者。但是现在很多品牌都不投电视广告了，因为现在广告渠道丰富了，电视广告成本太高，回报不足。 现代的营销需要做更辛苦的事情：要做种草，评测，笔记等方式，也要挑选有性价比的渠道，测算投放 ROI，把每一分钱花在刀刃上。 6、效果广告的问题小马宋从品牌知名度解释了效果广告的问题。 品牌知名度有三个指标： 品牌再认率。类似于“有提示提及率”，就是用户看到这个品牌的时候，能想起来之前听说过这个品牌。 品牌再现率。当消费者产生某种需求的时候，能够想到这个品牌。 无提示第一提及率。当消费者被问到某个品类的时候，消费者提到的第一个品牌。 如果一个品牌只投效果广告，那么对于品牌知名度的影响是非常微弱的。因为没有知名度，那这个品牌是无法从用户需求场景激发出用户主动的行为，因为一个新用户根本不知道有这个品牌存在。 品牌广告的效果在于：虽然当下的效果不如精准的效果广告，但是扩大了知名度，未来的顾客在需要的时候可能就会想起你，才会搜索你并产生购买行为。 7、不是所有产品都需要投广告一些产品的渠道和营销是绑定的，渠道即获客方式，这种情况就不需要另外投放广告。比如餐饮行业，路边的店面招牌就是广告。律师事务所也很少打广告。开在小区的小卖部也不需要打广告。 那什么产品需要投广告呢？应该根据企业的具体情况，设计可执行的营销获客方案。 如果是一家初创企业，看重快速的现金回报，就应该更多地投放效果广告。等企业慢慢壮大，可以拿一部分利润来做品牌广告，这样如果没有短时间内的效果也是可以承受的。 书中还有很多不错的观点和案例，推荐做市场营销的同行都看看。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"小马宋的营销总结(1) - 读《营销笔记》","slug":"xiaomasong-notes-1","date":"2024-02-09T13:53:40.000Z","updated":"2024-02-26T03:23:39.047Z","comments":true,"path":"2024/02/09/xiaomasong-notes-1/","permalink":"https://blog.devtang.com/2024/02/09/xiaomasong-notes-1/","excerpt":"","text":"小马宋创立了自己的战略咨询公司，为元气森林、得到 App 、极米投影仪等产品做过营销咨询服务。本书是他的营销总结。 华与华的华杉在营销咨询行业开创了写书立说的方法，收获了大量的知名度，这也引来了同行的学习。 读这些一线营销公司创始人的书，内容非常接地气，很多案例就发生在身边，所以感受会更加真实一些。 以下是一些笔记。 1、实体经济需要在第一天就挣钱互联网给了大家错觉，觉得做任何事情都可以先做规模，再做利润。但实体经济不是互联网。 互联网的 App 边际成本很低，如果规模化之后能够获得垄断地位、用户心智，那么长期的获客问题也解决了。另外 App 本身有黏性，大用户量的产品可以通过广告赚钱。 实体经济本身卖的是商品，商品的成本占比能到 20% - 50%，这么高的成本占比的情况下，规模化之后带来的成本优化空间很小。所以实体经济如果不能在售卖的第一天挣钱，就非常危险。 实体经济可以在不挣钱的时候，将规模限制在一个很小的范围内，打磨自己的产品和测试各种可以回本的获客渠道，努力让自己挣钱。 2、企业需要找到自己的独特经营战略企业的使命是为消费者提供有价值的服务，并以此让自己活下来。 但是企业虽然有这样的愿景，却需要找到一条独特的经营模式。独特的经营模式可以给企业带来竞争的壁垒。 企业不但需要回答：为什么消费者现在要选我，更重要的是：为什么消费者未来还会选我。 为了回答这个问题，企业需要在产品和营销两个角度上构建自己的长期优势，让自己拥有确定的未来。 从产品层面上：企业需要回答，产品未来是否会需要持续迭代？如果需要，为什么自己的产品迭代会保持竞争力？ 从营销层面上：企业需要回答，自己的用户现在从哪儿来，未来从哪儿来，获客渠道会不会变化？为什么可以一直稳定获得用户？ 对于以上问题，每个企业的答案都应该是独特的。 3、做大市场的生意作者举了白酒的例子：白酒是一个市场规模 5000 亿的生意，茅台的规模大概是 1000 亿，五粮液 500 亿，过百亿的企业很多，所以是一个大市场。 餐饮市场规模超过 4 万亿，也有大量过百亿的企业。 大市场的生意使得大家差异化经营成为可能。 4、用户需要解决的是“待办任务”作者引入了《创新者的窘境》作者提出的“待办任务”的概念：JTBD（jobs to be done）。在这个概念下，用户买转头其实是需要一个孔；用户点餐是需要让自己肚子饱。 从“待办任务”角度思考解决方案，可以容易跳出当前的产品框架。 从“待办任务”角度也可以发现跨品类的竞争。比如统一方便面传统的竞争对手是康师傅，但是因为外卖的兴起，大家都不愿意买方便面了。因为本质上外卖和方便面都是解决让肚子饱的任务。 5、包装和落地页对消费者购买决策影响极大在线下货架商品的年代，包装对售卖影响很大。如果你去线下的玩具店，你会发现很多玩具会有开窗设计，这种设计帮助消费者在购买前看到并且体验玩具的功能。 现在电商流行的年代，直播间和落地页对售卖影响很大，包装反而变得不那么重要了。所以， baby care 可以靠设计和高品质的落地页吸引宝妈购买他们的产品。我们的斑马思维机也可以靠直播间 1 年卖出超过 1 个亿的 GMV 。 6、品牌名是否应该复用之前看《定位》那本书，作者希望所有的产品都应该有自己的品牌名。但是咱们看实际的商业社会，集团品牌其实很常见。 书中举了雀巢的例子，也举了恰恰从瓜子扩品类到坚果的例子。所以，品牌能不能复用还是要看实际情况。 如果品牌复用能够同时对新旧产品都产生累进，那其实可以复用。这种累进体现在： 新产品因为品牌复用，更好卖了 新产品不会对原有产品的品牌带来伤害 7、定位理论的局限作者讨论了定位理论的一些局限性： 定位理论所说的“占领消费者心智”的逻辑需要大量的品牌广告投放才能有效，而这需要大量的广告费投入。 现在这个时代，传播渠道变得多样化了，像电视这种过去大规模传播的媒体消失了，品牌广告投放更难覆盖大众。 另外，作者举了很多定位书中的案例错误，说明定位理论只是商业竞争中的一个因素，而不是决定了竞争的全部。对此我是完全同意的。 以上。大家龙年快乐～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"上下同欲的几种情况","slug":"target-mapping-situations","date":"2024-01-29T14:00:28.000Z","updated":"2024-01-29T14:04:58.810Z","comments":true,"path":"2024/01/29/target-mapping-situations/","permalink":"https://blog.devtang.com/2024/01/29/target-mapping-situations/","excerpt":"","text":"故知胜有五：知可以战与不可以战者胜；识众寡之用者胜；上下同欲者胜；以虞待不虞者胜；将能而君不御者胜。 — 《孙子·谋攻》 在组织内部，上下对齐是非常重要的。否则可能下属做了很多事情，但是上级一点都不认可；亦或者上级想做一个事情，下级内心不想做，最后因为执行不到位而做得不好。 “上下同欲”的状态是最舒服的，但是很多时候现实并不完美。当上下对齐出现问题的时候，应该怎么解决呢？我分别在下属视角和上级视角阐述一下。 1、下属视角站在下属视角，如果上级不能理解和认同自己的观点，那么应该仔细判断一下，是以下哪种情况。 情况一：上级的信息量不足。这个时候下属应该尽可能将自己的信息共享给上级，帮助上级理解你的逻辑。 如果你说了很多上级还是没有被说服，而你还是认为上级的信息量不足，那只能说明你缺乏信息沟通的能力，应该加强这方面的锻炼。 情况二：上级的思考角度或者权衡方式不一样。这个时候下属应该尽可能通过询问，理解上级的思考角度或者权衡方式，通过学习共同的思考方式，逐步达成相似的做事方法。 情况三：上级的能力不足。如果你确定你的上级能力不足，那么应该尽可能帮助他意识到这方面你比他更专业，让他通过授权给你更多自主权。 但是在刚开始有分歧的时候，你可能还是需要多给上级一些时间来验证你的观点才是正确的，所以没关系，你如果实在没办法说服他，就先按他的来。 如果你实在受不了，也可以选择调岗或者离职，选择一个能够沟通的上级。 情况四：你无法判断为什么无法说服上级。这个时候可能是因为有一些信息领导不方便告诉你，亦或者是你的能力不足，无法理解领导的一些判断。这个时候没关系，先按领导的执行即可。 无论以上哪种情况，你都需要先充分沟通，站在上下同欲的角度试图达成一致。因为本质上你们都是想把业务做好的。如果达不成一致，就先按上级的来。 2、上级视角站在上级角度，如果下属不能理解自己的想法，那么应该努力阐述自己的思考角度和权衡的逻辑，这是一个非常好的对齐的机会。 上级也应该努力倾听下属的思考逻辑，避免自己因为信息缺失造成判断错误。 如果努力沟通之后，大家的观点还是没对齐，上级应该判断一下这个事情对业务的重要和紧急程度。 情况一：如果是一个重要且紧急的事情，上级应该承担起决策权力和责任，让大家按自己的想法来做。 情况二：如果是一个重要但不紧急的事情，上级可以给下属多一些时间思考和讨论，用时间来磨合思路，用沟通建立起大家都认同的目标。 情况三：如果是不重要的事情，上级可以选择授权，给下属多一些自由空间。 如果上级消耗了巨大精力还是与下属对不齐，上级应该动用自己的权力来决策。如果在这种情况下，下属不听上级的，那么应该把下属换掉。 另外，上级也应该时刻自省：自己是否足够胜任当下的职位？如果自己不能胜任，那么应该努力提升自己或者让位于能够胜任的其他人。 其它无论如何，一个上级应该承担他职位内的决策权力和责任，即使将决策权授权给下属，也应该是上级承担相关的责任。 以上。","categories":[],"tags":[]},{"title":"支持 LGBT","slug":"support-LGBT","date":"2024-01-15T06:24:19.000Z","updated":"2024-01-15T06:40:05.111Z","comments":true,"path":"2024/01/15/support-LGBT/","permalink":"https://blog.devtang.com/2024/01/15/support-LGBT/","excerpt":"","text":"最近看到一个新闻，OpenAI 的 CEO Sam Altman 结婚了，对象是另一个男人。 我想借此机会谈谈我的看法：我明确支持 LGBT。 现代的相关研究其实已经了解到，同性恋其实是一种基因上的特点，大概世界上有 1% 左右的人会因为基因的原因喜欢上同性。就像命中注定一样，他们看到同性会像我们看到某些异性那样：被吸引，有感觉。 如果这是天生的，同时对社会并没有带来伤害，那么我们就应该尊重他们的基因。就像我们尊重各种因为基因不同而在肤色、性格、外表上产生不同表现的其他人类一样。 相关的法律其实应该为 LGBT 人群开绿灯，保证他们在生活和就业上不被歧视，也应该在婚姻上给予他们相关的法律支持，让他们能够正常组建自己的家庭，通过领养等方式抚养自己的孩子。 这样的社会，才足够和谐。","categories":[],"tags":[]},{"title":"跑夜车的滴滴司机","slug":"didi-driver-who-work-at-midnight","date":"2024-01-09T09:50:20.000Z","updated":"2024-01-25T09:57:11.615Z","comments":true,"path":"2024/01/09/didi-driver-who-work-at-midnight/","permalink":"https://blog.devtang.com/2024/01/09/didi-driver-who-work-at-midnight/","excerpt":"","text":"最近出差较多，1 月 4 日回北京，当时到机场的时候已经是晚上 12 点了。我用滴滴试着打车回家，立刻叫到了车，正好我在飞机上睡了一路，不太困，就和司机攀谈起来。 作息司机师傅是专门跑夜车的司机。他的作息是这样的： 早上 10 点-下午 5 点，睡觉。 下午 5 点起床，吃晚饭，然后跑晚高峰。 下午 10 点以后，专门跑机场单。 半夜 11-1 点，看准跑车间隙合适的时候，吃第二顿饭。 凌晨 2-5 点。在车上小睡一觉。 早上 5 点-10 点，跑早高峰。跑完早高峰吃第三顿饭。吃完饭后睡觉。 问题我问了一些问题： 问：车上睡觉冷怎么办？ 答：全程开空调，但是要把车窗留个缝，防止一氧化碳中毒。 问：半夜找得到吃的吗？ 答：有专门的馆子，跑车的师傅都知道。我们跑车的有微信群，可以交流这些信息。 问：为什么专门跑夜车？ 答：因为晚上里程费高而且不堵车，跑习惯了比白天挣得多。 收入问了一下他的收入情况，他说到手大概 1 万左右。主要是需要跑早晚高峰来挣积分，积分高的司机在接单的时候才可以优先派单。所以他跑早晚高峰其实不挣钱，因为堵车，主要是为了积分。因为积分是按单算的，所以他早晚高峰喜欢接小单，这样积分赚的快。 家庭家里有两个娃，大娃读大四，小娃在读高中。老婆没工作在家带娃，钱挣来基本上都给家里寄回去了，供老婆孩子生活和上学。大娃在山东上学，毕业了想留在当地，大娃觉得北京的生活成本太高，北京租房一个一居室得 5000 左右一个月。山东那边租房一个月几百块钱，没啥生活压力。 竞争现在滴滴司机竞争很大，以前在机场都不用等，现在平均要等 1 小时左右才能接到客，钱都给机场交停车费了。据他介绍，疫情之前北京滴滴司机有 22 万，疫情之后增加到 55 万。很多做小生意的、打工的因为疫情公司倒闭做不下去了，转而开滴滴挣钱，造成现在接单困难。 最后我们现在处在一个变化的时代，出口和基建的红利慢慢褪去，普通人生活的压力越来越大。每一个人都不容易，愿国家的经济慢慢好起来。 以上。","categories":[],"tags":[]},{"title":"将 Hexo 升级到 V7.0","slug":"upgrade-hexo-to-v7-0","date":"2024-01-07T13:56:08.000Z","updated":"2024-01-07T15:59:26.538Z","comments":true,"path":"2024/01/07/upgrade-hexo-to-v7-0/","permalink":"https://blog.devtang.com/2024/01/07/upgrade-hexo-to-v7-0/","excerpt":"","text":"这次重装 M2 的电脑，Hexo 在设置的时候报很多警报，一些依赖库因为太旧有安全风险，查了一下 Hexo 有最新发布的 7.0 版本，于是打算整体迁移一下。 安装 Hexo 7.0首先 Hexo 的安装可以用 brew 了。使用 brew install hexo安装，安装好之后 Hexo 在 /opt/homebrew/Cellar/hexo/7.0.0 下。 使用 Hexo 的如下指令完成建站 hexo init blogcd blognpm install 安装插件建完站之后，把之前的文章都复制进去，在 themes 目录下同样把 Archer clone 下来： git clone https://github.com/fi3ework/hexo-theme-archer archer 然后需要在 blog 根目录下安装以下插件： npm install hexo-deployer-git --savenpm install hexo-generator-json-contentnpm install hexo-generator-feed --savenpm install hexo-wordcount 除此之外还需要一些配置，修改 _config.yml，增加如下内容： jsonContent: meta: true pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: true excerpt: false categories: true tags: true 并且将 _config.yml 的主题为 Archer： theme: archer 最后，复制 Archer 主题目录下的 _config.yml 到 Hexo 根目录，并命名为 _config.archer.yml。删除 Archer 主题目录下的 _config.yml 文件，或将它重命名为 _config.yml.template，避免配置合并或冲突。 这次 Archer 也更新了很多，所以看起来升级是必要的。详见：https://github.com/fi3ework/hexo-theme-archer 发布因为我在 config.yml 中配置好了deploy信息： # Deploymentdeploy: type: git message: &quot;Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm&#x27;) &#125;&#125;&quot; repo: github: git@github.com:tangqiaoboy/tangqiaoboy.github.com.git branch: master 日常操作主要是以下几个： #发布新文章hexo new 文件名#预览hexo s#生成文件到 public 目录hexo g#发布到 Github Pageshexo d 需要注意，如果改了文件发布的话，要先 hexo g，然后再 hexo d。 以上。","categories":[],"tags":[]},{"title":"重装 M2 的 MBP","slug":"install-mac-env","date":"2024-01-06T16:04:25.000Z","updated":"2024-02-26T03:23:39.047Z","comments":true,"path":"2024/01/07/install-mac-env/","permalink":"https://blog.devtang.com/2024/01/07/install-mac-env/","excerpt":"","text":"因为工作的电脑使用满 4 年，所以周末领到了一台新的 M2 的 MBP。考虑到新电脑 CPU 不太一样，所以我没有使用迁移助手，尝试重装了一遍电脑。 整个安装下来最麻烦的就是开发者环境，基本上无法正常连上外网下载各种开源软件，最后我灵机一动搜了一下，才发现清华大学上有不少开源软件的镜像。这样大大加快了我安装软件的速度。 整理了一下自己的生产力工具，现在做业务之后，基本不写代码了，所以偶尔写博客或者查资料有这些软件就够用了： iTerm2拥有一个更好的 Terminal 操作界面： https://iterm2.com/ Home Brew用镜像安装 Home Brew: 清华镜像：https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/ 阿里云镜像：https://developer.aliyun.com/mirror/homebrew/ 安装好后，可以用 brew doctor 检测一下。 有了 Home Brew 之后就可以装我需要的一些环境： brew install nodebrew install hexo npm 的资源比较慢，安好 node 之后也把镜像设置一下： npm config set registry http://mirrors.cloud.tencent.com/npm/ Oh My ZshOh My Zsh 可以利用镜像安装：https://mirrors.tuna.tsinghua.edu.cn/help/ohmyzsh.git/ 安装完可以设置一下 autojump 插件 再把 macos 插件打开。 Sublime Text我主要用 Sublime Text 来写博客。 配合下面的设置可以方便在命令行中调用 Sublime Text。 export PATH=&quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin:$PATH&quot; Alfred在安装软件的时候，我顺便花 30 美元把我的 Alfred 升级到了 5.0，试了一下它的 Power Pack 提供的 Snippets 功能，比 Dash 还强大很多，于是果断把 Dash 换掉了。麻烦的是我自己原本整理的 Snippets 无法方便迁移，只能一个一个复制，不过也当再次整理了，因为很多 Snippets 没用了。 Alfred 的 Snippets 也支持利用 Dropbox 同步。 1Password 6我还在使用之前买的 1Password 本地一次性付费版本，不用每月续费，配合 Dropbox 同步密码。 Dropbox离不开它，所有重要工作资料都用它来同步和备份。 Surge有了 Surge，Dropbox 才能正常工作。 ImageOptimImageOptim 可以帮助我压缩博客的图片。","categories":[],"tags":[]},{"title":"2023 年个人总结","slug":"2023-summary","date":"2024-01-01T02:09:04.000Z","updated":"2024-01-07T15:42:25.083Z","comments":true,"path":"2024/01/01/2023-summary/","permalink":"https://blog.devtang.com/2024/01/01/2023-summary/","excerpt":"","text":"一、工作硬件研发今年硬件研发团队主要完成了 斑马思维机 G2 版本的研发上线。这个项目因为供应商的配合度高，所以整体推进得还比较顺利。从最终的售后数据来看，我们的产品品质也是过硬的。 斑马思维机 G1 只能支持 256 张题卡，在发布的时候，我们把这些题卡都做成了思维类的题卡。但我们很快意识到，内容的扩展能力在竞争中是非常重要的。我们在斑马思维机一代上因为判断失误，没能预留足够多的题卡升级能力，导致我们不得不用一款新版本的机器来提供扩展能力，这也会后续售卖中的版本切换增加了不少挑战。 斑马思维机 G2 的各项功能都经过了仔细的考虑，比如要不要上 Wifi，如何升级，电池和喇叭的选型，未来内容的扩展能力，出海的能力，预留的存储空间等等。从现在来看，我们还没有发现产品侧的遗憾。 斑马思维机今年在产品侧也荣获了很多国内外的玩具类大奖，比如韩国的 K Design，美国的 MCM 等。 如果说硬件研发有什么遗憾的话，就是我们在新品的立项上还是没能想出足够多的可落地创意，这使得我们的玩教具业务在增量上主要还是依赖于斑马思维机和斑马拼音机这两个品。 斑马在玩教具业务上的思路与今年读的 《华与华方法》 书里讲的一致，我们力求站在企业社会责任和用户需求角度，思考如何做出具有创新性的硬件产品，希望能够结合自己在教育、互联网、人工智能以及硬件上的积累，提供独特的产品定位、希望做到总成本最优和竞争对手难以模仿。 硬件售卖今年硬件售卖的成绩还是可以的，爆品斑马思维机累计做到了 30 多万台的销量和 2 个亿的销售额。我们也走出了一条以直播为主渠道，与达人深度合作，带动天猫、京东销量的售卖方式。 海外售卖今年斑马思维机和斑马口算机都出口到了韩国，出海的工作真的挺难的，现在只能说还在投石问路，积累认知的阶段。希望 24 年有所产出。 二、读书和写作2.1 读书今年读了以下 8 本书： 消费产品的从 0 到 1 - 读《详谈吴骏》 读《第一性原理》 米其林收割机 - 读《详谈张勇》 用营销来建立领先势能 - 读《详谈杨浩涌》 现实的世界 - 读《我在北京送快递》 读《华与华方法》 读《价值为纲》 理解经济阶段-读《被追赶的经济体》 我个人比较喜欢的是《华与华方法》和《被追赶的经济体》，前者对如何做公司做品牌都有一些启发，后者对理解国内外的经济发展有很大帮助。 2.2 写作今年除了读书以外，写作上也有一些产出。 首先我把之前管斑马供应链的一些想法整理出来，写了 10 篇供应链笔记，分别是： 供应链笔记 (1)：如何挑选供应商 供应链笔记 (2)：如何降本 供应链笔记 (3)：挑选供应商的核心因素 供应链笔记 (4)：如何防止腐败 供应链笔记 (5)：注塑成本估算 供应链笔记 (6)：计划岗位 供应链笔记 (7)：什么时候自己投资建厂 供应链笔记 (8)：印刷的环节和成本 供应链笔记 (9)：开源岗位 供应链笔记 (10)：采购岗位 另外，今年 9 月，我在个人微信公众号 “ 唐巧 “ 写了一篇 《为承德程序员发声》 的文章，当天阅读量超过了 50 万次。这是我生平中第一次写出 10w+ 阅读量的文章。其实当时网上有很多相关的文章发表，我的文章从标题到内容都很克制，但是却被广为转发，这让我自己也感觉到奇怪，因为一般都是标题党和偏激的文章会更容易被转发。归因起来，我觉得有以下两个原因： 我的粉丝大多是互联网行业从业者，收入偏高，更加理性客观，对标题党一类的文章有天然的判断力和排斥感 该文章的标题是一个祈使句，转发非常容易被用来代表自己对该行为赞同 但无论如何，我在那天早上花半小时写出来的这篇文章，完全没有任何对它能够传播起来的预期，说明我在这方面的判断力还是不够的。 三、理财今年整体都是亏损的。 中证 500 指数增强，中证 1000 指数增强，元胜的 CTA 都是亏损，这部分亏损 10% 左右。 海外方面，我主要买的波司登和腾讯，整体也有 20% 左右的亏损。 医药方面，建平远航今年也是亏损的，估计有 20% 左右。 之前少配的一点点工银瑞幸债券略有收益，收益大概 3% 左右。 中低风险的理财也略有收益，收益大概 2.7% 左右。 中国的经济环境今年不太好，私人企业和 A 股的股民都缺乏信心，最大的担心就是政府的监管。所以能挣钱的业务（比如直播行业）就赶紧挣钱，相对短视，没什么长线的储备和规划；不挣钱的业务就裁员，想办法活下去。政府呢，一方面出台各种利好，一方面对言论大加管制，我认为是进一步让大家紧张了。一个宽松的营商环境是应该让大家可以随便说话的，连说话都随时担心被管，那就更别说做事情了。 我猜想了一下 24 年的中国经济。我认为政府主导还是经济增长的核心，这里面涉及增发货币和刺激经济的问题。大概率还是会从一些基建和新兴产业的建设入手，如果落地，未来中国会经历一波通胀。所以思前想后，我打算配置一些美元资产，以分散一点国内的风险。国家有外汇管制，所以看起来国内的 QDII 类的基金（比如 513500）是不错的考虑。现在标普 500 是历史最高点，所以只能定投来稍微降低一点建仓风险。 黄金一直是我自己想配置的资产，但是一直犹豫，结果今年黄金大涨，现在进场又不是好时候了。反思下来，一方面是自己对黄金相关的标的研究不足，不太有判断力持有哪种资产。另一方面是自己对黄金是否应该持有犹豫不决，所以受旁人的干扰比较大，定力太小。 四、演讲今年回师大做了四场关于职场能力进阶的演讲，分别是： 第一性原理思考：解决问题的框架 理解工作：互联网公司的组织架构和文化 找到好工作：准备简历和面试 产品的 MVP：互联网产品的创新过程 演讲对我来说其实是一种变化，让我能够接触到很多新鲜的人和事，希望每年都有机会挑战一下自己。 五、23 年的目标回顾 工作上，23 年初定下的目标是希望提升自己的业务判断力和人员判断力。今年多多少少有一点进步吧，我发现上下对不齐的话团队不会长久。 理财上，23 年希望的是不折腾。今年整体确实没有折腾。唯一失败的就是没有配置一点黄金。 读书上，一共读了 8 本，完成了 6 本书的读书目标。 运动上，因为经常出差，游泳在下半年基本就断掉了，还是没能坚持下来。 六、24 年的目标 工作： 销售：搭建好销售团队，带好团队的核心成员。培养有共同价值观和长久共事意愿的同事。 产品：推进硬件产品的创新尝试。 理财： 定投少量标普 500，建立初始仓位。 在合适的时候减少 A 股的指数增强仓位。 个人： 读 6 本书。 很久没出国了，想抽空去一趟加拿大。 每月游泳一次。 积极乐观。 七、个人 Milestone 硬件售卖销售额超过了 2 亿。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"理解经济阶段-读《被追赶的经济体》","slug":"the-age-of-country-chasing","date":"2023-12-31T12:54:29.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/31/the-age-of-country-chasing/","permalink":"https://blog.devtang.com/2023/12/31/the-age-of-country-chasing/","excerpt":"","text":"一、序言最近读完了中信出版社的《被追赶的经济体》，作者是辜朝明。辜朝明日本野村综合研究所的首席经济学家，也曾经在美国纽约联储银行担任经济学家。 作为一名经济学的非专业人士，我既从本书中收获了不少基础经济学知识，又学到了辜朝明开创的按照经济发展阶段来分析问题的底层框架。 以下是我的一些读书笔记。 二、经济发展的 3 个阶段作者根据经济体工业化程度的不同，将经济发展划分为三个阶段（如下图）： 城镇化阶段 黄金时代 被追赶的阶段 图中的刘易斯拐点是指：经济增长的需求扩大，导致来自农村的农民工和其他的非熟练工人的供应不足，从而使得农民工的工资大幅度上升的情况。 2.1 城镇化阶段在城镇化阶段，农村拥有大量剩余劳动力，由于劳动力供应充足，所以工人的工资非常低廉。由于人力成本低，所以需要人力的加工生产品在市场上具备价格优势。 这个阶段资本家利润丰厚，他们会将利润再投资以扩大生产。所以投资能够拉动经济快速增长。 1978 年的中国就处于这个阶段。那个时候改革开放，引入投资，利用劳动力充足优势迅速发展经济。 这个阶段贫富差距扩大，因为资本家挣得多，工人工资低，消费低迷。 2.2 黄金时代在黄金时代，随着城镇化的基本完成，资本也扩张到了一个拐点：劳动力与生产力需求匹配，不再有大量剩余劳动力。 这个时候工人工资开始快速增长，收入不平等问题开始自我纠正。收入差距缩小。随着工人收入增加，消费也开始增长。 美国的黄金 60 年代（golden sixties）就是指这个阶段。 2.3 被追赶的阶段黄金时代不会永远持续。当工人工资到达一个顶点后，其他国家的劳动力优势开始显现，这个时候就会有工厂把生产转移到别的国家。 随着国内的投资减少，被追赶的经济体经济增速放缓。投资减少意味着借款需求减少。家庭为了应对风险开始储蓄。 便宜的进口产品增加、工资增速放缓使得商品价格稳定，通胀率下降。借款需求减少导致利率不高。 在这个时代，收入不平等问题加剧。因为只有创新者才能有收入增长，底层的普通工人不再能享受以前时代增长的红利了。 如下图所示，美国的 5% 最高收入 / 20% 底部收入 的占比在 1970 年后显著上升。 从美国的工资增长率（下图）来看，也能显著看出，在黄金时代，穷人工资增长快；在被追赶的时代，富人的工资增长更快。 三、借贷关系的 4 种情形在上面提到的 3 个阶段基础上，作者提出了借贷关系的 4 种情形： 出借人和借款人都很充足 出借人 &lt; 借款人，即使利率很高 出借人 &gt; 借款人，即使利率很低 出借人和借款人同时很少 作者提出这样的观点源自传统观念认为借款人始终存在。但是在情况 3 和情况 4 中，借款人都变少了，因为： 借款人可能已经背负了较多债务，不愿再借钱了 国内没有比较好的投资机会 四、经济刺激方式和效果政府刺激经济可以是： 货币政策：央行通过货币政策，为市场注入更多钱。货币政策包括利率、存款准备金等。 财政政策：政府部门主导基础设施建设。 分经济阶段来对比效果： 在城镇化阶段，财政政策比较有效。 在黄金时代，货币政策比较有效，财政政策如果推高了银行的借款利率，则会有挤出私人投资的可能。 在被追赶的时代，因为没有借款人，货币政策无效，财政政策因为没有挤出效应，因此比较有效。 五、如何应对被追赶的时代作者提出了 3 个具体的办法。 5.1 保持财政政策，避免经济通缩政府在这个时代应该充当借款人的角色，提高自己的债务上限，借款推动基础设施建设，以免经济衰退。 5.2 推进产业升级和创新，用高质量发展来提升国际竞争力在被追赶的时代，国家已经没有廉价劳动力可以和其他发展中国家拼价格。所以，我们需要推进产业升级，用自动化来代替人力，降低成本。 我们也可以升级产品，给产品带来更高的技术壁垒。国家发展专精特新企业，就是在做这样的事情。 推动创新需要营造一个自由的创新氛围，这方面美国是全球的榜样。 5.3 改善教育，通过提升个人技能来提升整体生产力书中提到，通过对比一个国际巡游的马戏团雇佣当地布展的工人工作效率，作者发现日本工人的效率是欧洲工人的两倍。这种效率最终会体现到产品或服务的竞争力上。 改善教育，就是让教育回归到与社会生产真正挂钩的技能本身。避免学校学的和社会需求脱节。这方面需要教育部门与时俱进地改进教学大纲，教材和激励老师讲好课。 我当年在北京师范大学读本科和研究生，这里面的老师按理说都很厉害，但我发现有一半左右的课听起来索然无味，可能是老师的考核主要是科研而不是授课。而大部分科研课题，因为太过前沿，与社会实践都是脱节的，无法商业化，所以并不能给学生带来有效的技能提升。 作为一个计算机专业学生，我最大的能力提升来源于： ACM&#x2F;ICPC 国际大学生编程竞赛的备赛 帮导师给北师大成人教育计算机专业授课 在 IBM 中国研发中心的实习 和寝室同学接的网站开发外包 可惜以上这些都不是每一个计算机专业毕业生的必修课。很多人毕业后只会了考试，还需要进入职场二次培训学习。 六、中国所处的阶段书中提到，即便是已经进入被追赶的时代，如果国家能够激发出新的创新产品，有效改善国际竞争力，同时人才教育能够跟上，那么国家可能再一次回到黄金时代。 书中没有写，但是我感觉到中国处于黄金时代的末期，因为我们的 GDP 一直高速增长。 现在，我们面对出口萎缩、房地产调整、创新环境不够自由的问题，如果可以通过财政政策、鼓励创新、大力发展高质量教育找到新的增长点的话，我们将继续高速增长。 这是一本非常好的书，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"供应链笔记(10)：采购岗位","slug":"supply-chain-10","date":"2023-12-18T02:38:41.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/12/18/supply-chain-10/","permalink":"https://blog.devtang.com/2023/12/18/supply-chain-10/","excerpt":"","text":"一、采购的岗位职责采购岗位在供应链交付过程中至关重要。因为涉及采购款项的谈判和支付，通常采购是对供应商有极高话语权的人。 采购的主要职责是： 对合格的供应商发起采购项目的询价，比价和议价，为最终的价格合理性负责。 对供应商的生产交付负责，通过和供应商紧密沟通，解决生产过程中面临的各种问题，保障产品的按时交付。 二、采购的工作挑战采购岗位需要兼顾价格和交付双重目标，在保证交付的同时，让价格也在合理的区间内。这其实是挺有挑战的事情。 2.1 绩效普通的采购绩效普通的采购，只是按程序执行完三方比价，就合规地完成了价格的获得。又通过限制供应商的交货时间，达成交付目标。 这样的采购，虽然做事程序合规，但是获得的价格可能并不合理。又因为对供应商和生产不了解，所以虽然硬性规定了交货时间，但是对交付的达成率并没有风险预估能力。 通常这样的采购也很难在出问题后提供解决方案，帮助业务达成交付目标。 2.2 绩效优秀的采购绩效优秀的采购，会钻研价格的构成。通过拆分报价和行业研究，获得报价目标的真实价格范围。又通过对投标公司的实地考察、深入了解，获得投标公司对报价产品的生产交付能力。 优秀的采购能够真正交付合理的价格，而不只是合规的价格。为了研究清楚价格构成，优秀的采购会研究原料，工序，机台工时，损耗，人工等成本项，对BOM的成本范围做到了然于胸。在拿到报价表之后，优秀的采购能够指出价格中不合理之处，通过谈判再配合多方竞争让报价降低到合理范围。 优秀的采购会研究供应商的生产现场，通过询问生产环节的工人工作细节来判断供应商的生产管理执行情况。通过了解供应商的一线产线情况，对供应商的交付能力，订单饱和度，对我们的重视程度等各种因素产生立体的判断，从而对交付负责。 三、采购的任职要求采购岗位的主要要求是： 对目标采购品类有足够的专业度。 对目标采购品类的供应商生态有足够多的经验。 优秀的沟通能力，能够对内达成与其他岗位协同配合，对外达成商务谈判。 廉洁自律。 四、采购与其他岗位的配合采购需要与以下岗位配合： 开源。采购需要从开源同事手中接纳新的供应商资源，利用自己的专业能力把新的供应商能力摸清楚，配合好新供应商的导入工作。 质量。采购需要理解质量工程师对于目标产品的质量要求，保证供应商能够交付达成该要求。 项目经理。采购需要配合项目经理，在目标排期内完成交付目标。 产品经理。采购需要配合好研发环节，支持产品经理在研发过程中的打样和询比价需求。同时在研发过程中逐步建立对自研产品的核心物料成本的理解。 五、如何判断采购的工作能力判断采购的工作能力，可以主要从以下几方面来入手： 1、看看采购能否详细描述出研发产品的价格构成，以及BOM表中关键元器件的价格评估过程。 2、看看采购能否详细描述出研发产品的供应商列表，以及每一个供应商能力的优缺点，匹配度。配合案例来充分证明自己的观点。 3、咨询外部供应商和内部协同同事对采购的评价和打分情况。配合案例来判断采购的沟通能力。 4、采购过程不会一帆风顺。通过观察采购在关键报价环节的议价表现来判断采购的议价沟通能力。通过观察采购在交付遇到风险时的解决方案提出能力，评估采购的交付达成能力。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(9)：开源岗位","slug":"supply-chain-9","date":"2023-12-17T02:34:12.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/17/supply-chain-9/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-9/","excerpt":"","text":"一、开源的工作定义开源的工作主要包括： 为业务寻找合格的物料供应商 为物料的初始价格进行商务谈判，保证价格在合理范围内 为新供应商的顺利引入努力，包括核对相关的资质，对接打样，生产周期 供应商成功引入后，将供应商顺利交接给采购 二、开源的工作挑战2.1 开源的工作挑战一：寻找到足够多的合格供应商供应链的价格合理，供应安全都建立在足够的合格供应商库中，如果合格供应商不足（例如只有单一供应商），那么就可能会出现： 价格不合理。供应商如果找个借口坐地起价，为了保证供应安全，你很多时候在没有合适替代品的下，在权衡利弊之后，也可能忍痛短时间接受涨价。 标准打折扣。供应商生产的商品有轻微瑕疵。为了保证供应安全，你只能被迫允收。 交付延期。供应商可能延期交货，对此你无法有效监管和惩罚。 对于一个采购品，如果我们有多个合格供应商，那么我们即便对这个采购品的价格分析不够深入，我们也可以靠简单地多方竞争报价的方式，让供应商的价格回归到一个正常的合理水平。 2.2 开源的工作挑战二：保证合格供应商来源的丰富性多个合格供应商如果背后串通，那么在价格上就会产生围标行为，这对供应链来说是灾难性的。所以开源需要定期从不同的源头来寻找新的合格供应商，以保证合格供应商池的丰富度和新鲜度。 只有在源头上保证供应商的不断引入，才能有效减少围标行为的产生。为此，斑马供应链要求对于年采购额大于 1000 万的品，每年都要争取开新的供应商源，用小批量的试产和议价，保证价格的合理性和供应的安全性。 2.3 开源的工作挑战三：保持廉洁开源岗位很大程度上决定了引入哪些供应商，如果和供应商串通，对供应链影响极大。 除了在制度上要求开源来源的丰富性、引入供应商管理复核、多个开源岗位相互轮岗外，我们也要在各种环节引入内审的监督机制，定期督查供应商引入的细节，维持廉洁管理的压力。 三、开源岗位的要求从事开源岗位需要具备如下素质： 廉洁。能够抵挡住诱惑。 积极主动。主动解决问题。 优秀的沟通技巧。能够促成双赢的合作。 专业的领域知识。能够有效评价供应商的能力。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记 (8)：印刷的环节和成本","slug":"supply-chain-8","date":"2023-12-17T01:38:16.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/17/supply-chain-8/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-8/","excerpt":"","text":"一、序言印刷品的用处非常普遍，基本上各种产品都需要配套一些印刷品作为说明书或者教程。所以我们有必要了解印刷品的生产工艺和价格。 下面我先介绍一下印刷的生产环节。 二、印刷的环节印刷的环节通常包括以下项目。 2.1 准备印刷文件将客户给的印刷资料进行转码，检查字体有无缺失，对内容物进行拼版等。这个步骤通常使用印厂的专业软件完成。 2.2 制版印刷的原理是将油墨涂到底版上，然后底版再像 “盖印章” 那样把油墨转印到纸张上。 所以，印刷前需要制作用于印刷的底版。这种版都是一次性的，所以如果一次印刷量大，摊薄下来的制版费就便宜。另外，每种颜色需要一种版，四色印刷（CMYK）就需要制四个版。 一张版的制作成本大概在 50 块钱左右。通常印厂的含税含利润报价在 70 以上。 制版的机器通常不太贵，在几十万这个价格范围。 制版的速度通常很快，一张版制完大概在 10 分钟左右，所以制版一般不是生产瓶颈。 2.3 印刷印刷前其实一般还需要对纸张进行裁切，因为纸厂出厂的纸一般都是全开的，但是印刷机一般只能印半开。切好之后就可以印刷了。 印刷的机器分为双面印刷机和单面印刷机，像 4 色双面印刷机一次可以装 8 张版，完成半开纸双面的印刷工作。 印刷机的速度可以调到很高，一小时快的可以印 1 万张，慢的也能印 5 千张。 2.4 过油 &#x2F; 覆膜对印刷完的纸张，一般为了保护油墨不被划伤，可能还会增加过油或覆膜的工艺。这些工艺通常在一个起订量的基础上，按张数算钱。 2.5 折页折页是将印刷好的一大张纸不断对折，变成目标大小。我们有时候可以在书的背面看到 16 开，其实就是指把全开的纸折 4 次，2^4&#x3D;16。这种折页操作由专门的折页机来完成。 折页机的速度也非常快，每秒折 3 次非常常见。 2.6 配页 &#x2F; 锁线配页指将多个折好的折页重叠到一起。 锁线指将多个折好的折页用线缝到一起。 对应有相应的配页机器和锁线机器。 2.7 装订装订一般分为骑马钉和锁线胶钉两种。大部分图书都是胶钉的。一些页数比较少的图书或者宣传册会选择用骑钉。 斑马阅读和英语的绘本因为比较薄，就选择的是骑马订的装订方式。 胶钉是在书脊涂上胶水，再粘上封面。因为胶水需要时间干，所以一般都需要一个稍长的传送带，让书籍在传送带上稍微多待一会儿，保证胶水干掉。 2.8 切成品和打包图书在生产的最后环节是切掉四周的多余部分，这样使得折页的一些压痕处被彻底切开，保证书页之间没有粘连。 在产线的最后一般是打包。工人将生产好的图书打成小包，以便于运输。 三、成本的估算虽然印刷的环节很多，但是每个环节一般都有相关的标准价格，业内俗称 “工价”。我们拿到一个印刷需求后，根据工序拆分带入相应的工价就可以算出来费用。 另外，我们还需要计算纸张的费用。纸张的价格也是可以通过一些公开渠道查询到。纸张的价格有一定的周期性，现在价格在 6000 一吨左右。但疫情期间，白卡纸最高涨到过 1 万多一吨。 估算一个印刷品纸张的成本最好的办法就是拿个食品秤称一下。拿我之前看的这本《置身事内》书来举例，它大概 500g 重，胶版纸大概 6000 一吨（合 0.006 一克） 那么这本书的纸张费用就是：0.006＊500 = 3 块钱。 怎么估算工序的费用呢？详细算工价太麻烦了，我习惯的办法是把我们以前类似的产品工价与纸张的成本比例看一看，然后快速估算。 比如我们以前生产过的一本书，工价和纸张的比值是 1 比 1。那么就可以快速估算《置身事内》这本书整体成本就是 6 块。 四、小结印刷品的生产包括准备印刷文件、制版、印刷、折页、装订等环节。其生产成本主要包括纸张成本和印刷工费。 估算成本的最简单办法是通过称重 + 通过历史经验数据来预估工费比例来快速获得成本范围。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(7)：什么时候自己投资建厂","slug":"supply-chain-7","date":"2023-12-17T01:36:55.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/17/supply-chain-7/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-7/","excerpt":"","text":"在行业内，有一些品牌方会自己持股工厂或者投资建厂。比如咱们的兄弟公司粉笔就有自己的印厂。听闻喜马拉雅和火火兔也有自己的工厂。但大部分品牌方都没有这方面的投入。 那什么情况下才需要自己投资建厂呢，我想了几种情况。 1、目标工厂稀缺目标工厂稀缺有可能是： 相关的制造工艺复杂，比如特斯拉就只能自建工厂。 需求旺盛导致产能扩充不足。比如元气森林的需求旺盛和竞争导致相关第三方工厂无法完成生产任务。 技术壁垒。竞争对手把控了相关工厂并且对外的报价很高或者拒绝提供对外服务。 对于玩教具来说，大部分时候以上情况都不适用。 2、整合有助于大幅提升利润有些时候，工厂由于配合度或信任度等原因，无法进行深度整合。这个时候用自己的工厂，就可以因为整合带来效率提升，进而贡献出更多利润。 比如：一般的印厂因为业务多样性，为了应对印制任务的变化，通常印刷、折页、装订都是在不同的生产区域。这样便于灵活调配产能。但是粉笔因为自己的印刷品比较单一，就可以通过优化整个产线来设计一个虽然不通用，但是针对特别一类的印刷品效率更高的产线。 在评估利润增幅时，我直观感觉，如果投资工厂能够在 23 年内回本（年投资回报率33%50%），就可以考虑。如果需要 5 年甚至更长时间才能回本，则不那么划算。 除了以上两种情况外，单纯为了更多利润而投资工厂可能带来一些问题。比如： 自己的产能波动可能无法让自己的工厂跑满，带来闲置损失。 工厂由于客户单一且稳定，造成缺乏竞争力。最终可能因为缺乏竞争而管理不足，造成用自己的工厂反而成本更高。 业务&#x2F;产品调整对工厂会带来连锁成本，造成调整成本变高。 所以，除非有信心自己的产品在未来几年销量稳定并且能够管理好工厂的效率，否则不应该自己投资工厂。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(6)：计划岗位","slug":"supply-chain-6","date":"2023-12-17T01:34:56.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/17/supply-chain-6/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-6/","excerpt":"","text":"总结一下供应链的团队构成，今天这篇是计划岗位。 一、计划的工作定义供应链计划是供应链的大脑，他向上与公司的销售部门沟通，根据销售部门的活动规划以及过往的历史销量数据，做未来一定时间的销售量预估，然后在这个基础上，生成供应链的采购申请（PR:Purchase Request）。 采购申请通常包含需要采购的一级物料的数量、交期、以及交付的地点。但并没有指定从哪个供应商处采购，通常计划同事也不知道价格。 采购申请交给采购后，采购岗位通过物料拆解、分单、以及询比议价，将采购申请落实到具体的供应商，也将采购价格确立，将采购申请（PR）转换成了具体的采购订单（PO:Purchase Order），形成对供应商的采购合同。 二、计划的工作挑战供应链计划工作在具体实操时，需要考虑以下几个供应链的变量： 生产提前期。 安全库存量。 消耗预测。 2.1 生产提前期生产提前期是供应链计划的第一个挑战。 我们假设某个商品的生产提前期非常短，只需要几个小时。那么我们就可以在每天晚上预测明天的销量，然后下单，明天商品就可以生产好等着售卖。 但大部分时候，生产一个商品的时间远远超过几个小时，因为供应商需要备料，生产，送货，同时在生产繁忙的时候，供应商可能需要排产，以保证产线有较高的利用率。就常见的印刷品和采购品来说，生产提前期都超过 2 周。 生产提前期使得你需要提前很长时间，就开始为未来的需求下订单。你需要计划好这一切，否则当你发现仓库没有货物可用的时候，你是无论如何也无法短期内补上货，只能承受长达生产周期天数的缺货。这意味着：如果某个品生产周期是2个月，那你就会连续缺货2个月，这对业务的影响常常是致命的。 每一个计划同学都需要至少以周为单位核对他负责的每一个 SKU 的生产提前期，规划好入库时间，为生产做好足够的时间储备。 2.2 安全库存量安全库存是用来应对售卖波动的一个供应量策略。 我们还是简化模型来举例，假设我开了一个包子店。我每天晚上预测第二天的销量，然后提前准备好包子第二天销售。假如我预测明天的销量是 1000，然后我也按 1000 的量来备货。那么在这种情况下，如果第二天有 1200 人想买包子，我就只能对那多出来的 200 人缺货。这种情况下，销售的预测向上波动只能是 0%。 但如果我多备 200 个包子，那么我就可以支持 20% 的预测波动。 如果包子的保质期长一些，卖不掉的不用扔掉，可以继续用，那我可以每天稍微多备一点来应对销量的增加，这部分多备的货就叫“安全库存”。 安全库存量在不同的业务场景下，实施策略完全不一样： 对于刚刚提到的包子这种食品，保质期很短。所以我通常情况下不会备安全库存，这个时候，我相当于愿意承担一些缺货，来减少库存的报废。类似的产品包括：一些季节性的商品，比如过年礼盒装的商品，卖不掉很难处理。 有一些产品，保质期比较长的，我可能会愿意稍微多备一点，反正卖不掉我也可以第二天继续卖。 斑马的随材产品，本质上是课程交付的一环，如果随材缺货的话，用户可能就放弃购课了，这种情况下对我的业务影响很大，那我就会愿意备更多的安全库存。 斑马现在日常情况下是备了 X 周的安全库存量。在疫情期间，为了做多仓储备，斑马甚至会备 2*X周的安全库存，以保证供应的安全。 增加安全库存量，会给业务增加如下的风险： 消耗仓储资金。拿纸张来举例，纸张每存放一个月，就会消耗其货值的 1% 左右的仓储资金。一些更占体积的产品（例如天地盖形式的包装盒），因为内部中空，所以占用的面积非常大，一般情况下存放超过半年，其货值就与仓储租金相当了。 变质风险。一些产品存放久了，品质会变化。例如包装盒的颜色会因为光照的氧化而变浅，带有电池的产品有概率会漏液或者没电，纸张类产品可能会受潮起翘或长霉。 内容迭代风险。互联网公司对于产品的调整总是比较快的，供应链随材如果生产过多，就可能拖慢迭代时间或者造成更多迭代的报废。 所以，一个业务到底生产多少安全库存，也需要根据业务的状态来定。 2.3 消耗预测消耗预测是计划同学工作中最重要、也是最难做好的事情。因为市场变化迅速，行业内普遍对于消耗的预测的准确性水平也不太高。对于与市场投放相关的供应链工作，如果能做到 80% 左右的准确性就算是行业顶尖水平了。 做好消耗预测，计划同学首先需要了解清楚市场部门对于预测的基础判断。对于市场部门提出的预估销量的合理性进行质疑和求证。用历史的一些预测准确性来修正自己的判断。最终制定出尽量准确的消耗预测。 通常情况下，市场部门为了保障交付+承担更高的绩效标准，会将销售目标定在一个较高的值。但是供应链计划同学如果也简单地因此把计划生产量定在一个较高的值，那么就会将供应链团队置于不利之地，最终可能因为滞销，给业务带来过多的资金或者报废。 具体在执行上，计划同事可以让销售部门填写销售预测表。通过预测表和历史业绩达成率来逐步调整预测。 在销售数据剧烈波动的阶段，计划同事可以加大计划下单频率，以便灵活应对波动。在销售数据较为准确和平稳后，计划同事可以下长周期订单，分批交货，以便通过订单量来降低采购成本。 2.4 其他物料的齐套性。计划需要考虑一个物品的各种二级子物料的生产周期限制和最小起订量限制。比如：某一个采购品包括包装盒和里面的塑料制品。采购品生产周期 20天，塑料制品生产周期 40 天，那么理论上采购品应该晚于塑料品 20 天下单，以免货物不齐套造成无法完成整件的组装。 长周期物料。某些产品的稀缺零部件生产周期特别长，如果它是可以转卖或者复用的，那么可以考虑准备长周期物料来减少生产周期。芯片，电池，机芯都是这类产品。 计划系统。复杂的计划预测还是应该交由系统来完成。不同的业务形态对计划系统的要求不一样，所以计划系统大多自研。在好的计划系统帮助下，计划同事只需要输入物料主数据，BOM，销售预测数据，系统通过读取 ERP 里面的库存和在途数据，通过计算就可以自动产生需要的新下的订单数。 三、计划岗位的要求计划工作需要两个核心能力： 1、良好的数据计算和分析能力。能够将每个 SKU 的库存、在途、消耗进展、生产提前期计算清楚，给出清晰的生产指令。 2、优秀的沟通能力。能够通过沟通判断出市场部门的销量目标达成率预期，结合历史数据做出合理的生产计划预测。 为此，逻辑思维和沟通能力是计划同事必备的品质和要求。 四、小结 定义：供应链计划是供应链的大脑，负责创建采购需求。 工作重点：供应链计划需要重点考虑的是：生产提前期、安全库存、消耗预测。 岗位要求：良好的数据分析能力和沟通能力是计划同事必备的要求。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(5)：注塑成本估算","slug":"supply-chain-5","date":"2023-12-17T01:31:57.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/17/supply-chain-5/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-5/","excerpt":"","text":"交付和价格是供应链岗位日常工作的两大重点。这一篇谈谈与价格相关的工作：注塑成本估算。 注塑的费用构成在行业内比较透明，主要包括：机台费、电费、原料费、工人工资几大部分。 一、机台费注塑机的品牌和吨位决定了注塑机的价格，我们通过注塑机的销售渠道或者二手交易网站可以查到对应型号的注塑机的价格。 我们将注塑机的价格按 5 年摊销，就可以算出每年的机台费用。假如注塑机的行业开机率 50%（即一年 180 天），拿注塑机每年的摊销除以 180 天，就可以算出来每天的机台费用。 拿一台国产的海天 35T 注塑机举例，假设售价是 20 万元，那么每天的机台费就是 200000/5/180=222.2元。如果注塑机每天工作 22 小时，那么每小时费用就是 10 元。 在计算单件费用的时候，需要考虑上成型时间。例如：某个一出一的模具，成型时间是 60 秒。那么一小时只能做 60 个。那单件的机台费就是 10/60=0.17 元。 二、电费电费的成本占比其实还不少，我们可以查阅当地的工业用电电量，再检查注塑机的功率来计算电费情况。 不同吨位注塑机功率不一样，功率范围在 2 ~ 20 千瓦的都有。 比如某地工业用电是 2 块钱一度，注塑机的功率是 4 千瓦，那么每小时的电费是 8 元。一天 22 小时（假设每天检修2小时）就是 176 元。 通过了解每件壳料的成型时间，以及模具是1出几，就可以计算单件壳料消耗的电费。 例如：某个一出一的模具，成型时间是 60 秒。那么一小时只能做 60 个。如果注塑机的功率和电费按刚刚计算的是每小时 8块。那么每件该壳料的电费就是 8/60 = 0.13 元。 电费一般都高低峰的差价，如果要精确核算可以加权计算一下全天开机的成本。 三、原料费注塑机通常使用 ABS 等原料，这些原料都有市场的吨价。我们可以通过注塑成型的壳料重量，来反推这部分的原料成本。 例如：假设 ABS 塑胶粒 2 万一吨（实际应该没那么贵，我是为了举例）。某产品注塑成型后的壳料重量为 200 克。则该产品的原料费为 20000 / 1000000 * 200 = 0.02 * 200 = 4 元。 注意：如果注塑的模具是冷流道的，那么每次注塑还会有水口料存在。计算的时候需要把水口料的重量也计算在内。 一个复杂一点的例子：假设 ABS 塑胶粒成本是 2 万一吨。某个模具是 1 出 4 的形式生产，注塑出来的单件重量为 200 克，1出4的水口料为 100 克。那么单件的原料成本是多少？计算方式就是将每件的重量核算为 200 克 + 25 克的水口，一共 225 克，然后再像上面的方式计算成本。 如果有些供应商现场发现会添加一定比例的水口料在原料中，那么相应的也要减少水口料的成本。 当然，注塑过程还会有一定比例（例如3%）的损耗，但是因为占比较小，估算分时候可以忽略。 四、工人工资根据不同产品的特点不同，有些产品需要在注塑出料位置安排工人进行处理，处理的常见步骤包括：修剪水口，外观检查，打包等等。 下图是一个例子，工人正在修剪水口和打包壳料，套袋后装入旁边的打包箱。 工人的工资可以通过打听来了解。通常深圳一带的工厂，工人工资每个月大概 6000 ~ 8000 块钱，日薪在 200 左右。所以每小时的工资在 25 元左右。工厂通常还包吃住，加上管理人员，成本应该会更高一点。 我们通过计算工人每小时能够处理的塑胶元件的数量，就可以估算出每件占用的人力成本。 注塑机的操作通常也需要懂技术的工人看管，但是一般情况下一个人可以同时看管多台。注塑机上下模具和测试的时候，也会比较耗费高级工人的精力，这部分的成本具体如何估算，要结合现场来判断。 五、利润工厂不是慈善机构，也是要赚钱的。上面的成本计算以后，一般还是需要增加 10~20% 的利润，作为工厂的毛利。 六、小结注塑成本估算包括机台费、电费、原料费、工人工资几大部分。 以上只是一个笼统的框架，不同的产品在具体估算的时候考虑重点不一样，需要具体案例具体分析。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(4)：如何防止腐败","slug":"supply-chain-4","date":"2023-12-17T01:28:31.000Z","updated":"2024-01-06T14:52:37.943Z","comments":true,"path":"2023/12/17/supply-chain-4/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-4/","excerpt":"","text":"一、序腐败是供应链管理最大的敌人之一。我常常和同事聊天时提到：供应链其实是一个“高危”行业。 因为如果自己没有坚守住廉洁的底线，或者自己作为管理者，下属没有守住廉洁的底线，后果都是非常严重的。轻则名誉扫地、罚款失业；重则锒铛入狱，断送前程。 像国内外的互联网公司里面，腐败的新闻也屡见不鲜。我们公司也是，偶尔还是会有内部通报的违规案例。 那么，作为供应链管理者，怎么保证团队是廉洁的呢？我想可以分别从文化和制度方面尝试以下一些办法。 二、文化方面文化方面，我们需要建立出一种氛围，在这种氛围下大家会默认拒绝供应商的各种宴请和礼物。如果做得好，供应商也会被我们的氛围感染，用简单的方式与我们打交道。 怎么建立这种氛围呢？我们强调几件事情： 1、所有人都不能接受供应商的礼物，不管是多少钱的东西。 2、所有人都不能接受供应商的宴请，如果非要吃饭，报备申请之后我们买单报销。 上面规则定下来之后，我们会用各种案例来多次强调它的重要性。 比如：每年都有某些新供应商不清楚我们的规则，给我们公司或者某个采购寄来礼物，我们都会直接拒收。 比如：我每次带队去供应商那里，都会直接聊工作，聊完工作就自己叫车直接离开。 每次见到供应商，我都会问：有没有同事和你们吃饭让你们买单？每次过节，我都会强调，让大家如果收到礼物一定要退回。 比如：我们会将内审同事拉入所有合作群，向供应商介绍内审同事的联系方式，欢迎他们举报违规线索。 对于那些违规的供应商，我们也会让供应商管理岗位的同事记录下来，降低供应商的配合度得分，严重违反的不再合作。同时，供应商管理同事也会定期向供应商通报我们对违规行为的惩罚。 于此同时，我们会强调工作的专业性。 比如：及时给供应商付款，严格地进行多家比价和招标，给供应商一个专业的、负责任的供应链形象。 其实供应商很多时候是不知道客户想要什么，行业内又有很多宴请和送礼的陋习，所以供应商很多时候在摸不清的情况下，就会默认按行业的那套来。 但是行业内也不乏像我们这样严格要求的供应商。比如我了解到像字节，腾讯，华为以及很多欧美的客户就和我们的行事风格很像。 当供应商摸清了我们的文化，后续我们就建立了默契。现在我们去合作多年的供应商，大家都很快进入工作讨论，讨论完也不会客套挽留我们吃饭，工作就很高效。 三、制度方面3.1 三权分立在斑马供应链，我尝试将供应商合作的关键环节放到：采购、供应商管理、开源三个岗位上。每个岗位都承担了一部分，降低了权力的集中度。 具体来说： 开源决定供应商的引入。 采购负责日常的业务沟通和执行报价、比价、议价流程。 供应商管理记录供应商的合作得分，通过分单会决定订单的分配。 对于像印刷品和包装盒这类供应商，以上机制很好地限制了各方权力。因为： 开源只能引入供应商。但是他无法影响报价和订单分配。 采购只能执行订单。无法引入新供应商，也无法决定订单的分配。 供应商管理不直接面对供应商，但通过收集交付数据，质量数据，合作规模等信息来对供应商评级和打分，然后发起季度分单会来调整订单分配。 3.2 内部审计定期的内部合规审计可以很好地帮助团队找到并改善问题。 我们内审行为会发生在日常例行的工作中，以及所有敏感岗位离职的时候。 刚开始，供应链的同事可能会比较排斥内审，因为觉得是给自己挑刺，找麻烦的岗位。但是，我反复强调内审是帮助我们合规，避免我们在这个高危行业犯错误或者被误认为有嫌疑的情况。这样大家就能很好地接受内审了。 内审唯一要避免的，就是大家为了流程合规而不考虑业务本身的执行效率和质量。所以，我倾向不要增加过于复杂的合规动作，更多通过文化和供应链产研系统来保证合规。 3.3 价格研究和岗位轮换对于某个采购员来说，他可能一辈子换很多公司，但是却一直和行业那几个供应商打交道。 因此，我们假设采购员没有腐败，在面对公司利益和供应商利益冲突的时候，如果能够给公司合理解释，那采购员更有动力维护好和供应商的关系。 所以，我们对于一些大额的采购项目，分配了价格研究专员对产品的价格组成做详细的拆解和分析，希望公司对于价格有更多了解。 另一方面，长期用固定的采购对接供应商也是有风险的。供应链内部如果有条件可以对岗位进行2年左右一次的轮换，减少采购和供应商有太复杂关系的机会。据我所知联想会有这样的机制。 四、小结避免供应链的腐败需要从文化和制度上入手。 在文化上从不收礼物，不接受宴请开始，建立起严格的行事风格，并通过反复强调来形成清廉文化。 在制度上用分权，内审，价格研究和轮岗来限制权力，减少风险。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(3)：挑选供应商的核心因素","slug":"supply-chain-3","date":"2023-12-17T01:26:22.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/12/17/supply-chain-3/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-3/","excerpt":"","text":"挑选供应商的时候，关注点有时候会很多，最近我在想：哪些因素是供应商挑选的核心？我觉得有三条：能力、价格、匹配度。 简单展开说一下。 一、能力能力是供应商的基础实力，通常包括两个方面：基础能力和优势领域。 1.1 基础能力基础能力体现在供应商的日常生产的各种细节。从生产环节来看包括：来料、SMT、注塑、后处理、组装等环节。 比如：拿来料管理来说，电子料有没有单独控温控湿，有没有上erp系统，电池有没有单独存放，都体现着供应商的来料管理能力。 从分类来看包括设备能力（物品）和 现场管理能力（人）。 比如：SMT的设备决定了pcb的基础生产质量。SMT设备的管理人员对SMT现场的各种管理，体现了实际的生产能力。 又比如注塑机的吨位和品牌决定了注塑的基础质量。注塑调机师傅的水平决定了能不能用好这台设备。现成有没有做到5S管理，有没有合理的自动化也对生产效率和质量有巨大影响。 1.2 优势领域聪明的供应商会聚焦业务，构建自己的优势领域，从而实现差异化竞争，进一步产生单一类别规模化带来的成本领先。 比如：有些供应商专注做液晶手写板，有些专注做点读笔，一个细分品类可以做到行业内前三，由于制造业需求巨大，也可以做到很大的规模。 如果某个供应商一个优势领域都没有，是比较危险的。我们应该根据自己的需求挑选这个领域的优势供应商。 二、价格价格其实是能力的一种体现，但是价格因素实在太重要，所以从决策权重来看，需要单独考虑。 两个供应商的报价差很多，能力也差很多的时候，我们要评估好能力差的那一方到底能不能达到我们的质量要求以及长远的交付要求，不能一味追求短期低价。 三、匹配度供应商的精力有限，他肯定会更加重视核心客户和潜在大单的用户。如果你的单量太小，人家看不上你的订单，那么配合度就会受影响。 挑选供应商的时候，我们要考虑后续合作对于配合度的要求，如果像新品研发这种需要较高配合度的工作，就需要加重匹配度的考量。 匹配度考量有几个角度： 份额占比。如果你的全年订单额能够占到对方的5%以上，那就算是挺重要的核心客户了。 对方发展重点。如果你的业务是对方重点发展的方向，也会有比较高的匹配度。 对接人。如果对接人是老板（公司实控人），话语权很高，那么相对容易沟通。 作为客户，我们也可以在保证有备份的基础上，集中订单到能力和价格都具备优势的供应商，通过提高采购额来构建自己比较高的客户地位，提升匹配度。 四、小结挑选供应商需要重点关注对方的能力、价格、匹配度。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(2)：如何降本","slug":"supply-chain-2","date":"2023-12-17T01:22:40.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/12/17/supply-chain-2/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-2/","excerpt":"","text":"一、序之前管过供应链，分享一些我的思考。这是第 2 篇：如何在供应链降本。 大体上：供应链降本分为变更 BOM 和不变 BOM 两类（注：BOM指生产目标产品的物料清单）。 二、变更 BOM如果我们可以变更 BOM，供应链可以在满足功能和性能要求的情况下，考虑寻找更便宜的替代方案。 要做好这一点，首先需要理解上游的产品需求是什么和质量标准为什么那么设立。然后就可以找理解之后找供应链可能的降本方案了。 举一个例子：我们有一个内容物的包装袋，主要使用在产品包装盒里面。在包装盒里面意味着不容易被磨损和撕扯。在这种背景下，我们发现这个袋子材料如果薄一点可以降很多成本，那么就可以降低袋子厚度来降本。 第二个例子：我们有个产品最初底部的塑料壳很厚，这消耗了很多ABS原料。后来我们发现，如果把这个壳做薄一点，适当再加一些支撑筋，也可以达成类似的强度要求，这样就达成了降本。 第三个例子：我们某个产品用了某个带 WiFi 功能的主控，后来我们发现用另外一个品牌的主控性能差不多，价格却可以便宜很多，这也就达成了降本。 变更 BOM 的降本需要注意不能影响用户体验，所以降本的核心工作是评估替代物料能否达成我们要求的用户体验标准。 为了控制风险，我们可以使用小批量切换的方式来先做测试，保证用户体验不受影响。 三、不变 BOM不变 BOM 的降本不能改变产品的原料，所以我们只能从多个供应商、原料的价格、产线的优化、规模化等方式来降本。 3.0 多个供应商引入多个供应商，可以让一供和二供在价格上相互制衡，从而长期保证价格是相对公允的。 3.1 原料价格降本控制核心原料价格是第一个可以尝试降本方案。我们可以将生产的核心原材料采购部分拆分，引入多个供应商参与竞价，通过充分竞争让原料价格保持在一个非暴利的状态。 应用这种方式，首先需要我们有一定的采购规模，否则供应商可能看不上我们的招标。 另外，因为我们需要参与原料的管控，这对供应链的管理提出了更高的要求，我们需要借助合理的 erp、wms、srm 系统来管控原料的采购和记录原料消耗，否则很容易账目混乱。 我们在纸张采购上就用这种方式来降本。 3.2 产线优化制造业的现场总是有无数的可改进细节。丰田的 TPS 就是一整套产线优化的方案，见： 构建精益生产的企业 - 读《漫画丰田生产方式》。 其中的 U 型产线，及时生产、均衡化等都是有效配置人力资源，降低单件产品生产成本的有效方法。 一些小的制具也可以有效降低组装难度，提升良率。 产线优化的最大敌人还是规模。拿一般的玩教具来说，常见的一条组装线一天的产能通常都可以做到 2000 左右件成品，这样一个月就可以完成 6 万件成本，一年 72 万件。但是，一个年销量超过 50 万件的玩教具产品其实不那么容易做到。 所以，产线在规模不够的时候，暂停是常态，那相应的恢复成本就必须承担。 在这一点上，我见过做得很好的是一家兄弟公司印刷厂生产线。因为这个印厂的产品相似度很高，负责人通过将配料、锁线、上胶、风干、打包环节组合在一个 S 型的产线上，非常高效地完成了整个生产过程，避免了原料的多次转移。 3.3 规模化降本如果你能够比较好的预测未来的消耗，那么你就可以一定程度上通过规模化降本。 如果消耗是 100% 确定会发生的，你可以提前一年将订单下出，让供应商用工厂的闲置时间来生产。 例如：巧虎的用户因为是年度订阅用户，所以他们就可以提前预测下一年的大部分订单。很多供应商利用年底等生产淡季来排产巧虎的订单，这样可以保证自己工厂的工人和机器能够持续有活干。相应的，工厂会给巧虎一个好价格。 如果你不那么确定自己未来的消耗，你也可以通过同步自己的销售预测，让供应商提前一次性采购和储备通用物料。这种上规模化采购也有助于将原材料的价格谈下来。 3.4 价格分析降本有些时候供应商的报价虚高，但是受限于规模，我们也不可能短时间引入二供来竞争，这个时候可以尝试做价格分析降本。 价格分析降本主要是通过 BOM 拆解和组装环节分析，找到同供应商 argue 价格的合理诉求。供应商也是需要解释他挣得是合理利润，如果解释不通，采购通常就相对容易把价格谈下来。 BOM 拆解的常见技巧有： 通过比对多个供应商的报价，找出偏高的部分，进行谈判突破。 去 1688 或者一些行业网站上搜索原材料价格。 组装环节成本分析最有效的方法就是把整个组装的工序录像下来，计算单件的组装时间，然后通过当地的工人小时工资来核算组装费用。 比如：某个产品我们发现需要 10 个工人组装 1 分钟，同时当地的工人每小时工资为 20 块钱。那么单件产品的组装费用就是 20*10/60=3.33元。 四、小结供应链降本包括不变 BOM 和变更 BOM 两大类方式。 对于变更 BOM 方式，我们主要在保证用户体验不变的情况下做原料的变更。 对于变更 BOM 方式，我们可以尝试多个供应商、原料的价格、产线的优化、规模化、价格分析等方式来降本。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"供应链笔记(1)：如何挑选供应商","slug":"supply-chain-1","date":"2023-12-17T01:20:34.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/12/17/supply-chain-1/","permalink":"https://blog.devtang.com/2023/12/17/supply-chain-1/","excerpt":"","text":"一、序之前管过供应链，分享一些我的思考。 这是第 1 篇：如何挑选供应商 挑选供应商之前需要先开源和引入供应商，所以我们先从开源说起。 二、开源开源供应商的办法有很多：朋友推荐、网上搜索、查目标产品包装上的生产厂家等。总之，你很容易就可以找到很多候选的供应商，然后你就可以进行下一步的拜访了。 三、拜访拜访供应商我喜欢观察他们的生产产线，基本上管理到不到位一下子就可以看出来。即便是很小规模，优秀的供应商的产线也会是整洁有序的。 供应商的设备也体现出他们的实力。注塑机的吨位和品牌决定了供应商花了多少钱投在设备上，产能上限是多少。 接下来进入今天的正题：如何挑选供应商。 四、挑选挑选供应商的最重要的原则是：匹配。 所以，苹果的供应商对你来说不一定就最好，大部分情况下，你是用不起苹果的供应商的。即使你想用，人家也不一定愿意接你的生意。 所以，根据你的产品的采购规模，去匹配合适的供应商最重要。最好是你们相互之间都看得上对方。比如：你的年采购额能够占到他年营业额的5%~20%，在这个区间内就会比较匹配。他会很在意和你的生意，你呢，也不会担心他产能不足无法完成你的订单交付。 对于年营业额在 2 亿以内的供应商，我建议只挑选那些老板亲自管理厂子的供应商。通常职业经理人在这种规模的厂里面都不太有老板的决策权力和投入度。 五、合作合作上，应该在保证供应安全的原则下，尽可能把订单相对集中。这样可以对核心供应商有较强的利益捆绑。也容易让对方产生规模效应，从而达成降本的目标。 六、小结 挑选和自己采购额匹配的供应商。 挑选老板亲自管业务的供应商。 保证供应安全的前提下，集中订单，发挥规模效应。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"}]},{"title":"读《价值为纲》","slug":"value-frist-book-summary","date":"2023-10-22T00:52:25.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/10/22/value-frist-book-summary/","permalink":"https://blog.devtang.com/2023/10/22/value-frist-book-summary/","excerpt":"","text":"最近读完了华为公司出的 《价值为纲》，书的内容比较偷懒，是摘取的华为公司的各种内部演讲、通知、培训等内容组合出来的。 我看完书感触有以下三点。 感触一：价值为纲企业存在的使命是为社会创造价值。 为了创造价值，企业应该关注于自己的核心竞争力，深挖沟，让自己在核心能力上比别人提供更大的价值。 同时，企业不应该追求短期的利润最大化，而应该追求持续创造价值。在这种价值观下，给自己留合理的利润，持续改善产品，优化工艺降低成本，这样才能获得持续的合理利润。 感触二：以项目团队作为核心的工作单元项目团队是指能够完成业务目标的全功能团队。以项目团队作为业务工作单元使得团队的信息沟通效率大大提高。 同时，各个职能在共同完成业务目标的时候，职能团队也能学会在职能专业性和业务目标之间权衡。 感触三：关注现金流华为作为制造型企业，从获得订单到生产交付，最后项目结束获得回款，其中是有一个现金流先减少后增加的过程。 如果这里面垫款太多，或者回款遇到问题，企业就可能被现金流拖死。 乐视当年倒闭，拖死了很多上游的供应商，就是因为最乐视破产后，供应商收不到钱。 要做好关注现金流，需要： 在日常的月度财务报表里面不光有收支情况，还有现金流的变化情况 在业务工作中，不光关注业绩，也要关注项目回款情况 对于吃现金流的合作方式（比如无预付的大订单，口头承诺的增长，三年回款周期等），要谨慎评估 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"为承德程序员发声","slug":"stand-up-for-programmer-from-chengde","date":"2023-09-27T01:00:32.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/09/27/stand-up-for-programmer-from-chengde/","permalink":"https://blog.devtang.com/2023/09/27/stand-up-for-programmer-from-chengde/","excerpt":"","text":"事情起因承德一位程序员因为在 GitHub 上接海外的开源项目，因为交流不方便使用了俗话称作 “fan qiang” 的软件以便访问 Google 等外网服务，被罚款 200 元，没收 3 年 “非法收入”100 多万元。 行业观点事情发生后，我身边的所有人都为该处罚表达不满情绪。部分朋友把这个归结小地方处罚不规范。 胡锡进专门发文，希望对这种社会危害性为零的远程打工挣外汇行为进行宽容。 但随后他删除了微博。 我的观点1、程序员在国内向境外输出劳动力，既赚取了外汇，又解决了自己的就业问题，而且向世界展示了中国互联网行业的全球竞争力。国家非但不应该打击，而且应该鼓励。 这是一种新形态的 “出口”。有助于中国建立更大的全球影响力。事实上，这位被罚同行的工作内容，就是从事大量被使用的开源项目的开发。参与开源项目本就是输出行业影响力的最佳方式。 2、当前并没有渠道为这一类人群的合法访问外国网络提供便利。希望相关部门能对合法的使用外网需求，建立合适的申请和监管渠道。 3、在相关规章制度完善之前，对于工作生活需要，不得已访问境外网站的。如果没有对社会产生负面影响，那么不应该处罚。对于有利于个人就业，有利于行业发展，有利于国家声誉的事情，国家应该适度鼓励并组织研究相关法规，帮助规范和健全相关经济活动。 后记本文在公众号发表后，当天阅读量超过了 50 万次，并在当天晚上 9 点左右因“违规”无法查看。 在写本文的时候，我力求情绪稳定，用中性客观的语言陈述事实和观点，不攻击不煽动不偏激，至今我也不清楚我的本条文章违反了哪条法律法规。","categories":[],"tags":[]},{"title":"读《华与华方法》","slug":"hua-and-hua-methods-book-summary","date":"2023-07-18T00:56:18.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/07/18/hua-and-hua-methods-book-summary/","permalink":"https://blog.devtang.com/2023/07/18/hua-and-hua-methods-book-summary/","excerpt":"","text":"一、序最近读完了华杉写的《华与华方法》，这是一本关于品牌营销的书，华杉始终坚持自己的价值观和方法做事情，从默默无闻到现在成为国内最具影响力的品牌咨询公司，没有之一。 华与华服务的西贝、海底捞、蜜雪冰城等案例在带火自己产品的同时，也宣传了华与华的“超级符号”品牌理念。 华与华也是一家与时俱进的公司，从疫情期间摸索做直播，到现在开始直播讲课带货，华与华始终处在积极学习、进取改变的状态，这一点很难得。 以下是我的读书感悟。 二、企业存在的价值我很同意华杉的观点：企业存在的价值不应该是挣钱。企业的存在，首先是因为有社会价值，即用户需求。首先因为用户需要某种服务，才会有相应的企业存在。 在用户需求的基础下，企业才会有自己的经营使命和战略，战略应该围绕着自己的社会价值，去更好地满足自己的社会价值，这样的企业才能活得更久。 那么如何定这样的战略呢？华杉认为：战略定位是创造一组独特的经营活动，实现三个结果：独特的价值、总成本领先和竞争对手难以模仿。 三、品牌的原理华杉介绍了品牌三大原理：社会监督原理、品牌成本原理、品牌资产原理。我比较有感触的是品牌成本原理。 品牌形象的建立过程中，有识别成本、记忆成本、阅读成本、理解成本、传播成本。而我们应该在设计品牌的时候，把这些成本尽可能降到最小。 为了降低识别成本，华与华自己的广告牌一直都是两兄弟的头像。为了降低传播成本，华与华设计了绿格子的酱油瓶，Hi 符号的海底捞。 市场上，大家为了降低记忆成本，大多用动物、植物名等来做自己的产品名，例如：天猫、雪球、斑马、瓜子，也是同样的道理。 四、传播的三大原理传播的三大原理很直白： 刺激反射原理：传播就是给顾客刺激，希望让他产生购买行为 播传原理：传播的关键在于传 信息能量原理：刺激信号的能量越强，顾客行动反射越大 结合这些原理，华杉认为广告语应该简单、直接，易于记忆和传播，品牌的核心信息应该大，广告的覆盖强度应该够大。 另外，华杉也有一个关于品牌积累的观点：华杉极力反对从互联网买流量，他认为这样不能积累起来品牌资产。因为关键词竞价和效果广告会将你的成本抬到了你刚刚能够保本的水平。而华杉认为应该做品牌资产的积累，比如他做机场的广告，每一年都比去年积累了更多的曝光，这个资产是在累进的。 五、小结《华与华方法》是一本关于品牌营销的书，总结了华与华公司在品牌营销领域关于企业、品牌和传播的方法论。由于华与华公司本身是非常成功的咨询公司，所以书中的内容有很多落地的案例，值得大家研读分享，推荐给大家~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"现实的世界 - 读《我在北京送快递》","slug":"my-19-jobs","date":"2023-06-25T02:35:03.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/06/25/my-19-jobs/","permalink":"https://blog.devtang.com/2023/06/25/my-19-jobs/","excerpt":"","text":"一、序最近读完了一本有趣的书，叫做《我在北京送快递》，作者讲述了自己经历的一共 19 份工作。 这些工作很丰富，有加油站&#x2F;宾馆&#x2F;快印店&#x2F;超市&#x2F;自行车店&#x2F;面包店服务员，有线下&#x2F;线上的服装店&#x2F;卤味店店长，当然也有在北京送快递的经历。 这本书特殊的地方在于，全文都是真实的事件，作者的文笔又还不错，所以你能够一下子体会到19种基层劳动人民的生活状态。 在感叹生活不易的同时，每个职业里面的各种潜规则和灰色部分，也让人倍感真实。 以下是一些感悟。 二、感悟2.1 加油站多收钱作者讲到一个在加油站工作的小故事：加油站的服务员对于拿加油券加油的客户，会故意多收钱，因为这些拿加油券的人花的也不是自己的钱，真的被发现了也不会太计较。 这一件小事暴露出大家对企业公共资源的浪费。 2.2 勤奋还是融入作者讲的另一个故事是在酒店：在这家实习的酒店，他因为干活比较勤快而被大家嘲笑，因为这会显得其他人不够勤快。另一方面，领班不会让大家闲着，所以干得快只会干多。为了融入团队，他也只能慢慢干。 在一个你干得好就会影响其他人的环境下，你想干得好也是不容易的。 2.3 服装店因为发现别人卖小众服装火了，他们也去找货源做同样的款式。最后又引来别的竞争者。大家为了卖货相互诋毁，甚至大打出手。为了保证周转率，每次只进货一点点，生意做得非常辛苦。 线下商业的竞争壁垒极低，大家都在模仿，一些小创新和赚钱机会很快就被竞争充分消化。到最后大家只能赚个辛苦钱。 三、总结这个世界是复杂的，学校的教科书总是把每件事情都描述得完美，而现实世界中处处都是不完美，这本书给我们讲述了一个真实的世界。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"用营销来建立领先势能 - 读《详谈杨浩涌》","slug":"interview-of-yanghy","date":"2023-04-17T12:07:40.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/04/17/interview-of-yanghy/","permalink":"https://blog.devtang.com/2023/04/17/interview-of-yanghy/","excerpt":"","text":"杨浩涌曾经创办赶集网。后来赶集网与58同城合并，杨浩涌转而离开创办了瓜子二手车。 瓜子二手车起步本来晚于人人车，但是凭借杨浩涌果断大胆的营销投入，瓜子二手车很快在二手车交易行业占据龙头位置。 本书摘录了李翔对杨浩涌的4次访谈，分别为18年4月、18年10月、20年4月、20年10月。 以下是书中比较戳到我的一些观点。 一、用规模建立领先的势能18年那个时候中国互联网经济环境还比较宽松，很多项目亏损也没关系，对于投资人来说，只要有规模并且规模还在快速增长就行。 杨浩涌抓住了这一点，通过快速营销来把自己的交易量做到了人人车的两倍。进而保证自己的估值比人人车高，手里融资的钱也比人人车多。当时瓜子靠这个策略融到了2.5亿美金。 人人车因为估值低，不能估值到10亿美金，只能估值到 3~4 亿。所以融资也没法融2.5亿美金，只能融几千万美元，这样投资人就会担心这个竞争没法玩。从而使人人车融资更困难。 杨浩涌除了看出来规模领先带来的在融资和营销上的势能外，他还看到了互联网产品大多数市场瓜分是七三或者八二分的。所以领先者后期能够吃下大部分市场份额，值得前期在竞争激烈的时候，牺牲效率和利润来换规模。 我自己在教育行业也亲身经历了一个类似的案例，就是当年拍照搜题的竞争。当年学霸君领先同行一年多时间，但是他的创始人没有意识到规模扩张的紧迫性。所以一方面没有大幅度融资，另一方面也没有大量营销，用户还是以口碑传播为主的方式在自然增长。 但是后来，小猿搜题和作业帮快速切入这个赛道，它还是没有反应过来，营销上仍然不温不火。于是，市场很快教育了它。作业帮和小猿搜题上线后以数倍于学霸君的营销费用在做增长，差不多只用了一年，学霸君的用户量就只能排在第三了。 拍照搜题这个市场用户量其实非常大，全市场的所有类似App日活加起来能到2000万。学霸君由于自己在营销上的失误错失了这个赛道的领导地位。 二、销售的淡旺季问题杨浩涌提到瓜子二手车的销售淡旺季问题：“旺季是第四季度，6月份是最低点，然后慢慢往上跑。旺季交易量大概是淡季的两倍”。 我发现很多实物产品都有这样的类似情况。比如小天才电话手表，旺季的销量也是淡季的两倍。又比如链家的房屋交易也存在淡旺季。 斑马玩教具现在没有全年的整体数据，但是我感觉大概率销量也是集中在开学季和第四季度（因为第四季度有双11）。 淡旺季的存在使得我们需要关注工厂产能的均衡，市场投放的倾斜度，线下店销售的激励等各种问题。 杨浩涌在书中提到链家围绕房屋销售的淡旺季设计了一整套激励方案，用于保证团队成员的稳定性。如果未来有机会，我很想更深入研究这方面的生产关系构建方案。 三、终局视角和用户视角杨浩涌在书中提到了终局视角和用户视角，这两个也是经常被同事提起的思考问题的角度。 一个事情想不明白，就可以这么问问自己： 这个事情未来过5年10年会是什么样的 这个事情对用户到底产生了什么价值 一些犹豫的问题就会容易想清楚。 四、直播对电商的影响在20年4月的采访里面，杨浩涌就提到了直播对于电商行业的影响。 他认为传统的电商是“商场”，没有导购，你买完东西就走了。直播电商更像步行街，你在逛的时候，因为外界的影响，就买了很多原本没有打算买的东西。 直播将购物的触点改变了，就会带了新的变化。 杨浩涌在书里面主要讲到直播对传统行业的冲击，但是其实我认为因为直播主要阵地是抖音，所以对淘宝、京东的冲击也很大，对美团的冲击也很大。 用刚刚的终局视角来看，可以预见几年之后 TikTok 一类的直播电商对亚马逊在海外的市场同样会带来巨大冲击。 五、营销和产品的关系杨浩涌是营销高手，他在书中讲了他对产品和营销的关系的理解，再一次让我对产品的重要性产生确认。 杨浩涌觉得好的产品是营销的基础。如果你产品不好，好的营销就会让自己死得很快。 我想这方面的反面案例可以是 iEnglish 和宝宝玩英语。他们都通过优秀的营销短期积累了大量用户，但是由于产品不够好，最终都没能留住用户。 好的产品有了，营销也是需要好好做的，不是让产品自己传播就可以的。因为你如果做不好营销，就会被竞争对手甩在后面。 这方面的反面案例可以是学霸君和人人车，生生丢掉了自己的领先地位。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"米其林收割机 - 读《详谈张勇》","slug":"interview-of-zhang-yong","date":"2023-03-15T11:58:39.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/03/15/interview-of-zhang-yong/","permalink":"https://blog.devtang.com/2023/03/15/interview-of-zhang-yong/","excerpt":"","text":"张勇是中国高端餐饮品牌“新荣记”的创始人。新荣记旗下餐厅一共获得了米其林 11 星，其中包括北京的第一家米其林三星餐厅：新荣记新源南路店。 本书《详谈张勇》介绍了新荣记对于餐饮的不少理解，以下是我的一些感触。 一、产品好是基础新荣记定价非常贵（人均1000块），但是支撑这个定价的是高品质的食材和口味。高品质的食材很贵，但是因为好吃大家也愿意付费。 除了食材好之外，新荣记的产品一直在做差异化的爆款。通过爆款来建立大家的心智定位。比如：最早的店卖现杀的蛇，后面主打黄鱼等。 张勇本人就是一个研究怎么做吃的产品人，天天琢磨怎么把食物做得更好吃。也是因为这样，新荣记才能获得米其林的评星。 二、定位是关键新荣记诞生的时候还是抓住了市场上高端餐饮的空白。像商务宴请这种场景还是需要餐馆有档次，这个时候新荣记就成了少有的选择。 当然，现在做这个定位的餐厅已经不少了。但新荣记由于做得早，又拿了米其林，所以已经有了行业品牌和口碑，所以就越做越顺了。 三、招聘新人张勇不用大厨，用新人。因为大厨进来是学手艺的，学会之后就想离开拿更高的薪水。张勇觉得新荣记的菜普通人就可以做，所以就坚持培养普通人当厨师，这些人也更容易留下来。 四、顺势全书都能看到张勇的顺势而为。 他先做好一家店，做好食材，做好爆款单品。等品牌慢慢起来了，就开更好的位置的店。等时机成熟，就去香港、日本开店，之后再做食材电商。 每一步都是之前的积累的品牌和资本的进一步放大。但是他并不着急，一家一家慢慢开，一年没找到地方就先不开，很有自己的定力和节奏。 五、小结新荣记产品食材好，菜品有特色，定位有差异。抓住了中国消费升级过程中餐饮中高端品牌稀缺的机会，靠自己的专心经营赢得了米其林多次评星荣誉。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"读《第一性原理》","slug":"first-principles-summmary","date":"2023-03-10T01:13:03.000Z","updated":"2024-01-06T14:52:37.942Z","comments":true,"path":"2023/03/10/first-principles-summmary/","permalink":"https://blog.devtang.com/2023/03/10/first-principles-summmary/","excerpt":"","text":"最近读完了李善友的《第一性原理》，李善友是混沌学院的创始人。 一、简评全书的逻辑和结构还是比较混乱的，把很多东西都与第一性原理扯上关系，比如：还原论、爱因斯坦的相对论、从众效应、批判性思维。 我看得晕晕乎乎，觉得每一句话都对，但是在工作生活中如何应用第一性原理却毫无头绪。我不可能运用马斯克常用的物理学原理，来解决斑马玩教具的直播间售卖问题，对吧？ 二、什么不是第一性原理思考虽然不喜欢这本书，但它还是让我仔细思考了什么是第一性原理，哪些不是第一性原理。 比如：批判性思维就不是第一性原理。批判性思维是一种多角度看问题，希望获得问题的全方位信息，便于综合评估的思维方式。 又比如：避免从众效应肯定也不是第一性原理。因为从不从众根本不是真理的检验标准，正确才是。 物理学是第一性原理么？某些问题下是的。比如制造业的成本预估，就应该通过物理学原理来考虑“底价”，避免被当下的价格和成本迷惑。但显然这不够充分代表第一性原理，因为适用场景不多。 常圳说了一点也很有启发：唯数据论不是第一性原理的思考。因为统计数据在各种情况下很可能有偏差。 三、什么是第一性原理思考那么，第一性原理思考是什么？我认为是一种思考原因中的原因，不断问why的过程，最终找到目标问题的最底层、最核心因素的思考方式。 那有什么案例呢？我自己想了一些，供大家批判讨论。 3.1 教育培训产品对于教育行业来说，“有人背猴子，为结果负责”算是很多产品的第一性原理。因为这个底层因素，所以各大网课都提供了双师，最终双师模式把别的服务模式都干掉了。“有人背猴子”更底层的原因是家长也是普通人，人性是懒惰的，教育孩子很苦，所以家长希望能完全交给别人。 3.2 玩教具产品对于玩教具来说，知识性，趣味性，不费妈，护眼都是非常刚的需求，那哪个更底层和重要呢？我觉得是知识性。因为我们毕竟是玩教具品类的产品。玩具只是形态，提供专业教研的知识教育服务才是我们的本质。 3.3 失业最近身边有一些大龄的朋友失业，我就在想失业的本质原因是什么？是因为他们不努力吗？还是因为经济不好？我觉得大龄从业者失业核心还是供需影响。具体来说： 互联网的高待遇吸引了大量年轻人进入 高速迭代的环境使得大龄从业者没有太多经验积累优势，比如iOS研发以前用objective-c，之后用Swift，后面又流行RN和flutter，之后可能用codepilot调优更流行。 大龄从业者有薪资增长的诉求，企业有降本增效的诉求 于是，很多人就失业了。 如果行业变化没那么大，那么由于经验能够持续积累所以高级人员数量稀缺，供需关系就变化了。 又如果行业薪资没那么好，年轻人进入的变少，企业招不到那么多便宜的年轻人，也会选择大龄的。 3.4 供应商关系之前还想过与供应商的关系最根本需要考虑什么。我觉得是相互的匹配度。你看得上供应商，供应商也看得上你。这样合作就好开展了，有困难也会一起克服。 3.5 低生育低生育率本质是因为什么？我感觉本质是孩子的社会功能性已经极度降低，同时养育成本又变高。 孩子在过去代表着家庭劳动力，代表着老了有人照顾。现在的社会结构下，有没有孩子与家庭劳动力关系不大，养老也基本靠养老机构。 养育成本变高主要还是社会阶层的跨越焦虑。毕竟中高考各只有50%的录取率。社会又按这个来决定劳动收入层次。谁也不希望自己孩子没考上高中，读个中专然后去餐厅当服务员，对吧？ 3.6 低结婚率现在00后们不但不生孩子，好多也不结婚。我感觉低结婚率本质是因为家庭的社会功能对个体需求变低。 本来家庭提供了几个功能： 稳定的性关系。 夫妻分工协作。 共同养育孩子。 但是你看，现在不结婚也可以谈恋爱拥有稳定的性关系。夫妻现在基本都上班，并没有以前那种“男的挣钱女的养家”一样的社会分工了。孩子，刚刚说了也不是一定想要。这就让很多年轻人虽然谈恋爱很久，但是不知道为什么非要领结婚证。 四、小结 《第一性原理》这本书一般。 第一性原理思考是一种探寻问题本质原因的思考方式。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"消费产品的从 0 到 1 - 读《详谈吴骏》","slug":"interview-of-wujun-book-summary","date":"2023-03-07T15:19:09.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2023/03/07/interview-of-wujun-book-summary/","permalink":"https://blog.devtang.com/2023/03/07/interview-of-wujun-book-summary/","excerpt":"","text":"最近读完了《详谈吴骏》，吴骏是三顿半创始人。他是学广告的，之前做过市场营销相关工作。三顿半从 2015 年创立，刚开始几年做了各种探索都不太成功，直到 2018 年推出了冷萃即溶咖啡一炮而红，在 2019 年即成为天猫双十一咖啡品类销量第一。 读完有一些感受，记录如下。 1、产品创新三顿半最最核心的成功，还是来自于产品的创新。从最初的用冷萃的方式保存、到咖啡杯形状的包装，都是很好的产品创新点。三顿半的产品创新达到了很好的自传播性，产品审美很好，定价也相对高，适合朋友圈打卡，很多用户都是因为别人推荐买了三顿半。 我比较喜欢吴骏的这个观点：一个新产品上市后的半年不花营销费用，看半年数据，收集反馈，判断产品力。 很多人觉得产品上新一定要大张旗鼓，甚至把各种内部的流量都用上，我觉得这样是不对的，因为这会影响产品的反馈数据。内部的流量因为用户忠诚度高，可能会夸大产品的竞争力和美誉度。而刚上新就花费巨大的营销费用，则可能因为潜在的产品问题没有充分暴露而带来巨大的风险。 所以，实体产品还是应该慢一点，慢慢打磨。 2、定位是长出来的吴骏认为：定位是长出来的。应该结合自己的基因、体质和能力决定。其中： 基因：团队的天赋，性格特点 体质：你能不能做更多的事情 能力：你能不能做成，组织形态是不是适合 我个人觉得逻辑有点类似于战略的落地需要考虑自身的实际情况。不过我还是不太习惯 “基因” 和 “体质” 这两个词，这种类比有点搞不明白他到底想讲什么。 3、品牌是无处不在的质感我比较同意他的这个框架，用人、货、场、内容来思考品牌怎么做，具体是： 人：你和谁在一起 货：你的产品图是什么样的，你的交付体验是怎样的 场：你的品牌触点在哪里，在哪儿和用户打交道 内容：你塑造什么样的内容策略或者叫内容支点，把你的品牌触点立起来 像三顿半这个新品牌，在产品本身、产品详情页、公众号、以及活动上，都让自己被认为是一个高端的、有品质要求的、有调性的品牌。这就使得新用户愿意使用它，愿意传播它。 4、做产品的框架吴骏介绍了他理解的做产品的框架，分为 S1-S6，其中： S1：立意。点子阶段，需求是什么。 S2：结构。如何营销，卖点是什么。 S3：产品研发，追细节。 S4：上市。将 S2 的结构用起来，把营销和产品结合起来。比如三顿半做的回收计划。 S5：收集用户声音，获得反馈。 S6：迭代。 这里面值得学习的是 S2，即在产品研发前就思考如何营销，我们现在硬件产品的研发也引入了这样的环节，但还是不够深，三顿半将回收计划这些也都考虑在内，活动的节奏会更充裕。 5、关于营销吴骏认为：不应该把营销、分享这种动作做得太过，让客户觉得你就是想薅羊毛，想让他推荐。比如：晒单返现。应该更加周密地、完整地设计用户体验，把用户分享作为用户体验的一个部分，跟你的产品和整个系统连接起来。 这个概念和想法是好的，但在具体落地上还需要多思考怎么做。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"2022 年个人总结","slug":"2022-summary","date":"2023-01-01T01:00:41.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2023/01/01/2022-summary/","permalink":"https://blog.devtang.com/2023/01/01/2022-summary/","excerpt":"","text":"一、工作今年工作交了一些学费，总结起来有三点需要在后面重点提升： 1、业务判断力。学会做决策，承担责任。面对不同意见的时候，能坚持自己的想法（背后是深入的思考和判断带来的自信，而不是固执）。这个在今年进步了很多，但还是不够好，顶多是 50 分。 2、人员判断力。学会从思考问题的框架，信息传递的效率和层次来判断人优秀不优秀。今年这方面也是 50 分，不及格。 3、团队组建能力。看起来小斑斑、供应链、硬件研发的团队人才密度都不够。应该算低于斑马业务的平均水平。这方面只能算 60 分。 所以，明年重点在工作上我需要： 提升业务判断力。对所有核心工作需要自己思考明白业务路径。 提升人员判断力。如果自己有业务思考和判断，那么人员与自己思考的不匹配的部分，就可以成为判断力的来源。 提升团队组建能力。重点挖高潜的人才。 1.1 小斑斑月龄盒2019 年 6 月立项小斑斑月龄盒，到 2022 年 12 月，我一共参与这个项目 3 年半。这个项目是我一手做到现在的。小斑斑月龄盒这个项目是一个典型的市场上有一款成功的产品（即巧虎）的情况下，我们做为市场新进入者，试图参与竞争的业务。 这个业务在今年 12 月交给了新的负责人，我自己对这块业务的自我表现评价不算高，我需要反思和总结。 1.2 供应链我从 21 年 3 月开始管斑马供应链。刚开始汇报给轩姐，后面独立出来，再后面炜刚慢慢开始负责起供应链的事情，到 22 年 9 月交给川凌，整个过程大概 1 年半时间。 从业务上看： 我面临的挑战刚开始是库存准确性。这主要是靠引入系统 + 以周纬度的监控来解决。系统的引入周期比我们预计得慢很多。主数据的合理落地花费了我们大量时间。 在这一年半时间里，首先我初步了解了 ERP，SRM，WMS 系统的需求场景和用法。同时推进了供应链应用起各种系统，来解决库存准确性和效率问题。 我面临的第二个挑战是双减后的滞销压力。由于双减的影响，我们减少了大量的采购订单，这里面未付款的部分需要与供应商进行极其艰难的谈判。这其中涉及大量和供应商的博弈。采购组的同事在这方面整体都比较拉垮，也有很多同事因此选择离职的。 这个过程中也看出来不少优秀的同事的抗压能力。 我面临的第三个挑战是腐败的风险。除了在文化上的强调，以及让内控定期审查之外。我设计了开源、采购、供应商管理的三权分立架构： 开源做供应商引入 采购管询价，议价 供应商管理管分单 同时增加了价格委会员，做价格的拆解分析。 流程上，我增加了： 季度分单会议，将供应商的订单分配权收拢到管理层，让采购在订单份额上没有了支配权力。 价格评审会议，将三方比价的决策放到团队中。 我面临的第四个挑战是人员能力的问题。我主要的解决方案是增加培训、增加招聘、以及引入校招。这块解决得并不太顺利。但是因为供应链主要的核心目标是交付和成本，所以我本来的想法也是稍微慢一点，以免影响交付。 供应链日常工作供应链的日常工作是配合做新品研发，以及量产的交付，然后是成本的控制，最后是效率。 新品研发方面。供应链主要的压力在于开源要求比较高以及上游对产品的指定。 交付方面。22 年 12 月之前疫情都是处在 “动态清零” 政策下，供应链主要是防封控造成仓库停发或者工厂停工。我们做了很多多地备份的方案。 成本控制方面。我们主要是自驱完成，并没有上层的压力。我们做了一些纸张和仓配的降本，由于斑马量大，每一个都能节省上百万。 小结我的供应链工作，如果说有什么超预期的，其实可以说：并没有。 供应链的工作，需要的智力挑战并不大，更多的是执行上的挑战，需要有耐心，认真，正直，同时随时响应。 如果让我给这段工作打分，我觉得可以是 80 分，做得不够好的还是集中在团队的搭建上。如果再有一次，我可能会更加激进一些，也花更多时间在对高潜同事的培养上。 1.3 硬件研发硬件研发整体上还是由于思维机这个产品好，在 22 年下半年启动售卖的时候，有了一个比较好的开局。 23 年最主要的工作还是把产品做好，同时把售卖和品牌的工作思考清楚。 二、读书今年读了 10 本书： 《置身事内》 《金融的本质》 《做对产品》 《原则2：应对变化中的世界秩序》 《邓小平时代》 《女士品茶》 《漫画丰田生产方式》 《可能性的艺术》 《人类之旅》 《筚路维艰》 最喜欢的书是《置身事内》和《做对产品》。前者让我了解到最近 20 年国家在经济上的政策变化及其带来的积极影响。后者让我对 MVP 在落地有了更详细的了解。 三、22 年的目标回顾年初定了三个目标： 做好长期资产配置。这一点应该说不算特别好，但也不算差。 配置的 500 增强和 1000 增强的产品，面对大盘的回策，还是有一些增强效果，不致于亏太多。 CTA 的选择是对的，使得风险不全在股市上。 保本理财保证了基本的生活不受影响。 建平远航建仓时间点比较好，所以受影响不大。 读 6 本书。这个超额完成了，感受还比较好，没有很大的压力。 每周 1 次游泳，如果中午搞不定就尝试早上或者晚上去。这个完全没完成，疫情将运动的想法完全打破了。 四、23 年的目标 工作上：就像开头说的那样，需要提升业务判断力和人员判断力。 理财上：23 年还是有很多的变数，资产配置继续不折腾，能不动尽量就不动了。 个人上： 继续读 6 本书吧，争取再次超额完成任务。 最近刚刚阳康，身体恢复之后，就每周一次游泳。 五、个人 Milestone 不再负责供应链和小斑斑月龄盒，专注于斑马硬件售卖。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"时代的 beta","slug":"the-beta-of-time","date":"2022-12-17T09:28:38.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/12/17/the-beta-of-time/","permalink":"https://blog.devtang.com/2022/12/17/the-beta-of-time/","excerpt":"","text":"引子：alpha 与 beta 收益我们在评价股票基金的时候，通常会拿它和相关的指数（例如沪深 300、中证 500、纳斯达克综合指数等）相比较。 如果这支基金涨了 10%，同时相关的指数也涨了 10%。那么这个涨幅主要是行业的 beta 收益。 如果这支基金涨了 10%，但是相关的指数没涨。那这个涨幅才是主理人自己的主观操作 alpha 收益。 所以，看基金主理人牛不牛，不光得看他的收益，也要看他的 “超额” alpha 部分有多少。这才是你选他的理由。 这个道理在工作上也一样。 很多人的成功，其中不乏有自己的努力，但是自己的努力占多大的比例，别的因素占多大的比例，却很难短时间说得清。这些成功的人，如果归因不正确，以为自己的努力占主要成份，进而对自己的一些成果做错误的归因总结，再依据这些总结做更大的决策，最终会使得自己为这些错误归因买单，付出巨大的代价。 拿一句通俗的话来说：这就是 “靠运气赚的钱，靠实力亏掉”。 所以，判断清楚自己的成功，哪些是运气好，搭上了时代的 beta，哪些是自己真的判断对了，靠实力挣来的，非常重要。否则你是守不住自己挣来的钱的。 下面讲几个例子。 一、iOS 开发iOS 开发在移动开发刚兴起几年非常稀缺，那个时候很多人只需要参加两个月的培训班就可以找到一份不错的 iOS 开发工作。于是有些人就觉得自己就值这么多钱，殊不知这只是「时代的 beta」。 等移动开发岗位饱和起来，企业挑人的胃口就开始越来越刁钻了。这个时候，一些人就开始吐槽面试歧视学历，问些没用的算法，薪资涨幅越来越慢同时换工作的机会还特别少。 其实这就是一波移动开发时代 beta 的红利，来得快去得也快。 二、Copy to China 红利中国互联网时代，有一段时间就是完全照搬美国，美国火什么就抄什么。美国有了 twitter，我们就各种微博开始兴趣；美国有了 Groupon，我们就百团大战；美国有了 Facebook，我们就有了像素级模仿的人人。 因为是模仿，产品创新大家基本上都没有，所以成功的关键很多就是靠资本。但是即便你这样上市了，如果不好好做产品，做针对中国人的本地化优化，长期也留不住用户，也挣不到钱。 人人网就是一个反面例子，像素级模仿并不会让人人做得更好。现在大家几乎已经忘了人人网。 当然，也有坚持做好基本功，坚持不简单拼资本，最后也得到资本助力的美团。现在美团外卖和大众点评已经成为我生活中重度依赖的服务。 C2C 的红利过后，哪些管理者有能力挣 alpha，哪些管理者只挣得到 beta，一眼就看出来了。 三、中概股互联网时代，周围很多人买股票，也有很多人挣钱，大家基本上都是买互联网公司的股票，帐面上的收益也很高。但是今年应该这些人收益应该都不好，包括我。 互联网的 “逻辑” 完全变了，像哔哩哔哩这种年轻人集中的社区，不挣钱股价照样跌很惨。挣钱的公司，像腾讯，陌陌，没有了未来高预期的增长，也同样跌很多。 我不知道有多少人捕捉和预见到了这一波，这些人可能才是真正有能力挣 alpha 的钱。 以前挣得多，那只是挣的「时代的 beta」。 小结：如何自省我避免自己盲目自信的方式就是反复问自己：如果别人来做，成绩会跟我一样吗？如果是一样，那就不代表我牛逼，那成绩就只是 beta，甚至都不能称作成绩，只能称作 “预期内的结果”。 举个具体的例子：我在 iOS 开发圈的出名，就很大程度是「时代的 beta」。因为我刚好在红利期做 iOS 开发，在那个时候写文章，使得我获得远高于别人的曝光机会。当然，不是说我的努力没有用，我的文章肯定还是有点质量的，但 90% 以上的因素还是时代给的机会。 你还见过什么「时代的 beta」？欢迎一起分享~","categories":[],"tags":[]},{"title":"中国特色社会主义如何探路而来 - 读《筚路维艰》","slug":"five-choices-on-the-road-book-summary","date":"2022-12-03T13:20:44.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/12/03/five-choices-on-the-road-book-summary/","permalink":"https://blog.devtang.com/2022/12/03/five-choices-on-the-road-book-summary/","excerpt":"","text":"零、序中央在二十大报告提出：前进道路上必须牢牢中把握五项 “重大原则”，其中第 2 点原则是”坚持中国特色社会主义道路”。那么，中国特色社会主义如何探路而来的呢？为了深入理解国家历史，我读了一些书。刚刚读完的是《筚路维艰》，作者是萧冬连，华东师范大学中国当代史研究中心兼职研究员、中国经济体制改革研究会特邀研究员。 该书将建国后的发展分为 5 个阶段，分别是： 新民主主义阶段 效仿苏联模式阶段 追寻超之路阶段 文革阶段 改革开放阶段 每个阶段是如何启动的，又是如何终结的，当时的决策思路是什么，讨论是什么，支持方和反对方各自的观点如何，最终决策是如何达成的，作者通过查阅大量文献，将这些内容呈现给我们。 我个人读完的感受是：虽然每个阶段变化非常大，但是到了细节之处，又是非常合情合理的。在深感决策影响之大的时候，也深知做对决策非常不易，这也同时体现出咱们现在的美好生活来之不易。 以下是一些读书总结。 一、新民主主义阶段建国初期，大量的民生保障和就业都是由私人企业完成的。具体数据是：当时私人工业总值占全国 63.2%，职工人数占全国 54.6%，私营商业数量占 80%。 虽然当时的共产主义的终极目标是消灭这些私人企业，但是跨度太大就犹如给病入膏肓的人下猛药，人可能承受不住。 这个时候，作为过渡阶段的新民主主义阶段就出现了。私人企业主被阶段性安抚。公有制经济和私有制经济共同发展。 二、效仿苏联模式新民主主义阶段持续时间很短，到 1953 年基本就结束了。从那时起，中国效仿苏联搞起了计划经济，大力发展重工业。 这个转变的重要背景是：国家发展重工业需要有钱想外国采购设备和技术，而当时粮食出现了短缺，并且出现了粮食价格炒作的情况。 为了控制粮食棉花等重要农产品的价格和供应，同时从中获得国家发展的原始积累资金，国家开始施行粮食的统筹统销。最终发展为大量商品都纳入统筹统销的范畴内。 在进一步的，农村信用社借此机会发展起来。 之后，国家发展出以下制度对合作社及整个社会进行管理： 1、城镇街居制。即设立街道办事处和居委会。通过这两个末级行政机构，把政策传导到基层。 2、单位制度。通过单位将公有制人员进行组织。包括 3 类单位：党政机关；国有企业；事业单位（学校，医院，研究所，博物馆）。 3、人事档案。个人的简历、鉴定、考核、学历、政治审查历史、工资待遇等信息都纳入档案的严格管理之中。 4、户籍制度。户籍制度将人口划分为 “农业人口” 和 “非农业人口”，发展出了城乡分割的二元体制。 由于就业渠道统一分配，而单位编制有限制，人们不能自谋职业，只能听从分配，所以农民进城被限制，个人就被固定在一个区域或单位内。 国家权力覆盖整个社会，有助于动员民众实现国家目标。 三、追寻赶超之路这个阶段的背景是 1956 年 2 月苏联二十大召开，揭露斯大林的错误，引发了毛泽东的思考。 于是苏联这个好学生形象塌了，中国无法再全面效仿它，只能自己找发展之路。而且还需要避免重蹈苏联的覆辙。 在怀着快速发展的理想情况下，毛主席推进了大跃进。大跃进通过将权限下放到一线的党委，使得底层的分支机构拥了有很多实权，因为业绩是核心目标，所以造成了大家只顾占用资源发展，不考虑科学和全局的统筹，造成了比较多的资源浪费。 大跃进期间，人民公社也发展起来，人民公社由合作社发展而来，但进一步地：人民公社取消了农民的自留地，家庭副业。私有的基地，牲畜，林木等财产也归公。 由于农民的口粮在公社，饭碗在干部手中，所以强迫命令，瞎指挥就不可避免。干部的任命主要是政绩的考核，所以干部只对上负责不对下负责，所以比较难避免干部用造假来博取荣誉。到了 1958 年，造假变成了公开的理直气壮的竞赛，达到了“亩产13万斤”的离奇程度。 由于造假，所以中央对于底层人民的生存状态判断出现了失误，很多粮食被过多的征收和出口了，到了 1959 年，出现了大饥荒。 最终大跃进以失败造终。 四、文革阶段大跃进失败后，毛主席开始： 1、恢复自留地、家庭副业和农村市场。 2、缩小人民公社规模。 3、解散公共食堂，取消供给制。 4、将基本核算下放到生产队。使得干得好的生产队拿得多，大家有积极性。 在 1966 年，毛主席发动了文化大革命。 书中没有明确说明文革发动的原因，部分解释为：毛主席为了巩固自己的权力，同时给整个权力机构一定的压力。 文革的持续时间之长超过了毛主席的想象，刚开始将原有的权力机构打破后，为了维持秩序，很多军队干部进入了国家治理机构中任职，其中权力最大的就是林彪。由于毛主席感受到了林彪的权力威胁，后续又进一步削弱林彪的权力，造成了林彪的外逃。 林彪死后，国家的权力在“文革派”和“老干部派”中得到了暂时的平衡，但是只有文革派支持文化大革命，但是文革派对国家治理又毫无能力，最终使得毛主席无法放心交权，本来指望邓小平能够支持文革，但是邓小平坚持不表态，让毛主席只能临死前把权力交给了华国锋。 但两派的制衡显然是不稳定的，1976 年毛主席死后，“四人帮”很快被抓，文革结束。 五、改革开放阶段改革开放的契机有两个： 1、当时国家一穷二白，需要大力发展经济。 2、1978 年，国家高层开始出国考查，对于资本主义国家的发展感到极大的震动，对于国家有多么落后有明显的对比。 1978 年对于“实践是检验真理的唯一标准”的讨论，使得大家可以放下一些所谓的原则，把之前的一些可能的冤假错案平反。包括毛主席定下的一些案件。 邓小平的开放思路是：坚持中国的基本制度和共产党执政的稳定前提下，将中国经济融入西方主导的世界经济体系，充分利用外部资源来发展自己。这从推动经济特区的建立，推行从沿海到内地的梯度开放战略，以及争取加入 WTO 的持久谈判都可以得到印证。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"一切皆有因果 - 读《人类之旅》","slug":"human-travel-book-summary","date":"2022-08-14T02:44:32.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/08/14/human-travel-book-summary/","permalink":"https://blog.devtang.com/2022/08/14/human-travel-book-summary/","excerpt":"","text":"一、序中信出版社的明月老师悄悄给我寄了一本《人类之旅-财富与不平等的起源》，作者是以色列的奥戴德•盖勒。 盖勒是美国布朗大学经济学教授，他因为开创了 “统一增长理论”，被认为是诺贝尔奖的潜在候选人。这本书探讨了人类经济繁荣的背后原因，以及全球财富不平等的决定因素。 我上周花了一点时间刚刚读完。全书主要分两部分： ​​第一部分介绍马尔萨斯陷阱。该理论在过去有效了几千年，直到最近 200 多年才失效。该理论的失效从全球范围内解释了生育率为什么下降。 第二部分从自然选择的角度，介绍文化的差异如何在各国产生，进一步又是如何影响国家的经济发展的。 二、什么是马尔萨斯时代马尔萨斯时代代表一段时期，它从人类出现开始，到 19 世纪末的工业革命结束。 在这段时期，人类在两个状态之间循环： 状态一：通过育种或者迁徙等手段，获得更多的食物。 状态二：因为食物足够，人们加大生育。生育带来更多人口，人口增长速度到达了自然资源的限制，最终又变回仅能温饱。 状态一和二的循环在历史上有过多次出现。 例如：人类刚刚进入农业社会时，通过培育小麦，水稻，玉米等高碳水作物，为人类提供了更多的能量。进而可以支持人类繁衍更多后代。最终人类的人口受耕地的限制而到达一个顶峰。到达顶峰之后，某些家庭出生的更多人口就会由于无法获得足够食物而死亡。 又比如：人类通过迁徙到达一块新的大陆时，刚开始资源丰富，所以人口大幅度增加。但是人口到达顶峰之后，更多的人口也就无法获得足够的资源了。 三、马尔萨斯时代的终结马尔萨斯时代在工业革命后被终结。同往常一样，工业革命带来了大量的资源，但是为什么人口的数量这一次没有遵循历史的规律呢？ 答案是：工业革命之后，教育的成本变得异常高。 在中世纪，教育其实只是少数人的特权。拿识字率来说，中世纪的中国、法国、德国、荷兰等国家的识字率均低于 10%。 但是到了 20 世纪，全球的识字率超过了 50%，目前到了 86%。 工业革命之后，资本家们发现，生产对劳动者的教育和技能的投资变得愈发重要，从而推动各个国家将教育投入列为重点投资。 而有效的教育投入，确实又进一步加速了创新的步伐，进一步改善了人们的生活水平。 但是，人们发现：因为教育需要投入大量的资源，所以全球范围内生育率都大幅下跌。西欧国家在工业革命后，生育率下跌了 30%~50%（如下图）。 中国早在 13 世纪就引入了科举考试，书中提到的调查也显示：小规模的家庭的孩子更多地参加科举。 逃出马尔萨斯陷阱对人类社会而言意义重大。因为： 人均收入相比过去提高了 10 倍。 人均寿命提高了约 1 倍。 当然，虽然每个人都有时间享受生活，有着更加多样性的饮食，娱乐。但是，不能不说整个全世界都陷入了低生育率的时代。 四、自然环境对于文化的影响4.1 集体主义的文化之前读《原则 2》的时候，书里面提到很多中美在文化上的差异。比如中国人更加看重集体利益，美国人更加看重个人利益。 我开始觉得这种文化差异来自于中国古代的各种儒家文化。例如：孔融让梨，精忠报国这些词都在讲集体利益。但是没见到什么词赞美个人利益。 但是书中提到另外一个观点：中国的土地适合种植稻米，因此需要彼此共享大规模的灌溉系统，这有助于相互协作的集体主义文化。而像小麦所需要的协作程度就较低，会容易出现更具个人主义的文化。 总结来说就是：劳动密集型作物的耕种与集体主义文化相互关联。 4.2 女性进入职场的文化差异与此类似的还包括对女性进入职场的态度差异。研究发现，某些地区耕作需要用牛马拉动的犁耙，而控制牲畜和犁耙需要相当大的上肢力量。这些地区的女性就更多从事家务劳动。 所以，历史上较多使用犁耙的南欧、中东和中亚，女性面孔更少出现在职场。 4.3 损失厌恶诺贝尔经济学奖得主卡尼曼在他的书中介绍了人类的：损失厌恶心理。即 100 块钱的损失情绪与 200 块钱的获得情绪相当，可见人们多么厌恶损失。 本书也将这种情绪归结为马尔萨斯时代的影响。因为在那个年代，干旱等不利条件经常带了饥荒甚至灭绝；相反，丰收只能暂时改善生活，促进繁衍。所以，古代活下来的人会更加谨慎，即使损失一点潜在收益，也要防范灾难性打击。 所以，损失厌恶是一种面对灭绝威胁的古老适应性。 五、小结 工业革命之后，教育变成提升生产力的必要条件。 因为教育投入大，所以家庭生育率下降，马尔萨斯陷阱终结。人均收入和售卖大幅提升。 集体主义文化与大规模密集型作物的种植相关。 女性的从业观念与犁耙的使用相关。 损失厌恶是一种应对灭绝危险的古老适应性。 这是一本从自然选择角度讲历史演变的书，角度挺特别的，推荐大家读读。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"政治治理的各种可能 - 读《可能性的艺术》","slug":"politics-is-the-art-of-the-possible-book-summary","date":"2022-07-27T02:43:56.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/07/27/politics-is-the-art-of-the-possible-book-summary/","permalink":"https://blog.devtang.com/2022/07/27/politics-is-the-art-of-the-possible-book-summary/","excerpt":"","text":"一、序言最近读完了一本讲政治的大众科普读物：《可能性的艺术》。本书作者刘瑜博士，毕业于哥伦比亚大学，是清华大学社科学院副教授。 本书挑选了各种国家的不同治理结构做解读和分析，试图探讨出有益于社会发展的政治结构。 其中作者详细介绍的埃及、南非、印度、美国、委内瑞拉等国家的发展历程，让我收获很多。 以下是一些感悟。 二、国家是什么刘瑜说：国家是特定区域内合法对暴力垄断的机构。 “暴力垄断”，这是多么新鲜的一个角度！不过想想也对，只有国家授权的人员（例如警察）才可以合法的使用武器等暴力器械。 一个罪大恶极的罪犯，普通民众再狠他也不能动私刑，只能交由法院来审判。即便要剥夺罪犯的生命，也只能是法院来核准。 垄断了暴力之后，国家就可以衍生出一个必须的能力：征税的能力。 有了税收，国家才有能力为各种行政机构的运作提供经济支持，进一步国家就可以提供：冲突控制，发展经济，提供公共服务。 拿我们国家来说，去年 114 万亿的 GDP，国家收了大概 20 多万亿的税。这些税为教育、国防、基础设施建设，贫困地区的转移支付扶持，国家的重点产业扶持等提供了弹药。 新冠疫情持续了 2 年多，我接种了 3 针疫苗，检测过上百次核酸，都没有花钱，这都是国家从税收中支出了。 另外，你可能觉得国家税收很高。但是书中列出了别的国家的税收占 GDP 的比重：丹麦是 45%，法国 40%，日本 30%，比较下来，中国的税收（20%）其实是处于较低水平的。 三、世界秩序的发展书中从另外一个角度解释了西方发达国家对全球的剥削规划：全球化。 西方推行的全球化本来是希望赚取全球利润。以前 IBM、微软和苹果只能挣美国人的钱，但是全球化之后，可以挣全世界的钱。 全球化之后，自由竞争很容易形成强者更强的局面，因为领先者可以获得数倍与竞争对手的利润来改善工艺，最终形成自然的垄断局面。这都是西方发达国家乐于见到的。 全球化也容易造成优秀人才的自由流动。清华北大的优秀毕业生很多最后出国深造后留在了国外。很多优秀的人才也被外企录用。 例如：我所从事的互联网行业，曾经最好的工作就是去 Google、Facebook、微软工作，然后 transfer 到硅谷。 但是，发达国家没有估计到的是：中国因为提供了全球的制造业能力，抢了发达国家和贫困国家蓝领工人的饭碗。现在不光是发达国家制造业空心化，像非洲也没有了制造业。因为中国制造已经形成了产业集群和规模化优势。 中国的制造业在抢到全球领先的基础下，开始朝着智能化和高精尖发展。各种自动化设备无处不在，各种制造业人才也在这种环境下被培养出来。进一步强化了中国的制造业老大的地位。 中国在具备制造业优势的基础上，通过国家产业扶持等手段，对新能源汽车、光伏、电池、芯片、AI 等领域重点支持，又再一次使得中国在这方面赶超发达国家。 说实话，现在除了高端芯片，留给西方卡我们脖子的高科技产业不多了。 一句话总结：西方希望通过全球化赚取全球利润并维持垄断。中国却因为人口红利吃下全球制造业，同时发展为制造业强国。 四、民主决策不代表高质量决策很多人以为民主是银弹。殊不知，苏联也是被民主解体的。 刘瑜说：民主只代表一个决策程序，不代表这个决策程序出来的决策结果一定最好。 书中举了一个午餐食堂的例子：学校为了体现民主，让学生自行投票决定午餐吃什么。结果如果学生不够理性，最终选择吃不那么健康的薯片炸鸡可乐，那么就表示民主程序的决策出了一个糟糕的结果。 类似的例子还包括英国脱欧的公投等。很多时候人民的情绪是容易被煽动的，在这种情况下，民主投票不代表能够选出最优解。 民主也需要大家遵守契约精神。书中举了泰国的例子，因为红杉军和黄衫军的对持，所以不管代表哪边的候选人被合法选中，另外一边也会不顾法律规则来暴力抗议。最终使得泰国的民主实质上失败了，军方执政至今。 那是不是说民主不重要呢？也不是，但是民主只是原料，要做好一盘菜，别的比民主重要的因素也得满足。 五、价值观差异如果说有什么是这个世界相互不能达成一致的，那就是价值观。 书中列举了当今世界三大价值观：伊斯兰文化，儒家文化，西方文化。 书中也列举了这三种文化下对于不同价值观的评价差异。 秩序 vs 自由。儒家文化认为秩序比自由重要。 主权 vs 人权。儒家文化认为主权＞人权。 平等 vs 效率。儒家文化认为效率比平等重要 书中让我震撼的一个案例是：荣誉谋杀。穆斯林文化下的一些国家会对一些违反文化禁令的人私下杀掉，而把这个称做荣誉谋杀。相关的内容见：揭露隐藏在中东社会的毒瘤 —— “荣誉谋杀” 另一个让我记忆深刻的案例是一个问题：你是否愿意为国家一战？77% 的中国人选择 “是”，而只有 30% 的美国人选择 “是”。这背后是大家对于国家、名族的不同认同感。 六、小结 国家是特定区域内合法对暴力垄断的机构。 西方希望通过全球化赚取全球利润并维持垄断。中国却因为人口红利吃下全球制造业，同时发展为制造业强国。 民主是好的，但民主只代表一个决策程序，不代表这个决策程序出来的决策结果一定最好。 伊斯兰文化，儒家文化，西方文化之间存在着巨大差异。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"盛极而衰，过犹不及 - 读《逆转》","slug":"reverse-book-summary","date":"2022-07-24T12:48:06.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2022/07/24/reverse-book-summary/","permalink":"https://blog.devtang.com/2022/07/24/reverse-book-summary/","excerpt":"","text":"文章写于 2015.8.22，更新于 2022.7.24 。 一、序言 子贡问：“师与商也孰贤？” 子曰：“师也过，商也不及。” 曰：“然则师愈与？” 子曰：“过犹不及。”—- 《论语·先进》 最近看完了《逆转》这本书，作者是格拉德威尔（Gladwell）。这本书的作者格拉德威尔的另外两本书相对来说名气更大，分别是《引爆点》和《异类》。 这三本书的写作风格类似，作者是一个非常擅长讲故事的人，所以全书都是各种故事，在故事中再加上一些作者的观点。 在本书中，作者的观点非常简单，拿「过犹不及」四个字就可以概括。作者认为，任何优势，如果强大到一定程度，过了那个临界点，优势就会逆转，从另外一个角度看，优势甚至变成了劣势。 为了证实这个观点，作者讲了很多有趣的故事，我给大家分享几个比较有意思的。 二、改变游戏玩法的故事故事一：大卫和歌利亚的故事。大卫身材瘦小，歌利亚身材高大，但是在决斗中大卫利用自己移动快速和可以远距离投石攻击的特点，战胜了歌利亚。 故事二：篮球里面的全场紧逼故事。一个工程师爸爸，为了自己身材瘦小的女儿能够在篮球比赛中获胜，通过强化体能锻炼和全场紧逼策略，最终获胜。 以上两个是通过改变游戏玩法，来达到弱智胜强的故事。罗辑思维里面解释得比较好，即游戏规则其实很简单，但是社会里面的强者通常会在规则外面再包一层规则。比如说决斗，本来就是谁活谁胜，但是很多社会要求决斗的 “公平”，如果大卫真的和歌利亚 “公平” 的较量力量的话，那肯定是输的。 其实在互联网行业的人才招聘上，就出现过很多改变游戏玩法的类似故事。比如说，由于现在创业公司很多，风投的资金投入也很大，很多创业公司就利用 BAT 薪资涨幅无法快速决策的弱点，以高于 50% 的待遇来挖这些 BAT 的人。这样使得 BAT 在人才流动上相当被动，因为他们的薪酬体系造成他们无法通过快速决策来调整薪水。 三、资源越多就越好吗？故事三：小班教育的故事。美国一些地区为了提高教育质量，施行 10 人左右的小班教育。结果发现，由于在小班里面大家很难形成社会一样的兴趣相投、性格互补的小团体，而造成这些学生在社交能力上反倒变弱了。而社交上的缺失会造成一些学生更加厌学。 故事四：有钱人教育的故事。有钱人在家教教育上，更难让孩子感受到资源缺乏，从而无法进行有效选择和决策，也很容易产生浪费资源的现象。中国有句古话叫「富不过三代」，其实就是这个意思。 「富二代」因为由「富一代」亲手教育，多少还是有一些价值观念能够传递下去，但是三代之后，第四代人很难拥有第一代人挣钱不易，生活艰辛的感受，那么在教育中让他学会到选择，放弃，节俭，合作等能力都相对来说更加困难。 我老婆是学教育的，她也告诉我过一个故事。很多家长认为，给小孩买的玩具越多越好，但其实不是的。小孩小时候专注力的培养特别重要，如果一下子给他太多玩具，他会感觉到无所适从，无法集中玩一件玩具。 而专注力如果不能在小时候进行有效培养，就会影响孩子的学习。因为在学习中，孩子需要在长达几十分钟的时间内保持专注。英国牛津大学教育心理学教授也指出，那些家境优越、玩具成山的小朋友智力水平往往比玩具较少的同龄孩子的智力水平低些。 这算是我听到过的最贴近身边的，资源过多产生逆转的故事。 四、资源越少就越差吗？书中讲到美国律师博伊斯的故事，因为从小有阅读障碍，博伊斯一直成绩平平。但是因为他的阅读障碍，所以使得他在听力上锻炼出来惊人的能力。 在博伊斯的经典案件中，博伊斯可以通过和对方证人的现场提问交流，从对方的语气和语速中体会到对方的紧张程度，从而对他觉得有所隐瞒的细节进行追问。这个能力实在太强大了，就相当于一台精准的人工「测谎仪」，于是博伊斯能找到对方人证的有所隐瞒的地方。 作者的《异类》一本书中，提到过微弱优势通过多年选拔和累积，成为巨大优势的故事。但本书的故事说明，一些巨大的「缺陷」（比如阅读障碍症），也可能使得一个人被迫在另一方面不断强化，从而形成优势。 我自己也想到一个例子：假如有两个演员，一个长得比较帅，一个长得比较丑，那么长得帅的演员可以做偶像派，也可以做演技派，长得丑的人只能做演技派。这样的资源不平衡，会不会使得长得丑的人更加专注于提高自己的演技水平，从而在演技上更容易成功呢？我觉得从概率上来看，应该是的。 五、利用逆转原理的斗争书中重点讲了美国黑人领袖马丁路德金的故事，马丁路德金为了争取黑人的权益，有意识地利用各种方式来激化黑人和白人的矛盾，最终使得美国国会通过了《1964 年民权法》。这里面甚至有很多「不太光彩」的手法。在奥尔巴尼州，当地警察局长看破了马丁路德金的伎俩，采用了非常克制的方式，使得他花了 9 个月时间毫无进展。但马丁路德金换了一个州，最终在伯明翰州最科激化了矛盾。 六、总结这两年，逆转的故事越来越多。今天你还是网红一哥，因为大家都关注你，明天你就可能因为不小心犯的错误被封禁。今天你还处在火爆的行业，明天可能就因为环境原因变得没人搭理。 反过来，像罗永浩、新东方这样，今天你可能跌入底谷，不放弃的话，明天又​可能再次成功。 如果要说《逆转》这本书教会了我什么，我觉得就是要用辩证的角度看待事情，思考的角度越多，就越容易还原事情的真相。 另外，遇事不大喜大悲，专注做好每一件有价值的事情，做长期的价值主义者​，也是当下的生存之道。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"构建精益生产的企业 - 读《漫画丰田生产方式》","slug":"toyota-tps-system-book-summary","date":"2022-06-19T06:53:19.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/06/19/toyota-tps-system-book-summary/","permalink":"https://blog.devtang.com/2022/06/19/toyota-tps-system-book-summary/","excerpt":"","text":"一、引言最近周末在家，读完了《漫画丰田生产方式》，这是一本讲供应链优化的书。 丰田曾长期市值在汽车制造商中排名前三，这主要得益于它在生产方式上的有效改善。业界将丰田的改善方法称作：TPS，现在已经被各业界广为传播和学习。 美国 MIT 的研究人员将丰田这种生产方式称作 “精益生产”。 在今天，“精益” 一词进一步发展，成为持续改善和创新的代名词。 以下是一些笔记。 二、TPS 产生的背景TPS 的全称是：Toyota Production System，它的出现发生在丰田公司经营困难的 1950 年前后。 当时日本经济通胀严重，统治日本的美军政府经济顾问道奇提出了道奇计划（Dodge Line），其主要内容是让日本政府减少赤字，适应均衡财政。 于是日本政府将中央及地方税收从改革前的 25.9% 提升到了 28.5% ，强化征税有助于平衡政府的预算，但是也让企业经营更加困难。 当时汽车生产还是流行的流水线式的生产，为了追求规模化，流水线一经启动就会持续运行，商品非常容易产生库存积压。 而丰田公司的经营者去美国考察，从美国超市的 “及时销售及时补货” 的动作中得到灵感，从而发明了 TPS。 三、TPS 的主要内容TPS 的主要内容都是对浪费的优化。 在生产中，浪费无处不在。比如： 你的原料买进来放在库存里面长时间不用，这就是对资金的浪费 你的产品生产多了卖不出去，这就是库存的浪费 你的人不是在做生产工作，而是在做生产资料的搬运，这就是搬运的浪费 你的生产过程效率不高，动作不是最经济的，这就是生产的浪费 在我自己的理解下，为了减少浪费，TPS 主要做了两个方面的改造： 对生产流程的改造 对团队成员的改造 3.1 对生产流程的改造TPS 对生产流程的改造主要就是引入了以下方法： U 型生产线：减少生产线长度，引入复合技能工作 后序拉动：以实际的订单来决定生产量 及时生产：优化上下游，将生产周期尽可能缩短 看板系统：通过可视化的数据传输将生产信息传递 均衡化：将多个 SKU 混合在一起生产，保证交付时间 3.2 对团队成员的改造TPS 对团队成员的改造主要是培养多面手技工。因为按需生产后，产线可能随时切换，而如果一个工人只能做一个产线上的动作的话，他的人力就会被浪费。 按需生产后，工厂的生产状态就不再是 100% 了，因为需求是会波动的。 这个时候，为了让团队将非生产时间利用起来做有价值的事情，丰田让他们做产线的复盘总结，不断优化和迭代生产环节。 员工一方面技能丰富了，另一方面参与了生产改善的过程中，于是工作主动积极性也大大增加。 3.3 改造的本质是弥补劣势上面这些方法论，本质上都是为了追求 “按需生产” 这种从美国超市中借鉴到的理念，为了贯彻这种理念，丰田将整个供应链进行了上述的改造。 这个改造，其实就是在给 “按需生产” 的劣势 “打补丁 “，帮助 “按需生产” 的缺点不至于太致命，让 “按需生产” 整体上优势大于劣势。 按需生产有哪些劣势？ 产线启动成本太高。所以 TPS 引入了 U 型生产线来使得产线能快速启动。 原材料采购时间长。所以 TPS 引入了及时生产，优化上下游的采购和生产。 多个 SKU 生产的时候，只能先做一个，再做另一个。所以 TPS 引入了均衡化生产。 人员浪费。所以 TPS 引入了多技能员工。 通过这些补丁，按需生产的经济性就体现出来了，从而让丰田公司拥有巨大市场竞争力。 四、我从 TPS 中想到的4.1 多技能员工培养多技能员工是每个企业都可以学习和借鉴的经营理念。 对员工来说：因为市场需求在不断变化，如果一个员工只会做一件事情，那么在业务需求变化的时候，他就只能离开。而如果他是一个多面手，那么他就可以和企业共同应对变化。 对企业来说：一个多技能的员工，因为具有更多视角，所以有助于改善生产的上下游衔接，更有可能成长为管理者。以满足企业不断成长的目标。 拿技术开发举例，我们在技术领域常常讲要做 T 型人才，即一专多能。做服务器端的要会写前端、做前端的要会写客户端。这样你理解了各种开发技术的异同之后，不但有助于自己学习新的技能，也能帮助自己理解对方在开发上的挑战，使你们之间协同更舒服。 4.2 如何创新创新的机会总是发生在时代变化的时候，有可能是经济的变化，人们观念的变化，也可能是生产方式的变化。 而对创新的机会，如何做落地的方案？丰田的 TPS 引入过程给我了一个启示：抓核心问题，解次要矛盾。 拿丰田的改革来举例，核心问题是什么？核心问题是： 在经济日益下行的情况下，粗放的流水线式生产会带来大量的浪费。 解决方案是什么呢？解决方案是： 把粗放的流水线模式，改成按需生产模式。 按需生产模式引入，会带来哪些次要矛盾？次要矛盾是： 流水线启停成本高 原材料采购慢 工人可能闲置 多 SKU 生产响应慢 没关系，这些矛盾只要有一定程度上的优化，优化后问题小于收益，就可以。 于是创新产生了，帮助丰田度过了经济危机，并成为了市值前三的车企。 4.3 没有好或不好，只有合适不合适的解决方案我们家厨房有很多刀，有的适合削水果，有的适合切菜，有的适合切骨头，还有一种刀，专门用来切面包，特别好使。 每一种刀就像一个解决方案，它是为特定场景设计的，有优点也有缺点。 当时代变化的时候，解决方案可能就不再适用于它的场景了，那么你就需要重新构建你的解决方案。 这个时候，思考核心问题，解决次要矛盾就可以给你帮助。 五、小结丰田在日本经济萧条时期，为了减少浪费而发明了 TPS 这种精益生产方式，通过按需生产的目标来改造供应链和团队，从而取得了巨大的成功。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"统计学的编年史-读《女士品茶》","slug":"the-lady-tasting-tea-book-summary","date":"2022-06-08T01:12:53.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/06/08/the-lady-tasting-tea-book-summary/","permalink":"https://blog.devtang.com/2022/06/08/the-lady-tasting-tea-book-summary/","excerpt":"","text":"最近读完了《女士品茶-统计学如何变革了科学和生活》。这是一本科普性质的统计学发展编年史，在让大家了解统计学的发展之余，本书也八卦了费希尔，内曼，皮尔迩等统计学家的生活故事。 以下是一些笔记和思考。 一、女士品茶的故事为了和书名呼应，全书中的开场就讲述了一个女士品茶的八卦故事。故事发生在 20 世纪的英国剑桥，一些大学教员和他们的妻子在喝下午茶，其中一个女士坚持认为：将茶倒进牛奶和将牛奶倒进茶里味道不同。 可想而知，在座的大学教授们觉得可笑至极，因为两种化合物在化学成分上没有任何区别。但是，现场的一位身材矮小的男子严肃地对待了这个事情。 他跑到厨房一顿操作之后，开始了他的实验：男子把第一杯茶递给女士，女士品尝了一分钟，判断这个是牛奶倒在茶里制作出来的。男子记录下来，没有发表任何观点，然后把第二杯茶递给她。最后大家惊讶的发现，女士真的辨别正确了所有的测试。 书中没有对女士如何做到这个做过多展开，迅速切到本书男主角的角度。 故事中的这个男子就是男主角费希尔。费希尔是整个现代统计学的开创者，出版了影响巨大的《研究工作者的统计方法》和《实验设计》。 二、P 值与显著性检验我们现在做产品的过程，常常伴随着用户研究测试。在用研过程中，我们会做一些假设，然后用显著性检验来看这个假设是否显著。 为了判断假设是否显著，我们引入了 P 值，用以表示推翻这个假设的概率。 那刚刚那个女士品茶的故事举例。如果我们只测试一次，那这个女士其实有 50% 的概率猜对，P 值为 0.5。显然，这个 P 值不够显著。 但是，如果我们连续测试 10 次，女士都猜对了。那么这个时候 P 值只有 0.001。这个时候 P 值已经非常显著了。 三、真实数据很重要统计数据很多时候会撒谎，所以不能盲信数据，最好的办法还是深入用户，查看原始数据。 这方面的案例很多，书中举了一个犯罪率与刑罚时间的统计案例。 在案例中，人们做了一项研究：对成年男子囚犯获刑时间与重新犯罪的关系进行比较。结果表明：获刑时间较短的囚犯重新犯罪的比例非常高。人们以此为据，认为应该给这类人长期的刑法。 书中的 “坎利夫” 负责审查这项调研。她不满足验算统计表格，而希望和背后的原始数据：即刑犯聊聊。结果她很快发现，几乎所有这些刑犯都是 “可怜又可悲的老人，因为他们没有去处，所以通过犯罪来获得回到监狱的机会”。而研究人员在制作表格时，把他们的多次入狱算作了不同的犯人。 在删除这些数据之后，服刑时间和再犯罪率之间就没有明显关系了。 四、统计工作的复杂性统计工作其实很复杂，稍微不注意就可能得出误导性的结论。书中介绍了很多这样的坑，也提出了一些解决办法。 4.1 案例一：作物收成研究费希尔在研究作物收成的时候，发现很难保证每块地都是完全一模一样的样本，某些地可能因为历史用过一些肥料而影响现在的测试，这样实验数据就会被干扰。 费希尔为此引入了随机过程，让农田分割成若干块，每次实验的实验组与对照组均通过随机的办法来决定。 随机使得样本的个体差异被均匀性摊薄，在实验数量到达一定程度后，个体差异就很难只聚集在某一实验组内了。 4.2 案例二：吸烟与肺癌的关系现代观点大多认为吸烟与肺癌是呈显著的相关性的。但是费希尔却认为研究不够严谨，他提出了这样一种假设： 假如有一种基因 A，携带这个基因的人普遍比不携带这个基因的人更容易喜欢上抽烟；同时，这个基因天然容易患上肺癌。 于是你就能观察到吸烟的人和患肺癌的人相关，但可能背后原因是他们携带这个基因，即使他们不吸烟，这个基因也一样让他们会容易得肺癌。 满足费希尔的挑战：你只能随机选择两组人，一组人强行要求他们吸烟，另外一组强行要求他们不吸烟。以此来排除 “喜爱抽烟基因” 的干扰。但是，从道德和伦理层面上，这种实验根本无法实施。 你看，要在统计上证明因果其实很难很难。 4.3 案例三：癌症药物的有效性测试书中举了一个癌症药物治疗组与对照组的实验困境。因为病人会对疗效的感受做反应，如果一个对照组病人感受到没效果，就可能放弃当前的治疗，转投别的治疗方案。这样，安慰剂组中留下来的可能都是自身免疫力好而感觉治疗 “起效果” 的人。 最终，测试结果可能是安慰剂的效果甚至比药物效果还好。 但是，从人道和法理上，你又不能强行要求一个癌症患者必须冒着生命危险结束安慰剂治疗。这里面又发展出了更多研究，最终现代医学会追求接受安慰剂这种 “非最佳治疗” 的病人数量最小作为分析测试标准。 4.4 案例四：决策悖论假如我们接受假设检验和显著性检验的思想。那如果一件事情发生的概率只有万分之一，那我们就应该拒绝这个假设。 但是我们考虑这样一个场景：我们组织一个抽奖活动，活动中有 1 万张彩票，每张彩票中奖概率相同。 所以，1 号彩票中奖概率是 0.0001，我们拒绝了这个假设。 2 号彩票中奖概率是 0.001，我们也拒绝了这个假设。 对于任何一张彩票，我们都会拒绝这个假设。 类似的决策悖论其实很多。 五、小概率的决策很多时候我们面临小概率，但是我们还是应该满怀期待，为小概率努力。 比如：大家的孩子考上清华北大的概率不到 0.01，但是大家还是会努力培养孩子。 又比如，如果我们遇到一个疾病，存活率只有 0.01，我们还是应该期待奇迹，配合治疗。 面对小概率事件的时候，世界就是同步分裂成多个的平行宇宙，我们都有可能是幸运事件（小概率）发生的那个平行宇宙。 满怀希望，尽人事，听天命。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"我的移动开发程序人生 - 写在创业十周年","slug":"startup-10th-year-summary","date":"2022-05-22T10:50:37.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/05/22/startup-10th-year-summary/","permalink":"https://blog.devtang.com/2022/05/22/startup-10th-year-summary/","excerpt":"","text":"正值我在猿辅导工作十年，《新程序员》杂志的编辑小引老师邀请我撰文，作为第一代移动互联网开发者分享自己的成长过程和心得。文章经过多次修改，最终发表在 CSDN 微信公众号 和 2022 年第五期《新程序员》杂志上。 以下是文章全文。 一、序我是移动互联网时代兴起时的第一批开发者，见证了移动互联网将传统的 PC 互联网颠覆的过程。也有幸参与其中，推动移动互联网行业的发展。 本文介绍了我从接触计算机到选择职业开发道路，最后再承担起更多非技术工作的过程。希望我的程序人生能够帮助到大家，在面对新的时代机遇时抓住机会，与时代共舞。 二、接触计算机我的计算机之旅开始于 1999 年，那时我 15 岁，正在读初中。在我舅舅家里，第一次看到 Windows 98 电脑就被深深地吸引了。但那个时候，我对计算机完全没有概念，也不知道能做什么。我去学校对面的书刊亭，试图购买计算机入门的科普读物，但能够找到的只有《电脑报》。 2000 年，我升入高中，因为成都石室中学开设了 NOI（全国青少年信息学奥林匹克竞赛）课程，有幸得以学习计算机编程相关的知识。我还记得当时学的第一门语言是 Pascal，教材很难买到，于是老师自行复印了几本让我们学习。 那是一个让人热血沸腾的年纪！每天晚上做完作业后，我就会翻开编程教材，一句一句地读着那些晦涩的代码，希望参透其背后的算法逻辑。这可能是我这辈子学习知识最艰难的时候了，因为全年级参加这个课程的只有不到 5 个人，几乎没有交流，老师刚开始指导，也不太会讲，所以只能靠自己看书琢磨。 但现在回想起来，这真是一段 “打鸡血” 的日子。第一天看不懂就第二天接着看，差不多花了一个月的时间，终于把搜索算法看明白了。由于算法的原理大同小异，学完后再学其它的算法突然就容易多了。 也是在那个时候，我发现计算机相关的杂志变得更多了。《程序员》杂志在 2000 年创刊，我是它的第一波读者。那个时候，每个月我都会去报刊亭买《程序员》。其实好多内容我也看不太懂，但是它就有一种魔力，让我想读懂它。读着读着，好多也都懂得八九不离十了。 图 1：2003年的《程序员》杂志，摄于成都家中。 2002 年，我参加全国青少年信息学奥林匹克竞赛，由于太过紧张，平时能做对的一道题目写错了一个条件，本来是应该 “小于等于”，我写成了 “小于”。于是程序虽然通过了样例，但在更复杂的测试用例上都错了，最后得了一个省二等奖。如果当初这道题做对，我就可以拿到省一等奖，进而拥有保送资格。 虽然没有了保送资格，但因为备赛的原因，我早早就买了电脑，也接入了互联网。我在网络上查到北京师范大学对于省二等奖的学生，提供了报考自主招生的机会。于是，在 2003 年的非典时期，我自行从四川到北京，参加了北京师范大学的自主招生考试，并且通过了！我只需要上重点线即可被北师大录取。因为这件事情对我来说过于简单，所以高考整个过程心态都比较放松，最终超了重点线 100 分。 就这样，计算机改变了我的整个中学生涯，帮助我进入了北京师范大学。 三、玩转计算机大学开始后，我就继续参与计算机相关的竞赛和社团。竞赛上，我最终获得了 ACM-ICPC 国际大学生程序设计竞赛的亚洲区金奖（如下图）。而社团上，我则参与创建了北师大最大的民间 BBS 蛋蛋网。 图 2： 2004 年唐巧代表北京师范大学参加 ACM-ICPC 另外，我和室友也不断地接网站制作的外包工作，他负责设计，我负责开发，两个人在大学时期挣了不少钱。我自己还给中学生做竞赛培训的家教，这块其实收费很高，在 2000 年，一般的学科家教才收费 50 左右 1 小时，计算机竞赛的家教能收费 200 一小时。 所以，到了大学的第二年我就可以不用家里给钱，自己负担学费和生活费了。 到了研究生阶段，我进入了 IBM、网易这样的企业实习，每月的收入更加丰厚。那个时候 IBM 的实习工资一个月有 4000 元，加上研究生本身还有补贴，所以我还存了不少钱。 就这样，在大学里，计算机就让我深刻地感受到了它的力量，既满足了经济需求，也收获了足够的社会实践经验。 四、走上职业开发道路2010 年，我研究生毕业，拿到了百度、IBM、网易有道的研发工程师 Offer，最终选择了变化较多的网易有道，开始了职业开发的道路。 在网易有道，我先做了一年多的服务器端开发。当时正值国外 Twitter 火热，我有幸参与了网易微博的服务器开发。当时，我负责的是网易微博的搜索服务，为了支持海量的用户发贴能被实时检索到，我们基于 Lucene 开发了多级索引。整个研发过程对我帮助很大，让我知道了企业级的服务是如何被模块化拆解，并最终完成组合的。 2011 年，iPhone 4S 进入中国，我预感到移动端才是未来的行业发展机会，在咨询了很多朋友之后，果断申请转做 iOS 端开发。 当时的情景很像十多年前我刚学编程的时候。iOS 技术太新，基本上没有任何可以阅读的资料，公司内的同行也没几个，大家也都不精通，所以只能靠自己。但和初中不一样的是：工作和排期已经安排下来了，我只有 1-2 周的时间，需要完成自学并交付相关的工作。 又是一段打鸡血的时间，那个时候没有中文资料，我找到了斯坦福大学以及 WWDC 的视频，结合苹果官方的文档，每天用上下班坐地铁和周末的时间来学习。我从来没有这么高强度地学习英文资料，一段时间下来，不仅掌握了 iOS 知识，还把我的英文听读能力也练过关了。 为了让后来者们不像我学习起来这么难受，我从那个时候开始写 iOS 的博客和公众号，也由此结交了许多同行。一年下来，我认识的 iOS 开发者就遍布了几乎所有的互联网公司。 写博客的积累也让我有机会将自己的知识慢慢梳理出来，最终我出版了《iOS 开发进阶》，该书重印了 5 次，风靡一时。 五、从开发者到更多角色2012 年，我在网易的上司郭常圳邀请我加入猿辅导，作为核心员工参与在线教育行业的创业。在线教育行业在 2014 年开始火爆，而猿辅导的估值也以每年翻番的速度在增长。 在猿辅导，我的身份角色不停地在变化。 刚开始我是 iOS 开发的负责人，指导并招聘了很多 iOS 工程师。 2014 年，小猿搜题立项时，我成为它的产品技术负责人，开始接触产品工作。 2019 年，开始接触投放和运营的工作。 2020 年，组建了智能硬件团队。 2021 年，开始接触供应链的工作。 每一次角色的变化，对我来说都是一段似曾相识的 “打鸡血” 的日子。我会夜以继日地努力学习新领域的知识，希望自己的成长能够快速跟上业务的需求。有些时候，我做得还不够好，但好在公司一直给我机会，让我持续累进。 在从工程师成长为技术管理者的时候，我一边思考一边实践，慢慢形成了自己的方法论，即：将管理工作拆解成为管理业务、管理团队和管理技术。 管理业务时，我通过 Scrum 敏捷开发将整个业务开发流程管理起来。 管理团队时，我主要关注人的招聘、一对一指导，以及打造积极向上的团队工作气氛。 管理技术时，我主要思考业务发展与技术方案是否匹配，是否需要做及时的技术储备以应对业务增长。 从技术管理者到产品管理者，我主要学会了一些产品的核心方法论，主要为用户思维和数据思维。 用户思维是指能够将自己代入到用户场景中，思考解决方案的优劣性。在这个方向上，我学习了大量 MVP（最小可行性产品）的构建和测试方法。 数据思维是指一切以数据导向来评估产品方案。NPS、A&#x2F;B 测试、用户研究是数据思维的具体实践方法。 从产品负责人到业务负责人转变时，我更加关注商业模型的重要性，进而对市场端的获客工作有了大量的思考和实践。 在负责硬件和供应链团队时，我感受到了实体产品交付的挑战，对硬件产品在产品创新、供应链管控、渠道、品牌建设上的竞争局势有了更深刻的认识。 创业的这十年也是移动互联网高速发展的十年，我见证了抖音、滴滴、拼多多、美团的高速崛起，也见证了技术对于行业的变革。这也是技术开发者黄金的十年，很多开源的技术或社区能够在商业层面上带来巨大的回报。比如： 2017 年，MongoDB 上市，现在市值超 200 亿美元； 2018 年，GitHub 被微软以 75 亿美元收购； 2019 年，Elasticsearch 上市，现在市值超 80 亿美元； 2021 年，国内的开源分布式存储公司 PingCAP 完成新一轮融资，估值超过 30 亿美元。 图 3：MongoDB 的股价走势 这也是人工智能颠覆行业的一年，我们见证了围棋、德州扑克被 AI 统治，L2 级自动辅助驾驶已经广泛应用，信息流推荐和广告投放领域也早已被深度学习统治……各种商业化领域，都开始用深度学习进行功能改造。在教育领域，我们用 AI 来做： 语音识别，帮助学习者纠正不正确的发音； 语义理解，帮助学习者批改中文和英文作文； 图像识别，帮学习者检查口算作业； 自适应学习，给学习者推荐难度适中的题目，提高练习效率。 这黄金的十年给了我们太多的商业机会，锻炼了很多程序员成为行业专家，我个人也是这行业十年红利的受益者。 六、未来的机遇与挑战我是幸运的，赶上了移动互联网的红利，成为第一批的移动开发者。那个时候移动开发刚刚兴起，资料匮乏，而我抓住了这样的机会，在为行业分享移动开发心得的同时，也收获了技术的成长与行业的红利。 中国发展太快了，随着全球格局的变化，未来面临的发展机会和挑战都会越来越多。对于我们这一代技术人来说，只要顺应时代的变化，未来的机会只会更多。 对于新一代的开发者来说，我认为未来的领域会更加集中在用技术和算法进一步改造各种传统的行业，例如：汽车、物联网，以及用技术将人类社会朝着数字化的虚拟世界发展。所以，我推荐大家关注自动驾驶、人工智能、产业互联网、推荐系统、虚拟现实等领域，可能会有新的行业红利出现。 期待大家与时代共舞。","categories":[],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"改革开放的总设计师 - 读《邓小平时代》","slug":"the-time-of-dengxiaoping","date":"2022-05-16T04:48:16.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/05/16/the-time-of-dengxiaoping/","permalink":"https://blog.devtang.com/2022/05/16/the-time-of-dengxiaoping/","excerpt":"","text":"一、序最近读完了《邓小平时代》，作者是美国哈佛大学的教授傅高义（EZRA F. VOGEL）。 这是一本很厚的书，详细介绍了邓小平从出生到参与革命，三起三落，然后在粉碎四人帮之后掌权。他掌权后坚持党的领导，努力通过改革开放发展经济，最终使得中国走上经济发展的快车道。 这里面的艰辛与不易，只有看完了书中的细节才能真切感受到。 我们现在看起来无比正确的一些事情，在不同的时代背景下，却变得无比艰难。比如：坚持改革开放、实事求是、以实践来检验想法，坚持发展科技。 我们现在看起来相对容易的事情，其实实施起来异常艰难。比如：收回香港主权、应对苏联和越南的威胁、联合美国制衡苏联、重组领导班子、裁军。 我们小时候天天听新闻联播讲，但是不能理解的一些口号，看完书我也终于理解了。比如：“坚持四项基本原则”，“两手抓两手都要硬”，“有中国特色社会主义”，“社会主义初级阶段”。 以下是一些感悟。 二、维护国家的统一与稳定在我看来，邓小平做的最最成功的事情，就是在 89~91 年国家有可能剧烈动荡的危机阶段，坚持了稳定大于一切的重大决定。 这个决定非常艰难，但是我们看东欧和苏联这些共产主义国家，就是在这个年代没能稳定住国家，最终分裂解体，对长期的国家发展带来风险。分裂解体后，大部分国家的经济都陷入了衰退。 而最近的俄乌战争，也是当时的分裂种下的祸根。俄罗斯与乌克兰在分裂前本都属于苏联。 为了对比看到邓小平的伟大，我们先看看苏联解体的过程。 注：苏联相关内容主要参考自百度百科中的 ”苏联解体“词条 苏联在斯大林时代与新中国成立后的毛泽东时代非常相近，个人崇拜成为社会统治的主流风气。因为个人崇拜，就造就了比较强的个人集权。斯大林甚至对反对派进行大清洗。 1985年3月戈尔巴乔夫出任苏共中央总书记。当时因为国际上发展市场经济的国家都在迅速腾飞，所以他希望学习外国经验，发展市场经济，带动苏联快速把经济搞上去。于是他在 1990 年实施了 500 天计划。包括实行完全市场经济，大规模进行私有化，把权力下放到低一级政府手中等。 戈尔巴乔夫心愿是好的，但是他没有考虑到苏联当时的国情。整体的社会制度根本没有切换成市场经济的基础。快速的改革由于过于激进，苏联经济状况更加恶化，最终被迫中止了。 同时，戈尔巴乔夫在政治上开放言论，希望用更加自由民主的方式来统治国家。并且他主动和西方国家和解，希望结束冷战，营造出一个更加安全的外部环境。这些都是西方社会比较推崇的。他因为这一点还得到了 1990 年的诺贝尔和平奖。 但是他的这些政治政策并没能在国内团结好各个主要的政治盟友，最终使得苏联在 1991 年走上分裂。 分裂后的各国，虽然像乌克兰一类国家，进一步亲向西方。但是经济改革缺乏有效的制度监管，发展还不如继续推行社会主义国家的俄罗斯。 图片来自：https://www.kylc.com/stats/global/yearly_per_country/g_gdp_per_capita/rus-ukr.html 我们再看看中国与俄罗斯的对比。 图片来自：https://www.kylc.com/stats/global/yearly_per_country/g_gdp_per_capita/chn-rus.html 邓小平具体做了什么事情，使得中国没有像苏联那样解体呢？其实说起来就是第一个口号：坚持四项基本原则。 四项基本原则是： 坚持社会主义道路 坚持无产阶级专政 坚持中国共产党的领导 坚持马列主义、毛泽东思想 四项基本原则把所有试图以发展经济，人权，自由，民主等任何幌子来达到分裂国家的行为给中止了。使得国家得以在统治上稳定，一切统治上可能的错误，也可以更大胆地总结反思，不用担心政权不稳定。 三、坚持发展经济邓小平明白，国家落后就要挨打。这一点是他青年时去法国留学时深深烙印在他的记忆中的。邓小平家境很好，但是去了法国才发现国内的落后，作为中国人在外国也被各种歧视，他只能做最最苦力的工作。这使得他坚持以发展经济，改善人民生活，带动国家增强国际竞争力作为主要的执政目标。 在这一点上，邓小平和戈尔巴乔夫目标是一样的。但是邓小平的步子更加温和，也更有耐心。 邓小平首先在 1977 年恢复了高考，他一直坚信科学技术才是第一生产力。而要发展科技，首先要有足够多的科技人力。 当时，发展经济很容易与意识形态挂勾。大家都不敢做，怕被扣上资本主义的帽子。于是，当他发现他的意见不容易被大家接受的时候，他就开始反复讲一句话：实践是检验真理的唯一标准。让大家搁置争议，选一个小的地方试验试点。试验成功了，再向别的地区推行。这种方式很快就让大家都感受到人民生活的改善，从而放弃了之前以意识形态为基础讨论的行为。 四、坚持反腐败经济发展起来了，很容易让某些人由于权力集中而带来寻租空间。邓小平都明白，但是他知道如果因此停止改革发展的步伐，对国家影响更大，于是他提出新的口号：“两手抓两手都要硬”。 两手抓两手都要硬 是指：一手就是坚持对外开放和对内搞活经济的政策，一手就是坚决打击经济犯罪活动。 国家坚持廉洁的政策一直持续到现在，我们看到在近几年，也不断有高官因为在这方面的问题而落马。这使得政府在人民心中是权威的，正义的；也有助于商业环境更加纯粹追求提供产品本身的竞争力。 五、为中国发展找到合理的道理有了苏联的例子，中国作为另一个社会主义大国应该如何发展，备受世界关注。邓小平引入的“中国特色社会主义”，以及后面发展出的”社会主义初级阶段“，配合“一国两制”的思想，成为了中国在过去几十年团队大多数人，求同存异，努力发展的基础认知。 这些思想最大的价值是：它团结了大多数人，保证了国家的稳定，为大家齐心协力发展提供了保障。 近年来，我们进一步提出的共同富裕政策，更是延续了这样的思想。 六、小结有一些英雄是时代造就的，比如微信的张小龙。如果没有微信，在那个时间点也会有别的移动社交App 替代微信，成为国民 App。 但是邓小平不一样的地方在于，中国的繁荣发展不是必然的。看看苏联，乌克兰，越南，古巴，朝鲜。这些或大或小的国家，要么走向分裂，要么经济发展得并不顺利。 邓小平在没有任何外部国家参考借鉴的情况下，对内面对内部的各种争议声音，对外面临美国和苏联的威胁。他靠着自己的智慧和坚持完成了中国向更市场化的方向转型，为人民的幸福生活和国家的稳定做出了不可替代的、巨大的贡献。 邓小平说：“我是中国人民的儿子，我深情地爱着我的祖国和人民。” 当我读到这句话，我内心澎湃。 感谢你小平，给我们带来了现在的美好生活。我和你一样，也深爱着我们的祖国和人民。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"经济周期与中国崛起 - 读《原则2：应对变化中的世界秩序》","slug":"principles-for-dealing-with-the-changing-world-order","date":"2022-05-07T08:03:09.000Z","updated":"2024-01-06T14:52:37.941Z","comments":true,"path":"2022/05/07/principles-for-dealing-with-the-changing-world-order/","permalink":"https://blog.devtang.com/2022/05/07/principles-for-dealing-with-the-changing-world-order/","excerpt":"","text":"一、序最近看了一本书叫做《原则2：应对变化中的世界秩序》，作者是桥水公司的创始人达瑞欧。 看完这本书，我最大的感受是： 理解了中国人和美国人在认知上的一些根本性的差异。 在达瑞欧的视角下，学会如何分析中国和美国整体的发展状况。 在达瑞欧的预测下，中国未来整体的实力大概率会超过美国，这会带来一系列的冲突，甚至有可能是战争。 书中将这部分的中美冲突一一展开讨论，对我们评估未来影响自身切身利益的因素有了一些参考。 以下是一些分享。 二、中美文化的差异中美有一个文化上的巨大差异：中国人认为集体利益大于个人利益；美国人认为个人利益大于集体利益。 举几个面对新冠的例子： 当国家让大家打疫苗的时候。中国人大部分都会主动配合打疫苗；而美国人认为打不打疫苗是自己的权力，国家不能强制。 当国家让大家戴口罩的时候。中国人大部分都会主动佩戴口罩；而美国人，上到特朗普下到民众，都不太愿意遵守。 在中国，你如果让一个人因为是密接隔离 14 天，他大概率是配合的；而美国人则会把这个上升到人权自由。 类似的例子还有很多，比如持有枪支，发表言论等。中国人会更加务实，站在集体利益最大化角度来决策；而美国人会用“人权”来强调自己的个人利益，即便这对集体来说是有害的。 为什么会有这样的巨大文化差异呢？我个人认为是历史造成的。 中国是一个具有几千年历史的文化大国。在这几千年，华夏文明形成了自己独有的文化风格。这些文化风格随着时代的传承成为中华民族的一些民族性格。例如：中国古代有一个著名的故事，叫《孔融让梨》，这个故事让大家意识到为别人着想是更高尚的一种行为。类似的传统文化很多，最终形成了中华民族勤劳、朴素、谦让、内敛的文化。 在这种文化下，中国人喜欢少说多做，不喜欢给别人添麻烦，遇到利益的时候喜欢谦让。而这些文化在美国是没有的。 在美国，人们更崇尚自由，你想要什么你就主动去争取。别人的利益如果跟你的利益不一样，你就努力去说服别人达成你的目标。 在中国，人们喜欢用一种内敛的方式把自己的事情做好，不喜欢对别人指指点点。 美国人喜欢将自己的意见充分表达出来，然后为自己争取利益，也为别人争取相似的利益。所以说当美国人觉得他自己看来的人权被侵犯的时候，就会奋起为中国人来争取这些权利。但实际上中国人不一定特别在意这些权利。 中国人喜欢把事情默默的做好，相信水到渠成，该来的奖励最终都会到来，所以不太会主动为自己争取提拔和表现的机会，也不太愿意为了捍卫自己的观点与别人起激烈的冲突。 两种文化哪种更好？我觉得都有好的一面： 自由开放的人更加创新，更加积极主动； 而内敛的人更加为集体着想，会容易达成群体益利最大化。 但如果因为文化不一样，两个国家产生冲突，那就不好了。比如： 美国就不应该管那么多中国和别的国家的内政。中国人自己的事情自己知道怎么处理，中国人自己的权利自己知道争取。 中国面对美国也确实需要多表达。让美国人知道我们的立场，我们的态度，我们的文化差异。 三、经济周期与中国的实力达瑞欧在研究完过去 500 年各国的历史后，首先提出了周期的概念：每一个国家都会经历反复的周期化波动，周期包括： 新秩序 上升阶段 顶部阶段 下跌阶段 再次形成新秩序 如下所示： 而在不同的周期中，国家会有不同的特征。例如：在上升阶段，国家重视教育。而在下跌阶段，国家会有巨额债务。 为了计算各国间的实力以及考察各国所处的周期，达瑞欧提出了一个模型，用于评估国家的实力。这个模型包括以下几个维度：债务负担、教育水平、创新和技术、成本竞争力、军事实力、贸易、经济产出、市场和金融中心、储备货币地位、基础设施和投资、品格&#x2F;教养&#x2F;决心、国家治理&#x2F;法规、财富&#x2F;机会&#x2F;价值观。 然后，达瑞欧认为，中国处在上升阶段，中国现在的发展已经使得中国能够一定程度上对抗美国，这让美国感觉到了威胁。 比如：达瑞欧在书中写到，按照购买力平价折算，中国的 GDP 的总量已经超过了美国，达到了全球 GDP 的 23%（如下图）。 又比如：中国整体的负债水平较低，而美国政府常年赤字，其实是一直在通过借贷来消费。中国的出口一直大于进口，这使得中国一直在获得外汇储备。而美国的出口小于进口，这使得美国一直相当于在借债消费。 四、可能的冲突达瑞欧认为国家之间的战争分成五类，分别是： 贸易&#x2F;经济战。例如：加征关税、切断对方必需品进口。中国提出的“双循环”，就是为了应对这种危机而采取的措施。 技术战。例如：断供芯片，断供最新的各类工业软件，例如 Xcode，IntelliJ。 地缘政治战。例如：台湾问题，西藏问题，新疆棉问题。 资本战。例如：没收&#x2F;冻结冲突国家的境外资产。最近乌俄冲突，某些国家就把俄罗斯所有公民的境外资产都冻结了。 军事战。例如第一、二次世界大战。 书中讨论到了中国持有的美国国债问题。作者表示：中国虽然持有 1 万亿美元的美国国债，但是这仅占美国 24 万亿美元国债的很小一部分比例，所以即便因为中美冲突，中国将国债换成别的资产，对美国的影响也是很小的。 讨论到军事战时，作者有一个观点：当冲突双方都有了“毁灭一切”的能力时，战争反倒不容易发生了。这有点类似于上个世纪美苏之间的冷战。 五、教育和其它书中关于国家应该重视教育的观点，让我对“创造价值”的感受进一加强。对于一个国家来说，他应该努力创造价值，价值来源于两部分，一部分是出口，另一部分就是内部的经济循环。如何增加这两部分的价值呢？有一个很好的办法，就是提升生产力，提升创新能力，用更好的产品来满足国内外人民的需求。 这让我想起来，邓小平在改革开放的最初做的第一件事情就是恢复高考。科技是第一生产力，而科技的背后就是国家对教育人才的培养储备。做这种投资回报是很慢的，因为培养出一个优秀的科技人才需要花费非常长的时间。而国家在这上面的投入有助于这些人才最终产生科技创新，提升生产力，反过来创造更多的对人民有价值的产品，提升整体的 GDP 的收入和国家的商业竞争力。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"价值的思考","slug":"the-thinking-of-value","date":"2022-04-15T14:01:29.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/04/15/the-thinking-of-value/","permalink":"https://blog.devtang.com/2022/04/15/the-thinking-of-value/","excerpt":"","text":"我最近对于价值有了一些思考，分享给大家。 这个世界的经济运行，是建立在对于价值认可的基础上的。比如：我们去餐厅吃饭，一定是我们认为这份餐给我们带来的价值，大于我们付出的钱，我们才会做出购买的行为。 一、价值的来源价值来源于哪里呢？ 价值来源于人们的各种需求，包括：马斯洛提到的各种需求：性，安全，食物，社交，自我实现，自由。 价值也来源于人们追求更好，更丰富的生活，比如住更大的房子，吃更好吃的东西，享受更好的服务。 价值也来源于效率的提升。比如原来生产某个东西很慢，但是上了机器，生产变更快了。 二、人和公司的存活因为人和公司的存活，需要消耗一些价值，比如人的消费就是消耗别人创造的价值。公司付出的各种人力成本，生产成本，就是消耗别人创造的价值。 所以，他们需要创造出更高的价值，才可以通过价值交换，换得自己需要的东西。为了方便交换和标定价值，所以我们有了钱。 于是人和公司，都通过交换将自己创造的价值换成钱，再拿钱换别人创造的东西。 三、价值的衡量为了衡量人，公司以及国家在创造价值上的差异，我们有了各种指标。 对于国家来说，GDP 就是国家产生的价值。 对于公司来说，营业额就是它产生的价值。 对于个人来说，他为公司的营业额做出的贡献，就是他的价值。 拆分到每个人的贡献不太好衡量，但是一个业务的人均销售额，就是一个重要指标来衡量公司的人力投入效率。 我有一个朋友，他说他的公司人均能做到 500 万的营业额，就表示每个人创建了 500 万的价值。当然，这里面有很多价值是来源于产品的原材料本身，增值的部分才是每个人真正贡献的价值。 四、工作中的价值视角有人说：为什么公司不给我涨薪，为什么公司要裁员，为什么不给我更多机会，我感觉他们的想法都不对。他应该想：我应该如何为公司创造价值，怎么样可以创造更多的价值。或者说，如果我在这家公司无法创造出足够多价值，我是否应该换一个公司。 因为公司的钱不是白白变出来的，公司的钱也是通过价值交换挣来的，如果员工不能创造更多的价值，那他就不能获得更多的回报。 从价值视角，也可以感受到公司从产品研发到市场推广过程中，不同岗位对于公司价值的贡献变化。 在产品研发期，产品创新是在试图解决用户需求，创造巨大的价值。 而产品研发完成后，市场和销售部门又在从用户获取角度，给公司创造巨大的价值。 价值创造角度的思考，也是一种合作共赢的思维。因为只有你为别人带来了收益，别人才会给你带来收益。 五、个人成长中的价值视角在提升个人技能的时候，也需要时刻思考：自己的技能在价值贡献中的作用。 比如：如果你是一个管理者，那么提升你的组织能力价值就很大，因为你可以将团队的贡献通过你的能力扩大。 比如：如果你是一个产品经理，那么你的价值就是通过迭代使产品本身的价值提升。例如用户 NPS 值，复购率，留存率等核心指标。 比如：如果你是一个程序员，那么你的价值也是应该体现在用技术提升产品的价值。比如实现产品功能，减少崩溃率，减少加载时间等等。 如果你提升了一项能力，但是最终没有转化为公司产品的价值，那就没什么卵用。比如你是个运营岗位，抽空学了个编程，但是工作中没有用上，那就没价值。但是你如果通过编程，优化了运营岗位的一些工作，那就是有价值的。 六、结语所以，不管是个人，公司还是国家都应该努力提升自己的价值，只有这样才能保持竞争优势，获得足够回报。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"最近的投资感悟","slug":"invest-summary-2022","date":"2022-03-27T02:27:02.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/03/27/invest-summary-2022/","permalink":"https://blog.devtang.com/2022/03/27/invest-summary-2022/","excerpt":"","text":"一、序这几个月，美港股的中概股持续下跌，A 股也跌，我之前配置的不少指数增强产品亏损接近 10%。只有 CTA 产品略微盈利，但收益也不算高。我的美股去年 10 月因为一个偶然的原因全部清仓了，逃过了一劫。 亏损让人反思：到底之前的策略错在哪里。以下是一些感悟，分享给大家。 二、投资的本质2.1 投资是为了获得超额收益投资的本质是希望获得超额收益，不然就还不如存银行。 之所以投资可能获得超额收益，是因为投资有一定风险，所以大家是用风险来换取了获得超额收益的概率。只要整体的数学期望是超额的，那么长期看来收益就是超额的。 为了看清楚投资的决策逻辑，我们来做一些假设，从而控制变量。 我们假设：有一家公司 A，它估值 100 亿，每年利润固定是 3 亿，每年它都把 3 亿利润分红给股东。 同时，有一个低风险理财产品 B，年化收益率是 3%，保本保息，随时申赎。 如果不考虑 A 的经营风险，那么 A 和 B 就是两个完全一样的理财产品。 假如 B 的收益率比 3% 还高，那你就应该买 B，反之就应该买 A。 大部分时候，买股票就应该是和买理财产品一样的逻辑，你只是希望获得高于无风险收益产品（例如国债等）的投资回报。 实际情况当然比我们的假设复杂得多。比如，很多公司就根本不会分红。那这个时候，你的收益可能是来源于因为利润高而带动的股价上涨。有一些公司甚至亏损，那你的收益可能是来源于未来能够挣很多钱的 “概念故事” 带来的股价上涨。 2.2 投资收益来自于哪里大部分收益来自于：1、分红；2、股价上涨。 如果公司股价不变，收益就来自分红。如果分红的同时股价也在变动，那收益就是分红叠加上股价的变化。 如果公司不分红，你的收益只能来自股价上涨，如果股价下跌，你就是亏损的。 在不分红的情况下，投资收益来自于股票价格的持续上涨。 那什么情况下，一个不分红的公司，股票可以持续上涨？ 2.3 股价持续上涨的理由是盈利能力。 公司的股票可以因为追捧或者概念涨个几个月或一两年，但是如果要持续一直不断上涨，五年，十年甚至上百年上涨，只有一个原因：这家公司持续在挣钱，如果它不分红，那么经营现金流就会持续增加。 举个极端的例子：一个市值 100 亿的公司，如果它持续挣钱不分红，当它的现金到了 500 亿的时候，如果没有特别的原因，它的股价至少应该是 500 亿。 因为如果太低的话，某个投资机构完全可以把它收购下来分红，就可以把自己收购的本金拿回来。所以，市场的套利机会会让股价回归正常值。 2.4 股价的支持如果一家公司股票一直跌，支持剩下投资人不卖的信心是什么？ 还是盈利能力。 只要公司盈利，股价低到一定程度，利润分红收益明显高于无风险理财产品，同时又比较稳定的话，那么管理层或者投资机构都会去套利，从而稳定股价。 2.5 互联网的泡沫我现在发现互联网的公司股票，概念的东西太多太多了。 比如哔哩哔哩吧，它总给你讲用户要做到多少多少亿，但是你不知道它到了那一天商业化的能力能不能保证盈利。如果买入的价格很高，那到时候万一盈利不及预期，就会遭遇很大的估值下跌。 又比如滴滴吧，一直说自己是很好的生意，你算下来也是很合理的，但是财报亏得一塌糊涂。那到底应该怎么估值呢？ 过去 10 年互联网创业热火朝天，互联网的概念，有多大的概率真的变成了事实？有多少公司最后真正拥有了高盈利能力？ 很多公司，做到很大很大以后，才发现其实盈利也就那么一点点，增长也乏力以后，戴维斯双杀，估值就掉得非常厉害。比如微博，比如已经退市的优酷，比如爱奇艺。 2.6 怎么买股票​互联网早已经没有了红利，甚至现在从反垄断角度来看，互联网反倒是不利的。在现在的市场环境，股票的购买还是应该回归到盈利能力上。 同时，从共同富裕角度看，公司盈利也应该建立在创造社会价值，解决人民需求这个角度上，通过创新和提效，获得合理的利润。 找到了这种股票，怎么决定买入价格呢？直接和无风险的理财产品比较比较，看看自己承担了多少风险，对等的预期增长对赌合不合理，有没有安全边际。 三、小结 投资是为了获得收益。 因为可以套利，盈利能力是股价的有效支持。 概念和增长突然不及预期会遭遇戴维斯双杀。 应该买那些稳定盈利并且创造社会价值的股票。 买的时候，留够安全边际，不便宜的不碰。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"极致 MVP - 读《做对产品》","slug":"the-right-it-book-summary","date":"2022-03-20T15:24:01.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/03/20/the-right-it-book-summary/","permalink":"https://blog.devtang.com/2022/03/20/the-right-it-book-summary/","excerpt":"","text":"一、序最近海晨给我推荐了一本书，叫《做对产品》，英文名叫《The Right It》。作者是谷歌前工程总监索维亚，曾领导过谷歌广告团队。 索维亚写这本书源自于他的第四个创业项目：这个项目花了 2500 万美元的融资，历时长达 5 年，最后失败了。但他在这之前曾经 3 次创业成功。 这次失败的经历让他重新审视整个创业过程，从而发现产品本身的方向不对是失败的核心原因。 于是，如何最小化成本、最快速地去验证产品成为了本书的命题。 以下是一些总结。 二、创业失败率与失败原因作者引用了尼尔森公司的市场调研：80% 的新产品表现远低于预期。而低于预期的原因主要有三个（简称 FLOP）： 获客遇到问题：Failure due to Lanuch 执行遇到问题：Operations 产品定义遇到问题：Premise 而大部分的问题集中在第 3 个：产品定义遇到问题。即：产品的创意有问题，用户根本不刚需。 所以，定义好产品，保证在“做对的事情”，成为了创业的关键。 三、空想之地的危害人们常常通过思考来判断需求是否成立，通常的办法就是假设自己处于目标消费者的场景，但是这种思考有很大的局限。 最大的问题就是用户其实不知道自己是否真的接受它，除非你亲自把产品放到它手上。 书中举了一个 Uber 的例子：作者刚从别人那儿听说 Uber 的时候，觉得自己绝对不会接受坐陌生人的车，而且司机还没有专业的出租车司机持证。但是他自己尝试体验过一次之后，就完全不这么想了。 从逻辑上来看，作者的理由很合理：安全感是人类的最底层需求，陌生人的车 + 没有受过专业训练的司机 &#x3D; 危险。 但是实际体验下来，作者发现司机很随和很体贴，整个乘车过程感受很好，安全感问题一下子就不是问题了。 四、用数据替代空想为了防止各种空想带来的问题，作者在原型前，首先引入了一个数据量化的方法，这个方法叫：「XYZ 假说」。 「XYZ 假说」将用户需求用量化的方式来描述：至少 X% 的 Y 会 Z。 例如，初始的创意： 在污染严重的城市中生活的一些人会有兴趣购买价格合理的设备用于净化空气。 以上描述很模糊，什么是“污染严重”？什么是“价格合理”？「XYZ 假说」将这些量化，改成了这样： 在 AQI 超过 100 的城市中生活的人，有至少 10% 的比例会购买售价为 120 美元以内的空气净化机。 「XYZ 假说」进一步将验证范围缩小，演化成一个待办的可具体测试目标，如： 在公司 A，有至少 10% 的比例会购买售价为 120 美元以内的空气净化机。 然后拿着上面的假说，就可以在公司 A 做相关的原型实验了。 五、预型：快速化原型作者创造了一个新的词：预型（pretotype），以区别原型。 在我看来，这是一系列快速化原型测试的简称，用以强调快速、低成本。 书中举了很多方法，比较有意思的有： 土耳其机器人。用真人躲在机器里面假装机器完成任务，用以验证需求是否成立。案例是：IBM 当年测试大型的语音输入机器是否刚需。 匹诺曹预型。假装你真的拥有它，然后在各种场景中使用它，观测效果。案例是：Palm 的创始人当前就是用木制的假设备来模拟每天的操作。 假门预型。做一个假的店面门，看看有多少人被吸引进来。 一夜情预型。做一次服务招募，看看需求和体验强弱。案例是：爱彼迎（AirBnb）。爱彼迎的创始团队因为没钱付房租，从而尝试把房间的 3 个床位出租补贴自己，很快有 3 个人购买了这样的服务，于是他们发现这个需求是成立的。 改标签预型。把一些产品的标签进行更改，让用户以为这个产品就是你宣传的产品。 六、分析预型作者提供了几个分析预型的工具： 切身利益卡尺。强调一定要让用户付出成本，才能把预型中的结论总结成正向案例。付出成本包括：留下邮箱，留下电话，预付定金，预约详细了解等。而一般的“感兴趣”都不算作正向案例。 TRI 计量仪。将测试结果分为 5 个范围，用于不同范围成功的可能性。 量化预型的成本。用时间成本（单位是小时）和金钱成本来描述预型方案的敏捷程度。这里时间单位是小时，用以强调大部分的预型应该在 48 小时内完成。如果一个预型要做 1 个月，就太复杂了。 七、调整利用预型、TRI 计量仪，我们可以不断调整我们的「XYZ 假说」，然后从新做预型测试。 书中举了很多案例，最详尽的一个案例是作者自己的 BusU 项目，这是一个在上下班通勤车上进行教学的服务： 通过一轮问卷预型，作者迅速调整了自己的「XYZ 假说」。 通过一轮一夜情预型，作者发现晚上的教学效果非常差，并且大家不愿意购买 10 周的课程。 八、小结 产品没做对，是大部分创业失败的原因。做对的事情至关重要。 空想很难判断创意是否靠谱。 用「XYZ 假说」将用户需求用量化的方式来描述：至少 X% 的 Y 会 Z。 用预型：快速化原型来验证需求，方法包括：土耳其机器人、匹诺曹预型、假门预型、一夜情预型、改标签预型等。核心就是要快，要省钱。 预型中一定要让用户付出成本才算正向案例。 利用 TRI 计量仪来调整「XYZ 假说」，不断快速测试。 再次感谢海晨推荐，特别棒的一本书，也推荐给大家~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"央行是干嘛的 - 读《金融的本质》","slug":"central-bank","date":"2022-03-12T12:35:36.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/03/12/central-bank/","permalink":"https://blog.devtang.com/2022/03/12/central-bank/","excerpt":"","text":"一、序最近读完了《金融的本质》，作者是美国的央行—-美联储的前主席 伯南克 。 伯南克任职期间为 06 ~ 14 年，他任期内美国及全球爆发了严重的经济危机，而他通过降低利率、量化宽松，以及承担最后贷款人职责等手段，有效降低了经济危机对美国的影响。 以下是我的一些笔记。 二、央行的使命央行是一个特殊的机构，在伯南克看来，央行主要有两大使命： 1、保持经济的稳定增长 2、维持金融的稳定 这里面，经济和金融的差别困扰了我一阵子，原来它俩不是一个意思： 经济一般是人类的价值创造过程。所以“保持经济的稳定增长”主要就是指 GDP 能够持续增长，保证就业率，同时维持低通胀。 金融是指对经济活动中对资金本身的一些“交易”，比如银行、证券、保险、债券。所以”金融稳定”就是指各种借贷关系是正常的，没有大面积的违约。 那央行有什么特殊的技能，能够达成这两个使命呢？这主要靠国家赋予它的两个特殊的权力： 1、制定经济活动中各种规则的能力。比如：调节利率、存款保证金比例、中期借贷便利（MLF）等等。 2、承担最后贷款人责任，为各种金融资产兜底。 下面我展开说说我对这两个职责的理解。 三、保持经济的稳定增长经济衰退肯定是不好的，因为经济衰退情况下会有大量的失业，通货紧缩。在通货紧缩的时候，因为钱升值了，借贷的人就会发现钱越来越值钱，但是他以前借的 100 万还是需要还 100 万，相当于他的债务内在价值越来越高。这种现象会使得大家更不愿意花钱，带动整体经济进一步下滑。 3.1 降低利率面对经济衰退，央行通常的办法就是降低利率，同时减少社会融资成本。美国 08 年经济危机，美联储为了减少社会融资成本，把长期利率降成了 0%。 3.2 量化宽松然后美国施行了多轮的量化宽松政策，具体的做法是购买了大量的国债。大量的国债被购买后，市场上流通的债券就只剩利率更低的企业债等产品，这样就可以带动社会各种借贷的利率下降，从而刺激经济活动。 在本书中，伯南克否认量化宽松政策是“直接印钱”（书中第132页），因为： 钱是从存款保证金余额中借出来的。 量化宽松主要购买的是国债，国债到期后可以将本金及利息收回。 但是，量化宽松到期后能不能把钱全部收回，也取决于到时的政府财政状态，如果经济没有好转，大家还是缺钱，这样就只能到期继续购买国债，相当于往市场中注入了收不回来的现金。 3.3 直接印钱刺激经济的手段还有直接印钱。 印来的钱可以直接发给大家。比如：2020 年，美国总统特朗普的 2 万亿美元的财政刺激计划里面，就有 2500 亿发给了个人。其中年收入低于 7.5 万美元的单身人员将获得 1200 美元。 印来的钱也可以用来加大基础建设投资，我国面对 08 年金融危机时提出的 四万亿投资计划 就是这样的例子。 基础建设的投资可以带动上下游产业，从而把印出来的钱转变成大家的工资，进而刺激消费。但是这种行为多少还是会带来一定程度的通货膨胀。我为此专门查了一下中国的 CPI 数据，当时 CPI 在 08 年上升到 5.9%，但是后面迅速回落了，可见政府对价格的调整做得还是挺好的。 3.4 对面经济泡沫经济过热也是不好的，如果央行觉得经济泡沫太多，就会想办法抑制投资，给经济降温。常见的办法就是刺激经济的逆操作：加息，提高存款保证金，退出量化宽松政策等。 3.5 CPI 多少是合适的书中关于这个有不少讨论，但并没有提供详细的精算过程。核心就是：既要保证为波动留够安全边际，保证不会通缩；又要不能太高，带来泡沫。最终实践出来的物价稳定的低通胀率是 2%。 拿这个标准来看，中国过去 5 年做得都是比较优秀的，除了疫情等原因外，中国在 16 - 19年的 CPI 都稳定在 2% 左右。 四、最后贷款人最后贷款人是一种安全机制，让大家可以安心地把钱放在各种金融机构中。 我稍微展开解释一下： 银行收到大家的存款后，其实是会借贷给需要的企业或个人，大家的存款很多是短期的，而借贷很多是长期的。比如我自己的房贷，就是 30 年的，但是我存在银行的定期，大多是一年期的。这就造成了资金的错配。 资金的错配使得如果大家都到银行挤兑的话，银行是不可能拿出那么多现金来的。如果银行为了强行付钱来快速变卖资产或债务，就会造成资产价格的下降，进一步冲击经济。 所以，央行就承担起最后贷款人的责任，当真的发生挤兑的时候，央行可以直接拿银行的资产当作抵押，为银行提供现金。 以上只是一种理论情况。当你相信央行会行使最后贷款人责任的时候，你就建立了资金的安全感，从而挤兑行为就不会发生了。 在实操中，国内确实出现过银行倒闭的现象：2020 年包商银行 破产，央行就承担起了最后贷款人责任，为民众的存款提供保障。 但是根据《存款保险条例》，存款保险实行限额偿付，最高偿付限额为人民币 50 万元。所以超过 50 万以上的存款还是无法赔付。个人如果有大量的存款，可以考虑分散到多家银行中。 另外保险和理财产品大多数是银行代销，其实并不属于银行的自营业务，在发生风险的时候，也无法按照《存款保险条例》赔付。 比如之前大量的 P2P 理财产品暴雷，就不能指望央行来承担最后贷款人责任。 五、小结作为独立机构，央行的使命是维持经济和金融稳定，保证就业率和低通胀率。它通过调节利率、调节存款保证金、逆回购、调节 MLF、购买国债、增发货币、承担最后贷款人等方式来实现以上目标。 六、参考资料 经济的定义：https://baike.baidu.com/item/%E7%BB%8F%E6%B5%8E/403149 金融的定义：https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D 量化宽松的定义：https://baike.baidu.com/item/%E9%87%8F%E5%8C%96%E5%AE%BD%E6%9D%BE/9019987 中央人民政府网站公布的核心经济数据：http://www.gov.cn/shuju/hgjjyxqk/detail.html?q=1 四万亿投资计划：https://zh.wikipedia.org/wiki/%E5%9B%9B%E4%B8%87%E4%BA%BF%E6%8A%95%E8%B5%84%E8%AE%A1%E5%88%92 常听到的“MLF操作”，对我们到底有啥影响: https://m.21jingji.com/article/20210522/herald/ff87816c4132382ef27b46127121c1a1.html 逆回购：https://baike.baidu.com/item/%E9%80%86%E5%9B%9E%E8%B4%AD/2612290 《存款保险条例》: http://www.gov.cn/zhengce/content/2015-03/31/content_9562.htm","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"理解改革开放 - 读《置身事内》","slug":"china-revolution-insight","date":"2022-03-10T15:04:38.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/03/10/china-revolution-insight/","permalink":"https://blog.devtang.com/2022/03/10/china-revolution-insight/","excerpt":"","text":"一、序最近看完了一本讲中国政府与经济发展的书，叫《置身事内》，作者是复旦大学经济学院副教授兰小欢。 这本书一开始看就停不下来了。原来过去几十年，中国遇到了这么多发展问题，中央政府通过不停地改革试错，摸着石头过河，保证了中国经济的持续发展。 了解完当时的背景，“置身事内”之后，你很容易就理解各种政策背后的原因了，有一种恍然大悟的感觉。 以下是一些笔记。 二、从财政包干到分税制书中详细介绍了国内改革开放后，做得比较成功的经济改革。 第一次改革，是 1985 年开始的财政包干制度。不同于之前的大锅饭，全国各地搞承包责任制，提高生产积极性。 大锅饭因为干好干坏一个样，极大地损害了大家的劳动积极性。所以很容易就想到了通过多劳多得来刺激大家的积极性。 但这样的制度落地，其实也是不容易的。因为当年这种行为被左派指责为走资本主义。邓小平的用“不管黑猫白猫，抓到耗子就是好猫”来鼓励大家尝试，让大家把重点放到如何有效改善人民的生活水平上。 于是，在 20 世纪 80 年代，农村搞土地承包，城市搞企业承包，政府搞财政承包。 在那个年代，财政包干制度有效促进了经济发展。但是到了 90 年代，承包制的问题开始凸显： 承包制让地方收入越来越大，中央缺钱。 地方有隐匿收入的动力。通过计划外收入，违规减税等方式将企业利润留给自己，不分给中央。 因为地方企业所得税归地方，造成地方保护主义盛行，不利于构建全国统一市场。 以上的问题主要是体现在增值税和企业所得税。具体的改革如下： 1994 年进行了增值税的改革。增值税以前由地方独占，改成中央 75%，地方 25%。并且中央通过“返还”保证不比以前少。 2002 年进行了企业所得税改革。地方企业税收以前归地方，现在改成中央 60%，地方 40%。中央通过“返还”过渡。 分税制是 20 世纪 90 年代推行的根本性改革之一，也是最为成功的改革之一。改革扭转了“两个比重”不断下滑的趋势： 中央占全国预算收入的比重从改革前的 22％ 一跃变成 55%，并长期稳定在这一水平； 国家预算收入占 GDP 的比重也从改革前的 11％ 逐渐增加到了 20％ 左右。 最近正值两会召开，从政府工作报告中，我们能看到 2021 年的国家预算收入 20 万亿，占 114 万亿 GDP 的 17%。可见分税制改革一直有效地保证着国家预算收入的稳定。 经济改革一直在持续，书中没有提到的是：在 2016 年，为了避免重复多次计税，减轻制造业的税赋压力，国家将营业税改为增值税，同时将增值税的分成改成中央和地方各 50%，进一步刺激经济健康发展。 三、从分税制到土地财政全国预算收入是不包括卖地收入，卖地收入被统计在政府性基金收入中，从《2021年财政收支情况》来看，2021 年有 8.7 万亿的国有土地出让收入。 分税制改革使得中央有钱了，但是地方却很缺钱。这个时候，1998 年的两项改革：取消福利分房和地方政府垄断国有土地出让，使得卖地收入成为地方政府的主要收入来源。 土地财政使得中国加速向城镇化方向发展，同时地方政府可以通过廉价出让工业用地来招商引资，刺激经济、增加税收、解决就业。 因为地方政府需要刺激经济，通过卖地获得的收入，可以通过政府主导的投资，来达成招商引资的目标，带动经济进一步增长。所以，地方政府可以深入介入经济活动中。书中举了京东方等企业的故事，说明政府对于集中力量发展重点产业的优势。 类似的例子我们不断地可以见到，比如特斯拉落户上海的超级工厂，就是一次成功的政府主导的招商引资，带动新能源上下游产业链成长的案例。 四、中国的政治架构书中还介绍了中国的政治架构：党委、政府、人大、政协。从中央到省、市、县层层复制同样的架构。党委领导政府、政府具体施政、人大决定法律、政协提意见和建议。 最近北京在开“两会”，就是指全国的人民代表大会和政治协商会议。人大班子每 5 年换届一次，现在是到了第十三届，而人大会议每年开一次，今年（2022年）是第五次会议。 党委和政府的官员通常都是交叉任职，但是又不是绝对的人事重合关系。你可以理解成两个大的不完全相交的圆。 五、小结中国改革开放几十年来取得了空前的成功，离不开我们在经济发展上的不断创新和改进。 《置身事内》介绍了中国发展中的历次经济政策调整以及带来的效果，让读者能够理解并且认同到改革的巨大价值。 本书不但有助于大家理解各种经济运行的原理，也有助于理解中国特色社会主义经济环境下，各种改革如何落地。 如果再对比上过去几十年别的国家的经济发展速度，本书还能让读者建立起较强的民族自信和自豪感。因为照搬美国发展模式的一些国家（比如乌克兰），事实证明发展得并不顺利。 六、参考资料从本书出发，我也查了一些政府网站的资料，一并分享给大家： 《全国预算收入定义》 《我国的中央和地方财政关系》 《2021年财政收支情况》 《全国土地收入去年6.5万亿 钱都花去哪了？》 《中华人民共和国消费税暂行条例》","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"学会快速地估算","slug":"fast-count-ability","date":"2022-03-06T03:20:01.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/03/06/fast-count-ability/","permalink":"https://blog.devtang.com/2022/03/06/fast-count-ability/","excerpt":"","text":"一、从决策说起这个世界上，任何决策都会有支持它的理由和反对它的理由。而如果你把这些理由都写到纸上的话，你会发现一开始很难做决策。 为了做出好的决策，你首先就会给这些理由赋予权重。通过权重，你就能做减法，把相对不重要的因素给忽略掉，关注核心的矛盾。 一个好的决策，就是关注到核心问题后的权衡。而估算，可以帮助我们快速收集决策因素。 二、如何快速估算要拥有快速估算能力，需要： 有拆分的能力，能够抽象出核心的计算路径。 有创新的能力，能够用更合适的角度来描述问题。 有公式化的能力，用一个公式简化所有计算。 下面我用管理供应链遇到的一些场景给大家展开举例。 2.1 印刷成本的估算假设我们需要分析供应链印刷品的价格。 首先，我们可以进行成本的拆分。通过研究，我们可以把价格拆分为原料价格、印刷工价、运输费用等。而印刷的工价又可以拆分为各种工序的工价。如果某些成本占比很小，那么你就可以忽略它。比如印刷品送货前的仓储费用很小，就可以忽略掉。 接着我们可以分析不同印量，不同工艺下面，主要的各项成本的占比。我们发现原料成本和工价成本加起来占到成本项的 90% 以上，那么我们就可以直接将印刷品的成本简化成:成本 = 原料成本 + 工价。 如果进一步我们发现二者的成本基本上大概一样，那我们就可以把成本简化为:成本 = 原料成本 x 2。 然后我们要有办法快速计算原料成本。 印刷品的原料成本传统的计算方式是： 先计算需要用多少纸，然后折算成令，然后再计算每令的价格。 每令的价格是通过每吨的价格除以纸张每平米克重，再乘以每令纸的面积。 这样的计算过程，使得你不用计算器很难快速算出来。通过观察，我们发现不同克重的纸张在采购的时候基本价格都集中在 6000 元每吨左右，所以我们可以简单地简化：每克纸的价格 = 6000 / 1000 kg = 6000 / 1000000 g = 0.006 元 之后，我们如果要计算一个印刷品的成本，我们可以将公式简化为：成本 = 克重 * 0.006 * 2 即可。 那克重如何快速获得呢？很简单，放到称上称一下，或者拿手简单掂量一下，就会有一个快速的估计出来。 接下来我们要把这个公式“通用化”，可以看到，成本公式里面有两个系数是会变化的： 系数一：纸张每克成本。在上面这个公式中，该值是 0.006。这个对不同的印刷品其实不太一样，而且纸张价格会波动，造成计算偏差。比如白卡纸去年最高的时候超过了 1万一吨。所以我们可以根据实际的品类，来调整纸张每克的成本。如果在白卡纸1万一吨的时候，如果是一个白卡纸为主要原料的产品，它的成本速算公式中的每克成本就应该从 0.006 改为 0.01 。 系数二：纸张与工价的成本比例。不同品类的产品，纸张与工价的比例其实不太一样。比如手工类比较多的印刷品，其纸张与工价的成本比例可能不是 1:1，可能是 1:2。这样，在速算的时候，系数 2 就应该调整为 3，这样估算的时候才相对准确。 所以，对于某一个印刷品类，一个相对通用的成本速算的公式应该是：成本 = 产品克重 * 纸张每克单价 * (1 + 工价成本占比/纸张成本占比) 2.2 运输成本的估算再拿运输的成本估算举例。运输涉及不同的计算方式，有按托算的，有按立方米计算的，不同的车能够装的托数也不太一样，造成估算困难。 但是如果我们把各种托数、公里数的信息放到一张表里面做人肉拟合，就会发现 一托一公里一块钱 可以很快估算出成本信息。 然后在这个基准上，把比较近的（例如 100 公里以内的），成本乘个 1.5 左右的系数；把比较远的（例如 1500 公里以上的），成本乘个 0.5 左右的系数，就可以很快估算出大概的成本。 2.3 组装工序的成本估算供应链的组装工序很复杂，每次报价都很乱，我们也搞不明白各个环节是不是真的要那么多钱。 直到有一个供应商介绍了一种方法，特别简单：供应商说，你自己把这个东西拆下来组装一遍，看看要花多少时间组装，我们就按那个时间来估算组装费用。 大家一听都觉得好，因为组装产线肯定比单个人做效率高，如果我们简单用单个人做的时间，再算上工人的每小时平均工资，就可以很快估算出这个费用，比拆分工序简单快捷多了。 2.4 注塑成本的估算注塑成本最初我们也搞不太明白，也是一个供应商教我们，直接拿秤称重量。 就像纸张那样，我们可以通过重量来估算原料的成本，然后通过简单地统计各种注塑件原料成本与工费的比例，就可以列出几套速算公式出来。 2.5 公司估值的毛估估公司的估值计算也是一门学问，大家通过财报很难获得很精确的价值计算模型，所以只能估算。 有人用市盈率算，有人用市销率算，有人用现金流折现算，有人用对标公司算，总之都是为了决策而快速获得核心数据的办法。 算得不精确没关系，大差不差就行。 小结快速估算可以让我们的决策变快。面对问题，我们需要抽象出问题的关键因素，构建出一个简单的公式模型，这样才能让计算变得简单，方便我们决策。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"2021 年个人总结","slug":"2021-summary","date":"2022-01-01T02:01:29.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2022/01/01/2021-summary/","permalink":"https://blog.devtang.com/2022/01/01/2021-summary/","excerpt":"","text":"一、工作2021 年真是神奇的一年，不管是我们公司、还是在线教育行业、还是互联网行业都经历了巨大的变化。分享一下这一年的收获。 在线教育行业我们公司在 2021 年初还在赞助春晚和冬奥会，后面从刚开始广告受到限制，最后到了 6 月份具体的双减细则出台，公司和行业各到的影响逐步变大。这些限制包括： 广告投放的限制 NGO 的要求 资本的限制 以下是一些展开介绍。 广告投放的限制带来的是原有的主要获客转化模型彻底失效。所有公司的新增用户变得困难，同时由于前期投放带来的用户质量偏低，流失增加，造成整体用户规模明显下降。 NGO 的要求具体是指：K9 业务需要在 21 年底前转成非营利性机构。这样就可以有效限制投资进入这个行业。因为对于非营利性机构来说，利润是不能用于分红的，这样风投自然就不再进入 K9 行业了。行业没有了新增的融资。 虽然 NGO 的限制只是针对 K9，但是大家对整个教育行业产生了恐惧，从而造成资本市场整体对这个行业悲观的情绪。这带来的效果就是：没有哪一家在线教育公司能够拿到新的融资，不管是素质的还是非素质的。 没有了新增融资，这要求大家需要迅速调整到赢利的状态。但是原本的烧钱扩大规模的姿势已经摆好，调整到整体赢利的状态并不是一件容易的事情。 没有新融资+需要快速赢利，这两个要求造成超过 8 成公司没能挺过 2021 年，据教育部在 2021 年 12 月的发布会： 经过各方不懈努力，校外培训治理工作取得了明显进展，学科类培训大幅压减，目前线下校外培训机构已压减83.8%，线上校外培训机构已压减84.1% 互联网行业互联网行业的变化主要是政策对于文化、反垄断、社区的限制。 文化上，饭圈文化与选秀节目受到限制。 反垄断上，阿里、腾讯、滴滴、美团相继受到各种限制，例如： 要求阿里与腾讯解除相互的屏蔽 对游戏进行限制 取消互联网行业 10% 的税收优惠 因滴滴违规上市，涉及国家安全泄漏，对滴滴应用下架 要求美团给外卖员上社保 要求互联网公司承担“共同富裕”的责任，腾讯捐出了一整年的利润 社区上，政策对于昵称，头像，评论的管控更加严格。我大学时候成立了 10 多年的学校论坛近日关闭了，一些 ICPC 竞赛练习网站，虽然非常小众，也因为昵称管控不严被关闭。 供应链今年开始管理斑马的供应链团队，学习到了很多，感受到的压力也非常大。 我的供应链工作主要侧重在反腐、交付、价格、质量、系统搭建上。 1、反腐 供应链首先是一个高危行业，因为涉及大量金额的采购工作。如何保证团队在执行采购的时候没有腐败？如何挑选与我们配合度高的供应商？今年我做了不少尝试，例如： 开放流程和资料。让内审内控的同学参与到我们的采购流程当中，对有风险的环节提出改进意见。 启动月度&#x2F;季度分单会。让供应商管理的同事通过价格、配合度、质量来提出分单建议，由季度分单会来决策分单，使得采购同事无法控制订单分给哪个供应商。 高压的廉洁政策，不允许在供应商处吃饭或接受任何礼物。 好的供应链是通过机制来保证廉洁的，这一点明年还需要继续优化。 2、交付 供应链最主要的责任就是保质保量的交付。 今年上半年我们面临了不少交付的挑战，好在我们都搞定了。下半年行业有了变化，我们也第一次学会了如何处理滞销品，做得不够好，但是最终也基本搞定了。 交付最主要的指标在用户端看来是“妥投率”，即用户在开始我们服务之前，准时收到了我们的学习资料。但在妥投率的背后，是一层一层的往前计算的条件被满足，例如： 我的快递需要在指定时间内发货 我的推单需要在指定时间内完成打包 我的货物需要在指定时间前送到仓库，并完成质检 我的质检需要通过，如果没通过，在退货重入库前，我们有足够多的可用库存 工厂需要在指定时间前完成生产 我们需要在指定时间前发出生产订单 计划同学需要在指定时间内定出合理的生产计划 市场同学需要按期提前同步市场计划 每一个环节都可能有延迟或者问题，那供应链就需要想尽办法保交付。 确实不容易。别的行业都是 80% 左右的缺货率就行，但是我们肯定不行，我们得 0% 缺货。好消息是我们的系统版非入口版本学习资料是几乎可以准确预测的，坏消息是体验版和系统版入口版本的资料不太能准确预测。备货太多就长期占用库存并且影响迭代，备货太少就缺货，都是让人头疼的事情。 除了通过日常努力运营保交付外，我们还努力做了这些事情优化交付： 减少安全库存 缩短生产周期 压缩备料的时间 尽可能统一原料规格 将 SKU 缩减，尽可能通过“代采”替代“委外”，减少管理难度 供应链交付的挑战其实挺难，做得最好就是不出事故，上下游的同事感受不到。拿元祖的话来说，就是零分，但做得不好就是负分。 3、价格 今年在价格上主要做了供应链侧的降本，这些降本主要通过： 改善生产工艺，提升效率降本。例如： 采用联机过油替代脱机过油。 一些环节用机器代替手工环节提升效率。 引入多个供应商，通过有效竞争达成降本。 在外观无感知的情况下，替代原料和工艺降本。例如： 白卡价格过高时，用别的原料替代。 适当推动上游修改工艺，达成降本。例如： 将部分绘本内页由铜板纸改成胶版纸。 4、质量 质量的保障主要通过搭建独立的质量团队来完成，我对质量的认知是： 最好的质量工作应该在产品设计阶段做。DQE 在设计的时候就考虑好生产的难度和良率，同时兼顾好成本。 按着应该在采购环节就将质量和价格同供应商对齐。 生产过程中，通过巡检 SQE 来监督质量的达成。 仓库的质检 QA 其实是最后的一环，保证入库的商品质量合格。 质量团队最好相对独立，这样可以更大胆地提出质量要求。 5、系统搭建 今年我们才开始搭建供应链系统，我也是因为这个事情，才逐步参与到供应链管理中的。说实话交了不少学费，如果重新来过的话： BOM 主数据是系统的核心，应该一开始就设计好，并且严格要求各方读这份数据。 ERP 和 SRM 是供应链的基础，应该尽早采用。 WMS 系统不应该自研，应该外采 + 定制。即便自研，应该用奇门接口，不应该用自定义接口。 ERP 与 WMS 库存的差异，应该定期核对。 整个 ERP 项目实施，应该有两个负责人，一个人是运营负责人，懂业务流程；另一个人是产研负责人，懂研发落地。如果只能有一个负责人，那这个人最好既懂业务，也懂产研。如果实在选不出来，那还是应该选产研负责人，让他去学习业务。 工作上的认知收获1、现金流非常重要 年初有期权回购，我选择了 10% 左右的比例，如果再来一次，我会选择 20%，主要是因为现金流很重要。 我最近发现这个逻辑在很多地方都是成立的，比如很多公司，财务状态非常好，但他可能还是会选择稀释一些股份上市，通过这样获得未来现金流的折现。这种折现是有价值的，首先这可以让公司加快发展速度，另外现金对抵御风险也是很有用的。 所以你看 A 股主板上市公司都有赢利要求，但是在这种情况下大家还挤破头皮地排队等着 IPO。这都是现金流的价值。 对于个人来说，除了现金流重要之外，获得个人生活上的有效改善也是非常重要的。 2、一个收入规模为 N 的公司，应该有多少研发人员 因为整个行业受影响而裁员，所以我思考了一下人员规模与公司收入的关系。 一般情况下，如果不考虑未来的增长，拿收入的 10% 用于研发投入是挺多的了。所以，我们可以这么算出研发人员的数量： 研发人数 = 收入 * 10% / 人均成本 以业务向好的时候，我们应该面向未来的增长来储备人才。当行业遇冷，增长受困的时候，人才策略自然就需要重新按稳定后的收入规模来测算和调整。 只是对于个体来说，这是一个非常难受的事情。 3、企业应该创造真实价值 所有商业产品都应该努力创造真实的、非内卷的用户价值。这些价值应该匹配得上相应的商业利润，否则利润就是不稳定的。 企业应该和国家的整体战略一致，做国家鼓励的事情。 企业应该有一定的公益性，不与人民群众利益冲突。 4、主动求变 很多时候，觉得不好的时候，要主动寻求变化，这样才有机会调整。 举一个例子：刚开始管理团队的时候，我很害怕给下属打绩效 C（不合格）。但是后来我通常会尽量多打一些 C 。这不是说下属的水平越来越差，而是我发现绩效 C 对很多人来说是一个巨大的变化，他们需要处理这样的变化。 对于拿到绩效 C 的人，他们有两个选择： 通过沟通，你没能和他对齐目标，他认为没受到公平对待，离开这个团队。 通过沟通，你和他对齐了目标，他努力调整到你希望的状态。 以上两个可能变化，其实都是对团队好的。因为即便是离开团队，也表示你有机会改善现有的团队人才结构。 二、读书今年的读书目标没有达成，很遗憾。到下半年的时候，我就感觉特别吃力，因为发现工作上有很多需要学习的东西（比如供应链和理财），这些东西很多时候不是通过看书能学到的，所以我就把时间花在这些具体的事情上了。 今年读的书有： 像经营企业一样经营城市 - 读《我在深圳当市长》 鼓励犯错 - 读《华为供应链管理》 会计指标应该反映出经营活动 - 读《经营与会计》 谈谈心智控制 - 读《终身成长》 做难而正确的事 - 读《详谈左晖》 读《最强 iOS 和 macOS 安全宝典》 比较神奇的是《我在深圳当市长》这篇读书笔记发表后，我的书评最后被该书的作者，前深圳市市长看到，还专门来我们公司接见了一下我，还送了我一本亲笔签名的书，让我倍感震惊。 三、理财尝试今年打算系统性研究一下理财，第一步是从各种资产开始学起，也整理了一下自己的一些尝试。 3.1 尝试美股和 A股我花了一点点钱到美股和 A 股上。主要是为了验证认知。收益有一点点吧，也不太多，主要是对个人能力和风险有了更多认识。 美股的达斯达克综合指数（QQQ）其实是一个挺好的定投标的。而且可以在国内通过 QFII 基金来用人民币直接购买，合法合规。 A 股太凶险，好在我只碰了大盘股。茅台美的格力海尔，以及沪港通的腾讯。两年下来 25% 的收益。 股票市场除了指数定投和自己熟悉的行业，真的不适合个人投资者直接参与。 3.2 尝试私募基金靠公司朋友的推荐，几年前买入了“建平远航”私募。刚开始 20% 的回撤让我感受了亏损对于心态的巨大影响，毕竟是几十万的亏损，但是后来又是 3 倍的涨幅，然后最近又回落到 2 倍多。 私募投资让我意识到挑私募主理人的重要性，之后我一直都没有找到其它更合适的产品。主要是因为不了解，不敢投入。 3.3 尝试 CTA程序化的量化期货交易刚开始让我很迷惑，感觉会是风险特别高的产品。但是买了一个叫“元盛”的 CTA 之后，感觉还不错。 每年波动不大，收益率在 10% 左右。主要和股票市场相关性很低，所以作为组合来说降低了风险。 3.4 债券虽然债券整体收益率只有 5%，但一直觉得债券还是值得配置一些。我选了一个工银的债券，那个主理人 11 年来只管理这一只基金，年化收益吧，肯定也就只能对标中债基金了，比银行定期高一点就行。 整个 21 年这只基金收益率都很一般，但我打算继续持有。 3.5 尝试指数增强基金我刚开始特别弱，问了一圈才发现，原来指数增强其实不是把“收益或亏损同等放大”。搞明白它是挣韭菜的钱之后，我也就理解为什么能够增强那么多了。 可惜厉害的指数增强基金都买不到，我自己找了一个公募的中证 1000 指数增强产品购买。 3.6 尝试公募基金研究下来，还是有一些比较牛逼公募基金可以尝试。今年看了很多，但是一直没有入手。只是入了一点点富国天惠。 选择这个主要是这个基金时间长，我对成立时间短的基金都没有信心，没有信心我就不能在回撤的时候拿得住，拿不住就会亏损。 四、理财认知以下是一些理财认知： 1、可以尝试写模拟策略程序员有一个优势，就是可以直接写代码来验证各种策略是否靠谱。 今年我学习了一个理财课，然后课程里面提供了大盘的历史数据和几个策略的 Python 测试代码，让我意识到其实咱们可以直接上代码来研究投资组合的收益率情况。 我的另外一个朋友也是因为自己写程序演算了一遍，发现股债比组合特别适合他，就自己完全按照自己的程序来配置组合。 2、先入局，再学习很多投资项目水都很深，不应该轻易重仓。所以最好的办法还是多了解和判断，如果要试，也是先小钱试试，判断学习清楚后再碰。 3、别碰高收益产品巴菲特老爷爷这么多年，也就 20% 收益率。 这年头像 p2p，区块链这种收益率巨高的投资项目，大家要有清醒的认识，搞不好别说复利了，几年的积累都赔进去了。 一些小道消息，内幕消息也别相信，真的就是犯法，假的就是割韭菜，咱们不要参与。 4、记录下自己的所有操作我已经做了快 3 年的家庭资产负债表，还比较有用。 今年开始，我开始做专门的投资资产配置表，记录自己的资产配置情况、每种产品当时的判断、实盘情况，以及整体的风险、预期收益。 有表格记录和测算之后，我还是发现了一些问题。比如一个费前 15% 的理财产品，如果我们假设他有 20% 的超额提成 + 2%每年的管理费，那么其实他的费后收益率已经降到了 9.76%。下图是我做的测算表，分享给大家： 5、投资上的认知和行为统一，我个人还很欠缺今年个人有一次机会可以对冲掉风险：就是我其实可以做空整个教育行业。这样就可以像《反脆弱》那一本书中讲的那样，构建出一个不受极端情况影响的收益。 我个人想到了这一点，也做了一些尝试，但是我没能把我所有的美股资金都做这个事情。 我是一个很谨慎的人，所以我刚开始只拿了 10% 的资金做空，但是 PUT 的巨大波动率让我迅速受到了情绪的影响。差不多拿了 2 周之后，我把其中没赢没亏的卖掉了，只保留了有收益的，大概 5% 的仓位，也不再敢加仓。 最后这些仓位，我又在大概 3-5 倍收益的时候就全部卖掉了，没能拿到 10 倍。 这个事情的最优解其实理论上是这样：拿 5% 的个人资产用买入教育行业的 PUT 来做对冲。 99% 的情况下这部分资产就作废了，相当于保险没生效。 1% 的情况下，这部分资产生效，提供 20 倍的收益，对冲掉正股的损失。 我能完全想到这个做法，我也能够计算出这种收益模型，但是我实操中确实做不到。因为： 5% 的个人资产其实挺多的，我心态上没有那种不生效就算了的平静。 当 PUT 的资产巨大波动时，我无法控制卖掉它的冲动，特别是亏损一段时间好不容易回正的时候。有一种解套后赶紧想跑的感觉。 只能说自己能力没到位，不怪别人。 五、21 年目标回顾 读 12 本书。 没完成（6&#x2F;12）。但是我花了很多时间研究工作和理财的东西，个人觉得当初定的目标还是太激进，没有考虑到变化。 每周 1 次游泳，每次 1000 米。 没完成。中午的餐会太多了，唯一安排在周三的游泳，又时不时被耽误。 更多关注自己的心理状态，照顾好自己。 最后这一点做得还可以。 我发现人是需要释放的，选择好的方式给自己解压，该吃吃该喝喝该玩玩，对自己好一点。 人也是需要感恩的，时不时总结回顾一下，感谢身边的家人，朋友，同事，会让自己内心暖暖的。 六、22 年目标 做好长期资产配置，好的定义是： 想清楚再买，不会老反复变动调整。 能够承受波动不赎回不抱怨。 长期能够至少有年化 10% 以上收益，争取到年化 15% 收益。 读 6 本书。 给自己一个轻松点的目标，养成读书习惯还是很重要。 每周 1 次游泳，如果中午搞不定就尝试早上或者晚上去。 七、个人 Milestone 开始管理供应链，积累了不少供应链知识","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"把 DropBox 当作私有化 Git 仓库","slug":"using-dropbox-as-git-remote-rep","date":"2021-10-16T14:15:58.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2021/10/16/using-dropbox-as-git-remote-rep/","permalink":"https://blog.devtang.com/2021/10/16/using-dropbox-as-git-remote-rep/","excerpt":"","text":"一、序我最近有一些随手的小项目，不便于公开到 GitHub 上面，但是又想有一个简单的私有化仓库。 于是我想到了 DropBox。 但是，我们不能简单地把项目放到 DropBox 目录中，因为这样会使得每次简单的保存都会发起文件同步，编译的时候的一些临时文件改动也会造成 DropBox 同步，这样会把电脑 CPU 占用搞得很高。 我们要的只是一个远程仓库。 于是我想到了 Git init --bare 指令，测试了一下，效果还可以，给大家分享一下。 二、方法1、我们还是正常地在本地非 DropBox 目录用 Git 来管理工程，我们假设这个本地的工程已经建好了。 2、同步地，我们在 DropBox 目录下，新建一个对应的同步目录，在目录下，使用 git init --bare 进行初始化（如下图）。该指令只会创建一个空的 Git 仓库，同时没有工作区和缓存区。 3、在代码工程的 Git 仓库，使用 git remote add 指令，将刚刚创建的仓库指定成名为 origin 的远程仓库（如下图）。 4、最后执行 git push origin master 将代码同步到 DropBox。 5、看了一眼 DropBox 状态，它很快就将代码同步到了云端。 6、当我们要在另一台电脑上下载这个工程时，只需要这样：git clone &lt;DropBox仓库目录&gt; &lt;本地目录&gt; 即可（如下图）。 以上。","categories":[],"tags":[]},{"title":"关于教育行业变化的思考 - 写在创业 9 周年","slug":"thinking-of-education-industry-change","date":"2021-08-30T14:26:09.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2021/08/30/thinking-of-education-industry-change/","permalink":"https://blog.devtang.com/2021/08/30/thinking-of-education-industry-change/","excerpt":"","text":"一、序大家都知道了，教育行业最近经历了双减政策，好未来、新东方、高途的股价跌了 90%，行业经历了一轮大裁员。 资本被吓坏了，所有教育行业都融资困难，最近一家以素质教育为主营业务的公司：趣口才率先倒闭了。 不止是教育行业，整个互联网行业都在被重新审视。 美团被反垄断调查：美团市场监管总局对公司展开相关调查，公司或被处以高额罚款。 腾讯。今天刚刚出台游戏监管细则，未成人只能在周五、六、日以及法定节假日玩 1 小时游戏，而且只能是晚上 8点 - 9点。 这些变化都是为什么呢？以下是我的一些思考。 二、所有产品都应该创造价值最近有一个词很火，叫「内卷」。 我认为「内卷」就是一种不创造价值的行为。如果一个产品带来了「内卷」，那这个产品也是不创造价值的。 仔细观察之下，「内卷」无处不在，比如：996 就是一种「内卷」。 如果 996 能够让中国国际竞争力大增，带来外汇和世界影响力，那么国家一定会鼓励。这就像当前国家在艰苦的情况下研究导弹、核弹一样，能给国家争得荣誉和地位的事情，996 算啥？ 但是现在的 996 呢，其实就是一堆公司在同质化产品下的相互竞争，最终蛋糕并没有因为竞争变大，还是那么多。国家一看，你啥国际竞争力没搞出来，还把人民的消费时间、幸福感、以及重要的生育率搞低了。 你说国家管不管 996 ？ 又比如说互联网的很多龙头企业，如果他能够将技术输出到国外，为国家挣得外汇，这就是创造价值的。但是很多企业其实核心是利用互联网容易形成垄断的特点，将人们习惯养成之后，利用平台进行收割。收割的方式或是高额的提成，或是大数据杀熟。 你说这样的产品虽然有价值，但是相对来说，又有多大的核心壁垒？ 所以，最近我的第一个认知是：所有商业产品都应该努力创造真实的、非内卷的用户价值。这些价值应该匹配得上相应的商业利润，否则利润就是不稳定的。 三、商业公司应该注重公平现在的商业竞争，越来越白热化、同质化。竞争之后的用户收割，也越来越赤裸裸。 诚然，商业和资本是逐利的。但是，这也应该考虑社会的整体的公平性。 比如大数据杀熟就是非常不公平的行为。窃取用户隐私也是非常不公平的行为。 垄断性的平台对员工的薪资压榨，也是一种不公平的行为。 所以最近国家开始管了，要求提高外卖员、快递员的最低薪资：《中国监管要求外卖员工资不少于最低标准》。 监管也要求各个产品要提供可以关掉推荐功能的设置，以此减少杀熟和泄漏隐私行为。 四、商业公司应该配合国家政策桥水的创始人达利欧（Ray Dalio）说：中国是一个国家资本主义系统。在这个系统下，中国会寻求全局最优的变化。 什么是全局最优的变化？提升中国国力，提升中国出生率，提升中国整体的国民收入就是全局最优的事情。 所以你能看到，国家大力发展新能源，大力发展芯片产业，因为这些行业有机会影响世界，同时解决美国对我们的技术封锁。 为了提升出生率，国家鼓励三孩，减少课外辅导花费，减少加班时间，这些都是国家在寻求全局最优。 而鼓励三次分配，鼓励慈善，这些更说明了，共同富裕是国家关注的全局最优的事情。 作为商业公司，应该配合国家做这些事情，只有这样才能获得双赢。 五、现金流非常重要现金流非常重要，非常非常重要，非常非常非常重要。 重要到什么程度呢？在乐观情况下，你也应该把自己 20% 的资产换成流动性高的投资。 与此类比的就是：不管一家公司多么值钱，它都会出让自己 20% 左右的股份，来换取未来发展的现金投资。 这种出让比例，每次最高可以达 49% 。 六、小结 所有商业产品都应该努力创造真实的、非内卷的用户价值。 价值应该体现在效率（节省用户的时间）、经济（节省用户的花费）。 商业公司应该注重公平。 不能做让用户、员工感受不好的事情。 商业公司应该配合国家政策。 不能与国家的政策相抵触。 现金流非常重要。 应该将资产的 20% 换成高流动性投资。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"宜家的设计问题","slug":"yijia-design-problem","date":"2021-08-14T09:58:50.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2021/08/14/yijia-design-problem/","permalink":"https://blog.devtang.com/2021/08/14/yijia-design-problem/","excerpt":"","text":"一、序宜家是一家优秀的公司，他们为家装和家居设计出模块化、标准化、简约的解决方案。对于大众消费者来说，既保证了基础的品质，又物美价廉。 但是，我一直对宜家的商品展示牌的设计有很大的质疑，分享给大家看看。 二、信息的层次苹果的 iOS 7 操作系统从拟物化转向扁平化之后，带动了整个设计理解的改变。大家都习惯去掉各种修饰，用简单的字体，字号来展示重要的信息和信息层次。 宜家也是这样。下图是宜家的餐厅。 你一眼能够看到的是餐厅，然后紧接着看到的是热销的商品名、图片、价格。 特价商品的价格有一个特殊的底色。 英文名、售卖的单位相对不重要，用较小的字体显示。 这是一个特优秀的、具有良好信息层次的案例。 三、有问题的设计但是宜家也有一些有问题的设计，比如他们对于每件商品的介绍图： 在上图中： 第一重要的信息是：价格。这个没问题。 第二重要的信息，居然是这个商品的瑞典名，和根据瑞典名的发音直接音译过来的汉字。 第三重要的信息，才是这个商品的中文名：“儿童椅”，可以看到这个明显字体小了一号。 把瑞典名和音译名当作第二重要信息，是不对的。因为在中国会瑞典语的人实在太少，同时音译名基本上不具有理解和记忆效果。我去过几十次宜家，没有记住任何他们家的音译名。 类似的问题在很多地方都有，比如这个促销海报墙： 除了最重要价格，接下来加粗黑体的，也是瑞典名和音译的中文。 想知道“贝利帕姆”是什么？你需要再看下一行，你才知道它其实是：“被套和枕套”。这非常糟糕，信息效率很低。而且“被套和枕套”的字体是小一号的，说明设计者认为这个不重要。 四、正确的设计那应该怎么改呢？除了价格，最重要的信息就是这个商品的中文意义，所以应该把中文意义大写。瑞典语和音译，不重要，应该用较小的字体。 在宜家也能见到这种正确的设计，如下图： 除了价格，商品名“靠垫”被用了最大的字体，间距和位置也偏中部一些，更容易被注意到。 这就是一个正确的信息层次设计，不过我很好奇这种设计偏少，更多的是有问题的设计。 五、小结“中文意义的商品名” 比 “瑞典名和音译的中文” 更加重要，应该在信息位置和字号上给予更加显眼的展现。 就酱。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"销售如何卖出产品","slug":"how-to-sell-product","date":"2021-08-10T15:15:10.000Z","updated":"2024-01-06T14:52:37.940Z","comments":true,"path":"2021/08/10/how-to-sell-product/","permalink":"https://blog.devtang.com/2021/08/10/how-to-sell-product/","excerpt":"","text":"背景我发现同销售相关的同事聊天的时候，同事总会强调缺少活动，缺少赠品，缺少优​惠。当有了活动、赠品、优惠之后，销售同事又会强调缺少新的活动、缺少新赠品、​缺少新优惠。 在这些同事看来，这些抓手不但是转化成单的必不可少的工具，甚至是​致胜的法宝。​缺少了这个，成单会非常受限制。 我能理解这种归因，这种归因来源于以下几点： 相比没有赠品或者优惠。这部分的加成确实对转化率能够有一个明显的提升。这其实类似于产品降价。很明显，价格越低，转化率就会越高。 消费者与销售沟通的最后，都会秉着占便宜的心态，寻求赠品或者优惠。这种习惯是中国长久以来的双 11 等各种营销活动给培养起来的。在消费者看来，没有优惠是奇怪的。但是因为消费者每次都这么问，销售就会被反复心理暗示：顾客看重赠品和优惠。 从人性来讲，个体在提升 KPI 的时候，寻求外部资源，特别是免费资源是一种常见的行为。销售为了提升转化，在没有任何成本的情况下，他要求运营持续提供新活动、新赠品、新优惠是一种看起来只有加分没有减分的事情。 但是，以上理由都不能证明，这种事情是最好的销售手段。 问题这种强调活动、赠品、优惠的销售活动有两个巨大的问题。 问题一：它模糊了销售的宣传主体。销售会潜意识觉得用户是为优惠和赠品买单，而不是为产品本身买单。所以这会弱化产品本身的宣传。而产品才是用户真正购买的东西，不强调这部分的内容，本身会影响用户对于产品的理解和认知。销售应该花大力气介绍产品本身是如何好，而不是花大力气介绍赠品有多好。 问题二：它带来了巨大的运营、产研和供应链成本。 任何新花样的活动都是需要运营、研发与供应链配合才能上线的。如果一次活动仅仅用几周就下线，这就造成极大的人力浪费。 任何新的赠品都是需要供应链研发或采购的。这也需要付出足够的精力才能做好。 解决方案我们应该不断给销售强化宣传产品本身的价值。产品本身的价值可以通过多种方式来反复介绍。比如我们可以介绍： 产品研发的过程。 产品获奖的新闻。 用户优秀体验的案例。 询问用户对于这类产品的需求，对于我们解决方案的疑惑。 我们对于用户的理解，对于产品的理解。 以上信息，需要做到不过度营销、骚扰，不让用户反感。 我们要相信：用户下单，本质上还是基于对产品本身的喜爱和认可，没有别的。 当然，最后我们可能需要有一个优惠来关单，这是有效的，但没必要反复改变这个优惠。所以，我们要控制关单相关的资源和成本，让销售把精力都放在介绍产品本身上。 以上。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"做难而正确的事 - 读《详谈左晖》","slug":"what-is-zuohui-said","date":"2021-06-27T01:31:12.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/06/27/what-is-zuohui-said/","permalink":"https://blog.devtang.com/2021/06/27/what-is-zuohui-said/","excerpt":"","text":"一、前言左晖 是链家和贝壳找房的创始人兼董事长。不久前，左晖因肺癌恶化而逝世。选择读左晖的著作一来是因为贝壳上市后，市值超过了 500 亿美金（下图）。 二来是因为我发现用互联网手段改造传统行业是一个非常有挑战，但是成功后价值非常高的事情，想看看左晖是如何一步步把这件事情做成的。 左晖还有一点吸引我：他是学计算机的。他 1992 年毕业于北京化工大学计算机专业。这让我更容易把他当作一个模仿的榜样。 因为整本书都是李翔对左晖的访谈，所以我整理了一些对我有启发的观点，分享给大家。 二、决策机制左晖因为离管理具体的业务远一些，所以在管理团队会用沟通式决策。他会把自己的观点抛出来和大家探讨交流，大家如果同意，就达成了一致，执行就没问题了。大家如果不同意，那他就先放一放。 这种决策机制需要两个条件： 团队的氛围是足够倾听和平等的，否则左晖说什么大家就会当圣旨去执行。左晖也不太敢说了，因为他离业务远，他也不敢保证说什么都是对的。 他的下属要足够厉害。对于不够厉害的下属，这种方式也成不了。左晖选人用人还是足够好的。 三、互联网化传统行业房产中介是一个传统行业，但是左晖的贝壳会尝试用互联网的方式来赋能在这个平台上的中小中介。我看下来，这个赋能主要是： 标准化中介服务的环节。然后通过培训、数据、系统来帮助中小中介。 通过数据反馈来迭代。 左晖把贝壳的目标定义成了三个指标： 店面总交易额：GTV。5000 万一年是温饱线。贝壳会帮助大家达成这个目标，让大家活下来。 NPS 值。现在行业 NPS 是负的，贝壳希望做到 30% 。 经纪人平均从业时间。行业平均值是 6、7个月，贝壳希望做到 30 个月。 以上指标如何达成呢？贝壳把服务环节标准化，比如有一个标准就是：IM 的即时响应率，贝壳要求是 24 秒。因为贝壳发现，在现在这个时代，房产中介必须要学会在线上和消费者交流。 如何在 24 秒内就能回应消费者的线上询问呢？我相信这里面一定是一个系统工程。包括相关的工具、人员培训、话术 SOP、自动辅助应答、知识库的建立、客服人员的满意度考核、工作量与薪资结算打通。 这些系统性的工作，除了建立相关的技术工具外，还需要有相关的培训和服务。在淘宝，如果你需要一个 24 小时的客服，你不需要真正招聘这个人，网上有一堆这样的客服公司与你对接。他们会帮你梳理好问题，然后可以按次计费。而你只需要关心开店的核心工作就行了。我想贝壳很可能也是在超着这样一个标准化道路上前行。 好就好在，链家已经把这些工作在公司内部做到了。贝壳要做的，就是把链家成熟的工具抽取出来，把成熟的培训抽取出来，以加盟的模式输出给整个中介行业。 左晖把这个输出的能力叫做：品质的规模化复制。 四、品质的规模化复制的核心左晖认为品质的规模化复制，包括抽象能力和复制能力。 抽象能力需要把每个人角色、每个组织、每个流程以及匹配关系抽象出来。我感觉有点像定义人、事情、流程。 复制能力是通过文化、组织、IT 系统、团队把能力落地。这个一方面是需要时间，因为团队文化和 IT 系统的建设是需要时间的。另一方面是需要人才，传统行业的人才通常没有这个基础素质。 所以左晖说，线上的人做线下相对容易，因为线上的人更开放。 五、不看同行左晖有一个观点，和猿辅导的几个创始人的观点挺像的，就是不看同行做了什么。 大家的核心观点都一样：因为我们处在一个商业大变革的时代，别人做一个事情成功了或失败了，给自己的借鉴意义是相对小的。核心还是看自己怎么去思考和判断。 左晖在做贝壳的时候，市面上已经有一些平台公司了。但是他不太关心这些公司是怎么做的，坚持按照自己的想法做贝壳。按他的原话说： 我觉得我们今天好象都偷懒了，要去问踩了哪些坑。但这个坑毕竟是他踩的，你自己没踩过，你听的跟你碰到的差别是非常大的，或者是完全不一样的。你有那个功夫到处去打听，还不如自己去干。 六、小结左晖用他的抽象能力和复制能力把链家做好了，接着又把这种能力平台化，做好了贝壳。这给我很大的启发。互联网巨大的魅力就是数据和规模，而这些都是可以创造巨大价值的事情。贝壳用真实的案例让我看到了传统行业互联网化的巨大机会。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"谈谈心智控制 - 读《终身成长》","slug":"the-mindset-book-summary","date":"2021-06-13T15:44:56.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/06/13/the-mindset-book-summary/","permalink":"https://blog.devtang.com/2021/06/13/the-mindset-book-summary/","excerpt":"","text":"一、序言最近看了一本畅销书《终身成长》，里面主要对比两种思维：固定型思维和成长型思维。 固定型思维把任何挫折当做对自己的否定，而成长型思维把这个看做通往成功的必经之路。 有趣的是，这类思想的书我看了很多。从《和时间做朋友》到《为什么佛教是真的》；从《真实的幸福》到《终身成长》；从《假性亲密关系》到《情感吸血鬼》，我发现大家讲的都是一件事情：心智控制。 于是我打算再把这几本书里面讲到的心智控制整理一下分享给大家。 二、认识自己的大脑和情绪 我们还是得提到《头脑特工队》这个电影，这个电影把人的不同情绪分解成了几个不同的自我，当这几个自我打架的时候，谁占上风谁就主导了行为。 最后，人类的“叙事自我”会为自己的所有行为提供一个看似合理的解释，但这个解释只是为了让自我接受自己的行为。 所以说，人的大脑是一个菜市场，谁的声音大最后就听谁的。当你害怕的时候，“害怕”自我声音最大；当你高兴的时候，“愉悦”自我声音最大。 但是，《为什么佛教是真的》这本书里面就说了，这些“自我”其实都不是真正的自己。因为这些“自我”会绑架你的行为，让你难受。 人类千百万年的进化，使得人们对于一个快乐的事情的愉悦感，会随着刺激的次数变多而降低。比如你第一次吃某种美食特别好吃，但是你每天都吃的话，你就会觉得味道也就那样了；你刚住进大房子觉得特别舒服，但是住久了你也又习惯了。即便是吸毒，一个瘾君子也是需要不断加大剂量，才能够保持自己的快感。所以你看，如果你一味追求快乐，你会越来越难以获得快乐，快乐总是短暂的。 如果快乐难以获得，那是不是说，人类就是应该受苦一辈子呢？不是的。 三、糟糕的情绪控制 当你明白情绪容易控制你，快乐总是短暂这些事实之后，你要学会的是通过“跳出坏情绪”的方式来控制情绪。但是很多人不能掌握这种技巧，大家惯用的手段有两个：发泄情绪和压抑情绪。 发泄情绪很好理解，人们通过呼喊、争吵、哭泣，甚至动手打架来将情绪释放出来。这种方式是很好的疏解情绪的方式，但终归自己内心还是受到了压力。 压抑情绪比起发泄情绪看起来没有什么特别的行为变化，但是通常这种情绪的负能量会向内传达，最终引起心理压力。心理压力进一步也会影响生理，造成自己容易失眠、焦虑、抵抗力下降等等。我有一年得胃病，很大程度就是因为压力太大造成胃酸过多。 如果你有了坏情绪，还是应该释放出来。每个小孩都会这个事情，成年人反倒会压抑情绪，其实是不好的。 但是最好的办法，还是下面提到的不产生负面情绪的办法。 四、好的情绪控制《真实的幸福》、《终身成长》和《假性亲密关系》都介绍了这种情绪控制方法：简单来说就是用乐观的一面来看待原本糟糕的结果。 任何事情都是有两面的。如果你看乐观的一面，那么你就有可能不会产生负面情绪。 聚个例子：我当年做胃镜感觉特别难受。但是当我给别人提起这件事情的时候，我会这么说：“你没做过胃镜吧？只有做过胃镜人生才算完整，那个感觉一辈子都忘不了，推荐你下次试试。” 《终身成长》里面有大量的案例，比如你很喜欢的科目考砸了，如果你乐观一点看，这说明你又可以在自己喜欢的科目上继续提高了。你想，如果一个你喜欢的事情已经做到极致了，那会是一件多么无聊的事情。 平时很多时候大家都可以训练自己乐观处理情绪的能力。比如我最近老加班，但是我就想：明天肯定比今天会好一点，再加把劲。 《为什么佛教是真的》主要介绍了“冥想”这个技巧，通过冥想让自己能够站在上帝视角审视自己的情绪。这样当负面情绪产生的时候，你就会以一种同情和理解的方式接纳这个情绪，而不是被这个情绪控制。 关于冥想我练习很少，但是我特别理解它的那种控制情绪的目标。 五、小结1、人的行为由多个“自我”共同决定。 2、糟糕的情绪需要宣泄和化解，压抑情绪是不好的。 3、用乐观的角度看问题，就可以很大程度上避免负面情绪。 4、冥想有助于控制负面情绪。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"会计指标应该反映出经营活动 - 读《经营与会计》","slug":"operating-and-accounting-book-summary","date":"2021-04-24T14:48:42.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/04/24/operating-and-accounting-book-summary/","permalink":"https://blog.devtang.com/2021/04/24/operating-and-accounting-book-summary/","excerpt":"","text":"序最近常圳给我推荐了一本书，叫《经营与会计》，作者是日本的商界神人 稻盛和夫。稻盛和夫是京瓷、第二电电（现为 KDDI ）创办人，日本航空名誉会长（董事长）。 稻盛和夫最有名的著作应该是《活法》，我上一次看他的著作是 2019 年读的 《成功的真谛》，他的书通常都很薄，一个道理反复讲。我很喜欢稻盛和夫的这种风格，我不喜欢太长的书，因为这种书根本读不完。 《经营与会计》这本书反复讲了一个很简单的道理：会计指标应该反映出经营活动。这个道理似乎非常正确，但是落到真实经营上，却并不容易。以下是一些案例和心得。 案例一：设备应该怎么折旧《经营与会计》书中举了一个例子，京瓷有一个生产设备，在会计报表中按 10 年进行了成本的摊销。稻盛和夫因为深入经营，知道这个设备在当前生产强度下，根本用不到 10 年，大概 6 年就得报废掉。 于是他问会计：“为什么不按 6 年报废，而按 10 年？”。 会计告诉他：“因为法律规定这类设备的报废期都是 10 年，即使你按 6 年计算摊销成本，平均每年多出来的成本也无法抵税，你还是得补交相应的税款”。 但是稻盛和夫认为，会计指标不是为了使税款最小，而是真实地反映出自己企业的经营状况。如果企业的设备折旧不能在会计中真实体现出合理的成本，那么这种事情多了，当年企业经营到底是否挣到钱是不清楚的。这是一种经营的灾难。 案例二：美国分公司的月帐混乱京瓷的美国分公司刚成立的时候，每个月的帐很奇怪，有些月亏很多，有些月挣很多。稻盛和夫就让他们去查是什么原因，结果发现是因为客户有些时候要货物要得急，来不及开发票走流程就让京瓷立即送货。 于是京瓷有些月只有货物出库却没有钱款入帐，结果亏很多；而有些月客户补上了合同和款项，但当月又没有货物出库，结果挣很多。 稻盛和夫就让他们无论多忙，一定要保证相关的手续在 24 小时内补齐。保证了公司的帐目清晰。 感受：数据是经营的底层支持这本书看完让我首先想起当年稻盛和夫是怎么拯救日航的。 当前的传奇故事是这样的： 2010 年 1 月 19 日，日本航空公司申请破产保护。日航有 58 年历史，一度被视作日本战后经济繁荣的骄傲象征。2010 年 2 月 1 日，受日本首相邀请，稻盛和夫答应出日航董事长，一年之后，日航扭亏为盈，利润是对手全日空的三倍。仅仅用了一年时间，日航做到了三个第一。一个是利润世界第一，一个是准点率世界第一，一个是服务水平世界第一。 在日航重新上市之后，稻盛和夫分享了他挽救日航的秘密。这里面涉及的内容很多，其中有很重要的一条，就是稻盛和夫非常重视日航具体的会计数据，他花了很大的力气来优化数据的获取，从而能够对日航的现状进行判断。 稻盛和夫是这样说的： 我担任董事长后，最为吃惊的是，公司的各项统计数据不仅不全，而且统计时间很长很慢，往往需要 3 个月之后才能搞全数据，以至于经营者无法迅速掌握公司的运营情况。所以，在对企业内部进行改革时，我特别关注统计工作。经过改革，现在各个部门的数据做到即有即报，公司详尽的经营报告，做到了一个月内完成。 如果把日航看过一个生病了的病人，稻盛和夫的做法其实和现代医学的做法类似，就是首先进行各项检查，获得病人的身体指标信息，有了这些检查数据，我们就可以利用各种基于数据的经验，来进行病情诊断和治疗。所有的治疗手段又可以通过再次的检查来验证，从而进一步改进治疗方法。 人做为一个生命体，全身密布的神经负责着各种信息的传递，所以我们的大脑能够接受到各种信息，从而做出决策，饿了吃饭，冷了加衣服，保证着我们身体的健康。 而企业没有天生的神经系统，所以数据收集和会计指标分析就显得异常重要了。日航作为一家运营了 50 多年的公司，居然在这方面做得非常差，难怪会进入破产的边缘。而稻盛和夫用的办法也很简单，先让数据能够收集起来，那么后续依据数据做决策就不再那么困难了。 一些工作中的案例最近工作中就遇到一些案例，分享给大家。 打样该不该付费我们公司在供应链方面的工作，涉及一些商品样品的打样。某些商品的打样其实很花时间和精力，但是因为我们在合作公司都有长期的资金往来，所以我们通常都不付打样费，让他们免费帮我们打样。 但是我发现这样做产生了几个明显的问题： 1、因为打样是免费的。所以我们在对待打样工作上，变得不那么认真了。一些明显可以通过一次沟通打样成功的事情，变成需要打 N 次样才能沟通清楚。一些局部小改动，可以不用打完整样的事情，也就随便让供应商打完整的样了，反正我们不需要付钱。 2、供应商那边，因为是免费帮我们打样，也变得不那么认真和重视。遇到事情多，就把我们的打样工作延期，使得我们的研发计划变动得很随意，并且无法预料结束时间。 3、最最重要的，「羊毛出在羊身上」，打样的成本最终隐藏在了供应商最终给我们的各种报价上，我们从会计指标上，看不出来由于我们在打样环节的不认真，对整体成本的影响。也从会计指标上，评价不出我们的打样工作是否合理。 所以我认为，打样就是应该付费的。通过付费，我们马上就可以计算出每月和每年的打样成本。大家关注到成本了，就会有节省和优化的意识。所有的工作也变得可以追溯的了。 慢慢地，员工会重视起打样工作。打样的流程会被复盘和优化，打样会变成真正需要用才用的事情，而不是不用白不用的免费资源。 供应商那边，因为每次付费，所以就会有交期、质量要求的合同。我们就可以据此要求他们，进而控制我们对于研发生产的每个环节的进度。供应商也不会把这些费用最终隐藏到各种别的费用中。 仓库的费用应不应该单算供应链的生产涉及仓储费用，我发现有些仓库会提供一种打包收费的方案：不和你计算仓储费用，只按你发了多少货来按发货量收费。 这也是一种多项费用合并隐藏在一起的案例，如果仓库供应商真的不在意仓储的面积还好，但其实并不是这样。 虽然仓库供应商给你说按发货量来计费，但是他又会给你摆出一个「坪效」的概念：即你占用的每平米的仓库容量，相应有没有通过发货周转给他带来经济效益。坪效低了，供应商就会找你，要你补偿钱。 反过来，如果坪效高了，虽然供应商不会找我们，但是我们其实是做了亏本买卖，应该找供应商降价才行。 甚至举一个极端的例子，如果按发货量收费的方案，你会惊奇地发现：你即使把库存周转率降成 0，你的仓储费用也仍然没有任何变化。 你看，按发货量收费就是 会计指标无法反应出经营状态 的案例。 供应链的长线目标是做更精准的计划，提升库存周转率，减少迭代的浪费，所以费用计算方式最好能够与库存周转率有直接关系。这样我们做的任何优化，都可以同步在财务指标上有所反馈。 所以，如果我们将仓库的结算方式拆成：仓库租金 + 打包费用。这样的结算费用可以让我们以后在仓库租金和打包费用都做出明显的优化，并且得到费用的反馈。 计划和转周的优化可以明显降低仓库租金。 打包流程的 SOP 可以明显降低打包费用。 小结会计数据是经营的决策依据，会计指标应该反映出经营活动。工作中应该关注那些不合理的会计计算方式，让他们调整成帮助我们做决策的、能够持续反映经营状态变化的指标。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"鼓励犯错 - 读《华为供应链管理》","slug":"the-supply-chain-of-huawei-book-summary","date":"2021-04-18T14:42:02.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/04/18/the-supply-chain-of-huawei-book-summary/","permalink":"https://blog.devtang.com/2021/04/18/the-supply-chain-of-huawei-book-summary/","excerpt":"","text":"最近同事海晨给我分享了一本书，叫《华为供应链管理》，我看完有两个点印象深刻： 华为任正非在内部信中强调要鼓励犯错。 详细了解了一下 现金周转天数 和 库存周转天数。 我展开聊一下。 鼓励犯错任正非的讲话还是非常有水平的，这段鼓励犯错的文章出自任正非在 2001 年的内部信《华为的冬天》。其中我摘抄了相关的一段： 我身边有一些国企朋友，有时候和他们聊天，他们会聊到国企的做事风格，其中非常重要的一条，就是「不能犯错」。很多领导管一个业务并不是一辈子的，任期也就那么几年。这几年通常都不会愿意做那种高风险的事情，不求有功，但求无过。因为犯错的代价很大，但是不犯错就不会有什么影响。 但是这种工作方式如果放到竞争激烈的互联网行业，那这样的公司肯定会死得很惨。因为互联网强调创新，强调快速变化，如果负责人不能勇于创新，承担起创新的风险，那么同时也放弃了创新的收益。大部分时候，只要努力，创新从整体期望来说收益都是正的。这就是任正非说的：人均效益增长。 创新要求面对新事物勇于尝试，这就要容忍一定程度的失败，一种鼓励犯错的文化就必须存在。只要我们是做好了复盘工作，那么失败就不是可怕的。 最近华为的 L4 级别自动驾驶的视频 很火，华为在各个领域都很优秀，离不开这种鼓励犯错的文化。 另外，我找到了任正非历年的讲稿，推荐给大家: https://github.com/tangqiaoboy/RenZhengfei。 现金周转天数 与 库存周转天数卖硬件产品，都需要有存货。假如一个商品卖 100 块钱，成本 60 块钱。你把这个商品生产出来时，你已经投入了 60 块钱，它只是放在仓库的存货，只有把它卖出去了，才能收到 100 元，留下 40 块钱的利润。投入的 60 块钱本金，经过多少天收回来，就是一个关键的指标，因为它意味着你一年能把手中的资金循环多少次。这个指标叫「现金周转天数」（Cash Conversion Cycle）。 这个指标做到极致的是苹果，苹果在 17 年的现金周转天数是 -84 天。对的，你没看错，这是一个负数。这相当于，假如苹果生产一台手机，成本是 1000 块。苹果不但不需要垫付这个成本，还可以在手机卖出之后，把这个 1000 块拿在自己手里 84 天后，再付给供应商。 苹果是如何做到的？拿 17 年的财务数据举例，苹果首先对上游供应商有着 125 天的帐期，然后下游的销售对于它有 32 多天的帐期，加上它的商品在仓库的周转时间是 9 天，所以 125-32-9=84，苹果在 17 年的现金周转天数是 -84。 要做到这个指标，库存周转天数非常重要，苹果只有 9 天的库存，这使得它的周转非常快。与之对比的是，华为库存周转是 77 天。 结束语看完这本书，既感受到了华为的厉害，也感受到了苹果的强大，像苹果这样全球市值最高的公司，还需要中国公司相当长时间的追赶。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"码农装逼菜谱 (五) - 肥牛饭","slug":"the-food-of-flf","date":"2021-04-05T14:52:08.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/04/05/the-food-of-flf/","permalink":"https://blog.devtang.com/2021/04/05/the-food-of-flf/","excerpt":"","text":"序言今天的装逼菜谱是：肥牛饭 – 和吉野家肥牛饭味道一样。 这道菜主要靠照烧酱。做出来的味道和吉野家的一样，成品如下图： 照烧酱长这样： 用料食材：1 个洋葱，1 斤肥牛卷，一根胡萝卜🥕 ，半朵西兰花🥦 。 调料：照烧酱 4 勺，耗油 1 勺，盐 2g。 准备：洋葱切丝，西兰花切好泡水，胡萝卜切成圆形的片。 制作过程介绍一下什么叫焯水，焯水就是把水烧开，然后把食物放进去过一段时间后捞起，水一般需要倒掉。 步骤： 胡萝卜和西兰花焯水，3 分钟后捞起备用。 肥牛片焯水，没有血色后捞起备用。 锅烧热，倒入半勺油，待油热一点后，放入姜片爆 10 秒，然后放入洋葱丝，翻炒半分钟后，加 40ML 水盖上盖子炒 2 分钟左右，直到把洋葱炒软，这个时候水差不多也干了。 下肥牛片混在一起炒 30 秒。 开始调味，加入耗油 1 勺，照烧酱 4 勺，盐 2g 调味，翻炒均匀即可装盘。 将胡萝卜和西兰花摆盘，撒上芝麻。 小贴式没啥特别要说的，记得拍照发朋友圈。","categories":[],"tags":[{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"}]},{"title":"码农装逼菜谱 (四) - 叉烧肉","slug":"the-food-of-csr","date":"2021-04-05T13:55:57.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/04/05/the-food-of-csr/","permalink":"https://blog.devtang.com/2021/04/05/the-food-of-csr/","excerpt":"","text":"序言今天的装逼菜谱是：叉烧肉。 这道菜做法非常简单，只需要买成品调制好的叉烧酱即可。做出来的味道和外面卖的一样，成品如下图： 用料 名称 用量 梅花肉（或前腿肉） 300 g 叉烧酱 2 勺 (约 30g ) 蜂蜜 半勺 料酒 半勺 姜片 2片 李锦记叉烧酱如下图： 制作过程步骤 1把梅花肉（买不到梅花肉也可以买前腿肉）去皮，切成长条状（长度大概宽2指，厚1指），如下图。 然后加入料酒、蜂蜜、叉烧酱、姜片，然后拌匀之后，用牙签在上面各个方向都扎满小孔，便于入味。 接着把肉放入小盆中，盖上保鲜膜，放冰箱里至少放置 4 小时，中间可以翻动一次，最好放一整晚，这样比较入味。 步骤 2把肉放烧架上，下面放烤盘，烤盘铺上锡纸，用于接从肉上滴下来的酱，否则会非常难清洁。 烤箱上下 200 度，预热 3 分钟，放入肉先烤 20 分钟； 然后拿出来翻面，然后把之前的酱再刷一层上去，继续烤 20 分钟。 然后再翻面，刷一次酱，烤 5 分钟即可。 肉拿出来冷却后切片装盘。 小贴士 腌制时间 12 小时以上最佳，所以可以提前一天晚上腌制，第二天再烤。 表面的颜色主要是糖焦化的反应，所以需要刷够酱。 肉不要太厚，不然不容易入味。 也可以烤五花肉，吃起来更嫩更肥一点。","categories":[],"tags":[{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"}]},{"title":"码农装逼菜谱 (三) - 凉拌三丝","slug":"the-food-of-lbss","date":"2021-03-28T23:42:20.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/03/29/the-food-of-lbss/","permalink":"https://blog.devtang.com/2021/03/29/the-food-of-lbss/","excerpt":"","text":"序言今天的装逼菜谱是：凉拌三丝。 做的时候忘了拍照，下次补图。 用料食材：马铃薯粉丝，莴笋，胡萝卜 名称 用量 马铃薯粉丝 40 克 莴笋 半个 胡萝卜 1 个 调料：糖，醋，酱油，耗油，香油，麻油，盐。 制作过程步骤 1莴笋和胡萝卜去皮，用刮刀刮成丝。 莴笋丝加入 5g 盐腌制 15 分钟，然后用手挤掉水份。 胡萝卜快速焯水一下，捞起备用。 马铃薯粉丝用开水煮半分钟，关火用开水泡 5 分钟备用。 如果想做升级版的，可以再加入：鸡蛋皮，金针菇，鸡胸肉。 鸡蛋煎成蛋皮，切成丝备用。 金针菇煮 3 分钟捞起备用。 鸡胸肉用开水煮，加料酒，4 分钟之后捞起撕成丝备用。 步骤 2找一个大碗，将原料混合。加入糖 2 小勺，醋 1 小勺，蚝油 1 小勺，香油 2~3 小勺，麻油 1 小勺，盐少许。拌匀即可。 小贴士 糖醋需要配合一起放，起香味的是香油，麻油，蚝油。","categories":[],"tags":[{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"}]},{"title":"码农装逼菜谱 (二) - 麻辣香锅","slug":"the-food-of-mlxg","date":"2021-03-20T13:31:58.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/03/20/the-food-of-mlxg/","permalink":"https://blog.devtang.com/2021/03/20/the-food-of-mlxg/","excerpt":"","text":"序言今天的装逼菜谱是：麻辣香锅。以下是成品效果图： 用料麻辣香锅的原料就完全随意了，我个人喜欢的搭配是： 荤菜：五花肉、鸡翅、牛肉丸、肥牛、午餐肉、脆皮肠、鹌鹑蛋。 素菜：藕片、土豆、西芹、豆皮、香菇、洋葱、青蒜、西兰花、金针菇、魔芋丝。 麻辣香锅底料（或者火锅底料）：每一个人的量按 30 克算，如果是 4 个人就是 120 克。 相信你看出来了，这个菜适合人多，因为每个菜都可以加一点。如果 2 人份的话，建议只用选 6~8 种原料即可。 制作过程麻辣香锅的的制作办法核心就是先把各种菜弄熟，然后把麻辣香锅底料（或者火锅底料）炒香，最后把菜和底料混合即可。 步骤 1 - 处理荤菜 原料 处理方法 牛肉丸 直接和素菜一起煮熟即可 肥牛 焯水，没有血色后就熟了 午餐肉 切片后，直接最后放入香锅里即可 脆皮肠 在肠的一端切个十字花刀，然后把脆皮肠煎成开花 鹌鹑蛋 煮熟剥好，最后放入香锅里即可 五花肉 把五花肉切片之后，用小火煎，最后两边煎成金黄色即可 鸡翅 先把鸡翅划几个缝，然后用料酒、姜片、生抽腌制 20 分钟。 之后像五花肉那样双面煎成金黄，然后加水烧 2 分钟，水烧得快干后取出。 以上最好做的就是牛肉丸、肥牛、午餐肉、脆皮肠。如果想做起来简单，买这几样就行。 步骤 2 - 处理素菜 原料 处理方法 土豆 去皮，切片 藕片 去皮，切片 西芹 切段 豆皮 切成 1 厘米宽的丝 香菇 洗净，切成两半 洋葱 切成丝 青蒜 切成段 以上这些菜切好之后，除了土豆，直接放到锅中加开水煮，煮个大概 3 分钟就行。 不用煮太久，因为藕片、豆皮、洋葱都可以生吃。 土豆单独用油煎一下会更好吃，为了省事，也可以和别的菜一起煮。 以上最好做的是藕片、豆皮、香菇、洋葱、金针菇、魔芋丝，基本上不需要什么额外处理。 步骤 3 - 收尾上面的荤菜、素菜预处理好了之后，就开始处理底料了。 把葱姜蒜切成末，油烧热之后，下葱姜蒜，炒一下之后把火关最小，然后把麻辣香锅底料加进去，火锅底料容易糊，用铲子慢慢把底料炒融化。 底料完全化掉之后，先加入荤菜。等调料都裹上之后，再加入素菜。 最后放一点点糖调味，然后就可以起锅啦~ 小贴士 个人感觉麻辣香锅的灵魂是方便面，吃起来特别香。只需要把方便面单独泡好后加进香锅即可。 如果希望点缀一下，可以放一点炸花生米、白芝麻、以及香菜。","categories":[],"tags":[{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"}]},{"title":"码农装逼菜谱 (一) - 糖醋排骨","slug":"the-food-of-tcpg","date":"2021-03-20T12:16:56.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/03/20/the-food-of-tcpg/","permalink":"https://blog.devtang.com/2021/03/20/the-food-of-tcpg/","excerpt":"","text":"序言最近迷上了做饭，花几个小时给家人做一顿饭，然后美美的吃上一顿还是挺爽的。其实很多菜做起来一点都不难，只是中餐习惯用 “中火”，“少许”，“断生” 这些只可意会不可言传的词。所以我打算写一个「码农装逼菜谱」系列，让大家都可以轻松完成各种高级菜的制作。 我的菜谱原则是： 尽量简化。能不加的调料就不加，能用调好的酱就不自己调。 尽量量化。所有调料都用量勺或者克重表示。 为了量化食材配料，你需要备好两个便宜的小工具：一个是量勺（Table Spoon），拼多多上大概 10 来块钱包邮（如下图）。 另一个是电子厨房秤，大概 20 多块钱（如下图）。 今天第一个装逼菜谱是：糖醋排骨。以下是成品效果图： 用料以下提到的 1 勺表示 15 ML（Table Spoon），即上面量勺图中最大的那个 1 勺。 名称 用量 糖醋排骨 500 克 红糖（或白糖） 4 勺 镇江醋（或香醋） 3 勺 生抽（或酱油） 2 勺 黄酒（或料酒） 1 勺 这里有个好记的口诀，上面的配料比例刚好是 54321（500g 排骨，4321 比例的糖、醋、酱油、黄酒）。 记不清楚哪个是 4 勺，哪个是 3 勺怎么办？我的记法是：糖醋排骨，名字中糖醋糖醋，糖在前，醋在后，所以 4 勺的是糖，3 勺的是醋。剩下的两个就很好记了，因为料酒在稍后介绍的很多菜中都是 1 勺，所以最少的就是料酒。 制作过程步骤 1从超市采购猪肋排，让超市服务员帮你切成小段，尽量短一点。一般一次采购都不止 1 斤，可以分两次做。 拿个小碗，按排骨的重量，按比例把其他调料配好。比如如果是 2 斤排骨（1000g），调料就应该是双份的。 排骨拿热水器放出来的 40 度左右温水泡 2 分钟，去掉血水后沥干待用。 同时用电水壶烧 400 毫升开水，后面要用。 步骤 2不沾锅烧热，放 1 勺油，油热之后下排骨煸炒。大概翻炒的速度就是 15 秒翻一下，看看排骨贴锅的那一面变色的速度，如果没有变很快可以翻慢一点。最后效果就是排骨表面的肉炒出一点金黄色。 步骤 3加开水 400 毫升，水量能够把排骨快要淹没即可。如果加多了也没关系，无非就是烧久一点而已。 放入之前配好的调料，盖上盖子小火炖煮。一共需要炖 40 分钟，中间需要检查 2 次。每家的炉子火力不一样，如果水干得快，可以中途稍微加点水。 我习惯在手环上设置一个 20 分钟的倒计时，这样可以安心玩手机或者做别的。 20 分钟后翻一下排骨，再设置一个 15 分钟的倒计时。如果火比较大水快没了，可以加一点水。 步骤 415 分钟到了后，排骨基本就烧好了。 这个时候打开盖子，火力稍微大一点，让余下的水蒸发得快一点。同时时不时翻一下，避免水少糊锅。到最后基本收汁了，就可以起锅了。 小贴士 不需要葱姜，不需要焯水。放心，做出来一点都不会腥。 如果你希望排骨吃起来硬一点，可以在排骨泡完温水后，用吸油纸把水份都吸掉。 撒上白芝麻点缀，没有也没关系，这东西就是图好看而已。 起锅前也可以加几块话梅，没有也没关系。","categories":[],"tags":[{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"}]},{"title":"像经营企业一样经营城市 - 读《我在深圳当市长》","slug":"i-am-the-mayor-of-shenzhen","date":"2021-03-19T13:46:11.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/03/19/i-am-the-mayor-of-shenzhen/","permalink":"https://blog.devtang.com/2021/03/19/i-am-the-mayor-of-shenzhen/","excerpt":"","text":"引言最近看完了《我在深圳当市长》，作者是前深圳市市长李子彬。 李子彬在 94~00 年间在深圳市当市长，是深圳发展成为国内一线城市的主政者。在他的书中，我能看到一个城市经营发展面临的各种问题和挑战，很多情况下都比企业的经营复杂。 书中也涉及了很多社会发展的黑暗面。当我向一个深圳的朋友推荐此书的时候，他第一句话就是： 「这书写的是不是 20 年前的事情？」 我一算，00 年到现在，刚好过了 20 年。于是我问他： 你怎么知道的？ 这个朋友说： 因为刑法规定违法事情的追诉期是 20 年。20 年过了，很多事情公开讲了也没有人追究。所以，这本书讲了任何可能违法的事情，也过了追诉期。 有意思的是，虽然经营一个城市和经营一家企业很不一样，但是很多基本的原则和方法却惊人地一致。我从他的书中还是得到了很多启发，以下是一些小结。 为城市发展定位我们做企业做产品讲定位，而城市的发展也是需要讲策略和方法。深圳在当初改革开放的时候，首先确立了发展高新科技产业的城市定位。在全书中，我们都能看到市政府为了这个定位在做相关的工作。例如： 高新技术产业需要人才，而深圳本地缺少著名院校。于是政府与高校通过建新型研究院的形式，将清华、北大这些院校的研究人才吸引过来，同时配套推进创新的技术落地。 让管经济的副市长同时管教育，这样教育就可以很方便地经济发展协同发展。 取消传统的荔枝节，改办高交会。 深圳的每一次调整，都在朝着这个定位在走，几十年下来，深圳成为了全球供应链和配套最完整的硬件研发城市。 树立好的经营环境政府要发展经济，主要是靠市场的手段，而不是靠行政命令。深圳市的领导班子很清楚这一点，于是他们把工作重点放到了树立好的经营环境上。他们做了以下这些事情： 改善学校的学习环境，把歌舞厅等娱乐场所赶出学校。 改善治安环境。整治军牌乱象，成立独立的巡警，同时整治公安队伍。 整理乱收费，配合合理拨款。砍掉了将近一半的收费项目，另外设立收费登记薄，明确收费内容和收费额度，通过银行统一收款，从而规范收入。 整合部门，建立一站式投资服务大厅。将 27 个相关单位聚在一起办公，大幅缩短了办理相关手续的时间。 减少审批项。 这些事情看起来简单，其实每一件事情都不容易。因为这些改革都会触及很多人的利益。比如减少审批项，就会影响很多部门的收入，人员的配备，同时如果未来因为没有审批出了一些问题，也是容易被追责的，所以改革者都需要承担很多风险。在政府里面能够将这些事情一一推进，比在企业中要难得多，但是他们全部都做到了，实属不易。 其实这些工作对于经营公司也是同样的： 例如：对于一家公司来说，对内提供一个尽量舒服的工作环境，减少各种不必要的会议，减少审批的流程，减少工作汇报，让员工尽量将精力花在工作本身上，也是非常重要的。 又例如：企业的组织架构，其实也是需要是类似于一站式投资服务大厅这样的项目制形态。相关的业务同事应该聚在一起办公，才能让项目的进展尽量高效。否则就会出现特别多的流程，特别多的职能部门共同参与，但是事情却做得很慢，也做不好的情况。 国企改革深圳在国企改革的操作也让我觉得非常像互联网公司，其中的核心就是：放权。 深圳通过成立国有资产经营公司来管理股份制改革后的企业。而资产经营公司强调不干预企业的经营，只是做好特别少的几件事情。在人上面，只是参与董事会的提名，同时委派财务总监，这样可以保证财务帐目清晰，同时重大讨论的时候可以参与投票即可。另外做好服务，帮助企业融资或者克服一些困难。 这个其实特别像现在互联网公司的风险投资。风险投资一家公司，一般也就是进驻董事会，参与一些重大决策，同时审计相关的财务报表，保证公司的经营状态是清晰的。最后做一些投后服务，帮助企业融资或者发展。 你看一对比，是不是特别像？ 做对的事情在政府经营的时候，应该做对的事情，还是应该做程序正义的事情？大部分人为了自己的私利，在冲突的时候，会选择做程序正义的事情，而放弃做对的事情。因为如果违背程序正义，会给自己带了潜在的很多麻烦。 而在子彬的书中，我看到了很多为了做正确的事情，而违背程序正义的行为。 书中给我印象最深的案例是水利工程的例子：深圳市因为慢慢发展起来人口变多，水不够用了，于是需要引水。市政府费了很大力气找到了引水的方案，省委也同意了，但是一直拿不到国家发展计划委员会的批复。 是把一切工作暂停下来等批复，还是尽快解决人民群众的饮水问题？子彬选择了后者，对水务局长说： 「上头要追责，也是处分我，你们就开工干吧！」 结果开工 9 个月后，才拿到批复。 水利工程分为两期，第二期工程得 10 年后才做，那个时候子彬已经不是市长了。第一期如果为第二期在施工上做铺垫，就可以为未来节省上百倍的钱。但是这些铺垫工作也是需要额外花钱的。 是为了任期内的经济效果，还是考虑未来 20 年的城市规模，现在多花一点钱，但是为后来的市长做好铺垫？子彬选择了后者。提前为二期工程把征地、管线预留这些都做好了提前的准备，结果 10 年后的二期工程只花了一期工程 1&#x2F;6 的钱。 要任用能人有人说国企稳定，好混日子。但是我在子彬的这本书里面看到，政府的高层任命，还是挑选的是特别能干的人。大家要找的是能成事的人，不是资历多老，背景多深的人。比如子彬在找管经济的副市长的时候，就点名要找一个懂经济的人，费劲心思去请能人过来当副市长，一点都不是高高在上等着大家竞选，或者随便挑一个听话的。 最近我一个朋友，从互联网公司跳到一家传统的企业，因为一个项目做得好，一下子连升两级，直接向总经理汇报工作，把他吓坏了。我就告诉他，说明这家传统企业也有着努力经营的心态，在任何组织，只是是希望努力经营好，就会任用厉害的人，在人才提拔上面与互联网公司没有什么区别。 要亲临一线和了解数据子彬在书中介绍了大量自己亲自参与调研的情况，每次接受上级视察的时候，对深圳的各种指标倒背如流。 这也是互联网的公司重视的企业文化，管理者不应该高高在上，应该亲自参与核心的工作，对核心数据要了如指掌。 结束语历史是一面镜子，从李子彬的这本书中，我感受到了深圳过去 20 多年发展当中面临的各种重大挑战以及主政者的决心与魄力。深圳是中国经济发展的代表城市，中国在经济上的迅速发展，在国际地位上的崛起，不是自然而然发生的，每一步都倾注着政府各部门管理者们的心血，为中国政府点赞！ 同时我也发现，管理的原则是相通的，很多企业经营管理方法与城市的管理方法类似，这让我对政府运作的陌生感减少了很多，或许有一天，互联网的人才和政府的人才是可以相互流通的，因为方法是相通的。 还是很有意思的一本书，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"缅怀子睿","slug":"forevermissed-dengzr","date":"2021-03-14T11:48:11.000Z","updated":"2024-01-06T14:52:37.939Z","comments":true,"path":"2021/03/14/forevermissed-dengzr/","permalink":"https://blog.devtang.com/2021/03/14/forevermissed-dengzr/","excerpt":"","text":"就在几天前，我的大学同学、ACM 竞赛队友邓子睿因为癌症离开了。他今年才 35 岁，一直在硅谷的微软工作，刚刚成家立业，正是大展宏图的年纪。此时离开，让我和班上同学都感慨上天不公，造物弄人。 回想起来，因为共同参加学校 ACM&#x2F;ICPC 程序设计竞赛并且为同队队友，邓子睿可以算是和我相处时间最久的大学同学了。 邓子睿高中在全国有名的湖南雅礼中学，以 NOIP 信息学竞赛省一等奖的成绩保送北京师范大学信息学院。 邓子睿高中因为全力备战竞赛，所以放弃了很多正常的高中生的课程学习，这让他的 NOIP 竞赛更像是背水一战，特别是他当年是参加了两届竞赛，在高三那届竞赛才拿到了保送资格，这让他一直耿耿于怀。 所以在进入大学之后，邓子睿在参加 ACM 竞赛的时候，没有落下任何的学业，一直在班上成绩保持前十名。他说他受不了高中时候那种感受，他一定要竞赛好的同时把成绩也搞好。 他真的做到了。ACM&#x2F;ICPC 竞赛 3 人一队，我和他同为一组，2005 年，我们一起为北京师范大学拿下了历史上的首个银奖，也是学校 ACM 队首次获得奖牌（当时获奖率只有前 20%）。同时，他在大四的时候，因为成绩优异，拿到了保送到北京大学人工智能学院的机会。 因为 4 年的队友关系，我们一直保持着联系。研究生阶段虽然在不同的学校，但是我们时不时会回师大聚聚，看望一下我们竞赛的老师冯速老师。研究生毕业后，他选择了微软中国，而我选择了网易。 我们工作后的头几年也时常聚会。他在微软的头几年并不算特别顺利，他本来希望尽快 transfer 到美国，但是因为各种原因总是耽搁。终于有一天他请大家吃饭，宣布自己拿到了 transfer 的机会，我们都很高兴。 到美国之后，每一次有机会回国内，我们就会约上吃一顿。邓子睿还是一样的精力旺盛，滑雪、拉丁舞、摄影，各种广泛的爱好把自己的生活过得有滋有味。最后一次合影，是 18 年 11 月，那次他因为工作短暂停留北京，当时微软的市值第一次超过了苹果，我们畅谈之后都祝愿大家事业越来越好。 没想到，这竟然是最后一次聚会了。 就在一个月前，邓子睿主动联系了我，介绍了他的病情，希望我没事多和他聊聊天。当我知道他已经是肺癌晚期，已经开始做化疗的时候，我当时难过得说不出话来。反倒是他安慰我说，这边有最好的治疗条件，妈妈也来美国照顾他了，而且还有老婆，身边很多朋友都很关心，医保能够支付大部分的费用。 这一个月，我们会时不时地发一些好玩的东西，因为时差和治疗，我们之间回复的间隔比较长。我默默地祝福着他，希望他能扛过这一切。直到几天前，早上起来突然收到胡博的微信，说子睿已经离开了。 他的老婆为他建立了一个网站，上面有他从小到大的各种照片，我也翻到了我们当时的合影。那真是一个无忧无虑的年纪： 邓子睿这一生，活得精彩，只是走得太快，带着太多亲人与朋友的思念。 愿天堂没有病痛，也愿活着的人都珍惜现在。","categories":[],"tags":[]},{"title":"我对比特币的理解","slug":"talk-about-btc","date":"2021-02-23T16:08:16.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2021/02/24/talk-about-btc/","permalink":"https://blog.devtang.com/2021/02/24/talk-about-btc/","excerpt":"","text":"一、前言比特币今年涨势很好，但最近刚刚有一个大的回落，跌到 5 万美元&#x2F;个以下。对于比特币，市场有两个极端对立的观点：一波观点（代表者是巴菲特）认为是废纸，另一波观点认为比特币是黄金。 我说一些我的理解吧，不一定对，算作抛砖引玉，欢迎大家留言评论交流共同进步。 二、局部的共识 &#x3D; 全局的共识让我讲一个故事来解释这个观点：「局部的共识 &#x3D; 全局的共识」。 假设在地球上有一种东西，产量有限，但是所有人都不把这个东西当作值钱的宝贝。为了故事好玩，我们拿熊猫的便便当这个东西吧。 突然有一天，有一个神秘的宗教组织对熊猫的便便产生了兴趣，因为他们的「圣经」里面，熊猫的便便是极其尊贵的东西。这个宗教组织发展得还挺大，他们大量向市场买入熊猫的便便，并且在组织内部交易。那些原本要扔掉的熊猫的便便，因为有人花钱买，于是就被饲养熊猫的人收集起来卖钱。 慢慢地，所有人都知道这个东西可以换钱，熊猫的便便值钱成为一种共识。 你看，这个故事中，只要购买量足够大，交易足够多，同时这个东西产量有限。一个原来在宗教组织内部的「局部的共识」就会变成「全局的共识」。 比特币也是一样的，其实它不需要所有人认同它的价值，它只需要相对多的少数人认同它的价值，然后交易足够频繁到价格趋于相对稳定，买卖的流通速度比较快，那么这个局部的共识就会发展成全局的共识。 你不相信它的价值可以不买它，但是因为有共识，如果有一个人送巴菲特一个比特币，巴菲特会把它卖掉而不是扔掉，因为他意识到它是值钱的。 所以，比特币的局部共识早已经形成了，在这个情况下，它肯定就不是废纸了，在我看来，它就是类似故事中的「熊猫的便便」，是一种有价值的资产。 三、需求决定价格比特币确定是有价值的资产了，那么它到底应该值多少钱一个，如何给它定价呢？ 我们再讲一个故事，每一个国家都会印钞票，钞票印多了会贬值，印少了会影响经济发展，那么到底印多少合适呢？有一个说法是货币提供量的增长应该与 GDP（国民生产总值）的增长率相同，这样货币不会贬值或升值。 比特币作为一种数字资产，它是有着一定的货币属性的。所以它的价格其实取决于： 有多少人拿这个当作交易的货币，每年的交易额是多少。 有多少人拿这个当作投资的资产，每年的买入量是多少。 假如比特币每年有固定一群人拿它当作交易的货币，每年的交易额是 100 亿。同时有 一群人愿意拿它当投资的资产，每年愿意买入的金额是 200 亿。那么比特币的市值应该就是这两者正相关的一个函数。 因为比特币的总量固定，不会增发，所以当交易额和买入量上涨的时候，比特币的市值就会上涨。 所以，比特币值多少钱，核心是判断有上一节我们提到的这个「局部的共识」人群规模，因为核心的交易还是在「局部的共识」人群内部产生。如果这个规模一直在上涨，或者这个规模不变，但是人均愿意买入得更多，比特币的价格都会上涨。 四、比特币的需求在哪里比特币的非主流需求来自于黑市的匿名交易，这块是它不太光彩的一面。这方面它是类似于货币的。 比特币还有一个主流的需求，就是应对全球的通货膨胀。这一点就类似于黄金的效果。 大家知道因为疫情，各国都印了不少钱，国内因为防疫做得好印得少，使得人民币对美元都涨到 6.5 了。于是，在现在这个时间点，如果你持有现金，那么如果国家印钱，你的现金是贬值的，为了应对这个，你应该把钱换成保值的资产。这种资产应该随着国家印钱而增值，这样就抵抗通账了。 于是人们发现，买固定资产、买龙头股票都是好的抵抗通账的方式，这也是为什么去年美股以及 A 股的白马股涨得很好的原因。除了买股票，买比特币也是一种抗通账方式，这和买黄金的效果类似。 比特币相对于黄金来说，因为产量是固定的，所以稀缺性会更强。另外它的波动比较大，交易所又提供了很多杆杠交易，吸引了喜欢逐利的散户们。杠杆交易更像是一种赌博，人性都是好赌的，比特币交易所迎合了这类人的需求，同时又不受正常的股票交易所的监管限制。 于是，比特币在坚强的基本抗通账需求的基础上，变成了散户们的一场狂欢。 五、未来比特币的走势比特币的价格还是由供需决定，未来比特币作为一种发行总量固定的资产，会越来越被更多人认同。只要认同它的人在增加，长期来看它都是应该上涨的。 但是暴涨暴跌其实对一种资产来说是不好的，我认为主流交易量上一个台阶之后，加上散户们慢慢交一些学费之后，比特币的投机和赌博需求不会长期存在。 赌博本质上是一个零和游戏，没有人能够一直从别人手里赌赢钱，这个时候比特币的价格应该会趋于逐步稳定。长期来看，也没有哪种资产长时间地被当作投机和赌博的标的，巨大波动都是相对短时间的。 对于参与比特币投机的朋友，我帮大家算一个账： 如果一个人参与比特币的短期杠杆交易（看涨或看跌），连续进行了 4 次交易，其中有 3 次挣了 90%，另外有一次 -90%，请问这个人最终的收益率是多少？ 这个数学题其实挺好算的，1.9*1.9*1.9*0.1=0.6859，最终这个人本金会亏将近一半。 你看，这个天天在朋友圈炫耀炒币挣钱，很少亏的人，只要亏一次，整体收益都可能是负的。想明白这一点，大部分都不应该做高风险的杠杠交易。 如果比特币投机属性慢慢减少，它的价格会变得稳定，然后由于需求慢慢上升和社会的通胀，它的价格会逐步上涨。 六、可能的风险（黑天鹅事件）比特币的巨大风险有两个，一个是监管风险，另一个是数字加密的安全风险。 监管风险来自于部分国家可能认为它对法币带来了实质性的冲击，影响了国家对于货币的发行权。这种禁令可能不会在全世界发生，但只要有部分国家禁止它，就会影响它的需求量。 另一个风险就是它只是基于一个密码，所以被盗取后追回的难度极大。交易所由于安全漏洞被偷币的案例比比皆是。2019 年交易所币安就被盗了 7000 个比特币。所以你只要不是把钱放在冷钱包里面，就有可能因为交易所的安全原因被盗取掉比特币。 比特币冷钱包相对安全，但是未来量子计算会不会将现有世面上的加密算法攻克还不好说，到时候比特币应该需要全网的一次安全升级，才能保证密钥的足够安全。虽然现在看不到这方面的危险，但是技术的进步总是飞速的，奇点到来的那一天是否遥远并不好说。毕竟互联网诞生才 50 年就把全世界改变了。 七、小结小结一下： 比特币是数字资产，不是废纸，因为它已经有了「局部的共识」。 比特币的需求决定价格，长期来看它有类似于黄金一样的抗通胀的效果。 长期来看，比特币不再成为赌博和投机的标的后，价格未来会越来越稳定。 监管和安全是比特币最大的风险。 欢迎留言一起探讨。","categories":[],"tags":[]},{"title":"华为手机 vs 苹果手机，我的一年评测对比报告","slug":"huawei-vs-apple","date":"2021-02-21T12:40:38.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2021/02/21/huawei-vs-apple/","permalink":"https://blog.devtang.com/2021/02/21/huawei-vs-apple/","excerpt":"","text":"前言因为工作的原因，我早年一直从事 iOS 开发，所以一直用着苹果手机。iPhone 的体验一直挺好的。 但是我一直比较好奇顶级的 Android 手机怎么样，体验和苹果会差多少，于是我去年就换了华为的 P30 Pro。 对比使用了一年，给大家分享一下我的感受。预告一下，前面夸华为比较多，后面夸苹果比较多。 硬件对比之下，我发现华为的硬件某些地方比 iPhone 还要厉害一些。比如： 摄像头华为的这款摄像头可能是因为和莱卡合作，所以调校得还算不错。和苹果的摄像头比较起来，自然光照下可以说各有特点。苹果的拍照更加真实自然，而华为会用 AI 给你默认 PS 图，这样蓝天更蓝，美食饱和度更高。 在夜景情况下，华为拍照应该算是完胜，可以在人眼基本都看不清的情况下，通过延长曝光时间和自动的 HDR 拍出比较清晰的图片。 自拍模式下，华为会自动开启美颜：光滑皮肤，瘦脸，美白。把我整得像个小白脸一样。但不得不说，这确实符合大部分中国人的自拍习惯。 华为还搞了一个 50 倍变焦，可以拍月亮。这确实是一个比较好的营销的点，但是说实话除了给朋友装 B 之外没有什么卵用，因为 50 倍之后影像已经极度模糊了。 拍月亮这个场景华为做了专门的优化，因为月亮面向地球的一面是固定不变的。为此我还专门查了一下这个叫做「地球引力潮汐锁定」。反正因为我们看到的月亮环形山的位置和形状都是固定不变的，所以华为的 AI 算法帮我们把环形山给 PS 上去了。不得不说，这是一个好点子，但这和摄像头的能力没什么关系。 iPhone 12 Pro 的摄像头也有胜出的地方，iPhone 12 Pro 引入了更强的防抖功能，这样录制移动的 vlog 的时候效果会更出色，这一点华为是很差的。 电池电池和充电速度华为 P30 Pro 都比 iPhone 要体验好。一般 iPhone 的电池新手机能用一天，老手机能用大半天。而华为新手机能用一天半，老手机也能用一天。 华为在省电这件事情上做了一件很暴力，但是很有效的办法。华为把所有的应用，都默认禁止了后台操作，仅保留了中国人最常使用的微信等应用允许常驻后台。 安卓市场的应用本来很流氓，结果华为这招更流氓，直接相当于开启了白名单模式。我刚换华为的时候，发现百度云盘不能自动备份照片了，一看才发现百度也被强制默认禁止了后台唤醒操作。这些操作都是默认的，所以普通用户都不会看到应用对权限申请的提示。 相对来说，苹果的应用市场要正常一些，只要你的应用逻辑上需要常驻后台，审核的时候就不会卡你。 但不管怎么样，华为做到了更长的待机时间。 充电速度充电速度最新款的 iPhone 支持最高 22w 的充电，华为 P30 Pro 支持 40w 的快充。充电速度华为更厉害。 另外，iPhone 不送充电器，这一点有点让人不爽。华为是送 40w 的快充充电头和充电线。 ​华为对充电做了一个优化我觉得也很好，就是对有夜间插上充电线的用户，智能学习充电行为，避免长时间晚上电池过充，因为锂电池的过充和过放都不太好。 安全认证华为采用了类似 Face ID + 屏下指纹的双认证方式，苹果是采用 Face ID。 我个人还是更习惯屏下指纹，我一直觉得指纹比 Face ID 体验更优，特别是夜间在被窝里面玩手机的时候。 当然，现在疫情戴口罩了，Face ID 显得更加不人性化。 苹果应该引入类似的屏下指纹技术。 NFC 和红外遥控器安卓手机都可以开放对 NFC 硬件的控制，所以我使用华为的钱包功能，把各种工卡和门禁都复制到了手机中，这还是挺爽的，可以少带很多卡。 苹果为了安全的原因，虽然有这个能力，但是只开放了公交卡和 Apple Pay，从实用角度，还是差了一些。 红外遥控器的能力类似，华为可以通过这个遥控几乎所有的电器，虽然用得不多，但是找不到遥控器的时候应急还是挺方便的。 激光雷达扫描仪只有 iPhone 才有的硬件能力，可以扫描整个场景进行 3D 建模。配合可以做一些设计或者 AR 的游戏。 生态硬件的生态上，苹果就比华为厉害多了。比如苹果的跨设备剪切板，对于同时使用苹果手机和电脑的用户来说就非常爽。 苹果的手机与 AirPods 的连接，也是非常舒服的。 华为手机如果要做到同样的事情，得买华为的耳机，我为此就专门另外买了一个华为的 FreeBuds。但是华为的这款耳机明显比 AirPods Pro 差太多，比如降噪功能就是个摆设，完全不可用。 软件垃圾短信拦截软件方面华为有一些功能刚好解决了中国人的烦恼，比如：截长图和垃圾短信拦截。特别是垃圾短信的拦截功能，比苹果好用太多太多。我看了一下统计，它平均每天帮我拦截 5 条垃圾短信和 2 个骚扰电话（直接挂断）​： 苹果的 iMessage 垃圾短信在中国就没有断过，老是会收到陌名其妙的非法赌博短信。 应用市场华为预装了特别多的软件，这种特别有一种被绑架的感受。 华为的应用市场也有一个特别坑的地方，就是如果你在华为应用市场下载的游戏，是不能和微信的好友相互之间游戏的，现在很多游戏其实都有一些社交属性，如果看不到微信好友，那么就变成一个孤岛了。所以建议大家，下载游戏不要去华为应用市场下，一定要去应用宝或者游戏官网下载。 Google Play华为如果要下载国外的应用，会麻烦很多。不像苹果，只需要切换成国外的帐号即可。特别是现在美国对华为的制裁，会使得很多国外应用比较难下载到华为手机中。 前阵子 clubhouse 火的时候，我为了下载它就费了挺多精力的。但是如果是苹果手机，就会很方便。 科学上网苹果手机有很多收费的高质量的上网 App，这方面安卓生态也要差很多。 日历华为的日历不行，基本无法使用。全世界做好了日历这个应用的也就只有谷歌和苹果。 弄得我只好在华为手机上装了一个谷歌的日历，但是因为科学上网不方便，日历同步还是有影响。 这个对于我的日程管理多少有一些负面影响。好在公司统一用企业微信的日程，倒没有影响工作。 价格华为 P30 Pro 256G 我买成 6000 左右，苹果 iPhone 12 Pro Max 256G 得 1 万左右，价格还是差了不少。 小结华为手机占优的地方： 莱卡摄像头的夜景，自动美颜，50倍变焦 电池待机时间更长 屏下指纹 可以复制各种门禁到手机中 截长图，垃圾短信拦截 价格相对便宜 苹果手机占优的地方： 摄像头的防抖功能 激光雷达扫描仪 软件更安全 硬件生态更好，配套的耳机更好用 下载国外的应用更方便 科学上网 App 更成熟 华为手机特别不好的地方： 应用市场的游戏与微信好友信息不能互通 日程管理 苹果手机特别不好的地方： iMessage 垃圾短信 Face ID，戴口罩没法解锁啊！ 说了这么多，最后要换新手机，到底换华为还是苹果呢？ 我觉得吧，用习惯苹果的可以继续用苹果，毕竟很多花钱购买的 App 都买过了，而且苹果的生态确实更好，配合苹果电脑切换起来也更方便。虽然苹果手机稍微贵一点，但是给别人的品牌感受也更好一点，这就是全世界最值钱的公司生产的大众量产的最贵手机了。 习惯华为手机的人，可以继续使用华为。毕竟华为针对中国人做了很多定制的优化，美颜、门禁复制、截长图、垃圾拦截这些功能虽小，但是用起来还是挺爽的。大部分时候你也不需要下载国外的应用，也不需要复杂的日程管理。虽然你的手机没有人家的 iPhone 贵，但是你可以说你爱国，支持国货啊！ 那我呢？我两个都买，没办法，谁让我做互联网工作呢，工作需要！","categories":[],"tags":[]},{"title":"关于做空的一些新理解","slug":"us-stock-short-event","date":"2021-01-30T12:37:49.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2021/01/30/us-stock-short-event/","permalink":"https://blog.devtang.com/2021/01/30/us-stock-short-event/","excerpt":"","text":"引言最近在美股市场上出了一件大新闻，散户一起对抗做空机构，最终使得做空机构亏了几十亿美金，新闻见：《史诗级散户血洗华尔街三天三夜！感受人民的力量吧！》。 这件事情让我对于做空有了新的理解，分享给大家。 什么是做空对于不了解做空的朋友，我在这里稍微给大家解释一下什么是做空。 在股票市场上，做空一只股票就是从券商那里借来这只股票，然后卖掉。由于股票是借来的，所以最后还是需要买入股票，将买来的股票还给券商。做空的赢利来自于最后买入股票的时候，目标股票下跌，于是获利。 做空保证金做空不是随随便便都可以操作的，他需要你的帐户里面有一定的保证金。 我举一个具体交易的例子。假如一只股票价值 100 美金。你做空这只股票，从券商那里借入 1 股股票，把它卖掉。这个时候你的账户上马上会得到 100 美金。如果这只股票如你所愿股价下跌，那么你最后就可以以低于 100 美金的价格把它买回来还给券商。 但是如果这只股票最后价格还在持续上涨。由于券商要求你最后有能力将股票买回来还给他。所以你就需要往你的股票账户里面添加相应的保证金。如果股票涨到 200 美金，那么理论上你的股票账户上就应该有 200 美金的现金用于保证你能将这支股票买回来。 具体的保证金规则比上面的举例要复杂，但大体的规则都是随着股价上涨，帐户需要提供更多的保证金。下图是盈透证券的保证金规则： 散户与机构的战争当你的保证金即将不足的时候，你就会面临券商的强行平仓。理论上做空一支股票，你的收益最高则是这个股票卖空时的价值，但这个股票如果一直上涨的话，你的理论亏损是无穷大的。假设股票卖空时值100美元，下图是收益图： 由于标的一直上涨，亏损会无穷大，同时没有谁的账户有无穷多的保证金，所以做空机构如果保证金不足以承担买回做空的股票时，就会被券商强制平仓。 强制平仓时，做空机构的钱会全部用来买回之前做空的股票。而这种行为，又会进一步推高股价。 所以这次做空机构公开了做空的标的后，散户选择了与做空机构对着干，核心的目的就是使机构爆仓。而这些做空机构真的被强大的人民群众的海量资金爆仓了！于是人民群众收割到了几十亿美金的收益。 我对这种行为的理解这件事情让我对做空产生了一个新的理解。当机构对一个股票进行做空或者散户在逼空的时候。这个公司的股票已经完全无法与他的真实价值相关联。 最终散户和做空机构比拼的是谁的钱多。因为当散户集体推高价格的时候，做空机构需要不停地提供账户保证金，才能保证自己不被爆仓。而只有资金多的一方可以坚持到最后。 输的那一方，需要交出投入到牌桌的所有的资金；而赢的一方，可以拿走所有。这一点和德州扑克倒是挺像的。 拿这次的事件来说，做空机构输掉的，是他们帐户里面所有的保证金。 当你不知道力量的双方谁的钱多的时候，这就完全是一种赌博了。但是有意思的是，这居然还是合法的。 这种行为合法吗？这件事情后续又出了很多衍生的事件。 也许是这些做空机构给券商施加了压力，这次涉及的几支股票在随后被限制散户交易，这在崇尚自由的美国立刻引发了质疑和诉讼，很快这些限制又被解除了。 而马斯克也看热闹不嫌事大，在 Twitter 上说卖空是合法的骗局，因为特斯拉也经历过多年的做空。 这种行为合法吗？在现有的法律框架下，看起来这是合法的。但是细想一下，这又似乎是一个合法的抢钱游戏，游戏规则是：谁的钱多，谁就可以抢走进场玩的其他人的所有钱。 我想以后任何做空机构在做空的时候，都会心有顾忌了。因为人们可能不再理性的把股票买卖当作价值投资，而是把做空机构的钱抢走做为目标。 在基本的道德、公平、自由的原则下，看起来应该立法规范这种行为，因为这种行为就只是一种合法的赌博，并且对社会无益。 价值投资为什么不怕做空相对于做空，正常的买入股票被围猎的风险就要小很多。因为虽然股票可能长期被低估，但是你永远不用担心保证金的事情，因为拥有股票并不需要提供保证金。 而对于一家经营业绩良好的公司来说，它可以用分红，回购等多种手段来对抗股价的低迷。 小结1、做空与逼空者的游戏，是一种比拼谁钱多的，赢者通吃的赌博。 2、永远不要做空。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"为什么开发一款软件只要 3 个月，开发一款硬件却要一年","slug":"the-difference-between-software-and-hardware-development","date":"2021-01-07T00:28:23.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2021/01/07/the-difference-between-software-and-hardware-development/","permalink":"https://blog.devtang.com/2021/01/07/the-difference-between-software-and-hardware-development/","excerpt":"","text":"背景我们公司在软件开发上的速度极快： 2012 年猿辅导公司刚成立的时候，想做一款教育微博，我们花了 3 个月的时间做完上线。 2013 年我们想做猿题库，我们花了 2 个月的时间做完上线。 2014 年我们想做小猿搜题，我们仅花了 1 个月时间，就完成了功能开发。 而我们在开发斑马点读笔（题图）的时候，前后却花了将近 10 个月的时间，远远超过软件开发的时间。 2020 年我们有多款在研的硬件产品，我们试图压缩硬件产品的研发周期。但是执行下来发现，在极端顺利的情况下，也需要 6 个月的开发周期。稍有一些意外，就可能拖到 8 个月甚至 10 个月才能完成量产。 教育硬件还算简单的，我们再来看看手机产品。熟悉苹果的朋友都知道，苹果一般需要花 2 年时间，才能发布一个全新的手机设计。中间间隔的那一年，苹果仅仅会做一个小改款，升级一下 CPU 主频或者摄像头像素，整体的设计并没有什么变化。 问题为什么硬件研发的周期远高于软件研发呢？ 答案原因一：硬件的链条长，环节复杂，但是对调整的容忍度低软件研发的时候，最后一刻有严重 Bug，我们可以熬熬夜修好再上线。上线之后有小问题，我们可以在几天之后发布一个小版本升级。所以，软件可以用 Scrum 来快速迭代，业界常见的迭代周期是两周一次发布。 硬件如果最后一刻发现有严重的 Bug，那么不好意思，你需要重新制作模具。而不算模具的修改评审时间，仅仅开模的时间通常都需要 30 天左右。而开模前还需要重新做结构设计的调整，开模之后需要重新试模，外观调整之后可能涉及的 IC 排布的调整，包装设计的调整，3C 重新认证，运输测试重做等等，基本上相当于一夜回到解放前。 打个比方，硬件的外观大的调整有点类似于大家玩陶瓷，你好不容易做好了，进熔炉烧制好了，然后你发现有一个设计缺陷，那这个陶瓷只能完全报废掉了。 不止是硬件部分，电子部分的调整其实也很难。教育硬件产品通常逻辑不复杂，为了节省成本和功耗，硬件产品的逻辑通常使用 掩模 的工艺来进行烧录。这种烧录的能力现在还是集中在台湾地区，所以烧录时间要好几周。而且烧录有量的要求，一次烧录的起订量通常是 5K 左右的。 如果你研发到量产阶段，才发现有一个逻辑要修改，那么对不起，整个 IC 部分至少 5000 的起订量需要报废掉重做，重做周期可能好几周。这还没有算上 PCBA 电路板的重新贴片带来的时间成本。 所以，硬件的外观、电子逻辑在研发过程中的调整，都可能对整个产品的研发进度产生极大的影响。 为了防止这种事件发生，硬件在研发环节中，加入了多次的确认和检查，比如在开模之前先做 EVT 验证，又比如工业（ID）设计和结构（MD）设计做出来要打手板验证等。于是，我们就有了一个相对来说比较复杂的项目管理流程。 下图是小米公司的项目计划模版，可以看出一个硬件的研发牵扯的环节非常多。稍微不注意就会有差错。 即便这样，也还是很容易出错。我们在实践中，单单在包装工程上就出现过多次失误。比如和供应商时，不能很好地控制包装方案与成本；又比如设计的包装不利于运输，使得物流箱的成本变得很高。又或者打样的时候来回多次沟通，每次都打样不到位等。 但就像只要有程序就一定有 Bug 一样，硬件研发过程很难保证一定是完美的。所以如果有大问题只能召回或者报废，小问题只能忍着先发布，下一版再迭代。iPhone 每一代新品发布，就还是伴随着一些问题，历史上最有名的是 iPhone 4 的死亡之握，最终苹果没办法，所有人免费送了一个手机壳才解决。 原因二：硬件的资金成本更高硬件当前的 3D 打印技术和电子电路的技术，仅可以用来做用户试用，验证一些功能设计上的问题。 但是硬件产品从一个高保真的原型手板到量产，其实需要克服很多工艺上的问题，在这个过程中，就需要花很多钱。这些钱都是需要摊薄到未来的大规模量产上的，否则就很不经济。 打个比方，我们做一款玩教具，假设这个玩教具的开模费用是 20 万，那么如果我们只生产 2000 台，那么摊到每台上的模具费用都有 100 块钱。而一个模具通常可以用 50 万次，正常量产后的每台玩教具的模具费用只有 0.5 元。这里面差了 200 倍的成本。 所以为了把产品的成本控制下来，同时也为了保证开模注塑工厂的利益（不然别人不跟你玩），通常首批玩教具生产的量都需要是 5000 左右的，这就是一笔不小的投入费用。 IC 的部分也一样，掩模烧录的起订量通常也是 5000，这也是一笔不小的费用。 最后假设我们什么都很顺利，花 20 万开了模，做了 5000 套玩具，假设每款玩具的制造成本是 100 块，那么一共就花了 70 万元。 硬件第一批产品出去后，多多少少会有一些问题，这个时候你就需要尽快把存货卖出去，否则你回收不回来资金，很难启动第二轮的生产。我看 《马斯克传》，当年 Tesla 的第一代车就是因为有很多小毛病差点卖不出去，最终他没办法让所有员工都出去卖车，才逃过一劫。乐视当年做手机，手机卖不出去，最后好多都直接送出去，因为放在仓库里面电池亏电太久也报废了。 第一代产品有小毛病没卖好，资金又都压在存货上，有大量公司都被库存和资金周转搞死了。 小结 硬件研发链条长，在研发过程中的任何调整，都可能对整个产品的研发进度产生极大的影响。 硬件的研发需要基础量和开模，使得资金门槛高，给后续库存和资金周转带来挑战。","categories":[],"tags":[]},{"title":"我所经历的拍照搜题的竞争","slug":"search-tool-competition","date":"2021-01-03T12:28:11.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2021/01/03/search-tool-competition/","permalink":"https://blog.devtang.com/2021/01/03/search-tool-competition/","excerpt":"","text":"一、序言最近听说学霸君似乎陷入了危机，见报道 1，报道 2。我突然想把这段拍照搜题的竞争回顾一下，分享给大家。 二、拍照搜题的玩家入场学霸君是中国最早做拍照搜题的公司，拍照搜题这个需求挖掘得非常精准，到现在也是整个 k12 行业最大的工具类需求。 拍照搜题本身也有着非常强的技术和内容门槛，所以当学霸君上一定规模的时候，市场的竞争对手并不多。我记得当时学霸君对外宣称：自己的拍照搜题技术壁垒有 5 年。 这句话其实不对，对于有 AI 算法研究团队的公司来说，拍照搜题的技术壁垒也就最多 6 个月时间。 相对于算法的壁垒，题目内容的录入反倒更难，因为你需要收录国内上亿道题目，才可能提供这种服务。 所以，在 2014 年和 2015 年，我们猿辅导、百度的作业帮先后入场拍照搜题。猿辅导在做猿题库的时候就积累了很多题目，作业帮在做内容学习社区的时候也积累了很多题目。算法对于我们来说都不是很难的事情。 我刚好是这个竞争的重度参与者，作为小猿搜题的产品技术负责人，我从 14 年产品立项就一直跟进这个产品，我们大概花了 2 个月做出来了小猿搜题第一个版本，14 年 9 月教师节那天上线。 作业帮的反应速度也很快，作业帮在 14 年还是一个同学间作业互助的社区，到 15 年初也改成主要提供拍照搜题的工具软件。 15 年还有一家拍照搜题公司风头很大，叫学习宝。 于是，到了 15 年中，学霸君，小猿搜题，作业帮，学习宝开始了商业的竞争。 三、竞争的发展工具类产品竞争，核心是比拼什么？ 有人说是体验，有人说是算法正确率，有人说是内容。但是我看来，这些都很难做出极大的用户差异。 我们定期做算法评测，日复一日的优化算法和录入新的题目内容。长年维持着一个上百人的实习生团队。但这些事情，都不足以让大家拉开差距。 因为你在做的时候，别人也在做，而内容和算法的优化对于用户体验来说，感受是细微的。98% 的准确率和 97% 的准确率对于算法来说可能需要好多个月地努力，但是用户要差不多拍 100 次才能有一次感受到差异。事实上这一点算法差异用户根本就感受不到，没有用户会认真地评测搜题软件的准确率。 所以，如何规模化的获客，才是搜题软件竞争得关键。 学习宝是第一个看到这个核心的，他们非常早就开始了大规模的获客投放。但他们也是第一个掉队的，因为他们连基础的算法和内容补充都没有做好。我们和学霸君，作业帮的算法差距一直都在几个点这样，但是学习宝能够比我们差 20%~30% 的准确率。这肯定不行，用户简单搜两三次就会发现差距。于是他们在市场上连续投放几个月之后，就没有了声音。 学霸君在这个事情上犯了致命错误，他在所有方面都占优的情况下，在 15 年没有大规模的获客。因为他们之前太舒服了。 你想想：一款直击用户痛点的拍照搜题产品，在 2015 年之前没有竞争对手出现，用户口碑传播的效果肯定非常好。所以学霸君在竞争开始前，已经习惯了非常舒服的用户增长，口碑传播这一套，而且效果很好。他们很自然地继续希望用这种低成本的方式扩张。 这个决策失误带来的代价就是，我们和作业帮在商业上的投放使得我们迅速加速占领了增量的市场。2015 年猿辅导还是一家小公司，我们想了很多办法来降低获客成本。 最终完成这场竞争的其实是猿辅导市场部的同事们，他们用了很多创新的方法来寻找低成本渠道，最终我们探索出来很多低价的获客方式。 而学霸君，在拥有上百万存量用户的情况下，被我们很快超过了。我为什么知道他们被超过了？因为他们的用户 ID 是 “自增的”，每次注册，用户的 User ID 加 1。于是我们只需要每个月注册一个新用户，就知道他这个月新增了多少。到 2015 年底，我们已经甩开学霸君很多了。 到了 2016 年，拍照搜题的用户量排名是：作业帮，小猿搜题，学霸君。而这个排次也一直到了现在。 四、题拍拍 学而思后知后觉，20 年突然觉得自己不能在课堂上推荐竞争对手的产品，于是出了一个题拍拍。题拍拍挖了不少小猿搜题的同事过去。 竞争上，算法内容肯定没得比，所以他们主打搜不到的话真人答疑。其实大家都知道这个事情用户成规模之后根本做不到，但是学而思的逻辑应该是我先说我有，把用户吸引过来再说，而且用户量小的时候，我还真能做到真人答疑。 1000 个答题官，答题平均花费 5 分钟，高峰期的时候每小时也就只能服务 1 万多学生。搜题的用户高峰每小时至少是几百万用户，99% 的人排队是什么体验？或者学而思有能力招 10 万个答题官？ Anyway，从竞争角度看，初期用户规模小的时候用这个策略还行。长远来看，构不成差异化竞争。 五、结束语时光倒回，学霸君如果在 14 年就融资并大规模推广，有可能就会是这个行业最大的玩家并垄断市场，想到这儿也挺替学霸君惋惜的。","categories":[],"tags":[]},{"title":"2020 年个人总结","slug":"2020-summary","date":"2021-01-01T14:05:26.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2021/01/01/2020-summary/","permalink":"https://blog.devtang.com/2021/01/01/2020-summary/","excerpt":"","text":"工作融资今年公司融了 35 亿美元，估值也上升到了 155 亿美元： 年初的时候，高瓴资本投了 10 亿美元。 10 月，腾讯和 DST 分别又领投了共 22 亿美元。 12 月，媒体报道又有云锋基金 3 亿美元的交割。 应该说疫情对于我们来说是利好，因为很多线下的教育需求被迫转移到了线上。希望借助一这一波行业机会和资本的助力，猿辅导可以在竞争中占据优势。 入职 8 周年今年 7 月 28 日，在内网的系统上突然看到下面一张文案，一时感触就截图了下来： 没想到不知不觉就在一家公司待了 8 年，8 年时间转换了很多角色，也收获成长了不少，真心感激猿辅导给的机会。 在公司待久了，能够感觉到资历对于工作的一些推动作用。因为我对公司各个部门的人都认识，所以当我需要什么协同配合的时候，别人很难做到的事情，在我这儿就只需要刷个脸。 在公司待久了，自己期权的收益也变得越来越大，所以自然也越来越把公司的利益放在首位，只要事情做成了，别的东西相对不重要。 在公司待久了，上下级同事相互之间的信任感也越来越强，很多时候不需要花费特别高的沟通成本，也不需要特别担心信任关系，就可以把精力全部投入到业务中去。 这么说起来，现在工作得还真是挺舒服的，希望能够做出一些成绩出来。 新业务因为负责公司的某个新业务孵化，今年的工作让我进入了一个很不舒适的状态。我主要的经验在于对线上产品研发的理解和管理，而新的业务需要侧重线下的内容，这一下子让我有点蒙。当然不止是我，团队对于这个新业务的理解也是随着时间推移才一步步变得明了。 因为工作侧重线下，所以今年我花了挺多时间学习如何做好一款硬件，也在努力思考与供应商的关系应该如何相处。说实话，硬件的东西还是挺麻烦的，单单看涉及的岗位就知道这个链条比软件研发要复杂得多，硬件研发涉及的岗位包括：硬件产品经理、ID 设计、结构设计、开源和采购、硬件工程师、质量工程师、质检、项目经理、包装工程师。 因为涉及供应商，所以关系处理也不像对内那么简单。通常核心产品需要储备多家供应商，对供应商的管理以及对成本的管控也是相当麻烦的事情。 长期来看，今年在硬件团队上的投入还是非常值得的，我们公司之前在这方面是一张白纸，所以基本上完全依赖于合作伙伴，某些产品合作伙伴一旦不靠谱的话，我们就会非常被动。 硬件团队的建立可以有效地承担起供应商伙伴的培养和管理工作，同时也可以帮公司在长期的时间中发掘教育硬件的机会。 除了硬件外，今年我也花了比较多时间研究怎么做绘本。这方面其实是我的短板。绘本是需要很强的美术鉴赏能力的，我这方面偏弱，不过还好团队有轩姐、辰烯参与，帮我补了很大的空位。 新业务的孵化慢慢走上了正轨，但是一切都表明这是一个超级慢的业务，我在心里面保持着耐心，希望花个 3-5 年把这款产品打磨好。在这个飞速发展的年代，估计很少有人有耐心花这么长时间吧。或许这是我做这件事情的唯一优势。 读书因为今年工作需要学习的事情太多，所以挤占了我不少读书的时间。不过我觉得工作中的学习更有价值，因为它需要实际应用到工作中来检验学习效果。所以读书上​做了一些妥协。 今年读还是读了不少书，但是很多书就没有到读书笔记阶段了。有读书笔记的一共有 15 本，以下是简介和我的评分： 《投资中最简单的事》【7分】。高毅资产 CEO 的作品，主要强调投资中的逆向思维，指导大家关注股票的估值、品质、时机。 《俞军产品方法论》【6分】。作者俞军是互联网行业的前辈，在百度和滴滴都工作过，这本书可能最大的问题是观点太不系统。 《麦克米伦谈期权》【8分】。这是一部大篇幅作品，我花了很长一段时间消化它，并写了四篇读书笔记。对于想参与股票期权交易的人，本书还是很有必要读一下的。我读完最深的感受就是：普通人别碰期权。 《Machine Learning by Tutorials》【9分】。今年读的唯一一本纯技术书籍。给我带来的收获除了理解了 CNN，RNN 等常见的深度学习模型外，就是对于卷积有了更深的理解。 《您厉害，您赚得多》【8分】。雪球 CEO 方三文的作品。和俞军那本书类似，缺点是不太系统。 《关键对话》【9分】。很好的一本关于沟通的书，值得多读几遍。核心是在沟通的时候直观问题，同时又照顾好对方的情绪，以便促成有效的沟通。 《硬战》【7分】。一本硬件研发基础类读物，读完就知道硬件研发为什么那么慢了，书中的各种失败的案例也挺值得参考。 《情感吸血鬼 - 如何识别并逃离病态关系》【7分】。一本反 PUA 的书。 《痛风及高尿酸血症基层诊疗指南》【9分】。这其实不止一本书，为了研究清楚高尿酸我翻了大量的资料。如果你有和我相似的困扰，建议你读一下。 《价值》【7分】。高瓴资本的创始人张磊的作品。看的时候感悟很多，看完之后记住得很少，只剩下一些投资腾讯的逻辑以及对于品德的一些讨论。 《反脆弱》【8分】。《黑天鹅》的作者塔勒布的又一本畅销书。其实挺好的观点，就是内容又臭又长。我印象最深的就是教大家构建自己的反脆弱系统。 《掌控工作》【8分】。对于职场新人来说，这个书可以给 9 分，对我来说很多已经了解过了。 《全球房地产》【8分】。房地产长期看人口，中期看土地，短期看金融。 《女人这东西》【8分】。书名不太正经，但内容是正经讲两性关系的。适合有另一半的人看看，了解另一半。还有一本叫《男人这东西》，也是 渡边淳一 写的，适合放在一起看。 《好战略，坏战略》【8分】。介绍了一些制定战略具体方法，例如：聚焦、转换视角、设计思维、直面冲突、连贯性活动。 【9分】的图书有三本，重点推荐给大家： 《Machine Learning by Tutorials》、《关键对话》、《痛风及高尿酸血症基层诊疗指南》。 股票交易今年股票交易挣了 40%，但是我因为疫情有点恐惧，所以并没有全仓，一直保持在一个半仓的仓位上。详细的总结在：2020年我的股票交易总结。 最大的后悔是错过了特斯拉。 最大的惊喜是买入了哔哩哔哩。 最大的收获是「不要做空」。 20 年的目标回顾去年的目标，严格上来说，都没有完成： 读书如果以读书笔记来算，只完成了 14 本。这件事情主要是因为工作。今年工作带来的新知识学习更多更重要，另外今年负责的新业务变化比较快，没有以前那么舒服，所以更需要投入精力和时间思考。 游泳没有做到一周 2 次。最近的频率只有一个月 2 次。一方面是因为疫情，另一方面是因为没有了游伴相互监督。 工作上的大决策，今年做得都有一些晚，复盘下来其实可以更早更快一些。 21 年的目标 读 12 本书。坚持读书对我来说很重要，不过读书笔记希望减少到 12 本，这样我个体的压力不会太大。 每周 1 次游泳，每次 1000 米。 更多关注自己的心理状态，照顾好自己。 个人 Milestone 学习积累了大量硬件研发的行业知识。 买了心仪很久的特斯拉 Model X，晒一张提车当天的照片。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"如何申请境外银行卡","slug":"how-to-apply-international-bank-card","date":"2020-12-26T00:36:21.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/12/26/how-to-apply-international-bank-card/","permalink":"https://blog.devtang.com/2020/12/26/how-to-apply-international-bank-card/","excerpt":"","text":"老有人问我怎么申请的境外银行卡，今天就给大家分享一下我知道的境外银行卡开户方式。 一、肉身出境办理现在因为疫情出境游受限，其实平时大家可能都有境外游的机会，这个时候可以考虑直接在当地办卡。香港地区可以直接下卡，也没有资产的限制，美国我几年前旅游的时候，在当地的唐人街中国银行问了一下，只需要提供护照及一个当地固定的接收帐单地址，也可以直接办卡。 这种办理的方法的好处是不用受一些限制，你可以比较随意挑银行来办。性价比最高的应该就是去香港办理了。 二、国内银行国内比较大的银行也可以申请办理境外银行卡，比如招商，中行，不过限制都比较多。比如招商银行需要有 500 万的资产在招行才可以办理。中国银行我几年前问的时候，说名额有限，需要预约，然后我登记之后就一直没有消息了。 现在招商银行有针对我司的特别政策，如果是猿辅导的员工，即可办理境外账户的开立服务。包含招商永隆银行（借记卡账户）+招银国际（证券账户）。 除了境外账户的开户，招行还提供了针对性的私人银行服务（无限次机场贵宾厅服务+PP卡）和金葵花理财服务。该两项服务有硬性的资产要求，但都有相关办理的优惠。 所以你也可以考虑加入猿辅导。 三、境外银行的国内机构恒生、汇丰、花旗等银行在国内设有机构网点，所以其实可以去这类银行办理，相关的条件会比国内银行要低得多。 我个人就是在颐堤港的恒生银行办理的香港卡（下图）。2年前的要求是需要办 10 万块的非保本理财（挂钩恒生指数）或者办理 50 万的保本理财。这两种理财均为一年，到期后即可以转出。 现在应该这类银行也有政策，不过具体的条件我很久没有关注了，或许有变化。 四、华美银行 Velo 我有一个同事成功办理了这个银行卡。华美银行是设立在美国，但是专门为华人服务的银行，可以直接在网上申请它的银行卡。华美银行相对于上面那些银行较小，但也是纳斯达克上市公司（股票代号：EWBC）。 具体的申请方式可以参考华美银行的 Velo官网。 五、其它管理费就我所知，似乎所有境外卡在卡内余额小于一定数额时，都会收取一定的小额管理费。不同银行政策不太一样。管理费每月大概需要 100 元人民币左右。 风险提示依据中华人民共和国法律法规，中国大陆境内个人办理购汇业务时不得用于境外买房、证券投资、购买人寿保险和投资性返还分红类保险等尚未开放的资本项目。 所以，即使你有境外卡，外汇的来源也需要注意合法合规。 六、小结从办理门槛来看，我个人推荐的是恒生银行或者华美银行。 从使用体验来看，我推荐有条件的人选择去香港亲自办理，或者在国内的招行、中行办理。 当然，如果你恰好特别巧想换工作又对猿辅导感兴趣，也可以考虑加入我们，办理招行的永隆银行卡。 就酱~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"2020年我的股票交易总结","slug":"2020-stock-trade-summary","date":"2020-12-18T14:50:52.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/12/18/2020-stock-trade-summary/","permalink":"https://blog.devtang.com/2020/12/18/2020-stock-trade-summary/","excerpt":"","text":"概况今年股票美股的收益整体大概是 40% 左右，无图无真相，以下是老虎的统计数据： 比较巧的是，A股的收益整体也是 40% 左右，无图无真相，以下是平安证券的数据： 主要收益来自于疫情期间买入的各种股票，主要包括： 哔哩哔哩，买入价 22-25 美元 谷歌，买入价 1222 美元 腾讯，买入价 299 元 茅台，美的，格力，海尔等 今年我也有亏的，重仓的陌陌亏了大概 30% 。 以下是今年股票交易的一些认知。 贪婪和恐惧是关键疫情期间，很多人很恐慌，而我却觉得这是一个很好的机会，于是选择 1&#x2F;4 仓位入市，然后慢慢加到 1&#x2F;2，其间也有过多次犹豫和担心，现在看起来，整体决策还是对的。在别人恐惧的时候贪婪，通常就可以买到极低的价格。 不要做空疫情期间尝试了好几个做空，有一些差点得手的，比如游轮股，也有一些差点死很惨的，比如跟谁学。 我一直认为跟谁学没有猿辅导好，现在股价确实证明我是对的，但是跟谁学的那波暴涨，很可能把我的做空给逼爆仓。 这种极度考验心理，并且依赖于保证金的做空，以后我是不愿意再参与的了。 还好最后没赚没赔。 好的股票不应该过早卖去年底我持有了 4 支股票，分别是： 阿里巴巴，成本价 144 特斯拉，成本价 242 腾讯，成本价 403 拼多多，成本价 24 最终我卖掉了特斯拉和拼多多。这两个收益都不到 100%，但如果换成现在的我，我可能会一直持有。如果我一直持有的话，特斯拉应该可以带来 10 倍以上的回报，拼多多可以带来 5 倍以上的回报。 当时我开玩笑说：希望买特斯拉股票可以帮我挣一辆特斯拉，结果如果我不早卖的话，这个玩笑真的就实现了。 不过这也是我应该交的学费。每一笔学费都是用钱来强烈刺激我，让我难忘。 为什么好的股票不应该过早卖呢？我现在的感受是两点： 找到好标的难度太大，市场的机会并不多。 好的股票未来的持续成长能力是很强的，即便短期超出你对它的估值，但是不应该太短视，因为市场很多时候并不理性，你如果过早卖掉，你不一定还能买得回来。 为何买入哔哩哔哩我今年在疫情期间就很看好哔哩哔哩，于是在 25 元左右的价格就买入了很多。也是因为去年把特斯拉卖得太早了，所以我在哔哩哔哩上面就很有耐心。我周围的朋友有 40 多卖掉的，有 50 多卖掉的，但我一直持有到现在。 最近哔哩哔哩涨到了 80 多，我帐面上大概挣了 2 倍多，如下图： 另外还有一笔即将到期的看涨期权，挣了 4 倍多，如下图： 我为什么会买哔哩哔哩？主要是我当时发现，年轻人都在用哔哩哔哩，它在视频网站中拥有独特的社区文化和价值。有人说它是中国的 youtube，我觉得有一些道理。我和一些朋友讨论了一下，确定了它是一个好的标的。 然后我就在想如何为它估价，于是我翻了一些估值模型，以下是我 2020年3月14日 的记录： 如何估值哔哩哔哩？与 youtube 对标来计算： 可以按月活折算可能的收入，然后按收入乘以某一个倍数来计算估值。 如果对标youtube的话，youtube，月活 19亿，收入210亿$，估值 1500 亿 bilibili, 18年全年，收入 41 亿，估值 280 亿人民币？https://www.huxiu.com/article/294183.html 19年预估，1亿月活，60亿收入，估值 420 亿人民币？60亿美金。 如果保持增速，20 年应该 90 亿美金估值。 收入&#x2F;月活，哔哩哔哩大概是 60，youtube 大概是 77，差不太多。 估值&#x2F;收入，哔哩哔哩大概是 7， youtube 大概是 7，基本一样。 但是因为哔哩哔哩的商业化还没有大规模尝试，所以未来增长会乐观一些。 如何估值哔哩哔哩？按单用户价值来计算： youtube ，月活 20 亿，估值 1500 亿$，单用户约 75$ https://xw.qq.com/cmsid/20190504A09WCZ00 哔哩哔哩，月活 1 亿，估值 75 亿$，单用户约 75$ 快手，月活3.41亿，286亿$,单用户 84$ https://finance.jrj.com.cn/tech/2019/12/04072928486505.shtml 陌陌，月活1亿，50亿，单用户 50$ http://m.ebrun.com/361912.html 单用户价值：youtube(75$), 哔哩哔哩(75$), 快手(84$)，陌陌(50$) 当时哔哩哔哩大概估值 75 亿美元，于是我觉得是符合这个模型的，但是我觉得未来 B 站的用户量还有上涨空间，于是就买入了。 现在拿这个模型看，哔哩哔哩的估值是偏高的，但是这确实反映了它数据增长的优秀，因为不到一年，它的月活就达到了 2 亿。它的商业化也做得很好。 未来 B 站值多少钱？我不知道。我想等它的用户量稳定，收入稳定后，估值可能才会回归到一个合理的水平。在这之前，可能会有很多波动。现在不卖，有可能我挣不到这么多，但是卖掉，也可能失去一个挣 5 - 10 倍收益的标的。 所以这次，我想试试多看个几年，不管结果是好还是坏，它都将再次修正我的认知，这是我看重的。 为什么在陌陌上亏了我在陌陌 20 和 15 的时候分别买入了不少，现在陌陌 13 块多，整体我亏了 30% 的样子。 买入陌陌，核心是认为陌陌的估值太便宜。帐上有 20 亿美金的现金，每年挣个几亿美金，而估值才 40 亿美金（现在已经跌到 28 亿美金）。所以现在的陌陌，如果估值减掉自己持有现金，市盈率才不到 4 。 所以直到现在，我仍然认为陌陌是便宜的。如果一家公司一直亏钱，那么它最终可能资不抵债，但陌陌一直在挣钱，所以它不可能一直跌，它帐上的 20 亿美金现金就是它最低的价值。 但是为什么我亏钱了呢，还亏了 30% 呢？我低估了资本市场对于业绩下滑的悲观情绪。 陌陌是挣钱，但是它的月活在慢慢下降，利润也在下降。这背后可能是陌陌背后的金主用户们受疫情影响不太愿意给主播打赏了。在疫情期间，别的视频网站月活都在涨，而陌陌却没有，所以这更让资本市场不看好陌陌长远的发展。唐岩作为陌陌的创始人还离开了 CEO 职位，这让外界更加对陌陌没有信心。 我会卖掉陌陌的股票吗？有可能。取决于我能不能发现更好的标的。当前情况下，我还是持有陌陌的。陌陌虽然便宜，虽然下跌空间有限，但是这种股票也很难翻几倍了，所以很难给我带来很高的预期。 小结一些今年的小结： 不要做空。 好的标的应该一直持有。 要逆向思维，别人恐惧的时候贪婪。 还有，别以为我挣了多少，我只是拿很少一些不影响我生活质量的小钱在玩，主要是为了提升自己的认知而已。如果你心态上玩不起，你就已经输了。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"做连贯性活动 - 读《好战略，坏战略》","slug":"good-strategy-bad-strategy","date":"2020-12-09T13:50:57.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/12/09/good-strategy-bad-strategy/","permalink":"https://blog.devtang.com/2020/12/09/good-strategy-bad-strategy/","excerpt":"","text":"一、引言最近微信群里面流传了《美团清华产品课》的笔记，演讲人是王慧文。王慧文讲的很多内容都很有启发，里面提到了《好战略，坏战略》这本书，于是我就买来看了一下。以下是一些笔记。 二、好战略好战略的基本逻辑结构作者认为，一个战略的核心包括三个要素：调查分析、指导方针以及连贯性活动。 其实这三个要素和 《解决问题的商业框架图鉴》里面提到的 PDCA循环 类似。 但是不同的一点在于最后提到的「连贯性活动」。 连贯性活动所谓的连贯性活动是指：你的战略方法应该落地。怎么落地呢？无非就是结合自己的特点，发挥自己的优势，这样才可能成功。 对于这个观点，我想到了一个适合 iOS 程序员理解的例子： 假如你是一个刚出生的孩子，你就是 NSObject，没有什么特别的属性和方法。但是随着你长大，你就会添加很多属性和方法。 所谓的战略连贯性活动，就是指你需要结合自己的属性和方法的特点来发展。比如你已经有了 name, address 等属性，那么你可以发展成一个与物流相关的系统。如果你有了 url 这个属性，那么你可以朝着网络库那个方向发展。 任何不考虑自己以前的属性和方法来胡乱定发展方向的，就是一个「坏战略」。因为你的历史会成为你的包袱。 对于如何发挥自己的优势，书中提出了一些方法和案例。 方法一：聚焦书中首先举了苹果的例子。乔布斯回归苹果所做的战略，就是削减产品线，找微软拿投资，想办法活下来，然后等移动互联网的新机会。 值得注意的是：实施聚焦战略通常都会很艰难。因为战略转变必然触及很多人的利益，总是会遭到强烈反对。书中举了美国 DEC 的例子：CEO 让核心高管定战略，结果 3 个高管意见不统一，结果 DEC 的 CEO 奥尔森让他们必须达成统一，最后的结果就是大家把各自的意见综合起来，变成了一个不聚焦的坏战略。最终 DEC 经营不善被收购。 而 Intel 则是一个成功的案例，CEO 格鲁夫放弃了原来的主营业务，转而全力开发微处理器。最终成为了 PC 时代半导体行业的霸主。 方法二：转换视角转换视角，将自己的劣势变优势。书中举了两个让我印象深刻的例子。 例一是身材矮小的大卫与巨人歌利亚的故事。大卫利用自己的移动性来避免和歌利亚对抗力量。自己身材矮小反而变成了优势。 例二是 IBM 的转型。在 PC 产业分工日趋明确的情况下，IBM 将自己上下游整合的劣势变成优势，强调提供整合性的咨询服务。 方法三：设计思维好的战略是设计出来的，而不是很多方案投票选出来的。设计出来的战略会考虑到自己目标的渐进性，竞争对手，以及自己资源的有限性而保持聚焦。 三、坏战略书中提到了一些坏战略的特点： 空话。例如：成为 XX 行业领导者。 不能直面挑战。回避最艰难的挑战，例如不敢裁减业务，聚焦核心。 不能落地的战略。战略需要落地，需要有具体可以实施的步骤。 糟糕的战略目标。不能解决关键问题。 小结波特的《竞争战略》 里面提到了核心的三个竞争策略：成本优先，差异化，聚焦。而本书从执行层面讲具体应对商业挑战的时候，如何制定战略。 书中提到的聚焦、转换视角、设计思维、直面冲突、连贯性活动都是非常有效的执行上的要素。书中的案例也非常非常多，读起来相对轻松。 推荐给大家~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"解剖学角度的女性 - 读《女人这东西》","slug":"women-kind","date":"2020-11-29T14:44:19.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/11/29/women-kind/","permalink":"https://blog.devtang.com/2020/11/29/women-kind/","excerpt":"","text":"一、引言本书作者 渡边淳一 是日本文学大师，一生发表 130 多部作品。代表作是《失乐园》。渡边淳一的作品多描写两性关系，他本人一度任骨科医生，这本《女人这东西》就是他对于女性的一些见解。 以下我的一些读书感悟。 二、感悟2.1 男女天生的差异巨大书中举了很多例子，表明男性和女性天生就有着巨大差异，差异大到可以想像成不同的物种。这种差异也带了很多男女沟通之间的矛盾。比如： 女性投入两性生活会令她表现得更加柔和，心情更加欢愉。而男性却会无精打采，疲惫不堪。 又比如女性通常不会对旧爱藕断丝连，而男性通常对于前女友常保持着总有一天可能会再续前缘的心态。 又比如女性通常不会接受没有爱的性，而男性则会把性看成只是性，没有爱有冲动也可能发生性。 2.2 女性的两种快感书中还提到了女性的两种快感：阴蒂高潮和阴道高潮。而前者可以通过自慰达到，后者只能通过与男性的交合达到，同时后者带来的快感远大于前者。 作者说这种快感会让女性不断沉迷于性，而男性则不会。因为男性对于性的感受来源于新鲜感，所以只会越来越觉得无趣。 2.3 男女对于婚姻不满的差别女性对于婚姻中的不满常常是非常具体的事情，而男性则是心理层面上的：“我到底能不能一辈子永远爱这个女人？” 这个事情的核心差异是：女性随着夫妻生活的发展，其性体验是越来越好的；而男性的性体验，在结婚刚开始的时候是最高的，之后就慢慢下降。 最终维系男性家庭观的核心是精神层面上的爱，而不再是肉体上的爱。所以，男性对婚姻的不满，通常都是精神层面上的。 2.4 性感缺失的女人书中提到对于性的感受低的一类女性，这类女性由于过度神经质、坚持自我主张，而无法在婚姻生活中享受到性快乐。因为性快乐需要女性在心理上达到一种牺牲自我的状态。 现代社会对于女性的地位提升，助长了这一类心理问题，作者把这称作女性的非女性化。 2.5 女性的移情女性通常有三次移情，刚开始女性会在学校拥有恋人般的同伴朋友。一旦遇上中意的男人，则会全情投入到男人身上。而最后孩子出生，逐渐成长，她又会全情移至孩子身上，将丈夫抛在脑后。 男人通常不会像女性这么移情，即便转移，也无法做到像女性这么果断。这两性的差异核心是来自于荷尔蒙，女性行为的变化其实是来自生理激素的变化。 三、结束语这本书的很多观点让我感同身受。我们人类虽然非常厉害，站在食物链的顶端，但是我们毕竟也是经过千百万年进化而来的哺乳动物。 男性与女性的很多差异，来源于原始社会的自然选择。比如男性为了更多地将 DNA 遗传，所以性体验最高的是最初的时候，为了性男性有时候不择手段；而女性因为要照顾孩子，留住家庭，所以性体验却越来越高并且对家庭很专一。这背后都是基因的设计。 我们对于身体基因层面的东西无法改变，只能理解和尽可能适应他。 整个人类种群的繁衍，其实是牺牲了个体的体验，来保证整个种群的利益，这也是自然法则之一。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"理解房地产 - 读《全球房地产》","slug":"global-house-market-book-summary","date":"2020-11-19T00:44:44.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/11/19/global-house-market-book-summary/","permalink":"https://blog.devtang.com/2020/11/19/global-house-market-book-summary/","excerpt":"","text":"一、前言我们这一代人，大部分一辈子挣的工资，都拿来买房了。不信？我帮你算算： 拿北京为例，一个简单的三口之家，至少需要一个两居室，约为 80 平米。在北京，一个 80 平米的房子，大概需要 500-600 万。这还都没有算上不算上老人的居住需求，因为现在带孩子的都是老人，也没有算上学区房的溢价，大部分有孩家庭买房的重要因素是上学。 那 500 万的需要多久才能存下来呢？即便是中国互联网行业的顶层收入阶级：码农。一年平均能够存下 20 - 25 万就算是非常好的情况了。那 500 万需要至少存 20 年。如果你是贷款了 500 万买房，那么其实算上复利，你一共需要还 1000 万。这就是 40 年工作的存款。 所以，在北京的一套 80 平的普通住宅，需要一个码农从 25 岁本科毕业，一直还款到 65 岁退休，才能还完。 当然，实际情况可能好一点，比如： 夫妻双方都是高收入，共同承担还款义务的话，20 年可以还完。 双方的老人帮忙提供首付款，使得贷款额度下降。 遇上像拼多多，美团，头条，以及我们猿辅导这样的公司，最终期权收益远大于工资收益。 但是对于大多数人来说，花掉自己半辈子的积蓄买房，还是一个正常的现象。 所以，既然我们都花了半辈子的钱了，何不花半个小时理解一下中国的房地产环境呢？这就是我读《全球房地产》这本书的原因，以下是我的一些读后感受。 二、房价未来的走势简单一句话：虽然房价现在很高，但是房价不会跌。 核心原因是： 2.1 政府主导。房市是一个政策主导的市场，不是完全的市场经济，所以政府有多种手段来有效地控制房价的波动。 如果房价上涨过快，政府可以增加土地供应，增加首付比例，增加购房限制，调节贷款利率，甚至直接限制最高房价（比如北京就出现过限价房）。 如果房价下跌过快，政府可以减少土地供应，减少预售证的审批，降低首付比例等。 2.2 稳定大于一切在政府「房住不炒」的原则下，房市价格稳定是一个关乎国家民生稳定的重要指标。中央和地方政府都会花大精力来保证房市的稳定。 2.3 地方财政和 GDP 需要之前地方政府一直没钱，但是自从住房市场改革以来，出地出让金持续增长。2018 年，土地出让收入为 6.5 万亿，占地方财政收入的 66.5%。 地方政府有钱之后可以进一步增强城市的基础设施建设，带动经济。中国的 GDP 增长很大程度上来自于房地产业及上下游产业带动，整体在 2018 年占到 GDP 的 15.8% 。 另一方面，商业用地的出让金增长并不高，这使得政府可以用较低的商业用地价格来招商引资，带动产业和就业。 三、购房的需求还在持续房地产整体的主要需求来源于以下 3 方面： 城镇化率，占比 42% 。 城市更新改造，占比 5% 。 居民的改善型居住需求，占比 53% 。 城镇化率中国 2020 年的城镇化率为 60%，预期每年增长 1%，到 2030 年到达 70%。之后增速放缓，到 2050 年到达 80% 的城镇化率。 城镇化使得大量人口集中到一二线城市。当前来看，三四线城市已经显现出人口净流出的现象。 改善型居住需求随着人们生活水平的提高，大家对于居住环境的要求也越来越高。 我最近看了一下新的楼盘，像新风系统，地暖，智能中控都成为了标配。一些新技术还被部分强调科技的开发商应用，比如某茂府的恒温系统，是通过采集深入地下的地底地热，通过纯水将热交换上来，然后在墙上布微循环管道，达到不用加热就可以保证大楼恒温的效果。 现在由于大家见识过各种优质服务，所以对小区物业的服务要求也要提升。老的小区物业服务比较差，业主委员会经常缺失，这也造成很多人都换新房的需求。 改善型居住可以通过把旧房卖掉换稍大的新房，对于大家的资金要求也不算高。 四、房产税是未来 10 年必然的趋势本书详细测算了一下现在收房产税和未来收房产税对政府收入的影响。 因为现在住房交易还是以新房为主，地方政府通过卖地就可以维持比较高的财政收入了。所以现阶段上房产税意义不大。 但是未来房地产市场不可能一直是增量市场，总有一天，会慢慢进入以二手房为主的存量房交易市场。这个时候，卖地就很难保证财政收入了。 现在北京二手房交易已经占到了房屋交易的 55%。未来如果这部分占比到达了 80% - 90%，政府因为要提供公共服务，就必须将原有土地出让的财政收入找补回来。 书中也测算了一下，到 2030 年的时候上房产税，相应的税收是与当前的卖地收入同等规模的（不考虑通胀）。 五、小结 房地产行业对中国的经济起到了至关重要的带动作用。 房价未来的趋势是稳定。 城镇化率是影响需求的主要因素，未来 10 年还在持续。 由于进入存量市场，房产税会是 10 年后保证政府提供公共服务的财政来源。 书中对于房价也有一个很宏观的总结：「房地产长期看人口，中期看土地，短期看金融」，一并分享给大家~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"埃森哲的工作法 - 《掌控工作》","slug":"manage-work-book-summary","date":"2020-11-02T02:14:36.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/11/02/manage-work-book-summary/","permalink":"https://blog.devtang.com/2020/11/02/manage-work-book-summary/","excerpt":"","text":"引言埃森哲作为一家咨询公司，对外输出了很多人才和工作法。这次我读到的，是前埃森哲的员工邵文瀚的作品《掌控工作》。他将一个问题的解决过程进行了层层梳理和拆解，帮助我们用一个固定的流程来思考复杂的问题，以下是我的一些笔记。 掌控工作四步法作者首先抛出了咨询师的问题梳理流程： 界定问题 拆解问题 执行解决 总结复盘 界定问题面对一个新的陌生领域，界定问题分成以下三步： 熟悉和理解专业术语。作者推荐的方法包括： 案头研究。即自己查阅搜索引擎、国家统计局资料、专门书籍、知网数据库、行为研究报告。 访谈类研究。包括专家访谈、用户访谈、实地走访。 在案头研究方面，作者推荐了很多权威的数据收集渠道，比如： 国家统计局。有大部分的人口、产值、贸易数据。 海关总署网站。可以找到进出口情况。 教育部网站。可以查到招生人数，毕业人数。 作者还介绍了一种 what-else 的研究方法。拿 iOS 开发举例，如果你不懂 iOS 开发，你可以这么来研究： (what)什么是 iOS 开发？然后你可能通过查找资料发现这是一种移动开发技术。 (else)还有哪些是移动开发。你可能找到 Android开发，Windows Mobile 开发等。 (what)Android 是什么？然后你可能查到这是 Google 出的移动开发技术。 (else)Google 家还出了哪些开发语言？然后你可能查到 Flutter。 拆解问题在完成问题的界定之后，我们就需要着手拆解问题。 假如我们的问题是“iOS开发如何提高”，那么我们就可以从“输入”和“输出”两个角度来拆解它。 输入方面：我们可以拆解成阅读博客，阅读图书，看相关的视频，听相关的分享，参加相关的会议，找同事请教等。 输出方面：我们可以拆解成写总结的文章，代码练习，分享等。 我们还可以进一步拆解，比如代码练习又可以拆解成：工作上的代码优化、面试题目代码的练习、开源项目的参与等。 下图是一个示例： 拆解问题讲就 MECE 原则，这是《金字塔原理》那本书首次提到的，即不重不漏。 拆解问题作者介绍了自上而下，自下而上两种方法，同时建议我们在遇到一些不确定的问题，使用“假设驱动”的方法来寻找关键点。 拆解问题后我们需要注意的是采用 28原则 来将关键问题定位。因为这种拆解很容易让我们陷入大量的 Todo 中去，不知道做什么，哪个也做不好。所以我们应该聚焦关键问题，把别的问题排除掉。 又回到刚刚说的“iOS开发如何提高”这个问题上。其实借助工作上的问题，进行相关的代码优化，就是最高效的提升方法。因为这个方法是有实际的产出做检验，也有实际的回报做出激励，很多工作也有时间限制，让我们能够有紧张感来推进工作，大部分时候把这个做好就能提升很多很多。 执行解决执行的起来，作者建议如下 4 步的规划： 第一步：确定工作目标，估算工作量。 第二步：对工作进行优先级排序。 第三步：确定时间规划，把工作指派给各项目负责人。 第四步：考虑项目可能的风险点，并提出预案。 规划好之后，就开始执行了。执行的时候肯定不是一帆风顺的。所以我们要定期进行进度的同步。定期同步可以是邮件或者会议的形式，主要关注关键目标和时间点的达成情况。 书中介绍了不少提高个人执行力的手段，比如我自己也常使用的番茄工作法。 总结复盘复盘是非常重要的环节，一个复盘的流程分为以下 4 步： 第一步：回顾目标 第二步：评估结果 第三步：原因分析 第四步：优化改善 对于一些新的领域，如果通过复盘形成一些总结或者方法论，从而推进成为团队执行的一些潜在标准，则是更好的事情。 小结《掌控工作》是作者从咨询公司的 7 步工作法提炼总结出来的日常工作常见的工作原则。通过界定问题、拆解问题、执行解决、总结复盘四个大的步骤，将所有工作问题的解决框定在这个范围内。 本书非常适合职场新人来梳理自己的工作框架，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"从不确定性中获益 - 读《反脆弱》","slug":"antifragile-book-summary","date":"2020-10-12T04:13:24.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/10/12/antifragile-book-summary/","permalink":"https://blog.devtang.com/2020/10/12/antifragile-book-summary/","excerpt":"","text":"最近读完了《反脆弱》一书，这是《黑天鹅》的作者塔勒布的又一本畅销书。 全书的内容比较啰嗦，核心讲的就是两个方面：1、什么是反脆弱性2、如何应对不确定性，并从中获得收益 什么是反脆弱性首先我们应该看到世界是不确定的，人们试图预测很多事情，但是最终发现，对世界产生巨大影响的事情，人们基本上都预测失败了（比如今年的新冠疫情）。这种不确定性一方面是由于世界本身是很难预测的，另一方面是极端事情发生的可能性并不低。 尼采说：“杀不死我的，只会让我更坚强”。作者的反脆弱性就是指这种现象。如果面对压力，有一些事物反而呈现出更好的自己，这类事物就是反脆弱的。 书中举了很多案例，我觉得最容易理解的案例就是：如果把体力消耗看成一种压力： 如果我们面对高强度体力消耗，累死了，我们就是脆弱的。 如果我们面对高强度体力消耗，没累死，我们就是强韧的。 如果我们面对高强度体力消耗，变得更强壮了，我们就是反脆弱的。 我还看到一个读者的比喻： 一阵微风就可以吹灭蜡烛，蜡烛是脆弱的； 一阵风吹不灭所有的蜡烛，蜡烛就是强韧的； 一阵风反而助长了蜡烛的火焰，蜡烛就是反脆弱。 书中还举了很多组织的反脆弱案例，比如国家或者社区的某一个个体的悲剧，使得整个群体关注到一些危险，从而使得整个群体变得更加安全和健康。 如何应对不确定性作者推荐通过加强自己的反脆弱性来应对不确定性。我印象中的包括： 1、杠铃策略。把 90% 的投入到安全领域，把 10% 投入到损失很小，但是可以提高自己的反脆弱性的事情上。例如买保险，灾难可能使得你获得更多；例如培养自己的第二技能，万一失业还可以另谋生计。 又例如在股票市场上，买入股票的同时又买入看跌期权，这样万一股票大跌，你可以从看跌期权的对冲中锁定自己的损失。股票的期权权利金叫做 premium，这个单词本身就有保险的意思。 2、主动理性试错。做成功率虽然低，但是低风险高收益的事情。你要考虑的事情只有两件，一是万一失败是否致命，二是万一成功收益是否不成比例的多，如果同时符合这两点，这类事情就是多多益善，二者缺其一的事，则尽量少做，按照这样的做事策略，反脆弱性就会提高。 例如：加入一家早期的创业公司，就是符合这种策略的。因为加入一家创业公司收入和技能锻炼并不少，但是潜在的收益可能很高。 3、通过备份，即使一个备份丢失，你仍有别的备份可供使用。计算机系统上，我们就通常用线上从库 + Binary Log + 离线备份来实在数据的冗余备份。 小结人们常说，不要把鸡蛋放在一个篮子里面，这其实就是一种避免风险的办法。《反脆弱》用更系统的方式介绍了生活中各种有趣的案例，教我们通过杠铃策略、主动理性试错、备份等方式来应对不确定性。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"高瓴张磊的投资思考 - 读《价值》","slug":"value-book-summary","date":"2020-10-09T04:16:02.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/10/09/value-book-summary/","permalink":"https://blog.devtang.com/2020/10/09/value-book-summary/","excerpt":"","text":"一、序言国庆期间读完了高瓴资本的创始人张磊的新作《价值》。高瓴资本也是我所在的猿辅导在线教育的投资方，不久前猿辅导融资10亿美元的投资就是高瓴资本领投的。 《价值》全书分三个部分： • 第一个部分是张磊自己的成长史，介绍他如何一步步走向投资生涯。 • 第二个部分是张磊总结的投资哲学和修养。 • 第三个部分是投资执行层面上的原则与案例。 以下是我的一些读后感。 二、以德修身全书有很多地方讲到了品德。我印象深刻的几个案例有几个： 1、“这些钱一定要还”。张磊回国的首次创业“中华创业网”失败了，虽然投资人没有要求，但是张磊坚持要还投资人的投资款项。这种从法律上本可以不还的投资，现在越来越成为一种创始人对自己更高要求的行为。 罗永浩欠了4个亿，我想那应该是锤子公司欠的，但是罗永浩自己卖艺还债。我身边也有不少这样的朋友，创业失败了，但是总想着以后把投资人亏的钱补上。 2、史文森掌管着耶鲁捐赠基金，张磊说他最初能够通过面试，就是因为他在面试的时候展现出来的诚实。史文森一直觉得：“投资的目标是盈利还是实现某种社会理想，其间的平衡必须把握”。 3、张磊在介绍自己的投资哲学的时候，第一点就是坚持高度道德自律，“守正用奇”。 三、重仓腾讯的逻辑腾讯早期发展得很不顺利，小马哥甚至尝试卖掉它。在《腾讯传》里面我们能够看到，很多机构虽然投资了，但是也没能坚持下来，比如李泽楷的盈科以及IDG就在腾讯很早期退出了。真正大手笔买入的只有南非 MIH。 高瓴资本也买入了腾讯，不过是在腾讯上市一年之后。但即便这样，也是需要很大勇气的。因为当时腾讯的收入主要来自 QQ 空间，也不算特别有想象力。 如果从收入，利润，市盈率这些基本面指标，很难做出重仓的决定。但高瓴买入腾讯核心看重的是社会价值。当张磊发现社会各行各业都用QQ号的时候，他觉得这是巨大的价值。“只要是为社会疯狂创造价值的企业，它的收入、利润早晚会兑现，社会最终会给予它长远的奖励”。 四、如何做研究关于如何研究，张磊给出了下面这张图： 这里面我欠缺的是后面两个，我一方面对于一个行业的关键时点和关键变化关注不多。一方面独立性还不太够，经常还是消化和吸收别人的观点。 五、张磊的投资哲学张磊的投资哲学有3点： • 守正用奇 • 弱水三千，但取一瓢 • 桃李不言，下自成蹊 我感受下来就是坚持基本的道德，保持耐心和专注，坚持长期累进的事情不在意一时得失。 六、小结全书其实就是张磊对于价值的诠释，价值不是纸面上的数字。 对于投资人来说：价值是道德，是自律，是坚持。对于企业来说，价值是对行业的颠覆，是对用户的连接，对需求的重塑。只有这样才能看得更高，看得更远。 很棒的一本书，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"面试的艺术 - 如何面试别人","slug":"how-to-interview","date":"2020-09-24T12:41:55.000Z","updated":"2024-01-06T14:52:37.938Z","comments":true,"path":"2020/09/24/how-to-interview/","permalink":"https://blog.devtang.com/2020/09/24/how-to-interview/","excerpt":"","text":"前言工作这十年来，我面试了很多不同岗位的人。刚开始是面技术，后面是面产品，再后面是测试、运营、教研、设计。最近还面试了很多硬件相关岗位的人，比如 ID 设计师、结构设计师、质量工程师等。 我肯定不可能同时是这些岗位的专家，大部分情况下，我都是外行。但是我又要面试这些岗位，尽可能招聘到优秀的候选人。团队如果组建得不好，工作执行上肯定会受影响。 面试某种程度上是一门艺术，非常不标准化，又非常不确定，每个候选人都是一个独特的个体，需要你调整自己的问题，尽可能准确地判断出候选人的水平，这几乎不可能 100% 做到。 我是如何面试各种岗位的呢？以下是我的一些小结。 如何面试别人从 JD 开始当你招聘一个岗位，肯定是工作上具体的事情需要增加人手完成，所以梳理 JD（岗位描述）是招聘的第一步。 通常 HR、面试官、候选人也是通过 JD 来达成对于目标工作的一致性认知。 JD 主要包括两部分： 岗位职责 任职要求 岗位职责将这个人进来之后的工作细化，便于你理清楚到底为什么需要这个人，这个人进来之后可以改善哪部分的工作。 任职要求是对候选人核心素质的描述，便于提前过滤掉不合格的候选人，也便于你之后对核心素质进行考查。 承认面试考查的不完美一个候选人，你只花不到一个小时聊，很难完整得判断出这个人的水平。所以，面试考查算是一个不完备的决策行为。你可能误判，错过一个优秀的候选人。你也可能失误，把一个不合格的候选人招进来。 面试的第一步，就是承认这种决策的不完美。面试就是： 在非常有限的时间内从一堆候选人中挑出能够胜任的同学。 而我们能做的就是尽可能提高面试的 正确率 和 召回率。 进行有区分度的考查面试过程中，你可以提很多问题，但是如果一个问题所有候选人都答对或者答错，那么这个问题就完全没有区分度了。你不可能全部通过或者拒绝所有候选人。 所以，我们需要精心设计问题，让优秀的候选人能够被挑出来，不合格的能够被淘汰掉。 在技术面试中，算法题目就是一类有区分度的问题。常常有人问：某某公司面算法，工作中用得到么？其实答案就是，如果不面算法，一般的工程开发问题都答上来了又有什么意义？面试又不是考查记忆力。 对于工程师来说，逻辑能力和智力都是很重要的底层能力，而算法题就可以做到很好地筛选出这方面优秀的人。 用细节和数据来佐证候选人的简历可能非常光鲜，但是细问一下就会发现水分。所以面试的时候，我们需要就着细节问，一个事情他负责的，我们可以： 问宏观。为什么做这个事情，意义是什么，目标是什么。 问时间。这个事情什么时候开始的，具体每个阶段做了什么。 问人员和流程。这个事情相关的同事有哪些，相互之间如何配合的。 问方案。这个事情具体的方案细节是什么样的。 问数据。这个事情最终的数据如何，如何评价这个数据。 问困难。这个事情最大的挑战是什么，如何克服的。 问收获。对这个事情有什么复盘，下一次做会有哪些不一样。 除了问，我们还可以当场看。对于设计&#x2F;产品&#x2F;教研岗位，可以当场让他给你看线上的作品，讨论作品的细节。 有了细节，你就可以更真实地判断出来他的简历是否真实，事情做得到底好不好。 关注核心基础素质虽然我们面试的岗位千差万别，但是有一些基础的素质，每一个岗位都需要。 比如说：表达沟通能力。有些候选人连自己的答案都说不清楚，如何能够做好工作？而有一些候选人，说起话来滔滔不绝，但是一句也没有回答到重点上，这种人也是表达沟通能力有问题的表现。这种是信息表达的“密度”很低，和这种人工作会特别耽误时间。 除了表达沟通能力之外，我看重的核心能力还包括： 工作热情。 团队精神。 学习习惯。 通过问一些案例和工作上的细节，我就可以对候选人的这些能力有一个感受。 考查核心专业能力不同岗位的人专业能力不一样，如果条件允许，最好还是让候选人展示一下他的专业能力。如果面试当时时间不够，也可以是以作业的方式来考查。 对于技术岗位，可以当场考查一些代码。 对于产品岗位，可以留一个产品分析的作业，或者当场对一些产品交互进行分析。 对于设计岗位，可以让他当场手绘一张图或者留一个设计作业。 对于测试岗位，可以当场分析一些用例。 对于硬件产品经理，可以做一个策划作业。 标准化和复盘当你面试一个岗位的人久了，你就可以形成自己的面试「方法论」。这个方法论包括： 一组你熟悉的面试题目，你可以灵活地使用。 对于这套题目的答案好坏程度的经验值，帮助你将候选人分级。 这套方法论固化下来，可以共享给同事，大家用一个统一的标准来面试。 每隔一段时间，你也需要复盘一下。有时候因为环境的变化，一些题目不太适用或者已经太普遍了，无法产生区分度，这个时候需要进行调整。 小结面试从梳理 JD 开始，在承认面试不可能完美的前提下： 关注候选人的核心基础能力，通过问细节和数据来获得更详细的信息。 在专业考查上，通过现场和事后的作业，保证专业能力过关。 通过标准化和复盘，总结和迭代自己的面试方法。","categories":[],"tags":[]},{"title":"关于高尿酸的一些研究","slug":"study-of-HUA","date":"2020-09-19T13:46:27.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/09/19/study-of-HUA/","permalink":"https://blog.devtang.com/2020/09/19/study-of-HUA/","excerpt":"","text":"题图：尿酸的分子结构。 序言我因为自己有 5 年的高尿酸（指标大于 550) 的情况，加上最近在服药控制，所以查了一些资料。 中国的高尿酸比例其实挺高的，相关资料显示总体患病率为 13.3%，保守估计有 1.8 亿高尿酸患者，痛风患者达 1700 万。 如果你也和我有相似的身体情况，希望本文对你也有一些帮助。 高尿酸是什么定义高尿酸症状的医学说法叫：高尿酸血症（hyperuricemia，简称 HUA）。 高尿酸是指血液中尿酸的浓度超过了健康人的指标。血尿酸正常值： 成人男性为 149～416μmol/L ；女性为 89～357μmol/L。 年龄大于 60 岁的男性为：250～476μmol/L； 女性为：190～434μmol/L。 危害尿酸在血液中的浓度如果过高，就不能完全溶解于血液中，于是就会出现析出结晶。这些结晶在关节处累积，就会诱发痛风。 通常高尿酸不会那么快导致痛风，也有很多人高尿酸但是一直没有痛风，但是两者的相关性极大。我自己高尿酸 5 年了还没有痛风，但我一个朋友也就 3 年左右就开始痛风了。 《高尿酸血症和痛风治疗的中国专家共识》 建议：如果低嘌呤饮食的情况下，高尿酸还在 540 以上，或高于420（男）&#x2F;360（女）持续半年以上，即需要进行降尿酸治疗（下图）。 我自己在这件事情上还是拖了很多年，其实是不对的。 来源和排泄尿酸（uric acid）是嘌呤的代谢产物。整体上人体的尿酸来自两类： 内源性。依赖于自身代谢产生，这部分占到体内尿酸总量的 80%。 外源性。从饮食中直接摄入的，这部分占到体内尿酸总量的 20%。 尿酸产生之后，主要通过肾脏排泄（占比 70%），其余通过消化道排泄。 原因刚刚说到来源和排泄，所以产生高尿酸的原因主要是两种： 来源来得太多了。主要包括自身代谢紊乱（内源性）或者饮食中摄入（外源性）太多。 排泄得太少。主要是肾脏排泄能力下降导致。 当你体检时发现尿酸高的时候，医生或者朋友第一个建议你的事情就是：在饮食上进行控制，进行低嘌呤饮食。嘌呤主要来源于海鲜、内脏以及肉汤。 但是就像我们刚刚提到的，这部分只占到体内尿酸生成总量的 20%。所以如果是自身代谢紊乱或者肾脏排泄能力下降的话，即便是低嘌呤饮食也无法降低尿酸。 医生可以通过测量 24 小时尿尿酸来判断是否排泄减少： 小于 600mg(3.6mmol) 定义为尿酸排泄减少型 超过 800mg(4.8mmol) 定为尿酸产生过多型 研究表明，有 90% 的原发性高尿酸都是排泄减少型。对于排泄减少型，即使你坚持低嘌呤饮食，影响也相当有限。 监控精确地测量尿酸值，需要到医院抽晨血（抽血前不能进食）。我自己研究发现，可以购买尿酸测试仪在家自行测量，用于定期的监控。我买的是三诺的 EA-12 测试仪（下图），别的品牌也没试过。 我自己在去医院测试的同一天用测试仪也测试，发现这款家用测试仪误差大概在 50 以内，凑合能够接受吧。 治疗低嘌呤饮食饮食对于尿酸的影响占比是20%，当患者是代谢或者排泄问题导致高尿酸时，低嘌呤饮食虽然很多时候并不能解决问题，但是对控制尿酸还是有一些帮助的。 我个人总结的经验是，除了严禁的食物外，其它不用刻意地控制，因为如果真要严格控制，很多东西都吃不了了。严禁的食物是： 动物内脏，比如鹅肝。 海鲜。 浓肉汤和肉汁。 酒。 高尿酸鼓励吃的食物是： 脱脂或低脂奶制品 鸡蛋 蔬菜 低生糖指数谷物 饮水大于 2000 ML 可能有一些人还是忍不住想喝酒，现在研究只能证明啤酒和烈酒会引发痛风，而红酒与痛风的相关性证据还不足，所以你如果实在忍不住，就喝红酒吧。 别嘌醇（Allopurinol） 别嘌醇是一个老药了，1966 年在美国被FDA批准上市，到现在已经经过了半个世纪的使用。根据相关统计，别嘌醇在美国一年被开的处方次数为 1400 万次，在 2017 年排名第 54 位。 别嘌醇的用量： 初使剂量：50mg，一天1-2次。 一般剂量：200-300mg 一天。 最高剂量：600mg 一天。 别嘌醇对部分人会有超敏反应，严重情况致死。所以服用初期要密切关注身体状况。后来人们研究发现，超敏反应与白细胞 HLA-B5801 基因相关，所以在国内，有条件的医院就会在患者服用别嘌醇前，给他开HLA-B5801 基因的检测（这个检测也是可以走医保的）。 下图是我的检测结果： 刚刚我们提到这个药在美国使用得非常普遍，但是在中国使用得很少，这里面有一个重要原因，是白细胞 HLA-B5801 基因在不同种族人群间的差异： 中国汉族的基因频率为 6%-8% 白人的基因频率为 2% 所以即使在美国，如果是给亚裔人群开别嘌醇，都建议先检测 HLA-B5801 基因。 而中国不是每个医院都有这个基因检测设备，加上有后面两种提到的替代药品，所以如果你不是对那两种药过敏，否则医生默认都不会给你开这个药。 这个药虽然超敏反应严重，但是也有一个好处，就是特别便宜。一般剂量的情况下，每天的费用只需要花 0.5 - 1 元钱。因为降尿酸的药需要天天吃，所以全年算下来就不算贵。而后面我即将介绍到的非布司他就比较贵，每天的费用大概是别嘌醇价格的 10 倍。 非布司他（Febuxostat） 非布司他相比别嘌醇来说是一个新药，它 2008 年在欧洲上市，2009 年在美国上市，2013年国内上市。整个中国人的药物使用数据还不到 10 年（相比来说别嘌醇有半个世纪的使用历史）。 非布司他和别嘌醇都同属于抑制身体内部尿酸的合成，以此来达到降尿酸的目的。通常剂量是 40 - 80 mg 每天。 刚刚也提到非布司他比较贵，每天的费用大概是 10 元钱。 非布司他刚开始的时候没有发现什么副作用，后来美国 FDA 怀疑它会导致一些心血管疾病加重，但是相关的研究没有证实或证伪这件事情，所以 FDA 在 2017 年前公布了一个警告，建议有心血管疾病的患者慎重选择非布司他。 这个警告我在「用药助手App」上也查到了，如下图： 我刚开始也因为这个警告有点担心，但是咨询了多位协和医院的医生，基本上大部分都还是推荐非布司他。所以这个药是我现在正服用的药物。 苯溴马隆（Benzbromarone） 相对于上面两种药，苯溴马隆的历史就有点波折了。 苯溴马隆在 1970 年上市，但是在 2003 年，因为发现了严重的不良反应，所以发明它的公司 Sanofi-Synthélabo 将它从多个国家退市。 但是在很长一段时间，因为也没有找到它的替代药品，所以包括中国在内，别的一些药厂一直在向市场继续提供苯溴马隆。我查了一下，它的主要不良反应是肝功能异常，在欧美国家的不良反应率是 1/17000，国内还无此项数据公布。 苯溴马隆的降尿酸原理和前两者都不同，前两种药是尿酸抑制药物，而苯溴马隆是通过促进尿酸排泄来达成降尿酸。因为它将大量的尿酸通过尿液排出，所以为了避免尿液中的尿酸太高形成结石，服药期间需要进行大量的饮水，每天饮水量不少于 2000ML。 我当时为了测量饮水量还专门买了一个 1升 的巨型水杯，每天喝完两杯就算达标了。 因为尿酸大量进入到了尿液中，所以尿液的 PH 值会偏酸性，如果 PH 值过低，会影响尿酸的排泄，所以通常我们还需要服用碳酸氢钠片（其实就是小苏打）来碱化尿液。 但是碳酸氢钠片服用过多对胃还是有一点影响，我当时就感受胃比较胀气，毕竟碳酸氢钠和酸中和的时候会产生气体。和面的时候放小苏打能让面发胀也是这个原理。 我去年服用过一段时间苯溴马隆，后来主要是3个原因想换药： 查到这个药在国外退市。 每天必须喝够 2 升水让人感觉很麻烦和紧张，有时候出差路途不方便喝不了那么多水，就会感觉不方便。 我对碳酸氢钠有点胀气反应，胃不舒服。 苯溴马隆的价格介于别嘌醇和非布司他之间，每天服药的费用约为 2.5 元。 信息对比汇总 别嘌醇（Allopurinol） 非布司他（Febuxostat） 苯溴马隆（Benzbromarone） 上市时间 1966年在美国上市 2008年欧洲上市、2009年美国上市、2013年国内上市 1970年上市。2003年从多个国家退市。 使用风险 超敏反应，严重情况致死。超敏反应与白细胞HLA-B5801基因相关。 怀疑有心血管风险，但是没有被证实或证伪。 肝功能异常 风险数据统计 HLA-B5801基因：白人2%，亚裔8% 几十个怀疑案例 欧美国家的肝功能异常率为 1&#x2F;17000，国内无数据。 Wiki https://en.wikipedia.org/wiki/Allopurinol https://en.wikipedia.org/wiki/Febuxostat https://en.wikipedia.org/wiki/Benzbromarone 初使用量 一次50mg 1-2次&#x2F;d 20-40mg 1次&#x2F;d 50mg 1次&#x2F;d 每次递增 50-100mg 20mg 50mg 一般剂量 200-300mg 分2-3次服用 40mg 50mg 最高用量 600mg&#x2F;d 80mg 100mg 处方量统计 1400w 一年 90w 一年 退市 每天费用 100mg 约 0.5-1 元 40mg 约 10 元 50mg 约 2.5 元 小结高尿酸血症是一个内分泌代谢紊乱的病，如果不治疗有可能引发痛风。 国内最常用的治疗药物是别嘌醇，非布司他和苯溴马隆。 我自己研究下来，推荐大家有经济条件的话选择非布司他。 参考资料 《高尿酸血症和痛风治疗的中国专家共识》 《痛风及高尿酸血症基层诊疗指南（2019年）》 苯溴马隆，您不了解的 “新” 机制 24小时尿尿酸检查 尿酸值 Uric acid: https://en.wikipedia.org/wiki/Uric_acid","categories":[],"tags":[]},{"title":"关于用研岗位的思考","slug":"about-user-research","date":"2020-07-28T01:13:21.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/07/28/about-user-research/","permalink":"https://blog.devtang.com/2020/07/28/about-user-research/","excerpt":"","text":"什么是用研岗位用户研究简称“用研”，是一种主要通过面向用户的各种研究方法，达成对关键问题的信息收集和理解的目标。 这些关键问题可大可小。大的方面可能是确定某个市场需求，小的方面可能是验证某个产品的市场受欢迎程度，也可能是确认产品的某个问题。 用研常用的手段用研常用的手段包括以下几种：用户访谈（包括一对一和一对多）、用户使用场景的现场观察、以及用户问卷调查、用户反馈收集等。 我把这些手段分成 2 类： 客观数据分析类。包括用户使用场景。 主观数据分析类。包括用户访谈和用户问卷。 我们也可以按定性和定量分析，把用研手段分类： 定性分析。包括用户访谈和用户使用场景的分析。 定量分析。包括用户问卷，以及用户操作日志分析。 下面我稍微展开介绍一下。 用户访谈我认为用户访谈是最好的定性分析手段，没有之一。主要是每个用户都有着独特的个体差异。如果我们在访谈前不设置太多访谈目标的话，就可以获得比较多的新的信息点。 这些信息点可能暴露出一些未被发掘的用户需求。也可能发现产品设计当中的不合适的流程。 当然，大部分时候，用户提到的问题要么是太特殊，要么是并不合理，但这没有关系，如果用户访谈中只有一个用户提到，我们就简单记录下来即可。大部分时候用户提的东西都不能直接拿来用，需要消化。 但如果每个用户都提到同样的问题，那我们就要小心了，很可能是我们产品的问题。 用户使用场景的现场观察做产品一直讲要“还原用户场景”，而用研就是最直接的呈现出用户场景。这个信息非常非常关键。因为用户可以随便说，但是怎么做才是最重要的，“身体不会撒谎”。 有一个故事，有一个公司做用研，让用户挑他们最喜欢的杯子颜色，结果大家都投的红色。用户做完用研，这个公司说，你们可以走的时候带走一个杯子。结果，大家走的时候都带走的是白色的杯子。 这就是一个用户说的和做的不一样的故事。类似的故事有很多，像可口可乐换口味事件就是历史上成本最大的被用户说的欺骗的故事，详见：https://wenku.baidu.com/view/e847c601cc175527072208b9.html。 用户问卷用户问卷用于定位一个问题后，定量分析用户的一些看法。问卷的设计大多时候都带有调研者的倾向性，所以很容易设置得不合理，这也是乔布斯说他从来不看用户问卷的原因。 但是 NPS（用户净推荐值）是一个很值得做的问卷，主要是这个指标非常标准化，我从在工作的第一天就接触 NPS，这个值的长期变化还是能有效反应出产品的改善。 用研的核心挑战用户研究在很多公司都有岗位，但是这个岗位如果只做用户研究，那么很容易做得很差。所以大多数公司都将这个工作综合放到产品经理的工作中。 我也见过很多第三方的用研公司，请一些用户做访谈，然后搞一些问卷，出一个满是图表和数据的报告。看起来很牛逼，但是能够给决策带来支持的信息极少，信息本身的质量也值得商榷。 解决方案我认为客观数据分析类：用户使用场景的现场观察、用户操作日志分析是最有价值的用研工作。 用研要做得好，还是应该是最核心的人「亲自参与」或者「重度参与」。 所谓的亲自参与，即核心的人自己做用研。如果是决定产品需求或功能，就让产品经理自己做用研。我们猿辅导的教学端产品经理，就需要自己深入教学环节中去了解老师的需求，以便改进教学端的体验。 如果想节省一些时间，那么也可以选择「重度参与」的方式。「重度参与」的核心是：必须亲眼看到原始数据。比如，我听说在头条，当用研在给用户试用产品的时候，屋子里有一面单面玻璃，后面是相关的产品经理在现场观察。这个时候，用研只是帮忙进行了组织协调工作，核心工作和决策产品经理并没有缺席。 我们在做一些新产品用研的时候，我也要求用研的同学需要把现场录像下来。这些录像也非常有助于大家研究用户为什么那么操作，反复观看和思考。 小结 用研是一种面向用户获得决策信息的研究方法。 用研最有价值的是用户现场操作的原始数据。 用研的开放性访谈可以获得一些意外的发现。 用研问卷比较难以做决策支持，但 NPS 有一定价值。 用研最好是决策相关人「亲自参与」或者「重度参与」，否则用研结果很难被合理消化并得到推进。","categories":[],"tags":[]},{"title":"如何识别和摆脱精神控制 - 读《情感吸血鬼》","slug":"dodging-energy-vampires-book","date":"2020-07-09T00:40:29.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/07/09/dodging-energy-vampires-book/","permalink":"https://blog.devtang.com/2020/07/09/dodging-energy-vampires-book/","excerpt":"","text":"引言第一次听到 PUA 这个词，是从南方周末上看到《”不寒而栗”的爱情：北大自杀女生的聊天记录》的 报道，然后又接触到精神控制这一类的词汇，当时觉得很惊奇，没想到精神控制能够做到用言语最终让人自杀的地步。 最近看完了一本反精神控制的书《情感吸血鬼 - 如何识别并逃离病态关系》，这本书系统性地介绍了被控制人的性格特点，以及如何保护自己，比较有意思的一本书，给大家分享一下。 什么样的人容易被精神控制作者将精神控制者比喻成：情感吸血鬼，我不太喜欢这个词，所以下文中我还是称他们为精神控制者。被控制的人，我们称作高共情者。 作者认为：敏感性高的共情者最可能被精神控制，成为情感吸血鬼的受害者。而高共情者通常是比较会隐藏和改变自己，以适应环境的。这一类人通常在童年的时候经历过一段痛苦的经历。因为经历过痛苦，所以就会渴望关心，也更多时候站在别人的立场上考虑问题，愿意牺牲自己。 北大包丽（化名）就是一个高共情者，她就是因为很平常的一个事情：不是处女，就得接受男友的各种变态的要求：把自己称作狗，拍裸照给男友，答应做绝育手术，最后甚至愿意自杀。 交往的对象 “不是处女” 在现在这个社会是很平常的事情，但是由于包丽的高共情，愿意站在男朋友的角度考虑他的感受，所以愿意为男朋友的感受做出明显过分的自我惩罚。 想想你有没有一段不愿意回忆的童年经历？你有没有在童年缺少支持和认同？有没有需要付出，才可能得到父母的爱？有没有为了讨好别人而改变或者隐藏自己真实的想法？如果有的话，那么其实你也是容易被精神控制的高共情者。 坦白说，我自己就是一个高共情者。敏感，喜欢站在对方角度思考问题，不喜欢冲突，容易妥协。 精神控制的套路精神控制的套路其实在北大包丽事件上演绎得很完整。首先，实施精神控制的人通常都很优秀，书中的案例包括公司的 CEO，高管等。控制包丽的牟林翰在北大也是学生会副主席，但这并不代表他们善良。 精神控制者首先是与高共情者建立信任关系，在这个期间，他们会表现得非常友好，让你感受到找到了理想的人。但是其实，这只是精神控制者的套路。他们真实的目的是利用你与他建立的信任，来深入地了解你的一切，从而获得你的缺点，这就是你的伤口。 这个缺点是什么不重要，重要的是精神控制者会声称这个缺点毁了他，让他遭受了巨大的打击，这会让高共情者感觉到内疚。于是，日复一日地，精神控制者往共情者的这个伤口上撒盐，让共情者人格慢慢扭曲。扭曲的效果就是，共情者会真的认为这是一个巨大的缺点，应该为了这个缺点补偿精神控制者。 当共情者愿意为了一个被夸大的缺点补偿精神控制者之后，共情者就坠入了被控制的深渊。精神控制者的要求会逐步升级，从写忏悔书，到下跪，到身体惩罚，到精神惩罚，最终变成精神控制者的奴隶。 北大的包丽先和牟林翰建立了恋爱关系，让牟林翰知道了自己的隐私，从而被牟林翰抓住缺点不断强调，进而认为自己真的应该 “认错并且忏悔”，从而从刚开始的发毒誓，到后面纹身称自己是狗，把牟林翰的微信昵称改成主人，再到后面接受去做绝育手术。从精神控制来说，牟林翰真的像是教科书般的存在。 如何识别和逃离精神控制识别精神控制精神控制者首先自己的心理就不是健康的，通常他们的行为模式标签包括心理变态、自恋、边缘型人格或反社会的行为倾向，这些人格类型为 B 类。在美国精神病学协会出版的《精神疾病诊断与统计手册》中，B 类人格特征包括： 反社会型人格障碍 边缘型人格障碍 表演型人格障碍 自恋型人格障碍 我查了一下百度百科，牟林翰可能有一部分 边缘型人格障碍 和 自恋型人格障碍 的特征。前者喜欢用表现强烈的情绪反应，贬低、攻击或挖苦对方，同时用自杀、自残自伤等来阻止被抛弃。后者在意社会成就，可能在工作上比较成功。 当精神控制者拿自杀来威胁你的时候，你就要特别小心了，他很可能不是真的想自杀，而是想要拿自杀要挟你。 逃离精神控制精神控制者惯用的伎俩就是过度夸大共情者的缺点，当出现这种情况的时候，就应该尽快想办法逃离这种关系。 书中提到很多共情者会经历多次反复，因为内心深处觉得对方可能改变。但是事实上这种人格障碍心理问题可能是来自于遗传或者长期的生活，改变的可能性极低。作者建议大家选择尽快结束掉这种关系，不要抱希望。 共情者因为已经足够为别人着想了，所以在面对这种关系时应该要注意守住自己的边界，不能让自己的一点点小问题被无限放大。同时专注于自己的感受，如果自己感受已经很有压力了，那么这种关系就是不对的。 如何修复自己内心的童年创伤作者在最后也提到，大多数共情者与精神控制者一样，都有着一定的心理问题，共情者的问题主要来自于童年的创伤，由于缺少爱而渴望关心。作者在书中也提到了各种心理治疗的方式。我这里摘录两个印象较深的。 表达情绪共情者常常压抑自己的负面情绪，但像愤怒、悲伤这一类情绪，都是身体的需要，应该表达出来。如果不表达出来，就会出现一些生理或心理的问题。当你经历痛苦的时候，你必须通过动作、声音和眼泪来进行治愈，这是身体治疗痛苦的天生方法。否则，所有这些能量会卡在你的身体里，导致各种各样的健康问题。 书中介绍了心理治疗师对受害者的一个声音治疗方案，让受害者假想面对精神控制者，说：”某某，你这个 XX 的 XX，你真是个混蛋，我送你踏上疗养之路”。 自我沟通法书中介绍了一种通过和幼年的自己假想”对话”的治疗方案，我感觉是一种特殊的表达宣泄式的治疗，具体做法是： 第一步：停止。想像一个停止的标志。 第二步：用鼻子深呼吸。让自己放松。 第三步：承认：”哇，我又来了”。帮助自己意识到你的故事。 第四步：获得一个数字。想一个数字，这个数字表示你将遇到的过去的自己的年龄。 第五步：与这个”内在小孩”相遇。创造一个神奇的花园，你和过去的自己相遇，看看他在做什么，你能不能给他爱和安慰。 第六步：告别孩子。让孩子放心，然后你离开，把孩子留在花园。 第七步：你作为一个成年人回到现在。 我估计这个方法是帮助那些深受伤害的共情者解压的方法，书中的作者以自己为案例，花了 40 天和过去的自己和解。 小结 高共情者容易成为精神控制的对象。 高共情者通常在童年有一些不幸，使得他们愿意改变和隐藏自己，获得关爱。 精神控制者通过建立信任、放大共情者的缺点来获得过分的补偿，最终消耗尽共情者的身心。 共情者需要识别出精神控制者并且逃离这种关系，并且通过各种方式缓解情绪，并与自己的过去和解。 这就是《情感吸血鬼》一书的小结，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"硬件创新的故事与逻辑 - 读《硬战》","slug":"hardware-war-book","date":"2020-07-05T02:12:46.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/07/05/hardware-war-book/","permalink":"https://blog.devtang.com/2020/07/05/hardware-war-book/","excerpt":"","text":"刚刚看完一本智能硬件的书《硬战》，作者曾经就职于大疆，UBTECH 和 IBM。这本书主要讲的是硬件行业的竞争案例，读起来相对轻松，以下是我的一些感受。 硬件产品的特点硬件产品和软件产品有几个很大的区别： 【研发周期】。硬件产品研发周期长，拿儿童类的玩教具来说，新品研发通常得 6 - 8 个月。而软件的研发周期通常也就 3 个月以内。 【迭代周期】。硬件产品涉及开模，一个模具通常可以使用 50 万次，前期投入巨大。所以硬件的迭代通常不能很快，即便你上线就立即迭代，因为涉及开模，也得需要至少 3 个月左右。而软件的迭代都是以周为单位，快手就每周发布一个版本。 【管理难度】。硬件产品通常需要依赖方案商和组装厂。这些乙方的配合度是非常关键的。锤子手机当年量产难，一部分原因就是自己的订单量不够大，组装厂没有全力配合。而软件的研发通常不涉及外部合作，所以管理难度会小很多。 【资金投入】。硬件产品的研发周期很长，资金投入大，这就使得行业内普遍不愿意创新。因为你创新的时间和金钱成本都太高。亚马逊做 Echo 音箱做了几代才做好，微软做 Surface 失败了一代继续做下一代，这都需要巨大的决策成本。软件的创新通常只需要两三个人就可以做 MVP 了，投入就只有几个人的工资。 【体验难度】。硬件因为是实体，所以它的售卖需要拿到手里看才能很好地体验。这使得大部分硬件是通过经销商卖出去的，因为经销商有线下的渠道可以让用户体验。软件可不一样，软件你在手机上几乎就可以体验到完整的服务了。 以下是整理的表格： 项目 硬件 软件 研发周期 长。6-8 个月 长。3个月 迭代周期 长。3-6 个月 短。1-2周 管理难度 高 中 创新难度 高。时间和金钱成本高。 低。可以做 MVP。 体验难度 高 低 相对来说，因为时间长资金投入大，硬件如果积累起规模效应和时间窗口，也能积累起足够的壁垒。 硬件的获客软件的获客大多是通过线上的方式。 硬件的获客方式其实分为线上和线下两种。线下获客是大部分硬件主流的方式，即走渠道商，通过渠道来获客。但是商品需要给渠道商留够利润。线下获客也可以是像苹果这样的直营店，但是通常只有品牌大到一定程度才可以。 硬件的线上获客最多的，就是通过电商平台了。这个时候，因为用户无法亲手拿到硬件体验，所以文案的能力以及 PS 的能力就变得重要了，价格也变得很重要。淘宝上卖得好的商品，都是质量一般，文案做得好，图拍得好，价格也吸引人的商品。 直播卖货是现在比较火的线上销售模式。相对来说，这种模式是能鼓励大家做优质商品的，因为带货的大 V 需要将商品品质与自己的人设搭配，质量一般的商品反倒不那么受欢迎。大 V 最欢迎的是那些品牌力最好的，价格相对公道即可。 小米当年的获客，算是一个独特的存在。小米核心是靠产品的性价比，通过性价比来获得口碑传播，通过传播来获客，这背后是当时安卓手机给市场留下的 2000 元以内的空间。但是这种方式一方面不太可复制，另一方面增长也会有问题，所以小米现在的获客和华为，Oppo，Vivo 没有太大的差别。小米无疑是成功的，但是小米上市后股价一路下跌，未来的估值到底是多少，还要再看一段时间。 智能硬件落地难互联网成就了 BAT，移动互联网成就了美团点评、滴滴、拼多多。那么利用创新能否颠覆硬件行业，成为每一个创业者的梦想，而这里面的技术变化就是：AI。 但是，智能硬件从概念到落地，从来都不像软件那么容易。如果我们看这些年智能硬件的创新，从智能路由器到智能音箱，从陪伴机器人到智能家电（台灯、门锁、摄像头），从智能穿戴设备（耳机、手环、VR&#x2F;AR眼镜、运动相机）到无人机，竞争可以用惨烈来形容，但是真正的赢家却没有几个。 从智能路由器到智能音箱智能路由器作为网络带宽的出入口，本来想成为家庭的控制中心，但是最后人们发现，其实这个角色应该是智能音箱。 智能音箱这个设备本身的技术难度又不高，语音识别既可以自己实现，也可以用迅飞的 API。于是，这个生意注定是有布局意识，经受得住亏损补贴的大厂。 经过小爱同学、小度在家、天猫精灵几家补贴式的竞争，最后小的玩家全部被挤出去了。 而就算这样，智能音箱在国内的应用场景也不算高，只能拿来听听新闻和音乐。家庭的各个设备还需要几年的时间才能够一一连上网并且开放给音箱。 我家的小度在家和天猫精灵，基本上都是用来听歌和听故事。小度在家我另外配了一个红外遥控器，可以遥控电视开关。开关窗帘？我太懒了，还没有勤快到专门为了这个更换窗帘的导轨。 陪伴机器人到智能家电AI 机器人从傅盛成立猎户星空的时候就被媒体和行业密切关注，从 2014 年开始持续火爆到 2017 年。 后来人们发现，机器人的能力其实可以拆解成： 移动&#x2F;搬运 对话 带屏 在 C 端场景下，除了扫地机器人，没有哪个家庭需要一个没事跑来跑去的可以对话&#x2F;带屏的机器，如果这个机器不跑来跑去，那么它其实应该是个智能音箱。 在户外场景下，商场可能需要一个移动的引导机器人？但是我发现更多人对它只是好奇，好看大于实用。因为你又不能真正的给别人带路，无非还就是提供屏幕查询操作。 餐馆方面，送餐机器人可能是一个有用的场景，因为餐馆有移动送餐的需求。但是就算在海底捞，我发现这个机器人使用起来也有诸多限制，更多只是一种尝试。 在教育场景下，很多人把智能音箱变个机器人的人形外观，就当作教育机器人来卖，说什么情感陪伴，智能对话。要打破这个谎言，只需要问机器人两句话就可以： 第一句：“望京在哪儿？” 第二句：“怎么过去？” 还没有机器人能搞定上下文这种对于 3 岁小孩来说都是基础的对话要求。 智能家电提供的能力也谈不上颠覆，大部分时候就是提供蓝牙和 Wifi 的连接，然后提供一些 App 或接口可以远程控制它。我把我家的冰箱连上网之后就后悔了，因为我完全没兴趣远程调它的温度，还额外占用我的一个路由器的连接数。后来换洗衣机的时候我就学聪明了，都没有尝试联网过。 或许把空调连上智能音箱之后，用语音开关空调和调温度是一个需求。不过我的小度红外遥控器离空调太远，遥控器的学习功能也有问题。为了空调专门再买一个红外遥控器，并且放到离空调近的地方还是太麻烦了。所以只能等换空调的时候，买一个可以连接音箱的空调了。 智能穿戴设备大家对穿戴设备兴趣特别高，但最终落地的，现在只有手环。我自己买了第二代的 Apple Watch，Fitbit Force，小米和华为的各种手环，现在用的是华为的手环，只是因为它在游泳的时候计圈相对准一点点。 大部分时候，我只是用手环来看时间和设置定时器。如果只是这些的话，随便哪家的手环都可以用。 NFC 支付功能在手机上其实使用起来更方便，因为你可能忘带手环，但是你绝不会忘带手机。不然你连各种楼都进不去（因为要出示健康宝）。 当前手环的价格也很难说有很大的利润，最终的玩家估计也就只有手机厂家了。把手环作为手机的生态硬件中的一环，以达成更好的体验。我的华为手环还有一个重要功能就是“找手机”，基本上每两天就要用一次。 无人机无人机是一个非常值得聊的话题。我们刚刚看到的少有的几个成功的硬件产品：智能音箱、手环都是被大厂抢了生意。放在无人机领域，当然大疆的竞争者并不少。一方面是国内的小米等大厂，另一方面是国外像 GoPro 这种在相机领域拥有优势的公司。最终大疆是如何胜出的呢？ 刚刚我们提到，像智能音箱、手环相对核心竞争力不强，在当时的技术下，大家的技术壁垒都不高，在能力相似的情况下，最终赢家是靠价格和补贴完成了竞争。 无人机之所以不一样，我们可以看到 2016 年左右 GoPro 和大疆直接竞争的时候，他们同质化的产品是 GoPro Karma 和 Mavic Pro，最后因为前者出现了极大的质量问题，全部召回。由于技术优势，市场给了大疆完全空白的竞争期。在这段时期，大疆又持续地研发低成本的无人机，将 Mavic 系列的体积和价格越做越低。大疆甚至还成立了一家子公司做了一个 799 的 Tello 无人机。 在我看来，大疆的无人机在技术上的壁垒已经领先同行 2 年左右，同时无人机的研发投入并不低，加上这并不是一个巨大的消费者市场（相对手机、手环、音箱、汽车来说），别的硬件厂商未必愿意投入那么长的时间和钱来追赶，于是大疆就成功了。 小结 硬件产品相对于软件产品，在研发周期、迭代周期、管理难度、资金投入、体验难度都要难一些。 智能硬件大多是伪需求。智能音箱当前成为家庭接入的桥梁，但生态还未完善。 像大疆这样，硬件产品如果能够积累足够的技术壁垒，那么可以成功。 像手环、音箱这样，硬件产品和同行没有足够的差异性，那么就是资源竞争，看谁的资金和补贴能力强，背后是集团产品的战略协同目标。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"既做正确的事情，又照顾人的情绪 - 读《关键对话》","slug":"crucial-conversations-book-summary","date":"2020-04-19T14:26:34.000Z","updated":"2024-01-07T17:15:16.060Z","comments":true,"path":"2020/04/19/crucial-conversations-book-summary/","permalink":"https://blog.devtang.com/2020/04/19/crucial-conversations-book-summary/","excerpt":"","text":"引言你是否遇到过这种情况：和朋友、爱人、同事在一些事情上遇到激烈的分歧，然后你觉得你无法说服对方，于是你只有两种选择： 方案一：激烈地对抗，但有可能也无法达成目标，反而可能会激怒对方，让沟通变成双方情绪的宣泄。 方案二：选择沉默。被迫接受你内心不认可的观点，不管这个行为带来的影响有多大。 这本《关键对话》解决的就是以上问题，希望让你 「既做正确的事情，又照顾人的情绪」。 以下是我的一些读书笔记。 确定你的目标人天生就有捍卫自己观点的冲动，这容易最后让对话变成双方都试图说服对方，而不是真正和对方沟通。所以，关键对话对话的第一步让你站在「上帝视角」观察自己，了解清楚你的目的，从而不让情绪主导自己的行为。 然后，时刻提醒自己不要做「傻瓜式选择」，「傻瓜式选择」就是我在引言中提到的两种沟通的方式：要么直接对抗，要么放弃沟通。 观察对话的氛围拒绝「傻瓜式选择」并不容易，要做到这一点，首先需要的是观察对话的氛围，如果氛围不对，那么对话可能就无法有效进行了，书中列出了三种信号： 对话陷入危机的时刻 对方失去安全感的信号（即表现出沉默或暴力） 你应对压力的方式 保证安全书中介绍了一些在谈话出现安全感问题时，可以使用的技巧： 道歉。当你的行为冒犯了对方的时候，先行道歉。 对比说明。当对方误解了你的时候，用对比法消除误会。 创建共同的目的。当目的冲突的时候，寻找共同的目的。 道歉如果对方的情绪确实由于你的某些错误造成，那么你首先需要道歉。这有助于对方情绪的缓解，进而能够冷静下来理性沟通。 对比说明对比说明的结构是：「否定部分 + 肯定部分」。否定部分纠正对方的一些误解，肯定部分强化你的真实目的。 书中有一个案例，夫妻双方讨论一个敏感问题，丈夫首先发飙，认为是妻子指责自己。书中建议妻子用「对比说明」回答：我不是说这是你的问题，实际上我觉得这是我们俩的问题。我也不知道应该如何解决，但是我希望和你交流，这样才能更好地了解对方。 书中提供了一个练习的格式：我不希望＿＿＿，而是希望＿＿＿。 创建共同的目的有一些时候，很容易找到双方的共同目的。但沟通遇到问题的时候，共同目的就不那么容易创建了。 书中建议对双方的主张背后的真正策略进行讨论，试着问对方：「你为什么想这么做？」。 书中的案例是夫妻之前关于下班后是出去还是在家的争论。在试着问对方「你为什么想这么做？」之后，最终发现：妻子想在家是想安静一点，而丈夫想出去是因为想躲开孩子，享受一下二人少有的独处时光。于是，对话的共同目的就出现了：找到既能够安静一点，又可以享受二人独处时光的方案。在共同目标下，夫妻很快讨论出了方案。 控制情绪认识情绪在控制情绪之前，我们首先需要认识情绪： 让情绪产生的只能而且永远是你自己。 产生负面情绪之后，你要么控制它，要么被它控制。 另外，情绪本身没有好坏之分，所有情绪都是合理的。「生气」这种情绪有助于肾上腺素的分泌，在远古时代拥有这种情绪的人会在暴力行为中占据上风（因为那个时候竞争靠力量居多）。「害怕」这种情绪也会让人远离危险，人看到蛇之类的动物天生就会害怕，这也是靠上万年的自然选择留在我们基因深处的情绪触发机制。 虽然情绪没有好坏之分，但是由于情绪不加控制产生的行为，就很难说都是好的了。比如一个人因为生气，杀了人，那他就要承担刑事责任，就可以肯定是一个坏的行为。 控制情绪通过拆解对话中情绪的产生过程，我们发现在信息和情绪之间，我们有一层对于信息的偏主观的理解，如下图： 书中的案例是一个合作的同事 A 和 B，同事 A 在报告的时候自己独自演示，没有给同事 B 机会说话，这让同事 B 认为自己的功劳被忽略了。但具体的客观分析下来，有可能同事 A 是由于紧张才这样，并不是有意埋没同事 B 的贡献。 在对话的时候，如果我们把对方想得善意一些，就容易建立起平和的情绪进行沟通，避免误解。书中建议我们使用「一个理智而正常的人为什么会这么做」来反问自己，试图给对方一个理性解释，然后再试图通过对话来解决问题。 当然，这种理性解释只是让对话可以开展，不代表最终对方就是这么善意，但是这总比你一开始把别人往坏处想，误会好人要好得多。 书中只是介绍了对话的情绪如何解决，我在以前还看过一些别的情绪的解决方法，比如遇到伤心的事情了，仍不住想哭之类的。首先我们得知道情绪的宣泄是有助于心理健康的，一个人如果老是压抑自己的正常情绪，那么也容易产生各种心理疾病。所以，情绪产生了，最好的办法就是合理的把这个情绪控制住。 控制情绪的办法有很多，以下是我想到的一些。 1、适当宣泄。比如悲伤的情绪，最简单的方法就是哭出来，倾诉出来就会好很多。又比如焦虑的情绪，可以通过适当地放松来调节。 2、转移注意力。如果有一件事情你很生气，很冲动，你可以先想想别的事情，让自己的情绪先冷静下来。小朋友发脾气的时候，我们虽然不能让他转移注意力，但是我们通常让他找个安静的地方平静一下，也是类似的道理。一般情况下，给自己 5-10 分钟安静时间，就不会那么冲动了。 3、上帝视角自嘲。把自己的行为看成第三者犯的，自我嘲笑一下。比如：「哎，我怎么又犯这种低级错误了」，这有助于控制自我否定的情绪。有些时候也可以把一些影响情绪的小事用另外的角度来解读和表达，比如麻烦了大家，说：「我又给大家挖坑了」，再配个下面的图。 陈述观点书中介绍了「综合陈述法」，一共五种技巧： 分享事实经过 说出你的想法 征询对方观点 做出试探表述 鼓励做出尝试 前面三种是「内容」方面的技巧，后面两种是「方式」方面的技巧。 分享事实经过。这个阶段只陈述事实，不加工对于事实本身的理解。 说出你的想法。这个时候要注意让对方留在安全区，通过刚刚提到的各种方法，保持一种理性的沟通气氛。自己要表现得足够自信和谦逊，即把你的观点毫无保留地表达出来，又对对方表达出足够的尊重。 征询对方观点。这个时候需要认真听取对方的观点，并且将对方的合理观点放到自己的观点库中，以便修正自己的观点。对话不是为了说服对方，而是让双方达成一致。如果是自己的想法有问题，修正就可以了。 做出试探表述。这种表述显示出你的观点不一定成熟，这有助于双方进行讨论，这样的表述常见的格式是： 「我很好奇为什么…」 「可能你没有意识到…」 「我有点怀疑是否…」 使用试探表述不要走向另一个极端，即表现得特别软弱。因为这会让人感觉到很不自信，这对你的观点非常不利。软弱的说法包括：「我这样说可能有点傻…」，「我可能是错的，不过…」，「我可能太苛刻了，可是…」。 鼓励做出尝试。当沟通双方是上下级关系时，对方可能会担心风险。这个时候鼓励就很重要，要让他们理解你交流的意愿。比如说：「我很想知道大家的意见」。 最后，我们以上的技巧都是为了将注意力放到事情本身而不是情绪上，只有这样才能获得有效地沟通，达成正确的结论。 了解动机为了鼓励对方道出行为动机，我们应该用四种有效的倾听技巧来营造安全感。这四种技巧分别是： 询问观点。 确认感受。 重新描述。 主动引导。 询问观点比较直接，例如：「我想听听你的看法」，「如果你有不同观点，可以直接告诉我」。 如果直接的方式无法让对方开口，可能是因为对方安全感不够，你可以通过确认感受来营造更大的安全感。比如：「你好像对我很生气」，「你嘴上说没事，但是看起来不像是没事的样子」。 用你自己的语言，把对方的话再重复一遍，可以营造更强的安全感。比如：「好的，你看看我的理解是否正确。你感觉不开心是因为…，是这样吗？」。 如果以上办法都没有达成有效的沟通，这个时候不要急于求成，而应该放慢节奏，可以选择退出或者询问对方希望看到的结果。询问对方的目的有助于避免他们陷入攻击或逃避的简单思维模式，转而思考更重要的问题的解决方案。 主动引导是猜测对方想法，主动抛出来的行为，这有一种风险就是有可能会让别人误会。所以需要前面提到的方法没有用，同时你又非常确定他们的想法的时候才可以使用。例如：「你是不是觉得….，对吗？」这是一种承担风险，主动示弱和营造安全感的行为。 开始行动当大家建立了安全感，确定了共同的目标，向目标贡献了各种观点和想法，却无法将它们转化成行动。书中建议在确定行动方案之后，明确以下信息： 行动人。明确执行人。 行动目标。明确行动的目标，需要非常具体。 行动时间。需要明确完成的时间。 检查方法。比如完成之后通知大家，或者定期检查进度。 这有点类似 [SMART 原则](https:&#x2F;SMART 原则&#x2F;baike.baidu.com&#x2F;item&#x2F;SMART%E5%8E%9F%E5%88%99)。 小结本质上，《关键对话》是一本讲如何做出正确决策的书，只是因为很多错误的决策是由于情绪造成讨论不足分，故意对抗，所以这本书强调要放下自己的主观立场，在一个安全的气氛下「共享观点库」，以便做出正确的决策。 所以，本书最关键的点就是： 自省。能够放下自己的观点，为了达成正确的决策做好沟通的基础。 营造安全感。通过道歉、对比陈述、创建共同目标、控制情绪（避免曲解他人）、陈述观点、寻找动机来构建安全的信息沟通方式。 最后，用 SMART 原则来做一个明确的、具体的、可检查的、有时间限制的方案，推进方案的实施。 这本书有点类似于去年看的《谦逊的探询》，都是为了营造一种安全的沟通气氛而使用的技巧，不过本书针对的是更敏感的问题，《谦逊的探询》更像是针对一些开放性问题，各有侧重。 一本非常好的书，推荐给大家！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"做决策的时候，你相信什么？","slug":"how-to-make-decision","date":"2020-04-15T13:23:43.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/04/15/how-to-make-decision/","permalink":"https://blog.devtang.com/2020/04/15/how-to-make-decision/","excerpt":"","text":"​ 一、引言最近发生了两件事情： 1、同事 A 给我说，有一个产品他想迭代，因为那个产品的视觉他觉得不好。而我觉得那视觉还行。于是我就给他说：是不是要做个调研，让用户们评一下？ 2、同事 B 给我说，他想把某个产品的视觉迭代一下。我对新的视觉风格不确定，就问了一些人。有一些人说好，有一些人说不好。我问同事 B，要不要做个用研投个票。同事 B 觉得这样不好，因为他认为专业的判断更靠谱。 就决策来看，我们应该相信自己的判断或感觉，还是相信专家，还是相信一个流程？这引发了我的思考。 二、决策的原则更多时候，人性是相信自己的感觉的，然后会靠着自己的感觉，来选择性的相信一些信息。 比如我发现，当我对一件事情怀疑的时候，我就会选择性相信自己看到的证据，忽视或者怀疑别的证据。我不会简单地以证据的多少为决策依据，当支持我的观点少的时候，我会觉得“真理掌握在少数人手里__”，当支持我的观点多的时候，我会觉得”__应该听取大部分人的观点，减少风险“。 那么，真正好的决策原则是什么？是相信自己的直观，还是相信专家，还是依赖于投票，调研的结论？ 我首先觉得，盲目自信是不好的。别人说的信息，应该还是消化吸收进来，对的接受，不对的过滤。 另外，依赖投票和调研数据来做决策是不对的。因为投票和调研都非常容易被问题或者场景或者调研样本影响。依赖这个做决策很多时候都会死很惨。比如历史上的 1985 年可口可乐的换口味事件，依赖于用户盲测，结果最后决策是完全错误的。 桥水基金的创始人 Ray 在公司发明了一种基于置信度的带权重的投票决策机制，但是我觉得这个机制只适用于他们公司，同时这对于大部分人来说做不到。 对于大部分人来说，可能最好的决策方式就是：客观。客观是指先把自己的观点放一把，然后把自己的观点和别人的观点都放在一起看一看，逐个分析每个观点是否正确。最后分析完了，还是得”相信自己的分析“。 因为这本质上对于一个决策，一个人只能相信自己相信的决策 。对于自己不相信的决策，即使短期妥协，一旦遇到一些相反的信息就会后悔，会坚持不住。 这跟自己没研究透的股票在持续下跌的过程中拿不住是一个道理。这波疫情造成的股市下跌，我发现我最后拿住的股票，都是我坚信会涨回来的，没拿住的，都是不确定能不能涨回来的。 三、决策能力差怎么办不是每个人都有很好的决策能力。如果一个人最终决策能力低，那可以不决策，把决策过程完全交给自己信得过的人，这也是可以的。 比如在家里，夫妻可以让决策能力强的人拿主意；工作上，可以让决策能力强的人做负责人；在生活上，也可以多咨询身边决策能力强的朋友的意见。决定把决策交给别人，并坚信别人，也是一种决策。 这就类似于买私募基金，就是一种将理财的方案决策交给专家来做的行为。 四、小结1、决策的时候要理性，客观，不能盲目自信。 2、不要轻信专家，投票，用户调查，历史经验，而应该把这些信息当作参考，从底层自己独立思考。 3、只有自己相信的事情，才能持久。 4、精力有限或能力有限的情况下，可以考虑把一些事情的决策交给别人。 就酱~","categories":[],"tags":[]},{"title":"方三文的聊天记录 - 读《您厉害，您赚得多》","slug":"snowball-ceo-book-summary","date":"2020-04-11T15:49:34.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/04/11/snowball-ceo-book-summary/","permalink":"https://blog.devtang.com/2020/04/11/snowball-ceo-book-summary/","excerpt":"","text":"引言最近读完了雪球 CEO 方三文的《您厉害，您赚得多》。这是一本比较特别的书，里面很多内容以雪球上的聊天记录的方式呈现，稍微显得体系感没那么强。但是一本书能够给读者带来几个点的思考和总结，也就值回书价和时间了。 整本书给我带来的思考还是挺多的，以下是一些记录。 什么是赌徒书中关于「股市与赌徒」让我思考，什么才是真正的价值投资者。结果我发现，实际上基本上所有的投资都带有赌博的成分。 我们通常可能认为，股票挣钱的方式有两种： 挣市场的钱 挣交易对手的钱 但是，即便是所谓的价值投资者，也是在目标股票价格合理或者极低时买入。这个时候，他如果真的做到了超过平均收益率的回报，那前提是他假定当时和他对手的交易都是傻子，并且事实上确实如此。所以，他其实也是挣的是交易对手的钱。 同时，当你在买入一支股票的时候，你其实就做了两件事情：择股，择时。这两件事情本身都有极大不确定因素： 没有人能够预测股票未来的涨跌，所以你的择时就是一种赌博。 没有人能够获得一家公司所有的信息，决策都是不完全信息情况下做出的。这个时候做出的投股决定，虽然有很多信息当作参考，但是因为不完整，所以也是一种赌博。 唯一可能没有赌博操作的，可能就只有指数定投了，因为它放弃了择股和择时，它是纯粹挣市场的钱，而其它的都不是。 如何研究公司方三文认为研究公司研究 3 件事情就可以了： 所处行业是否可持续增长。 商业模式是否有优势和壁垒。 公司的治理结构和创始人人格是否有优势。 行业书中讲到很多案例，对于行业的案例中，我印象最深的是移动互联网。这是我亲身经历的行业，我是最早的一批 iOS 开发者，经历了移动互联网从 2010 年起步到飞速发展的这十年。 其实移动互联网对于整个行业的影响是巨大的，但是我身处当中对此其实并不敏感，本质上就是一个人拥有了一块随时在线的屏幕。这对于信息交流的便利性，实时性，以及内容展示的个性化，位置化都是极大的改变。 公司治理方三文在书中介绍了他是如何研究比亚迪的公司治理的： 有空就去比亚迪 4S 店观察，跟销售员和顾客交流 从供应商那儿打听比亚迪的采购体系 看公司对外的承诺是否兑现过 有一些公司，治理结构相对不那么重要，反倒显示出这个公司壁垒高，比如茅台。 估值书中又一次讲到了「现金流折现法」，我最早是在段永平的一个采访文章中看到的。 现金流折现（discounted cash flow ，DCF）旨在通过将所有未来的现金流折成现值来求得资产内在价值。相关的介绍文章很多，比如知乎上的这篇文章。 估值方面，段永平介绍过《谈毛估估的思路与方法》，其实也挺有价值，里面提到的估值法包括： 现金流折现法 存银行本金估值法 市盈率（PE）估值法 隐性资产估值法 企业价值（含负债）e&#x2F;e估值法 这些计算其实都不算是特别精细，都是估算，所以段永平叫毛估估。但是如果初步算起来，都觉得特别便宜，那可能股价就是便宜的。 什么时候卖出有人说，价值投资者就应该永远持有股票，或者至少持有 5 年以上。我去年 220 多买了特斯拉，年底 420 卖出了，很多人评论我这个是伪价值投资。这让我一度思考应该什么时候卖出标的。 我去年觉得特斯拉的估值底部在 300 亿美元，所以我就在那个区间买入，但是涨到多少是合理的，我并不清楚，所以就没拿住，这也算是我能力不行吧。 就巴菲特来看，他既有像可口可乐这种长期持有的案例，也有像中石油，迪士尼这种高价卖出的案例。 就本书的讨论来看，我觉得卖出标的时机还是这个股票的价格远远超过了它的价值。那远远是多远呢？我想了一个办法：如果这家公司的行业&#x2F;模式&#x2F;治理都好，那就以一个偏长期（5-10年）的心态，来计算出公司未来的长期赢利能力，然后买入之后的目标就是持有到这种长期赢利能力达成之后的合理股价。 一般来说，一个行业&#x2F;模式&#x2F;治理都好的公司，10 年之后的复合增长应该是非常夸张的。这个时候计算出来的长期合理股价就会非常高，这个时候中途卖掉之后，不排除就遇不到合理的买回来的机会了，那不如就长期持有了。 资产配置其实资产配置就是把钱放在合适风险的产品上。 银行活期，零风格，但是利率低。 银行定期，失去一定流动性，但是利率变高。 货币基金，低风险。比活期和短期的定期都好，现在大概 3% 左右。 债券基金，中低风险，平均能到 5% 左右。 信托，风险再高一些，牺牲流动性，收益能再高一些。 股票型基金，中高风险，有可能做到 10% 以上的收益。 股票，高风险。 所谓的资产配置，就是你在调几个参数：风险、流动性、波动率。高收益的配置同时也意味着高风险，流动性差，流动率高。 下图是中国的各类资产规模情况： 具体怎么做呢？ 把保命的钱放在低风险资产中，这部分的钱至少是家庭未来 6 个月的开销。 把你亏得起、亏光不影响生活的钱放在中高风险的产品中，最多不超过 1&#x2F;3。 小结方三文的这本书给我带来了一些关于投资的思考，包括： 如何研究公司：行业&#x2F;公司&#x2F;管理层 如何估值公司 什么时候卖出股票 资产配置的思考 参考链接 https://www.zhihu.com/question/23005134 https://zhuanlan.zhihu.com/p/80541445","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"利用 Automator 自动化你的工作","slug":"automatic-thinking","date":"2020-03-25T03:52:39.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/03/25/automatic-thinking/","permalink":"https://blog.devtang.com/2020/03/25/automatic-thinking/","excerpt":"","text":"开端最近需要压缩一些 MP3 和 MP4 的大小。首先我在网上搜了一下相关的 App，试了好几个都没有理想的，于是我就想用 ffmpeg 或许更方便一些。 安装好 ffmpeg 之后，我搜了一下，找到了相关的压缩指令： 压缩 MP3： ffmpeg -i source.mp3 -map 0:a:0 -b:a 96k dest.mp3 压缩 MP4: ffmpeg -i source.mp4 -vcodec libx265 -crf 26 dest.mp4 于是，我很快就完成了相关的压缩。 存档和同步不过，我发现这些指令参数都很长，我很可能下次用的时候还是记不住要查询。于是，我想到了 Dash。 Dash 是为程序员提供的一个文档查找工具，同时它还有一个代码片段（Snippets）功能，可以帮助你保存和查询常用的代码片段。 我首先把这些命令放到了我的 Dash 的 Snippets 里，这样我以后只需要输入 mp3 或者 compress 或者 ffmpeg 即可调出这条命令（如下图）。 我的 Dash 的存储目录是在 Dropbox 下，于是这条命令自动同步到了我所有的电脑中。 Automator但是这样的使用还是不够方便，因为我还是需要切换到命令行来输入这些指令，我想以后能不能我在 mp3 或 mp4 文件上点击右键，就自动出现相关的压缩指令呢？于是我想到了 Mac 自带的 Automator。 Automator 可以帮你将一些自动化的流程转换成右键菜单甚至是 App。 首先在 Application 目录下找到 Automator 并启动它。然后选择新建一个 Quick Action: 接着，设置 workflow 只在音频文件的右键菜单中出现，也只在 Finder 中生效。 接下来进行 3 步： 拖入一个 「Run Shell Script」模块 将「Pass input」设置成 as arguments 在 Shell 中填入以下内容 # 输入文件fileName=$1# 输出文件名targetName=$&#123;fileName:0:-4&#125;&quot;-compressed.mp3&quot;/usr/local/bin/ffmpeg -i $fileName -map 0:a:0 -b:a 96k $targetName 编辑完成之后保存。找一个 MP3 文件测试，在 finder 中右键已经可以出现我们想到的菜单了： 以下是最终的操作效果图(用 EZGif 生成）： 运行状态像这种运行时间挺长的执令，其实可以在系统的顶部状态栏看到一个滚动的小齿轮，点击即可看到运行状态： 备份~~Service 是保存在本地的，我们还是要备份一下，直接复制到 Dropbox 同步盘即可： cp -r ~&#x2F;Library&#x2F;Services&#x2F;* ~&#x2F;Dropbox&#x2F;Service-backup&#x2F; ~~ 可以直接将 workflow 文件保存到 iCloud 上： 小结Dash 和 Automator 是你自动化命令的好帮手，再借助 Dropbox、iCloud 等云盘将它们同步到你所有的电脑，你就可以随时随地使用这些命令。 祝大家玩得开心~","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"}],"tags":[]},{"title":"美股期权学习笔记（四）","slug":"option-learning-notes-4","date":"2020-03-22T13:40:01.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/03/22/option-learning-notes-4/","permalink":"https://blog.devtang.com/2020/03/22/option-learning-notes-4/","excerpt":"","text":"前面写完了 3 篇笔记之后，说说我的一些体会吧。 期权不适合大部分人期权的操作太复杂，不适合大部分人，特别是通过期权组合来建立各种头寸，对非专业人士来说很难掌握。 我感觉如果要成为这方面的专家，应该需要投入非常多的时间，对于普通人来说不但不划算，而且即便投入了也不一定能挣到钱。 用裸卖看跌（PUT)期权来买入股票用裸卖看跌（PUT)期权来尝试降低买入股票的价格，是我认为唯一适合普通投资人尝试的操作。 比如特斯拉现在股票值 450，但是你觉得只有跌到 220 你才愿意买入。那你可以裸卖出一周或一个月到期的 220 元的 PUT 期权。这样： 如果到期时股价跌到 220 以下，你则以 220 完成了建仓。 如果到期时股价没有跌到 220 以下，你则收取了权利金。 这个事情的风险有几个: 如果股价跌得特别多（比如跌到 100），这种操作实际上把买入的价格被锁定到了 220，造成帐面上的亏损。 如果股价上涨很多，这种操作会失去拥有这个股票的机会。 产品化的版本该操作被一个 App 产品化了，这个 App 叫高格证券。高格证券把该操作称作「优买计划」，如下图所示： 我觉得这种产品化的思路还挺好，首先它强化了这个策略应该用来长期持有看好的股票。然后它把权利金描述成现金收益，并且提供了年化收益和买入概率等信息。 如果你打算尝试，可以用我的邀请二维码（下图），这样我们俩各可以获得 5 美金的现金奖励。 也说说高格的缺点吧。高格的优势也同时是它的劣势，因为高格把它产品化了，为你隐藏了大量信息，所以你也就无法做各种各样期权的组合以及中途回购期权。另外从保证金角度，如果是深度的虚值期权，保证金会动态变化，大多时候不会到 100%，而高格因为是鼓励以购买为目标来使用「优买计划」，所以你需要交 100% 的保证金。 该操作的风险《麦克米伦谈期权》的 2.5.3 章节提到了这种操作。作者认为，如果你目的并不是持有股票，而是通过这种方式获取权利金，那么极端风险情况下，你会有极大的账面损失。书中也讲了一个真实的案例： 市场上的专业投资者在裸卖空看跌期权的时候，喜欢选择低权利金，低波动率的股票，而 IBM 就是一个这类的股票。当时，IBM 的股价是 100 ~ 105 之间，挂牌的有行价权为 90 的 IBM 长期期权。许多投资者裸卖出了看跌期权，他们的理由是他们不介意有机会以 90 的价格持有 IBM 的股票。结果，IBM 的股价意外下跌到了 45。这个期权由虚值变为了深度实值。虽然期权没有到期，但是因为它是深度实值，很多被对手方提前行权了。最后分析发现，其中很多投资者并没有打算真正地在熊市中持有 IBM 的股票。 所以，这个故事告诉我们，再好的股票也有经历它自己的熊市的时候，而当事件发生时，裸卖空看跌期权就会遭受损失。 如果你想控制这种情况发生时的风险，有一个办法是用更低的成本买入深度虚值看跌期权，这样就形成了一个牛市价差的期权组合，这将控制你的下行风险。下图是牛市价差的盈亏图。 我自己的一些体会我自己尝试了一段时间裸卖空看跌（PUT)期权，以下是一些感悟： 期权的到期时间不要过长。最好不要超过 3 个月。主要的原因一个是 3 个月时间波动可能非常大，另一个原因是你的保证金锁定时间太长。我建议过期时间选择 1 周 ~ 1 个月这个范围。 想清楚自己是为了挣权利金还是持有。如果是为了持有，不要将卖空的价格设置得特别低，否则大概率是不可能完成建仓的。而一些极端情况下完成的建仓，真正发生的时候，可能跌幅就不止是当时设置的那个买入价了。 如果是为了挣权利金而裸卖空看跌（PUT)期权。那么需要关注好 Theta 指标和 Vega 指标。因为 Theta 是时间价值指标。如果 Theta 指标特别低，而期权收益又高的话，那很可能是由于波动率（Vega）高带来的。那么这么高的波动率本身可能就意味着买入的风险。最好选低波动率的，同时时间价值高的期权。例如：下图中的一周到期的 Tesla 期权，Theta 值就很高： 最后一些朋友告诫我不要操作任何期权，我觉得他们说的很可能是对的。我的以上总结大概率是有一些片面性的，未来我也有极大可能交一些学费。 不过，如果使用完全不影响生活质量的钱，抱着学习的心态，不上杠杆，心里能够接受最后全部赔光，我想这样也没什么大不了。人生苦短，生活总得有些事情不试试不死心，对吧。 愿大家玩得开心！ 本系列文章汇总： 美股期权学习笔记（一） 美股期权学习笔记（二） 美股期权学习笔记（三） 美股期权学习笔记（四）","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"美股期权学习笔记（三）","slug":"option-learning-notes-3","date":"2020-03-21T03:02:41.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/03/21/option-learning-notes-3/","permalink":"https://blog.devtang.com/2020/03/21/option-learning-notes-3/","excerpt":"","text":"这篇再展开讨论一下期权的指标。 影响期权的变量期权因为相关的变量很多，包括时间，行权价等。所以任何一个变量变化就会影响期权的价格。人们研究发现，影响期权的价格因素一共有如下 6 个： 标的资产价格。对于看涨期权，标的资产上涨，看涨期权也上涨。 期权行权价格。 距离到期时间的长短。 标的波动率。标的波动率越高，期权价格越高。 短期利率，一般是 90 天的短期票据利率。 股息。公司如果提高股息，看涨期权会下跌，看跌期权上涨。因为股价会随着派息后下降，但是期权所有人无法获得股息。 实值期权和虚值期权受到期时间的影响不一样： 距离到期时间越近，虚值期权的价格越低。所以会出现随着临近，虚值的看涨和看跌期权都下跌的情况。 距离到期时间越近，实值期权的价值越来越接近标的行权价与市场价的差价。 对此，《麦克米伦谈期权》1.9.2 节有一个汇总表格： 期权的指标为了更好的理解期权，人们又抽象出一些指标来描述它。 DeltaDelta 表示随着股价的变化，期权价格的变化速度。Delta 变化区间在 [-1, 1] 之间。其中看涨期权的 Delta 变化区间在 [0, 1]，看跌期权的 Delta 变化区间在 [-1, 0]。 比如 Delta 为 0.5 就表示，股价每变化 1 点，期权变化 0.5 点。比如实值的看涨期权，Delta 就比较高，股价每上涨 1 点，期权几乎也上涨 1 点。 实值看涨期权的 Delta 接近 1，虚值看涨期权的 Delta 接近 0 一些。说明实值看涨期权更像是股票。 如果 Delta 为 0，则表示无论股价怎么变化，该组合的价格都不会变化，这种情况下，我们也称作该组合的 Delta 是中性，这也解释了上面提到的套利为什么被称作 Delta 中性头寸。 Delta 随着时间也会变化。比如对于虚值期权来说，随着时间流逝，它的 Delta 会趋于 0。因为时间越接近，股价的波动除非将虚值改变为实值，否则就没有意义。 与虚值期权相反，实值期权随着时间的流逝，它的 Delta 会趋近于 1（或-1）。因为这个时候，期权的时间价值几乎没有了，它的价格反映的就是行权价和股价之间的差。 书中对 Delta 还有一种另类的看待角度：Delta 可以看作期权最终到期时为实值期权的概率。虽然数学解释不严谨，但是很有效。 波动率波动率是用来衡量标的价格变化速度。 历史波动率（historical volatility）是根据股票历史的波动率数据，是算出来的。 隐含波动率（implied volatility）是隐含在场内期权价格中的未来波动率水平。 当隐含波动率远高于历史波动率，说明股票在经历一些事件，例如：并购，诉讼，重大合作，重大危机，这些事件因为没有确定，所以买卖双方力量均衡，但事件结束后股票就会有大的变化。 书中 6.6.2 节举了一个有趣的例子： 1994 年，一家名为 Gensia 的制药公司被 FDA 宣布，将对它的主要药品举行听证会。该公司的股票没有什么巨大的波动，因为 FDA 的结果没有出来，所以看多和看空的双方力量均衡。但是，这家公司的期权的隐含波动率即上升至 140% 左右的区域。这是因为交易者知道 FDA 的结果将决定这家公司的成败。结果 FDA 最终做出了不利于这家公司的决定。这家公司股价瞬间下跌 50%，同时期权的隐含波动率回归到了正常水平。 VegaVega 描述的是波动率的变化如何影响期权价格（假定其它变量不变）。实际上 Vaga 就是代表的是隐含波动率。 Vega 值如果为 -5.0，则表示波动率每增加 1 点，期权会亏损 500 元。 Vega 值如果为 +5.0，则表示波动率每增加 1 点，期权会收益 500 元。 所以 Vega 代表的是波动率变化后，期权价格的变化情况。 ThetaTheta 表示的是期权时间价值的减少。它是用负数来表示的，期权每过一天它的时间价值就会减少一些。 如果一个期权到期时间还很长，那么它的 Theta 值可能非常低。 例如：下图是 哔哩哔哩（BILI）在 3.20 的一份 7.17 到期的 22.5 PUT 合约，可以看到因为到期时间还有 4 个月，所以每天由于时间因素带来的影响只有 -0.014： 而与此对比，只有一周就到期的 3.27 Tesla PUT 的 Theta 则高达 -0.23： RhoRho 表示的是利率变化对于期权价格的影响。但是大部分活跃的期权交易因为到期时间都比较短（1-3个月），所以 Rho 的值都很小。 Gamma因为 Delta 和 Vaga 值会变化得非常快，不利于构建中性头寸，所以理论家们又引入了 Gamma。 Gamma 是衡量 Delta 变化快慢的指标。如果 Delta 和 Gamma 都是中性的，那么组合保持中性的概率就高了很多。 对于如何建立一个中性头寸组合，书中介绍了详细的方法，但估计一般人都应该用不到，我就不展开介绍了。 时间价值期权时间价值是指期权合约的购买者为购买期权而支付的权利金超过期权内在价值的那部分价值。期权购买者之所以愿意支付时间价值，是因为他预期随着时间的推移和市价的变动，期权的内在价值会增加。 期权的内在价值是通过对标的股票价格变化而变化的，如果股票没有超着预期的方向波动，那么期权的内在价值就不会增加，而随着时间流逝，期权的时间价值又会减少，期权的价值就会减少。 小结因为期权的影响因素很多，所以人们抽像出来 Delta, Vega, Theta 等指标来更好地理解它。 本系列文章汇总： 美股期权学习笔记（一） 美股期权学习笔记（二） 美股期权学习笔记（三） 美股期权学习笔记（四）","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"美股期权学习笔记（二）","slug":"option-learning-notes-1","date":"2020-03-15T14:41:43.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/03/15/option-learning-notes-1/","permalink":"https://blog.devtang.com/2020/03/15/option-learning-notes-1/","excerpt":"","text":"最近研读了《麦克米伦谈期权》，以下是一些总结。 什么是期权期权是以特定价格买入或者卖出特定证券的权利，该权利在特定时间内有效。 期权有几个关键的概念： 过期时间（expiration date），到了时间就过期。有期权的一方可以在到期前选择执行期权或放弃执行。 行权价（strike price），买卖双方按行权价执行。 权利金（premium），也就是期权的现金价值。期权的现金价值会随着时间以及股价波动。 类型。分为买入权利（CALL）和卖出权利（PUT）。CAll 又被称为看涨期权，PUT 被称为看跌期权。 标的。指目标期权。 期权在美股上按手交易，每手代表 100 份标的。据说历史上有人把 1 手当成 1 股，结果就是多买了 100 倍的期权。 行权时间美式期权和欧式期权不一样，美式期权可以在到期前的任意时间随时行权，欧式期权只能在到期时行权。美股上交易的股票期权都是美式期权。大部分的指数期权是欧式期权。 所以，对于美式期权，如果你通过卖 CALL 或者卖 PUT 做空一个期权，即使最终到了过期时间你的期权收益为正，但是有可能在中段波动的时候，你的期权在某一个时间点是亏损的，只要你的对手方提前行权了，你的这个亏损就被确定了。 我使用的期权软件背后的券商是盈透证券（IB）, 使用它提供的 TWS 软件，即可将自己的期权提前行权。 具体操作方式是在 TWS 中选择 “账户”-&gt;“期权行权”，然后操作相关的期权选择“提前行权”即可，如下图所示： 期权拥有方到期的默认操作期权拥有方按理说在到期时有行权和不行权的权利，那么如果不进行任何操作，默认的操作是行权还是不行权呢？美股的规则如下： 到期日，期权在价内 0.01 或以上的股票期权将被自动行权，但是当投资者的保证金不满足行权条件时则会按照市场价平仓。 到期日，价格已低于 0.01 且投资者不主动行权或者平仓。这时候期权会自动失效，您的损失为全部期权费；一般情况下，这时候如果主动行权损失会更多。 实值期权与虚值期权如果行权价低于股票的价格，则我们称这个期权是有实值的，是实值期权，反之则称为虚值期权。 虚值期权之所以有交易，是因为它们具有时间价值，随着时间的变化，股价也会变动，有可能当时还是虚值的期权，未来就是实值了。 如果到了期权的到期时间，期权还是一个虚值期权，则它的价值就会归为 0。比如一个以 30 元买入的看涨期权，如果到期时股票价格是 20 元，那么期权所有者肯定不会行权，因为行权的价格比从市场上直接买还贵，这个期权就相当于废纸。 盈亏曲线我们假设某家公司的股价是 50 元，然后可以画出不同期权的盈亏曲线。不得不说，画这些图还挺有意思的，笔者用 keynote 完成的所有图的绘制。 买入看涨期权买入行权价 52 元的看涨期权的价格是 2 元，则盈亏曲线如下： 从图中可以看出，期权到期时： 当股价低于 52 元时，损失为 200 元（1手期权的价格） 当股价等于 54 元时，刚好盈亏平衡 当股价高于 54 元时，有盈利 买入看涨期权，最大损失为 200 元，最大盈利无上限 卖出看涨期权卖出看涨期权的盈亏曲线和买入的刚好上下对称，因为两者互为对手盘。你盈多少，对手就亏多少，所以盈亏曲线如下： 从图中可以看出，期权到期时： 当股价低于 52 元时，盈利为 200 元（1手期权的价格） 当股价等于 54 元时，刚好盈亏平衡 当股价高于 54 元时，有亏损 卖出看涨期权，最大收益为 200 元，最大亏损无上限 买入看空期权如果我们买入一个 48 元的期权，期权价格是 2 元，则盈亏曲线如下： 从图中可以看出，期权到期时： 当股价高于 48 元，则亏损为 200 元（1手期权的价格） 当股价等于 46 元，刚好盈亏平衡 当股价低于 46 元，则有盈利。理论上，最高盈利是 4600 元，对应股价是 0 元。 卖出看空期权同样，卖出看跌期权的盈亏曲线和买入的刚好上下对称，因为两者互为对手盘。盈亏曲线如下： 从图中可以看出，期权到期时： 当股价高于 48 元，则盈利为 200 元（1手期权的价格） 当股价等于 46 元，刚好盈亏平衡 当股价低于 46 元，则有亏损。理论上，最高亏损是 4600 元，对应股价是 0 元。 保证金当你买 CALL 或者买 PUT ，你付出的就是权利金，损失是有限的，最坏情况下就是期权价值变为 0，损失掉所有的权利金。但是你的理论收益是无穷的。 当你卖 CALL 或者卖 PUT，你就会收到权利金，但是你的收益上限就是权利金。当你的对手方行权的时候，你需要执行相应的义务： 对于 CALL 期权，你需要按指定价格卖出标的股票 对于 PUT 期权，你需要按指定价格买入标的股票 为了保证你有行使这个义务的能力，你需要在帐户中保留足够的保证金。保证金的计算规则比较复杂，与你的期权仓位占比以及期权集中性都有关系，在盈透证券的帮助页面上有详细的介绍。 如果你的证券价值和现金加起来的保证金不足，则系统会随机平仓你的一部分股票以维持保证金要求。 期权的组合（一）期权组合起来，可以构建一些特殊的盈利曲线。比如我们同时卖出看涨和看跌期权，就可以将以下两种曲线叠加。《麦克米伦谈期权》在 2.5.5 小结中介绍了这种被称为跨式期权的组合。 下图中的红色和蓝色分别为卖出看跌和卖出看涨的盈亏曲线，而黄色则表示叠加之后的组合盈亏曲线。 这个曲线很有意思，它表示不管股票是上涨还是下跌，只要股价到期时的波动范围在 44 ~ 52 元之间，这个组合就是盈利的。 想当然的，你可以构建一个波动范围极宽的跨式组合期权，虽然这种组合期权盈利不多，但是盈利的概率极大。历史上曾经这种策略很流行，但是市场总是会出现小概率事件，这种跨式期权收益有上限，但是亏损无限的特点，遇上一次极端事件就能让投资者破产。 期权的组合（二）相比刚刚介绍的那种组合，以下的期权组合更被做市商所采用，即：买入看涨期权 + 卖出看跌期权。 你看完下图就能明白这个组合的有趣之处了： 这种组合的收益曲线和直接买入股票是完全一样的。但是在这种组合下，你所需要的资金只是买入股票的一部分，所以你可以以更小的资金成本，达到同样的收益曲线。 实际当中，这种策略与买入股票并不是完全一样收益，因为股票还会涉及分红，而持有期权是没有分红权的。另外则是交易费率和交易次数的差异。 组合套利因为买卖价差的原因，有些时候做市商会通过组合，构建一个收益为正，但是风险为零的套利。 刚刚说到期权的组合（二）就是一种持有股票的策略，如果我们用期权组合（二）再加上卖空股票，就构建出一种组合。由于买卖价差的原因，这种组合虽然相当于什么都没干，但是却会有收益。 以下我就以一个实际的案例进行说明。我们拿好未来在美股的真实股价与期权价举例。 好未来在 3 月 6 日的收盘价格是 56.49，同时 4.17 到期的 50 元看涨期权挂单价格是 7.8(买) ~ 9.8（卖），最近成交价是 7.62 4.17 到期的 50 元看跌期权挂单价格是 1.45（买）~ 1.95（卖），最近成交价是 1.69 我们假设，我们在 3.6 收盘前，以： 以 56.49 的价格卖空 100 股股票 以 7.62 的成交价买入 1 手看涨期权 以 1.69 的成交价卖出 1 手看跌期权 那我们的收益应该是多少呢？为了计算收益，我们需要搬出初中学习的二元一次方程。如果你不想跟着我计算，可以直接看最后的结论。 计算卖空的收益函数假设未来股价为 x，则卖空 100 股股票的收益函数 y1 为： y1 = (56.49 - x) * 100 = (50 - x) * 100 + 6.49 * 100 = (50 - x) * 100 + 649 应该很简单对吧？因为是做空，x 越大，则 y1 越小。 计算买入看涨期权的收益函数假设未来股价为 x，则期权到期时收益函数 y2 为： x &lt; 50 时： y2 = -7.62 * 100 = -762x &gt;= 50 时： y2 = (x - 50) * 100 - 762 能看懂吧？因为期权行权价是 50，所以股价少于 50 则期权就作废了，损失为 762 元的权利金。如果股价高于 50，则可以按上面的公式来计算盈亏。 计算卖出看跌期权的收益函数假设未来股价为 x，则期权到期时收益函数 y3 为： x &lt; 50 时： y3 = (x - 50) * 100 + 169x &gt;= 50 时： y3 = 1.69 * 100 = 169 因为我们是卖出看跌，所以如果股价高于 50，我们的收益就是 169 的权利金，否则我们就需要按上面的公式计算收益。 求和我们将 y1, y2, y3 进行求和 x &lt; 50时： y1 = (50 - x) * 100 + 649 y2 = -762 y3 = (x - 50) * 100 + 169 求和： y = y1 + y2 + y3 = (50 - x) * 100 + 649 -762 + (x - 50) * 100 + 169 = 649 - 762 + 169 = 56y &gt;= 50时： y1 = (50 - x) * 100 + 649 y2 = (x - 50) * 100 - 762 y3 = 169 求和： y = y1 + y2 + y3 = (50 - x) * 100 + 649 + (x - 50) * 100 - 762 + 169 = 649 - 762 + 169 = 56 最后，我们发现，x 不管是大于 50 还是小于 50，情况都一样，y = 56。 你看，如果你当时按市场价同时完成了这 3 笔交易，你就构建了一个套利。这也是做市商的生意模式。 这种组合在《麦克米伦谈期权》的 6.2 章节中被称作 Delta 中性头寸。 小结 期权是以特定价格买入或者卖出特定证券的权利，该权利在特定时间内有效。 美式期权是可以提前行权的。 卖出期权收到权利金，但是需要帐户中留有足够执行期权义务的保证金。 期权的组合可以用来构建各种特殊的盈利曲线。 如果一个组合与标的股价无关，我们就说这个组合是 Delta 中性的。它可以用来做无风险套利。 本系列文章汇总： 美股期权学习笔记（一） 美股期权学习笔记（二） 美股期权学习笔记（三） 美股期权学习笔记（四）","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"写给 iOS 的机器学习入门","slug":"machine-learning-for-ios","date":"2020-02-26T13:52:24.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2020/02/26/machine-learning-for-ios/","permalink":"https://blog.devtang.com/2020/02/26/machine-learning-for-ios/","excerpt":"","text":"最近买了 Ray Wenderlish 上面的 《Machine Learning by Tutorials》一书看了看，对机器学习有了进一步的理解。 这本书前面几章特别适合 iOS 背景的同学，因为相关的实践都是直接在 Xcode 环境下做的。 以下是我的一些小结。 机器学习基础概念首先我们需要理解一些非常基础的概念。 深度学习虽然严格意义上的机器学习定义范围很广，但是这本书讲的其实是指深度学习（Deep Learning），这也是当前最火的机器学习研究领域。 深度学习其实是一项相对有些年头的研究成果了，它之所以最近 5 年才这么火，主要是因为人们发现了可以用 GPU 来加速其计算过程。原本需要算几年才能训练出来的模型，现在在 GPU 的帮助下可以在几天训练出来了。 这样，一项原本理论上完美但是实际上困难的技术终于落地了。Google 旗下的 DeepMind 研究出来的围棋 AI Alpha Zero，就是在 40 天的训练后，超过了世界围棋冠军以及它的前辈们。 深度学习之所以名字中带深度，是因为它的模型是分层的，这一层一层的模型与人类的大脑皮层类似，我们把它叫做神经网络（Neural Network）。 模型模型代表的是训练（Training）出来的神经网络，训练的方式有三种： 监督学习（supervised learning）。在训练的时候告诉模型什么是对的，什么是错的，让模型学习。 非监督学习（unsupervised learning）。主要是通过 k-means 之类的算法，让模型自己从数据中找规律。 强化学习（reinforcement learning）。设立一些简单的规则，让模型通过正向奖励和负向惩罚来训练。 模型在训练的时候会抽取特征（feature），比如一个预测房价的模型，那么它的 feature 可能有房间数，面积，楼层，位置，朝向等。 大多数情况下，为了让模型训练出好的能力，都需要进行大量的训练。而很多大量的训练数据，都是通用人工标注来完成的。小猿搜题的拍照搜题算法就是基于深度学习的，为此我们长年维持着一个上百人的标注团队，用于提升模型的准确度。所以我们的同事戏称： 人工智能是有多少人工就有多少智能。 这也是我去年为什么重仓 Tesla 的原因，在相关法律法规还不完善的情况下，特斯拉的自动驾驶算法已经靠它全球几十万辆车收集了海量的数据。有一些甚至是自动驾驶算法的事故数据，而这些海量数据是自动驾驶技术的核心优势。除了 Google，没有第二家有这么海量的数据，特斯拉的自动驾驶算法就值 300 亿美金。 神经网络的工作原理这本书用了一种很简单的方式解释了神经网络的工作原理。 我们首先定义任务：设计一个神经网络，从一堆图片中区分出猫和狗的图片。 其实任何数据，我们都可以把它看作一段输入的序列。比如一张图片，我们可以看成图片的点的序列，每个点我们又可以看成一个 RGB 值的序列，这样我们就可以把一张图片，变成一个序列。 假设所有图片长宽是 NxN 的，那么它就包含 NxN 个点，每个点有 R,G,B 三个值，这样就是 3xNxN 个值。我们知道，在二维的平面，所有点都是 [x,y] 两个值的。在三维空间，所有点都是 [x,y,z] 三个值的。所以我们当前任务的图片，如果长宽都一样，那么就都是 3xNxN 维空间上的一个点。 这一堆图片，其实就是 3xNxN 维空间上的一堆点。 而神经网络的任务，就是在这个空间中，找出一种方式，把这些点分成两堆，其中一堆全是猫，另一堆全是狗。 为了更形象地举例，书中拿 3 维空间举例，神经网络的任务就是找出一个平面，把下面的点分成两堆。 但是，很多时候，这些点明显不是像上面这样排列的，它们很可能混淆在一起，像下面这样： 所以，你需要进行变换，把这些点通过一些变换，映射到另一些点上面，我们希望通过这些变换，最终可以找到一个平面，把这些点很方便地分割开。拿图中的例子来说，如果你可以变换成下面这样，我想你用肉眼就可以找到分割方式了。 神经网络的厉害之处在于，它会自动进行这种变换尝试，最终找到一种尽可能好的变换，这也就是训练模型的过程。而最常见的变换方式就是卷积（convolutions）。 卷积神经网络（CNN）也是现在最常见的处理图像类的深度学习模型。卷积运算被大量用在图像显示处理中，这也是为什么深度学习更适合使用 GPU 而不是 CPU 的原因。 CNN 和 RNN卷积神经网络（CNN） 和 （循环神经网络）RNN 是当前最常见的两种神经网络。 CNN 通过卷积来完成神经网络的变换，通常情况下适用于图像一类的场景，比如人脸识别。CNN 通过卷积，将图像的特征一步步地提取，从最初的像素点，慢慢变成边，再慢慢提取出小的部件，最终能够识别出复杂的东西。比如下图就是 CNN 人脸识别的过程（来自参考资料2）： CNN 通常要求输入数据是相同规格的，刚刚我们提到那个识别小猫小狗的问题，其实用 CNN 的话，首先需要做的就是把图片缩放成一样的尺寸。但是有些时候，我们并不能很方便地做这种事情。 例如：我们要用 CNN 做一个语言翻译模型。我们不可能让所有的语言输入的时候长度都是一样的。这个时候，RNN 的优势就体现了。RNN 更注意关注输入数据的连续性，并且每次运算的时候，可以反复地把当前层的输出又当作输入进行运算。 拿数据结构来说，CNN 应该是一个有向无环图，而 RNN 是一个有向有环图。 如何理解卷积卷积如果上数学描述来解释，容易让人晕。我打一个比方吧： 卷积就是拿一个矩阵，我们可以把它想像成一个盖子，这个盖子在目标图形上不停地移动。每次移动的时候，这个矩阵就和目标图形上被“盖住”的区域做一个操作，这个操作形成一个新的数字，填到新的图形中。 具体的操作方式是：将这个矩阵和被盖住的矩阵对应位置做乘积，然后求和。下面是一个示意图（来自参考资料1）： 卷积的公式选择得好，就有助于提取图像中关键的信息，下面是一个示意，可以看到花瓣通过卷积，在目标图形上得到明显地体现，而其它信息被抹去了。（来自参考资料1）。 使用 Create ML 来训练数据我们可以使用 Xcode 自带的 Create ML 来训练一些基础的深度学习模型，然后应用到我们的 App 上。苹果系统自带的 Core ML 和 Metal 可以很方便地在底层提供这些支持。下面是一个例子。 从 Xcode 的菜单 Xcode -&gt; Open Developer Tool -&gt; Create ML 可以打开 Create ML 工具。 然后，新建一个图像分类的模型，然后选择 Input，将需要训练的图片导入进入。每一种类型的图片需要放在同一个目录。导入之后可以看到 Create ML 识别出图像的种类数（class）。点击工具栏上的训练按钮即可开始训练。 训练结束后，可以看到 准确率（precision）和 召回率（recall）。 直接拖动 output 中的那个文件到 Finder 中，即可将训练好的模型导出。 在代码中应用训练好的模型也非常方便，将模型文件拖入到 Xcode 工程中，就可以看到这个模型对应的类名和方法定义了。可以直接在 Xcode 中初始化这个模型，然后调用其 prediction 方法进行图像的分类。 小结 深度学习其实是利用神经网络的变换，来对训练数据进行学习的技术。 大部分的深度学习案例都需要大量的标注数据。 卷积神经网络（CNN）和（循环神经网络）RNN 是当前最常见的两种神经网络。 CNN 常用于图像处理，RNN 常用于语音识别和翻译。 Xcode 的 Create ML 可以进行一些简单的模型训练工作。 参考资料 秒懂各种深度学习卷积神经网络操作 DNN、RNN、CNN.一文带你读懂这些绕晕人的名词","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"App 换肤功能的思考","slug":"talk-about-theme-changing-feature","date":"2020-02-26T02:17:37.000Z","updated":"2024-01-06T14:52:37.937Z","comments":true,"path":"2020/02/26/talk-about-theme-changing-feature/","permalink":"https://blog.devtang.com/2020/02/26/talk-about-theme-changing-feature/","excerpt":"","text":"序言我们发现市面上的 App，有一些做了换肤功能，比如网易云音乐，而大部分 App 没有做换肤功能。那么： 什么样的 App 适合做换肤功能，什么样的 App 不适合做换肤功能？ 最近我找一些同行交流了一下，做了一些小结，分享给大家。 定义我们在讨论的时候，常常把为运营活动提供的换肤和为用户提供的换肤混为一谈，因为毕竟它们最终都是达成了用户界面外观的更换。 在讨论的时候，我发现大家对于为运营活动提供的换肤功能都持正面态度，因为： 这种功能并不增加 App 可见的换肤入口，运营同事是通过企业后台的 CRM 系统来配置相应活动的皮肤。 运营活动需要新鲜的活动界面来刺激用户感兴趣，而一个视觉上的界面变化就是最直接的刺激。 运营活动的换肤功能通常涉及的界面相对小，不会影响整个 App 的视觉体验。 所以，我们下面就只讨论为 C 端用户提供的，可供用户主动挑选和设置的换肤功能。 用户需求我们可以先从用户需求角度来看换肤功能解决的问题。 用户换肤的需求我觉得来自两个角度： 社交角度 情感和审美角度 其实还有一个特殊的场景角度：夜间模式。这个比较特殊，我们放到最后讨论。 社交角度在社交角度，换肤代表着 TA 的个性化表达，用户希望界面能够传达出一种自己的个性或审美。这种需求多涉及个人展示的地方，比如社交头像、个人主页、个人博客等。 本质上，这是一种偏社交属性的需求，用户是希望让其它人看到才用换肤。 案例包括：微信的聊天背景，QQ 空间，bilibili 的个性挂件，王者荣耀的英雄皮肤等。 情感和审美角度情感和审美角度是内在的，即有一些别人看不见的界面，用户基于内在的情感表达或者对于审美有新鲜感的需求来使用换肤功能。比如： 用户喜欢某个人，就可能拿这个人的照片当自己某些界面的背景。 用户觉得 Mac 桌面太单调了，就会时不时换一张。 当然，也有时候是原来的界面用户不喜欢，希望自己定制。 案例包括：网易云音乐、QQ 浏览器、Chrome、手机锁屏界面、系统界面等。 成本角度换肤的成本可以从以下几个角度评估： 研发实施成本。换肤看功能的强弱程度，可能涉及比较多的界面，这种情况下，在未来调整功能的时候，不同皮肤下功能是否正常或许都是需要测试来覆盖的。研发也需要调整架构，以支持换肤。整体这方面的难度算中低吧，基本上都能搞定。兼容性需要未来持续投入时间成本来测试，但也算是一个低程度的成本。 功能复杂性成本。产品的功能都需要占据用户界面，多了一个功能，对于那些不喜欢用的用户来说，就是成本。因为占据了他们的注意力精力，特别是他们看到了这个功能之后不用。这也是为什么一个不好的功能不是零分，是负分。就这个功能来说，可以通过上线之后用户使用率&#x2F;留存率来评估，如果用户使用率低于 1%，留存率低于 20% 那么可能需要思考这个功能是否还有必要为了少数人保留。 产品焦点缺失。换肤可能会影响用户对于产品功能的焦点或核心功能的体验。一个朋友提到微博当年不做皮肤，也是觉得微博产品的核心是内容，不希望界面抢内容的焦点。 个人觉得研发成本和功能复杂性都可以几乎忽视，最影响的还是产品焦点，一个产品的核心功能或体验如果被界面干扰，反倒是不好的。我们看到苹果的界面风格越来越简洁，越来越凸显内容，也是为了聚焦核心体验。 夜间模式夜间模式需要单独拿出来说，因为它还是比较特别。本质上他和前面的都不一样，满足的是用户在特定场景下使用 App 的体验问题。比如猿题库的夜间模式，是为了保证孩子在被窝里面刷题的体验。 做不做这个功能，要看用户在这个场景下的使用频率。常见的新闻客户端、阅读软件都有夜间模式，比如网易新闻、多看阅读。 夜间模式对整体的界面设计改动比较大，开发成本会稍大一些。但是如果需求成立，那么就不存在产品焦点缺失这些担心。 小结小结一下： 运营角度的换肤是成立的，并且是好的。可以为特定节点的活动增加整体的视觉效果，提升运营效率。 用户定制的换肤，有一类偏社交的，这一类的换肤能让其他人看到，如微信的聊天背景，bilibili的个性挂件。 用户定制的换肤，有一类是满足用户情感和审美需求的，比如网易云音乐。 换肤的成本包括：产品研发（偏小），功能复杂性（偏中），产品焦点影响（偏大）。","categories":[],"tags":[{"name":"PM","slug":"PM","permalink":"https://blog.devtang.com/tags/PM/"}]},{"title":"用 Travis 来自动更新博客","slug":"update-blog-with-travis","date":"2020-02-08T17:43:45.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2020/02/09/update-blog-with-travis/","permalink":"https://blog.devtang.com/2020/02/09/update-blog-with-travis/","excerpt":"","text":"Travis 是一个自动化集成测试工具，原本的用处主要是在提交代码之后进行自动化的编译和测试。但是其实你不光可以拿它来编译代码，还可以做任何你需要执行代码做的事情，就比如更新博客文章。 如果你的博客像我一样使用 Hexo &#x2F; Jekyll &#x2F; Octopress 等工具生成静态文件，并且发布在 GitHub Pages 上，那么你可以使用 Travis 来自动帮助你发布博客文章。 整个发布的流程如下图所示（图片来自这里），你只需要将本地的文章 PUSH 到 GitHub，GitHub 的 Web Hook 会通知到 Travis，之后 Travis 就会自动地从你的项目中获得博客文件，然后执行 Build 操作生成静态文件，然后再 PUSH 回你的博客仓库。 当然，为了做到这些自动化，你需要一点时间进行 Travis 和 项目的设置，以下是详细的设置说明。 授权 Travis 去 Travis 授权访问你的 Github。如果你的博客是开源的，那么你可以免费使用 Travis。 去 Github 的应用管理界面 设置 Travis 的访问权限。 去 Github 的 Token 管理界面，点击 Generate new token 按钮，生成一个 OAuth Token，权限可以都勾上。但是要注意，不要把这个 Token 的内容直接放到博客文件中。 去 Travis 页面，进入到你博客项目的设置里，在 Environment Variables 下，增加一个名为 GITHUB_TOKEN 的环境变量，值为你刚刚生成的 OAuth Token 值。为了方便调试，建议你勾选上 DISPLAY VALUE IN BUILD LOG。如下图所示： 修改项目修改依赖为 submodule将你依赖的主题，以 submodule 的方式添加到项目中，这样 Travis 会在 clone 你的主项目的时候，自动把 submodule 也 clone 下来。注意，因为 Travis 并不拥有你的 SSH 私钥，所以你需要用 https 的方式来下载代码。代码如下： git submodule add -f https://github.com/tangqiaoboy/jacman.gitthemes/jacman 请将上面的代码稍作修改，把主题换成你使用的主题项目地址。 创建 .travis.yml 文件接着，在项目中创建一个 .travis.yml 的文件，内容如下： sudo: falselanguage: node_jsnode_js: - 10 # use nodejs v10 LTScache: npmbranches: only: - source # build source branch onlygit: depth: 1 submodules: trueenv: global: - GITHUB_TOKEN: &quot;$&#123;GITHUB_TOKEN&#125;&quot;before_install: - npm install -g hexo-cliinstall: - npm installscript: - # echo &quot;$GITHUB_TOKEN&quot; # 调试用 - hexo generateafter_success: - git config --global user.name &#x27;Tang Qiao&#x27; # 结合自己的情况修改 - git config --global user.email &#x27;tangqiaoboy@gmail.com&#x27; # 结合自己的情况修改 - sed -in-place -e &quot;s/git@/https:\\/\\/$&#123;GITHUB_TOKEN&#125;@/&quot; _config.yml # 结合自己的情况修改 - sed -in-place -e &quot;s/github.com:tangqiaoboy/github.com\\/tangqiaoboy/&quot; _config.yml # 结合自己的情况修改 - # cat _config.yml # 调试用 - hexo deploy 上面的文件针对的是我个人的博客，请你对上面的文件进行适当修改，将博客地址替换成你自己的。 修改 _config.yml在 _config.yml 中增加 deploy 相关设置： deploy: type: git message: &quot;Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm&#x27;) &#125;&#125;&quot; repo: github: git@github.com:tangqiaoboy/tangqiaoboy.github.com.git branch: master 原理完成了以上设置之后，每次你有 push 文件源文的时候，Travis 就会自动帮你 build 代码，生成博客文件，并且发布到 GitHub Pages 上。 以上这些修改主要起的作用是：通过在 .travis.yml 中调用 sed，修改 _config.yml 文件中的 repo 地址，将自己之前申请的 GITHUB_TOKEN 给替换上去，最后用它完成鉴权，把文章上传到你自己的仓库中。 如果你的博客是基于 Jekyll 的，那么可以在 这里 获得官方的发布教程。 参考链接 https://maologue.com/Auto-deploy-Hexo-with-Travis-CI/ https://hexo.io/docs/github-pages https://gist.github.com/rokibhasansagar/b92dc248a6e88e0d9403e45499002165","categories":[],"tags":[]},{"title":"美股期权学习笔记（一）","slug":"option-learning-note","date":"2020-02-08T13:51:06.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2020/02/08/option-learning-note/","permalink":"https://blog.devtang.com/2020/02/08/option-learning-note/","excerpt":"","text":"最近学习了一下美股的股票期权交易，以下是一些笔记分享给大家。 期权是什么期权（Option）是一种权力，持有期权的人可以在未来的某个时间，以期权约定的价格，来买入或者卖出相应的股票。 这种权力在美股市场上是可以交易的，交易该权利的价格被称作权利金（premium）。 期权的分类美股期权分成看涨期权（CALL）和看跌期权（PUT)。 相应的，你可以直接买入（或卖空）这两种期权，所以一共有 4 种操作： 买入看涨期权（Long Call） 卖空看涨期权（Sell Call） 买入看跌期权（Long Put） 卖空看跌期权（Sell Put） 我说卖空而不是卖出，是指你不必手中真的有相应期权再卖，你可以直接卖出，就像做空股票一样。 和做空股票不一样的是，期权因为有过期时间（expiration date），所以到了那个时候，如果你的做空没有平仓，你就需要执行相应的期权义务： 如果你是卖空看涨期权（Sell Call），那你需要按指定价格卖出相应的股票。如果你手里没有，你需要自己先买入，再按指定价格卖给别人。 如果你是卖空看跌期权（Sell Put），那你需要按指定价格买入相应的股票。你需要帐户里留足相应的买入保证金，否则可能被强行平仓。 期权有几个关键的概念： 过期时间（expiration date），到了时间就过期。有期权的一方可以在到期时选择执行期权或放弃执行。 行权价（strike price），买卖双方按行权价执行。 权利金（premium），也就是期权的现金价值。期权的现金价值会随着时间以及股价波动。 期权按行权价分类我们把行权价（strike price）与当前股票的价格（stock price）相比较的，会出现两种情况，分别是比当前股票价高（Covered） 和 比当前股票价格低（Naked）。所以，不同行权价的期权又可以分为 8 种： Long Covered Call。买入看涨期权，并且 strike price &gt; stock price。 Long Naked Call。买入看涨期权，并且 strike price &lt; stock price。 Sell Covered Call。卖出看涨期权，并且 strike price &gt; stock price。 Sell Naked Call。卖出看涨期权，并且 strike price &lt; stock price。 Long Covered Put。买入看跌期权，并且 strike price &gt; stock price。 Long Naked Put。买入看跌期权，并且 strike price &lt; stock price。 Sell Covered Put。卖出看跌期权，并且 strike price &gt; stock price。 Sell Naked Put。卖出看跌期权，并且 strike price &lt; stock price。 之所以这么分类，是因为 strike price 的价格是高（Covered）还是低（Naked）背后所代表的意义差别非常大。 Long Naked Call下面我们拿 Long Naked Call （买入看涨期权，并且 strike price &lt; stock price） 来举例，我认为 Long Naked Call 其实相当于加了一个额外的杠杆来买股票。 比如，有个股票当价价格是 100 元，你买入了一个行权价为 50 元的看涨期权，因为 strike price &#x3D; 50，而 stock price &#x3D; 100，所以 strike price &lt; stock price，这就是一个 Long Naked Call。因为这个期权的行权价比股票低了 50 元，所以这个期权的权利金（premium）不会便宜，肯定是 50 元以上。因为如果权利金低于 50，那么你的行权成本（ strike price + premium &lt; stock price），这样的亏本生意，不会有人愿意和你对手交易。要有人愿意和你对手交易，必定权利金高于 50 元。 我们假设权利金是 60 元。这样，你买入这个期权的成本是 60 元，在这种情况下： 如果这个股票涨 50% 到 150 元，则你的收益就是 40元，收益率为 40&#x2F;60 &#x3D; +67% 如果这个股票跌 50% 到 50 元，则你的收益就是 -60 元，收益率为 -60&#x2F;60 &#x3D; -100% 而如果你的钱不是买期权，而是买股票的话： 如果这个股票涨 50% 到 150 元，则你的收益就是 50元，收益率为 50&#x2F;100 &#x3D; +50% 如果这个股票跌 50% 到 50 元，则你的收益就是 -50 元，收益率为 -50&#x2F;100 &#x3D; -50% 你看，相比于直接买股票，你的收益率几乎相当于乘了一个两倍的杠杆。但是这又不完全是一个两倍杠杆。因为你的权利金带有时间价值（time value），所以你额外付出了一部分成本在这里面。 Long Covered CallLong Covered Call 背后的意义又很不一样。 比如一个股票价格 100 元，你买入一个 strike price &#x3D; 110 的期权，这个时候因为 strike price &gt; stock price，所以这就是一个 Long Covered Call。这个期权的权利金（premium）不会像刚刚的例子那样那么高，我们假设它的价格是 10 元。 好，假设你以 10 元的价格，买入了这个期权： 如果这个股票涨 50% 到 150 元，因为 strike price + premium 会大于 stock price，而 strike price 是固定的 110 元，所以 premium 至少会上涨到 40 元以上，收益率为 (150-110-10)&#x2F;10 &#x3D; +300% 如果这个股票涨 20% 到 120 元，则你的收益是 （120-110-10)&#x2F;10 &#x3D; 0% 如果这个股票涨 10% 到 110 元，则你的收益是 （110-110-10)&#x2F;10 &#x3D; -100% 事实上，因为你的行权价是 110，只要股票没有上涨超过 10%，你的收益率都是 -100%。 你看，Long Covered Call 和 Long Naked Call 的杠杆率差别非常大。 期权的对冲属性期权更多时候，是给专业的机构投资者做为对冲工具，来构建一个安全的投资组合的。 比如一个做空机构，为了防止做空的股票持续上涨，控制风险，那么它就可以 Long Covered Call。这样如果股票持续上涨，那 Long Covered Call 的收益就可以对冲掉做空的损失。 如果你持有一个公司的股票，最近公司出了一些短期风险，你觉得短期有下跌风险，你就可以 Long Naked Put，这样股票下跌了，期权收益可以对冲掉股票下降的损失。 你看，买 Call 可以为做空者锁定损失，买 Put 可以为持有者锁定收益。所以，你可以把权利金看成一种保险，而我在查词典的时候，权利金 premium 就有保险的意思。 价值投资者可以用期权做什么在我查阅一些资料的时候，我发现很多人都只推荐卖期权，而不是买期权。因为虽然买期权亏损有上限，收益无上限，但是买期权额外付出的因为时间价值而不菲的权利金很难保证收益。当然，这些话应该不是说给投机者说的。 那我们什么时候可以使用卖期权这种操作呢？ 1、抄底增持的情况。当你想增持某个股票，但希望股价再跌10%的时候买，可以使用 Sell Naked Put，strike price 设置成股价的 90%。未来如果股票上涨，那么这些 Put 全部失效，等于你白收一笔权利金（premium）。如果接着下跌，期权行权，你就可以以目标价完成建仓，同时权利金（premium）可视为折扣价（等于以预期价位的 95 折完成建仓，一样很划算），因此 Sell Naked Put 也成为价值投资者建仓的利器。巴菲特很推崇这个方法。 2、卖出的情况。当你想股票再涨 10% 的时候就卖出某个股票时，可以使用 Sell Covered Call，strike price 设置成股价的 110% 。如果股票没有涨到目标价，你就白收了一笔权利金（premium）。如果股票价格上涨到了目标价，你就按照目标价完成了股票的卖出，而且还多收了一笔权利金。 这两种操作都使得买入和卖出股票的收益更加确定了。但是有没有坏处呢？坏处就是遇到股票暴涨或者暴跌的时候，因为 Sell Put 和 Sell Call，我们的收益都会限制在了 strike price 上，无法获得更多收益了。 小结 期权是一种股票的衍生交易形式，分成看涨期权（CALL）和看跌期权（PUT)，可以分别做多或做空。 期权虽然被一部分人当作加杠杆的投机工具，但它更多的用处是为机构提供风险对冲。 对于价值投资者，可以利用 Sell Naked Put 来增持股票，用 Sell Covered Call 来卖出股票。 本系列文章汇总： 美股期权学习笔记（一） 美股期权学习笔记（二） 美股期权学习笔记（三） 美股期权学习笔记（四）","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"俞军产品方法论","slug":"pm-work-from-yujun","date":"2020-02-03T14:07:35.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2020/02/03/pm-work-from-yujun/","permalink":"https://blog.devtang.com/2020/02/03/pm-work-from-yujun/","excerpt":"","text":"​今天读完了《俞军产品方法论》，俞军是互联网时代的前辈和开创者，负责过百度和滴滴两个上百亿美金产品的开创性工作。 他 2001 年加入百度，也为互联网最早的产品经理，主导了百度早期每一个知名产品的产品经理工作。他为了梳理产品经理的方法论，在 2016 年加入滴滴，帮助滴滴搭建完一个产品团队的同时，也梳理了自己对产品经理的理解，最终这些理解成为了这本《俞军产品方法论》。 以下是我的一些小结。 一、用户模型和交易模型俞军将产品经理最重要的两个里程碑总结成理解「用户模型」和「交易模型」。 1、用户模型用户模型侧重于理解需求。俞军为了说明一个用户的需求具备多样性，于是将需求放在用户模型的首要位置。他举了很多例子，比如一个用户在意物流速度的时候，他会用京东；当他在意性价比的时候，他会用拼多多。所以这个用户即是京东的用户，又是拼多多的用户。又比如同样是微信的用户，一个只用聊天功能的用户，与一个同时用聊天、支付、朋友圈功能的用户，价值是不一样的。 在需求的纬度下，产品经理的工作就变成了如何满足用户的需求：即创造用户价值。俞军老师希望大家避免追求极致的需求而忘记了成本，于是在用户价值前面加了四个字：「有利可图」，即：创造有利可图的用户价值。 如何创造有利可图的用户价值呢？俞老师引用了诺贝尔经济学奖获得者萨缪尔森的幸福公式：幸福&#x3D;效用&#x2F;欲望。在顺便提到人的欲望是无穷的之后，则引出了他多次对外宣讲的公式： 用户价值=新体验-旧体验-替换成本 俞老师用了这个例子来理解该公式：产品增长期，一个全新用户因为没有体验过别的竞品，他的「旧体验」就是零。这个时候用户价值就比他体验过竞品的时候大，所以获客就容易。 我认为在实践中，大部分时候该公式的价值是将用户的迁移成本显式地展示出来了。这个时候做任何功能，都需要对用户习惯进行评估。 2、交易模型任何企业最终都是需要利润存活的，而交易模型就是关注用户在产品体验中产生的金钱与价值的交换。所有的成功的互联网产品，背后的交易模型都是非常健康的。产品经理在满足用户需求的同时，也需要关注自己的商业价值能否以合理的方式体现出来，否则长远来看就会陷入麻烦之中，Keep 就是一个例子。 窃以为，把「用户模型」叫做「需求模型」，把「交易模型」叫做「商业模型」更易于理解一些。 二、组织文化组织文化由什么决定？俞军老师引用了罗宾斯的《组织行为学》一书，书中提到决定组织文化的是三点： 创始人的人格特征 高级管理者的真实行为 日常的制度，文化价值观宣传 看到这儿，我就明白为什么我们公司没有什么文化价值观输出了，因为我们公司的文化价值观都一直在通过创始人和高级管理者的行为在输出。相比而言，某些公司天天组织学习和强调文化价值观的活动，其效果其实是大打折扣的。 三、职场菜鸟的战略是什么俞军老师在书中介绍了一个能力弱的产品经理应该怎么找好工作。这个回答非常有借鉴意义，大家也可以类似推导出一个能力弱的程序员应该怎么找好工作。 我之前一直觉得，能力弱的程序员就应该努力学习，就应该转行。看了俞军老师的回答，我感觉自己的思考还是不够深刻。好的战略还是应该好落地实施，「努力学习」虽然大多数时候都是有用的，但是却忽略了对方的学习能力。如果这个人学习能力很差，那么努力学习可能还是没法帮助他获得好工作，反倒会让他怀疑自己，自我否定。而转行这个建议就更离谱了，转行意味着放弃之前的积累，在新的职业环境中又有多大的胜算呢？ 所以，我们来看看俞军老师怎么给一个能力弱的产品经理规划工作的： 1、借势。找大公司的新产品，这个新产品是衍生类产品，不用愁流量。 2、借运。找新团队快速增长的早期加入。 3、不可评价。找一两年内很难验证结果的高大上的 PPT 产品。或者找没有对比的产品。 4、倚人。找能力弱的上司。 你看，一个产品经理即便水平一般，他还是有一些出人头地的机会。虽然很多策略价值观不太对，但是对个体而言，确实比转行可能更具实操性。 所以，大家觉得 iOS 菜鸟应该怎么找好工作？借势、借运、不可评价、倚人这些招，应该都是可以套用的。 四、小结俞军的这本书，观点特别多，每一个点都值得深挖。不好的地方就是不够系统，有点散，可能因为该书大部分内容来自他平时的语录整理。 Anyway，这还是一本没有什么口水的书，全书总结多信息量大，句句都透着俞军的思考，推荐大家阅读。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"关注估值和品质 - 读《投资中最简单的事》","slug":"simple-investment-book-summary","date":"2020-01-27T14:12:41.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2020/01/27/simple-investment-book-summary/","permalink":"https://blog.devtang.com/2020/01/27/simple-investment-book-summary/","excerpt":"","text":"序言最近冠状病毒流行，在家无事看完了《投资中最简单的事》。该书作者是邱国鹫，高毅资产CEO，曾是60亿美元私募基金合伙人。这本书是他总结的投资经验。 我从他的书中学到了一些基础的投资方法，比如：逆向投资，评估公司的估值，品质的常见方法。另外他提出的“投资方法的有效性悖论”也让我耳目一新。 以下是一些小结。 逆向投资股票的价格是通过交易确定的。一只股票好，大家都喜欢，那就会通过交易抬高股票的价格。即便这只股票确实就是真的很好，过高的股价带来的下跌风险，收益率降低，高市盈率都使得这个股票不那么好了。 所以，如果追随大盘和主流，是很难获得超额收益的。要获得超额收益，就需要逆向投资。在大家都看衰的时候买入，在大家都看好的时候卖出。 邱国鹫在书中介绍了逆向投资的一些要点： 估值需要足够低，低到已经过度反映了各种可能的坏消息。 看遇到的问题是不是短期的，是否是可以解决的。 看估值的下降会不会造成公司局面进一步恶化。 警惕快速变化的行业。因为这些行业可能被颠覆。 价格便宜桥水公司的创始人达瑞欧有发布一个视频，叫《30分钟看懂经济机器的运行规律》，我最近又看了一遍。这个视频介绍了一个很重要的概念就是周期，因为借贷产生了短期和长期的债务周期。而借贷背后，是人们对于经济的乐观&#x2F;悲观情绪的过度反应。 而股票的价格也是这样，不管多好或者多差的股票，总会经历价格被高估或者低估的时候。 所以邱国鹫认为，买股票便宜才是硬道理。因为： 股票的回报并不取决于它的未来增长快还是慢，而是取决于未来增长比当前股价反应的增长预期更快还是更慢。这里有股价是否已经反映了所有好消息或者坏消息的问题。 估值、品质、时机他认为买一家公司股票需要回答3个问题： 估值。为什么认为这家公司便宜。 品质。为什么认为这家公司好。 时机。为什么要现在买。 于是对不同的行业，他建议用波特五力，杜邦分析，估值分析等简单工具，弄清楚行业的决定竞争胜负的关键因素是什么。 邱国鹫还总结了一个技巧，即让大家填空，对于一个行业，得______得天下。这样可以快速用一个词概括这个行业竞争的是什么。 例如： 基金业是得人才者得天下 高端消费品是得品牌者得天下 低端消费品是得渠道者得天下 制造业是得规模者得天下 对于时机，邱国鹫认为很难把握。因为首先各种技术指标正确率拿历史数据模拟出来都接近50%正确率；然后国外的公募基金基本上不择时，因为历史上择时的基金业绩差于不择时的。 投资方法的有效性悖论邱国鹫认为：世界上不存在每年都有效的投资方法。一个投资方法能长期有效，正是因为它不是每一年都有效。如果一种方法每年都有效，这个投资方法早就被别人套利套光了。 其实很多事情都是这样，特别是运营和推广方面，一个运营活动有效，那么很快它就会被模仿，最终效果就大打折扣。一个推广渠道有效，那么客户就会涌入，渠道成本就会上升，变得不那么吸引人。 小结 选公司要关注估值，价格足够便宜才买。 选公司要关注品质，搞清楚行业的核心竞争力，选那些有足够竞争力的公司。 有效的方法不一定随时都有效。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"2019 年个人总结","slug":"2019-summary","date":"2020-01-01T12:17:16.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2020/01/01/2019-summary/","permalink":"https://blog.devtang.com/2020/01/01/2019-summary/","excerpt":"","text":"工作今年在工作中还是有不少新的认知获得，有一些认识还是交了不少学费之后才建立。很多不便分享，稍微聊一些能分享的吧。 1、商业的模型非常重要。今年上半年我孵化的某款产品就是模型不太优秀。头条就是一家在模型上算帐非常清楚的公司。帐算清楚了，就可以放心地做投放获客和商业化转化。今年活得不好的公司，比如 VipKid, 宝宝玩英语，都是商业模型不够好，他们在规模化之后再调整模型就很困难了。 2、游戏化的学习非常难做。游戏化学习或者功能游戏的核心还是学习，游戏化如果不能持久地提升学习的效率，坚持的效率，那么就是失败的游戏化。最终我看到的成功的游戏化学习案例，其中的游戏部分已经被拆解得面目全非了。仅仅剩下了一些积分，榜单，徽章等游戏化元素。最近刚玩一个叫《健身环大冒险》的 Switch 健身游戏，感受也是相同的，这种玩意新鲜感一过，留存率都会降得很惨。 3、职能部门的负责人应该有很强的业务意识，并且与业务部门负责人站在同一战线上，好的职能负责人能够引领业务的发展。越是专业度强的职能部门，这方面的挑战就越大（比如研发部门），需要研发负责人花费更多的精力做好沟通。《决战大数据》的作者在这方面的榜样作用非常大，我觉得职能部门就应该做成他那样。 读书今年书读够了 24 本，但是没有写完 24 篇读书笔记。整体上让我感觉收获很大的书没有去年那么多。整个书单在 这里，大部分书都是同事推荐的。 最喜欢的书是一本 20 多年前就出版的《竞争战略》。 健康今年身体状态很一般，先是过敏性鼻炎老犯，然后就是抵抗力比较低，国庆的时候还得了带状疱疹。 尿酸一直很高，拖了四年今年终于去看了一下，医生说这个指标早该吃药了。。。于是到现在一直在吃药。 身体早已进入了熬夜熬不起的状态，只能依靠经验积累来竞争，不能拼体力。考虑自己还想为国家多工作几年，所以一直在坚持运动。 健身今年主要的运动就是游泳，平均一周游一次，一次 800 米左右，说实话效果一般，只能当作活动活动。希望明年游泳能够频率高一些。 今年还尝试了两周晨跑，结果没能坚持下来，而且我发现跑步姿势不对的话对膝盖伤害很大，所以我最后还是放弃了。 近视手术今年花了 2 万多做了一个全飞秒的近视手术，协和医院的李莹医生做的，整体做下来的感受特别好，有点后悔做晚了。 近视手术经过 20 多年的发展，已经非常成熟，个人认为近视手术会以后每个近视的成年人的标配。 强烈不推荐同仁医院，价格只差 2000，但体验和协和差了一万倍。我去同仁排队检查了 3 天都没弄完检查，而且手术要排到半年后，白花了不少检查费。协和的检查当天就可以做完，第二周就可以手术。 旅游19 年旅游去了两个地方，一个是曼谷。吃吃喝喝，感受不深。 另一个是公司的年度旅游，去了欧洲（匈牙利，奥地利，捷克，巴黎），对于欧洲的历史文化借此了解了不少，也看到了很多名画（比如蒙娜丽莎的微笑，自由领导人民）的真迹。 炒股今年是炒股的第二年，第一年我交了好几笔学费，整体亏了 1 万美元左右。 第一笔学费是关于买入时机的，当时瑞思英语刚上市，我在它股价还在剧烈波动的时候就买入，结果亏了很多。这笔学费在今年起到了作用，我在腾讯的股票上就看了很久，最终买入价 400 块虽然也比较高，但是相比最高价 480 还是低了不少。这使得我今年在腾讯这支股票上只是小亏（当前腾讯股价 383）。 第二笔学费是关于心态和认知的。18年当时买股票不知道为什么买，股价一跌就着急想卖。李勇说过好的股票应该越跌越买。今年我在特斯拉身上实践了一把，特斯拉一路跌的时候，我不断加仓。最终打算在跌到 200 元的时候全仓，虽然最后没有全仓成功，但是均价控制到了只有 242 元，现在特斯拉涨到了 430 元 (+77%）。 所以，2019 年我整体的股票收益都还可以，手里的几只股票除了腾讯外，收益率都还不错： 阿里巴巴，成本价 144，现价 215 特斯拉，成本价 242，现价 430 腾讯，成本价 403，现价 383 拼多多，成本价 24，卖价 30 今年做到了 50% 的年化收益，不过去年是 -20% 年化收益。 A股市场今年也小试了一下，茅台和格力的收益率都还可以。 整体觉得自己水平还是比较菜的，还需要再多体会和总结几年。 明年的目标 首先还是继续读书吧，还是一个月读两本，全年读够 24 本书。 游泳还是想捡起来，希望能够坚持每周至少 2 次，每次 1000 米。 工作上，希望能够做好大决策。 个人 Milestone 做了近视手术 炒股有了一些收获","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"从早期市场到主流市场 - 读《跨越鸿沟》","slug":"cross-gap","date":"2019-12-09T15:34:35.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2019/12/09/cross-gap/","permalink":"https://blog.devtang.com/2019/12/09/cross-gap/","excerpt":"","text":"最近看完了《跨越鸿沟》，这是一本最初写于 1990 年的书，它被美国《福布斯》杂志评为 “最具影响力的 20 本商业书籍”。 本书的独到之处在于提出了所谓的 “鸿沟理论”，该理论是指：高科技产品在早期市场和主流市场之间存在着一条巨大的 “鸿沟”，能否顺利跨越鸿沟并进入主流市场，就成为企业增长的关键。 以下是一些笔记。 用户分层作者首先把消费者按照接受产品创新的激进程度进行分层，拿 iPhone 和新能源汽车来说： 早期采用者（early adopter）。最早一批买 iPhone 一代和特斯拉的车主，就是这类人。他们通常对产品抱着极高的容忍度，能够接受各种不完美。 早期大众（early majority）。早期大众是一类处于中间立场的技术采纳者，他们会客观评测 iPhone 和新能源汽车的各项指标，只有这类产品真正具有较全面的优势时，才可能采用。 后期大众（late majority）。后期大众非常介意习惯的迁移成本，他们不愿意冒风险或者变化，除非这种变化特别方便并且没什么风险。比如周围很多人都用 iPhone 的时候，他们才会考虑 iPhone。大部分人都用新能源车并且油车变得没电车方便的时候，他们才考虑新能源车。 落后者（laggard）。基本上除非迫不得已，否则怎么都不会接受新事物的人。我爸爸大概就是这样的人，不用手机支付，买东西坚持用现金付款，担心网络不安全（他确实也中了好几次电脑病毒）。 作者认为早期大众和后期大众各占 1&#x2F;3，其他人占 1&#x2F;3。 鸿沟在哪儿那么鸿沟在哪儿呢？作者认为有两个小鸿沟和一个大鸿沟。 第一个小鸿沟在早期采用者内部，作者把他们描述成创新者和早期采用者之间的鸿沟。这个鸿沟产生的主要原因是需求太小众。太小众的需求虽然在一个极小的圈子里面受欢迎，但是无法传染给更多人。 第二个小鸿沟在早期大众和后期大众之间，这需要产品解决用户的迁移成本问题。迁移成本如果不够低，那么用户就会因为成本放弃迁移。 最大的鸿沟在早期采用者和早期大众之间： 早期采用者非常包容，但早期大众非常务实 早期采用者预期产品是颠覆性的，早期大众预期产品是改进式的（对自己的习惯影响不要太大） 这两类人群的特点不同，可能导致他们的需求完全不一样，营销方式也完全不一样。 如何跨越鸿沟作者觉得需要关注市场的细分，做” 小池塘里的大鱼 “。这个观点类似于《竞争战略》一书中讲的聚焦和差异化战略。成为一个细分市场的领导者，有助于你直接获取早期大众的认可。之后企业要做的就是借助这个细分市场与其他市场的联系，努力进入下一个规模更大的市场细分。 书中举了 Mac 的例子，Mac 在最初的时候，聚焦在世界 500 强的图形艺术部门。然后再慢慢扩展到与图形艺术工作人员交互的外部市场：例如创作机构，广告宣传机构以及出版商。 在关注细分市场的基础下，作者把企业的工作分为四步： 瞄准目标。通过用户画像，场景细节描述等方式具象化需求。 集中军力。关注核心需求，建立核心需求的整体解决方案，如果需要，可以建立同盟的企业和引入第三方的服务。 制定战略。确定产品的市场定位。 发起入侵。选择合适的销售渠道，并制定正确的定价体系完成获客。 瞄准目标作者建议通过情景画描述用户采用我们的产品之前，以及采用我们的产品之后的场景，通过对比来感受新产品带来的竞争力。 在考虑新场景的时候，主要考虑以下 4 个角度： 目标顾客。购买者群体是否足够大，购买力是否强。 购买理由。需求是否足够强劲。 整体产品。是否提供了一个整体性的解决方案。 竞争。竞争对手是否已经开始涉足这个场景。 集中军力作者将解决方案分为：一般产品，期望产品，延伸产品，潜在产品。然后建议创业者做好一般产品的基础上，从用户需求场景出发，构造整体性的解决方案。如果这里面涉及第三方的服务整合，那么应该尽早建立这种同盟关系。 书中举了一个电子书阅读器的使用场景：机长使用它来查找文档，排除飞行故障。从场景中，我们就能看出以下环节都是整体解决方案需要考虑的： 阅读器的便携性 文档格式的兼容性 文档内容的及时更新 超链接的支持 是否需要实时联网 只有整体解决方案匹配场景，才可以真正解决用户的痛点。 制定战略有效的战略，可以跨越鸿沟，赢得实用主义者的信任，作者把战略分成 3 步： 1、首先产品本身需要有竞争力，即：优秀的产品、匹配的目标顾客、强有力的购买理由。 2、在市场中创造有利于你的竞争，选择合适的竞争对手。你的解决方案优于这些竞争对手。 3、定位及营销。在传播上使用户记住你的定位，了解你相对竞争者的优点。 最终，作者希望以上步骤可以使企业进入竞争性格局的领导者。 发起入侵如何把产品卖出去永远是成功的最后一步，而这个过程最重要的就是确定价格和渠道。 基本上价格和渠道是互相绑定的，一个产品的定价策略的根本作用就是帮助企业确定合适的销售渠道。所以，定价的首要目标不是让顾客或者投资者满意，而是寻找适当的销售渠道。 互联网和移动互联网快速发展，看起来我们不需要渠道了，但是其实渠道只是从线下转到了线上。而线上渠道的获客成本，是每一个互联网产品不得不考虑的重要问题。很多创业公司都死在了高额的获客成本上。 跨越鸿沟书中最后一章还提到了一些不错的观点，小结如下： 利润从来都是企业需要关注的问题。有些时候资本的助力可能让企业短时间内不必考虑这个，但是企业的经营目标最终还是需要回归到利润本身。 产品早期，产品经理的权力会比较大，因为他需要完成一般产品。但是到了后期，因为企业需要把注意力转移到整体产品的开发上，所以就需要完成从产品驱动到市场驱动的转变。这个时候权利应该收回到运营和营销经理手中。书中举了产品包装的例子作为说明。 技术员工的价值主要集中在产品早期。但是因为企业早期并不能提供高额的回报，所以只能以期权的方式来给技术员工提供回报。但企业需要保留足够的期权，以便激励后期帮助企业跨越鸿沟的人。 小结《跨越鸿沟》建议企业从小市场切入，做小池塘里的大鱼。具体来说，把工作分为 4 步，我个人觉得比喻得有点绕，其实： 瞄准目标，即：确定用户需求。 集中军力，即：确定产品方案。 制定战略，即：确定竞争策略和市场定位。 发起入侵，即：确定价格和渠道。 书中最后说的企业要回归利润，早期重产品技术，后期重市场运营等观点，我都非常赞同。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"网易云音乐的产品故事 - 读《幕后产品》","slug":"the-background-of-app","date":"2019-11-07T13:40:18.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2019/11/07/the-background-of-app/","permalink":"https://blog.devtang.com/2019/11/07/the-background-of-app/","excerpt":"","text":"最近读了网易云音乐的产品负责人王诗沐的《幕后产品 - 打造突破式产品思维》，这是一本来自互联网一线产品经理背景的书，很接地气。书中既有框架性的方法论，也有实际的案例。而且各种案例都直接是网易云音乐或者市场上的相关产品，让人很有实际上手的感觉。 不过我并不打算把诗沐的内容都复述一遍，分享一些我自己的感悟吧。 程序员视角 vs 产品经理视角《幕后产品》书中提到大众点评的外卖入口，有两个入口，一个是首页的一级入口，另一个是首页的美食下面的二级入口。从逻辑上说，一个一级入口同时又是另一个一级入口的二级入口，显然是有点逻辑矛盾的。但是作者认为：这可以照顾两类用户的习惯，在产品慢慢影响用户习惯的过程中，我们不需要为产品做出完美的逻辑（第 7 章 第 1 节）。 我非常赞同诗沐的观点，这个观点在产品经理圈可能是常识，但在技术圈可能是异类。 曾经有一个技术同事私下向我抱怨：我们的产品稿，一些逻辑都不完备，这不应该是最开始就应该考虑的吗？这代表的就是典型的程序员视角。 程序员总觉得这个世界有很强的「硬规则」，所有事情都应该是「确定的」，不存在模糊或者不清楚的情况。遇到产品稿在某种特殊情况下没有定义清楚就会很生气，觉得产品经理考虑问题不严谨。 比如，一些 App 可能有断网显示缓存的功能，这个功能就很多异常情况，比如缓存了一半怎么显示？缓存过期了怎么办？显示缓存中突然又连上网上怎么办？连上网好好的突然又断网了怎么办？缓存中的各种操作（比如点赞），是显示失败，还是显示成功？如果显示成功，是假成功，还是待连上网后再发送真实操作？如果是后者，如果发送失败怎么办，如果发送时帐号需要登录怎么办？ 好家伙，这么多特殊情况！这个时候，牛逼的产品经理可能会扔一个文档：这些都定义好了。但大多数情况下，产品经理需要和程序员一起把这些异常细节补充完善。 其实，产品经理在思考产品稿的时候，从来都不是把逻辑完备当成第一优先级。第一优先级的还是对产品影响最大的那些因素。从大的角度考虑，这些因素是竞争策略和产品定位。从小的角度考虑，这些因素是用户的需求，场景，流程。 所以，程序员同学应该要理解和体谅产品经理，他们在考虑用户的时候，更多的是考虑需求的强弱。他们在设计流程的时候，考虑最多的也是 99% 情况下的主流程的体验。那 1% 的异常分类下面的各种异常情况，是需要最后定义清楚的，但是并不是对产品本身影响最大的。 有意思的是，这 1% 的异常却是对程序员工作影响最大的。有些产品功能，主流程写起来很容易，但是各种异常情况处理起来烦死人，而且还很难测试到位。最终大家的精力都消耗到了这 1% 的异常定义中。 所以，牛逼的产品经理会做减法，不止是减功能，而且还减异常。不需要缓存的地方就不会加缓存功能。各种异常情况，怎么方便怎么来。最终让开发和测试的力量都可以集中到最核心的用户体验和功能上去。 先有定位，再有功能音乐播放类的 App，在网易云音乐诞生的第一天起，就不缺少竞争。思考如何定位，做出差异化产品，是王诗沐需要考虑的第一件事情。 最终，诗沐选择主打个性化推荐、歌评、歌单、发展 UGC 社区的方式来做网易云音乐。 有了这样的战略定位，之后的很多产品决策都在配合这个定位。诗沐在介绍网易云音乐要不要做，怎么做一个具体功能的时候，都会思考与自己的定位是否冲突。例如：当做下载功能的时候，产品设计让用户一定要选择歌单。做收藏歌曲功能的时候，产品也让用户一定要选择歌单。 在考虑场景电台功能的时候，因为考虑到会对 UGC 社区带来分流影响，所以选择不做场景电台，只针对某些特别场景（比如跑步）做一些专门的支持。 这种先战略，再战术，让战术配合战略的做法，处处着眼整体，不至于让产品细节一处的得失影响全盘，是非常有章法的。 文档化你的重要判断诗沐把还原用户场景拆解成 3 个纬度：角色、场景、流程。然后在判断一个功能做与不做的时候，先问自己，为什么要做这个功能。在列出一系列做的理由之后，再一一看这些理由是否足够强。再看看做这个功能有什么风险。 书中拿了很多案例来举例，有些功能不做是与定位有冲突（例如场景电台），有些功能不做是价值不高（例如勋章）。 我个人感受最深的是把这些东西文档化。因为我有些时候发现，一些思考了很久的东西，有结论了。过了几个月，别人问起这个事情怎么决策的，我并不能一下子完全回忆起来。 重要的决策过程，通常可能同时有着收益与风险的权衡，有一些重要的理由支撑着这些决策，有一些被忽略的理由当时可能觉得不重要，这些决策细节都挺重要的。事后回顾，可能发现一些被忽略的理由变化了，或者市场环境变化了，决策就应该有所改变。 而文档化，是这一切的基础。 我想诗沐也是记录了大量网易云音乐的大量决策过程，才可以将网易云音乐从 12 年到现在的发展历程娓娓道来。 小结 程序员背景的同学要注意自己的思考角度。 产品功能应该服务于产品定位。 文档化自己的重要决策，便于事后回顾调整和复盘。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"像做产品一样做大数据 - 读《决战大数据》","slug":"fight-with-big-data","date":"2019-10-30T12:00:01.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2019/10/30/fight-with-big-data/","permalink":"https://blog.devtang.com/2019/10/30/fight-with-big-data/","excerpt":"","text":"车品觉是《决战大数据》的作者，阿里巴巴的前副总裁，红杉资本中国基金专家合伙人。在阿里巴巴的 6 年，车品觉从刚开始只负责支付宝，到后来负责淘宝，最后负责整个阿里集团的数据工作。 作为大数据背景，很难有第二人能够做到这样的职业跃升。在看完整本书后，我才明白了，原来车品觉不单单只是在做大数据，而是把大数据当作一个产品，把业务负责人及需求方当作用户，不但在大数据的产品上做到了创新，而且还深度理解和配合业务方，难怪他最后能够统管整个阿里集团的数据工作。 那么车品觉做了哪些亮点的事情呢？以下是我的小结。 把数据报告当成产品数据报告最容易做成例行的数据罗列，如果是罗列数据，那么数据团队就真正只是在做数据了。 车品觉首先觉得数据报告应该做成一个好产品，那么好的产品是什么样的呢？他列了一些要求： 有好的开头。报告的前 3 页一定要吸引人，让人有欲望读下去 有结论。当有人猜测数据背后的各种原因时，下一页要解答他的疑问 有讨论。每次的数据报告如果高层只看了 5 分钟，就是失败的。车品觉后来做到了每份报告被讨论几个讨论。 为了达成以上的目标，在执行层面，车品觉又做了下面这些事情。 深入用户将日常的业务需求与紧急的数据需求拆开，然后车品觉自己天天和业务高层混在一起，了解他们当前最关心的事情，然后利用自己的数据突击队，提供这些事情的数据支撑。 车品觉和业务高层紧密接触就相当于产品经理和用户紧密接触一样，只有这样才知道核心的需求在哪里，才能抽像出需求，及时响应，而不是等着用户提需求。 在车品觉的团队给高管做报告的时候，车品觉不会看报告，而是主要记录高管们什么时候记了笔记，什么时候在玩手机。因为高管看手机的时间，就说明数据报告相关的内容没有吸引力，应该改进。 在车品觉负责整个阿里集团的数据时，他也将这个理念口号化，他提出数据同事要 “混、通、晒”，这里中的 “混”，就是和业务团队混在一起，深入业务。 数据产品创新在深入了解需求，努力提供有吸引力的数据报告的同时，车品觉也在不停地整理需求，提供创新性的数据产品。他针对阿里的高层、中层都分别做了合适的数据产品，方便不同职位的同事便利地获取数据。 他在技术上也努力创新，曾经有一个数据产品需求，没有哪个技术同事可以做到 3 秒以内出结果，但是他坚持要做到 3 秒以内，最后终于找到了一个能够做到的同事，这个同事后来做到了腾讯数据中心总经理。 建立数据原则、理念与方法论车品觉将自己的数据工作整理成了各种原则、理念和方法论，方便在整个集团进行推行。 他将数据工作分成两类： 运营数据，是指将数据进行收集、整理，然后进一步提供数据创新或改善的工作。 数据化运营，是指将已有的数据进行分析判断，进而解决我们业务当中的各种问题。 对这两类工作，车品觉提出了运营数据的「存、管、用」，以及数据化运营的「混、通、晒」原则。 运营数据的「存、管、用」现在这个大数据时代，业务 &#x2F; 产品负责人很容易想当然地把数据尽可能地收集。但是数据增长实在太快了，如果我们没有目标，那么收集到再多的数据也没有意义。 车品觉自己在经历过很长一段盲目收集数据，不知道如何备份和管理数据的日子后，终于觉得：数据收集应该有目的性。他在书中说：「我们必须知道这些数据未来可以用来做什么，如果今天都想不出来的话，日后就更不可能了」。 车品觉将这个理念整理到他的数据原则：「存、管、用」中。 存：就是指衡量收集多少数据、哪些数据才足够。 管：如何管理如此多的大数据。 用：如何使它们实现更大的价值。 在保存数据的时候，我们需要「假定数据是脏的」，对数据进行合理的清洗，因为大数据来源各种各样，很容易获得脏数据。脏数据不进行处理的话，所有的后续结果都会是错的。 数据化运营的「混、通、晒」数据化运营，是指利用现有的数据来解决业务运营中的各类问题。 车品觉提出了「混、通、晒」的口号： 混：是指数据分析师需要和业务混在一起。这样才会有商业的敏感度，知道当前业务部门最关心什么问题，最关心什么数据。 通：通有两层意思。我们首先需要将不同地方收集到的数据打通，也需要将商业理解和数据之间的联系打通。 晒：是指数据要易于获取，易于呈现和理解。相关的报告要人性化，相关的系统要好用。 小结车品觉的这本书对我的最大感受，还是来自于他的类似于做产品的创新意识。很多人做工作就只是重复前人的做法，车品觉将自己的工作产出看成一个高品质的产品，用做产品的思路来做大数据分析。 战略对了，战术也就很容易了，战术执行上车品觉的深入理解用户，提创新解决方案，总结方法论都将大数据分析高质量地落地了，帮助业务的同时，也成就了自己成为负责整个阿里集团的数据工作的副总裁。 天下无难事，就怕有心人。与君共勉。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"可复用的工作模式 - 读《解决问题的商业框架图鉴》","slug":"thinking-framework","date":"2019-10-25T12:49:55.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2019/10/25/thinking-framework/","permalink":"https://blog.devtang.com/2019/10/25/thinking-framework/","excerpt":"","text":"前言什么是框架？框架是一种可复用的思考模式，通过这个模式我们可以快速地将一个问题 &#x2F; 思考 &#x2F; 工作整理清楚。 比如：Scrum 就是一种框架，它把工作流程分为：计划，每日站会，评审，回顾。然后在这种框架下工作就会比较舒服，既保证了沟通的透明度，又保证了进度追踪和反馈迭代。 又比如：SWOT 分析也是一种框架。它将环境整体分为内部和外部，然后分别进行优势和劣势的判断。 框架不是万能的，具体问题还需要具体分析。但框架确实给解决问题提供了一些范本，用于进行有条理的思考。同时，框架也是一种共同语言，大家用同一个框架讨论问题，就更容易同步想法，沟通见解。 最近看了一本框架类的书，叫《解决问题的商业框架图鉴》，把常见的框架都整理了出来。我一开始以为只是工具书，用到的时候查阅，读下来之后，发现一些常见的工作场景，都可以应用书中提到的大框架，所以收获挺多。 以下是一些小结，分享给大家。 找出问题的框架To be &amp; As is有些时候我们遇到一个复杂问题或目标，都找不出问题在哪儿，书中提到了一个理清问题在哪儿的框架：为名「理想状态 To be 和 现状 As is」法。 书中举了一个将公司经营得更好的例子，什么样是更好的？首先用 To Be 和 As is 列出理想的一些状态和现状，然后就可以关注落差。 「落差」其实就是我们需要达成的目标。这样就把问题视觉化，目标清晰化了。 进一步，用 TAPS 就可以进一步思考问题原因和解决方案。 为什么这也是一种技巧，遇到问题，连续追问为什么，就可能找到问题的本质。 6W2H这也是一种把问题了解得更清楚的框架，通过列出 Who, Whom（对谁）, What, Where, When, Why 以及 How, How much，把问题理清楚。 分析市场SWOTSWOT 是把环境当成第一维度，分析自身优势和劣势的一种框架。 五力图《竞争战略》那本书提到的思考角度，把竞争的来源分成 5 类。如下图： 探索曼陀维九宫格有些时候为了让自己穷尽所有的想法，以便遍历出所有可能的选项，「曼陀维九宫格」可以是一个不错的办法。如下图： 「曼陀维九宫格」的使用方法： 【设定中央的关键字】：在正中央的格子写下主题或关键字。 【写下联想到的关键字】：在周围的 8 个格子写下从中央关键字所能联想到的关键字。 【再写出从这里联想到的更多关键字】：在周围的 8 个 3x3 的格子里，再扩展写 8 个相关的关键字。 格子的数量其实不一定非得是 8 个，可以具体情况进行表格数量的拆分或者合并。 实现KPI 树状图有些时候，我们需要将 KPI 拆解，而 KPI 树状图就可以很好地达到我们的目标。比如一家饭店，如果以营业额作为 KPI，那么就可以按下图的方式进行拆解。 把 KPI 拆解的好处是可以进一步细化执行，找到比较容易落地的方案。 我个人认为拆解也有一定的坏处，就是失掉了整体性，如果过度追求某个拆解的 KPI，可能对业务长远的或隐性的基石（比如品牌）带来影响。 PDCAPDCA 将工作阶段分成计划、执行、检查、行动。其重要的就是其中的检查环节，使得迭代成为活动流程中重要的一环。 小结框架不是银弹，不能解决所有问题，也不一定适用每个场景。 对于一个新的问题，整理出一套解决这个问题的框架，其实就是形成了特定的方法论，还是非常有必要的。 本书的价值就是让你对现有商业环境常见的方法论有一个大概了解。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"询问而非命令的艺术 - 读《谦逊的探询》","slug":"humble-inqiury-book-summary","date":"2019-10-05T16:22:20.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2019/10/06/humble-inqiury-book-summary/","permalink":"https://blog.devtang.com/2019/10/06/humble-inqiury-book-summary/","excerpt":"","text":"序最近读了一本很薄的书，叫《谦逊的探询》，讲的是作为管理者如何进行更好地沟通和决策。 这本书写作的背景是：作者发现一些严重的事故，比如核污染事故和哥伦比亚号事故，都是因为职位级别的原因。在这些事故中，底层员工掌握的重要信息要么并没有被上报，要么虽然上报了，但是被忽视或否定了。 于是，作者认为我们缺失的是一种下层员工能够放心的把问题向上层传递的气氛。那么如何才能够建立这种气氛呢？答案就是管理者必须学会更好地提问。 以下是我的一些读书笔记。 文化的困境我们首先处在一个崇尚个人主义大于集体主义的社会。在企业，表现优秀的员工被提拔。所以，大家认为管理者就应该是优秀的个人，就可以独立做出正确的决策。 第二，我们的文化也强调少说多做。强调执行力，强调完成。在安排任务的时候提问题可能会被人认为是“挑刺”。这种文化压抑了员工的表达欲望。 第三，大部分员工习惯听命于领导的安排，因为这样员工不用承担决策责任。在文化上，决策权责确实通常也是赋予给管理层的。 以上，使得员工并不习惯把信息尽力上报。因此，管理者需要构建一种合适的气氛，尽可能收集到底层的信息。 谦逊的探询把“谦逊的探询”拆开来看，分为“谦逊”和“探询”。 谦逊作者认为，我们首先要在心底做到“谦逊”。这种谦逊不同于对于长者或者偶像的谦逊，它表达的是一种对自己无法独立决策，需要时刻依赖别人来共同完成任务的心态。 这种心态在我看来也是这个社会信息爆炸的一种现象，就像《赋能》一书所说，现代社会大量的信息是被基层人员掌握。管理者仅仅只有综合信息而决策的优势，不再有信息掌握的优势。认识到这一点，才可以做到足够“谦逊”。 谦逊的态度本身，也给了其他人足够的心理安全感，让他们能够缓解由于职级或者文化带来的表达压力。 做到谦逊之后，我们应该学习的就是如何“探询”。 探询我理解的探询是一种“请教”或者“咨询”，通过放低姿态提问，让双方可以尽可能地共享信息。 但是探询的本质不仅仅是提问。因为这种探询源自于兴趣和好奇的态度。它表示我们对建立关系抱有渴望，这样可以带来更加开放的交流。 在这种开放的交流气氛下，提问者暂时处于从属地位，如果你利用这种机会欺骗了我或者利用我，提供了并不需要或者糟糕的建议，我会在未来避免接触你。如果你的建议帮助了我，我们就已经建立起了一种积极的关系。 探询的形式书中给了 4 种不同形式的询问： 谦逊的探询。最大限度地表达出自己的好奇心和对他人的兴趣，是引导他人多说的提问方法，对方并不需要多想。 诊断式询问。与上一个的区别在于，这个需要对方多想，想一些之前没有意识到的问题。这样可以引导对方的思维过程。是一种解决问题的提问方式。比如：“你对此感受如何？” 对抗式询问。在提问中使用反问句比较常见，直接带入自己的猜测。比如：”为什么今晚我们不去看电影？” 面向过程的询问。是直接针对谈话流程的提问，特别是认为对话朝一个错误的方向进行时。比如：“我们跑题了吗？”，“这样问会不会太过隐私？”。 案例案例一：一个公司的 CEO 觉得大家开会的时候都坐得很远，但是又不希望命令大家。一个好的谦逊的探询是问：“大家为什么坐那么远？”。 案例二：作者在很忙碌地写作，他妻子打扰到了他，邀请他出去走走。作者认为谦逊的探询是：给妻子一个认真的谈话，表达当前自己需要集中精力写作，询问妻子的建议。 小结谦逊的探询是一种组织能力，可以团结团队成员，激发成员的表达，最终获得充分的信息并且与团队成员共同决策和成长。 团队成员既可以借此机会建立和管理者的友谊，又可以部分参与决策思考过程，帮助自身成长。 推荐给大家~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"如何有效地竞争 - 读《竞争战略》","slug":"competitive-strategy-summary","date":"2019-09-21T15:18:55.000Z","updated":"2024-01-06T14:52:37.936Z","comments":true,"path":"2019/09/21/competitive-strategy-summary/","permalink":"https://blog.devtang.com/2019/09/21/competitive-strategy-summary/","excerpt":"","text":"最近看了一本比较老的书，写于 1990 年，作者是哈佛大学商学院的教授迈克尔·波特，书名叫《竞争战略》。 竞争这件事情其实挺复杂，因为每个企业就像每个人一样，生下来就和别人不完全一样，各自有着不同的优势和劣势。有些人家庭条件好，可以和别人拼教育资源；有些人天赋高；有些人只能拼努力。 企业也一样，有些企业是明星创业团队，一开始就有比较好的资源；有些企业是草根创业，无法吸引到顶级的人才。 《竞争战略》这本书，讲的就是如何有效地竞争，以下是我的一些感受。 竞争来自哪里波特首先分析了竞争的五种力量： 新进入的力量 替代品的威协 买方的议价能力 供应商的议价能力 当前竞争者的对抗力量 每种力量相互的博弈会产生利润分配方式的极大差异。比如苹果和富士康，虽然富士康是苹果的上游企业，但是因为苹果极强的议价能力，所以苹果手机的大部分利润都没有富士康什么事。 但是换个行业可能就完全不一样。比如，上次看一篇电子烟的文章，里面就提到电子烟其实核心的生产厂家就那么几家，品牌商都没有什么核心竞争力，这个时候，品牌厂商就得分给生产厂商大部分利润。 说到底还是话语权的高低，半年前的 奔驰女车主维权事件，暴露出奔驰厂家和 4S 店利星行的冲突，而这其中就显示出利星行作为经销商极强势的话语权。事后因为好奇，我查了一下利星行的历史，利星行不但垄断了奔驰车的销售，而且还反过来持股奔驰的合资公司，真正控制了下游企业。 我理解话语权的背后，是自己的不可替代性，以及对决策的控制力。不可替代不一定表示自己的竞争力很强，像利星行只是因为垄断了销售渠道，别的地方买不到奔驰，所以也达到了不可替代。而对决策的控制力，就是进入到决策层，比如投资和控股对方企业。 进入壁垒创业的时候，投资人总喜欢问：“你的壁垒是什么？” 波特在书中介绍了 7 方面的壁垒： 规模经济。规模经济是指：随着产出的数量的增加，产品的单位成本将会下降。这将使得竞争者需要以一定规模进入，才能产生足够的竞争力；或者接受成本劣势。 品牌识别度和客户忠诚度。简单来说就是品牌价值。这种心智的力量非常强大，竞争者如果选择同样进行品牌建设，那么将投入巨大的资金成本。 资金。汽车的研发就是一个重资金的产业。如果企业没有足够的融资能力，就无法进入相关的高资金门槛行业。 转换成本。每个产品都会让消费者产生一些习惯，有一些产品甚至会让消费者产生数据（比如苹果手机），如果迁移到别的产品，这种转换成本会使得消费者犹豫。 分销渠道。在互联网没有兴起的时候，销售渠道确实是一个极大的壁垒。即便是现在，零售商都有极大的话语权。有一次我听一个在 711 负责采购的人说，某家方便面就因为不配合降价，于是被 711 拒绝采购了。互联网的时代，分销的渠道变得更加集中，于是渠道费用也不可避免，上次问一家公司旁边的饮料店，为什么在美团上不能点他们的外卖了，老板说，因为美团要抽 20% 的分成。过了半个月，我发现美团上又可以点了，不过饮料的价格都比门店的高了一些，看来老板还是怂了。 与规模无关的成本劣势。比如：专利、特许经营、原材料获取优势、地理位置优势、政府补贴、学习曲线。上次看一个文章讲大疆与美国一家公司的竞争，印象深刻的一点就是大疆在深圳相比美国占了极大的地理位置优势。这种优势一方面是可以更低的成本获得原材料；另一方面是人力成本大概只有美国的一半。 政府政策。政府有些时候为了安全，会要求一些行业准入，比如食品业和健康相关的行业。这些行业因此进入门槛就变得很高。另外有些行业会受到管制，比如运输，能源等。 对于互联网行业，因为政府限制较少、资金门槛低、也不太需要销售渠道，所以壁垒会更加集中。刘润在「五分钟商学院」里面的总结就只有 4 点，即： 专利或特许授权 网络效应 规模效应 迁移成本 只是刘润把品牌价值这一条忽略了，其实这一条同样重要。 竞争战略在波特看来，对了应对上面提到的五种竞争力量，有效的竞争战略只有三类： 成本领先战略 差异化战略 聚焦战略 不过这 3 点并不是互斥的，而是可以同时实现一个或多个。下图表示了这 3 种战略的关系。 成本领先战略成本领先战略简单说起来就是比别人的成本低。这种战略可能是通过规模化生产实现的，可能是通过不断优化成本环节实现的。但是，优化成本并不是意味着低质量，差服务。 应用成本领先战略通常情况下表示企业需要获得比较高的市场份额。 711 通过密集开店，从而减少了配送的成本。它的竞争对手如果开店数量不够，那么就会使得配送的效率不及 711 而在成本上有劣势。宜家家居通过标准化生产，以及自助提货，使得家居的生产和销售成本得到大幅降低，在保证板材家俱质量的同时，提供了极具竞争力的价格。 差异化战略差异化战略就是指企业使其产品与众不同。这种差异可能是产品设计、品牌形象、技术、客户服务、经销商渠道等。而好的差异化战略，可能在多个方面都与众不同。 海底捞在服务上就做到了与众不同，真正实现了餐饮业的差异化竞争。这种服务的与众不同又与海底捞的管理、文化极度绑定，使得市场非常难以抄袭。 差异化战略通常都不是把成本当作第一考虑点，所以差异化战略的成功实施使得消费者对于价格并不那么敏感，从而使得企业可以获得较高利润。 差异化战略的选择，某些时候也代表企业放弃了较大的市场份额。 聚焦战略聚焦是指企业聚焦于某个特定的购买团体，这个团体可能是某个产品线的细分区间，也可能是某个特定的地理市场。 因为只服务于特定团体，所以企业有可能更好地满足客户的需求；也可能使得研发资源更加集中，从而获得成本优势；也可能做出更有差异化的产品。 我在猿辅导公司确实多次体会到聚焦战略的决策。比如我们只做 K12，只做线上，这些都是我们将精力集中的一种战略。 竞品分析这本书还拿一个小节讲了讲如何做竞品分析。我特别赞同其中的两点： 应该强调竞品分析的沟通功能，除非收集到的竞品数据用于制定战略，否则就没什么大的效果。 收集的数据必须以某种言简意赅的形式上报给高管层，否则就是浪费时间。 有些时候，公司搞个实习生，每周发一个竞品研究周报，看起来每周产出了很多内容，实际上效果都会很差。因为首先这些周报有没有被认真看就不清楚，然后这些周报如果只是竞品大量行为和数据的罗列，也无法做到很好的被管理层吸收和判断，从而影响了其沟通功能。 导致产业分散的因素其实我们生活中，有很多产业是分散的，CR4 不足 5%，比如典型的线下课外辅导市场，就是一个极度分散的产业。 波特在书中介绍了一些常见的导致产业分散的因素，这有助于我们理解这种产业分散现象。这些因素如下： 整体进入壁垒不高。 缺乏规模经济或者学习曲线。有一些产业主要依赖于人工，那么规模化之后成本并不会显著下降。 运输成本 &#x2F; 存货成本居高不下。使得很多产业在商品消费地小规模存在。 在应对买家或供应商时，企业无规模优势。书中举了大量的例子，比如女装业，讲究的是快速反应，小公司反倒会有优势。比如某些产业需要较高程度的创新，比如广告业，室内设计业，大公司很难吸引所有的这些创新人才。比如本地人脉网络对业务至关重要。 市场需求丰富多彩。 产品差异化极高。比如影视制作行业，艺术表演行业。 退出壁垒。那些边缘企业因为退出壁垒选择低利润生存，从而阻碍产业整合。 地方 &#x2F; 政府管制。 新兴产业。因为行业新，所以还没有发展到巨头开始整合那一步。 克服产业分散的办法克服产业分散的办法，包括： 创造规模经济或者学习曲线。 标准化市场需求。 将分散的因素分离。比如唱片业就将出版、营销整合，但是对每一个子品牌保持独立，这使得华纳兄弟拿到不错的市场份额。 收购。 李鑫曾经给我讲过阿芙精油的故事，这就是一个典型的创造规模经济的案例。阿芙精油创始人关注到精油这个品类在淘宝上很火，但是极度分散。于是用巨额投入在线下品牌店（比如在王府井），然后在淘宝上同时提升小量价格，构造精油品牌。于是精油的需求被集中到品牌更好，价格只是高一点点的阿芙精油上。 对于竞争者来说，要么跟进和阿芙精油一样做品牌升级。但是资金成本是这个行业的问题，因为大多从业者是小作坊式的规模，不可能像阿芙精油一样大量在线下开店。于是，资金成为阿芙精油前期在行业整合中的一个壁垒。 后期阿芙精油完成品牌传递和市场占有率后。规模化的成本优势、品牌优势、转换成本都成为阿芙精油竞争的优势。 小结本书还讲了很多其它竞争有关的内容，比如新兴产业的竞争等，但是我个人很难完全记住，只能用到的时候再行查阅。 本书对我理解竞争最有价值的就是以五种力量来框架性分析竞争的各种因素，并且把有效的竞争战略分为 成本领先、差异化、聚焦 3 种。 本书也让我关注到了竞品分析行为的最重要要素：言简意赅地向管理层沟通。 虽然这是一本写于 20 多年前的书，但在今天看起来仍然很有效，推荐给大家！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"效果广告基础 - 兼读《计算广告》","slug":"ad-101","date":"2019-08-25T14:00:56.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/08/25/ad-101/","permalink":"https://blog.devtang.com/2019/08/25/ad-101/","excerpt":"","text":"广告的类型广告收入撑起了中国互联网行业收入的半壁江山，本质上百度、阿里、头条系的大部分收入，都是来自广告。腾讯虽然游戏收入很多，但广告收入也不少。 而广告的类型，我个人理解主要分为：品牌广告 和 效果广告。 品牌广告不容易直接计算广告的效果。比如今年猿辅导与《最强大脑》节目合作，在节目中做一些宣传，就属于品牌广告。其部分效果虽然可以从节目播出前后的下载量变化看到，但是对消费者更长期的口碑和心智影响却不容易评估。 效果广告与品牌广告相反，它直接以转化效果来计算费用。广告主可以设定具体的转化目标（例如：App 激活、用户付费、用户注册等），然后就可以为此目标进行出价，广告平台通过竞价的方式最终完成相应的广告投放。 搜索广告属于效果广告的一种，不过需要与用户的搜索行为相配合。用户搜索一个关键词的行为，表现出对相关广告极高的了解欲望，这个时候的广告转化的效果就非常好。这类广告都引入了竞价排名的机制，使得广告位的价值通过竞价达到最大。搜索广告主要提供者是百度和 Google 这类搜索引擎产品。 除了搜索广告，展示类效果广告也非常多。比如我们在各种信息流，例如：微信朋友圈、微博、今日头条、抖音里看到的广告，就属于展示类的效果广告。在本文中，我主要展开讨论这一类效果广告。 品牌广告的效果效果广告与品牌广告，本质上都是要评估效果的。只是品牌广告的效果不直接，不容易评估，但是不代表品牌广告不需要评估效果。从长远看，品牌广告的资金投入，最终都应该转化到获客成本上，最终可以计算出这些广告的价值。只是相对来说，这些计算不太容易。 百货业之父约翰·沃纳梅克说过一句话：“我知道有一半广告费浪费了，但我不知道是哪一半”。讲的就是品牌广告相对来说不好评估效果的困境。 效果广告中的角色为了大家理解各种角色，我给大家讲一个拍电影的故事。 我们假设你是导演，要拍一个有关效果广告的电影。 你写了一个最简单的人物剧本，要做效果广告显然需要两个角色： 广告主：负责花钱打广告的。 广告平台：负责卖广告位的。 广告主为了打广告，他的团队需要有投放主管、渠道经理、产品技术团队，内容创意团队： 投放主管算是广告投放工作的负责人，进行工作的统筹并为结果负责。 渠道经理是某一个或几个广告平台渠道的专家，负责相关的广告平台的投放工作。 产品技术团队负责为投放工作做相应的广告页面开发，相关的支撑系统和数据分析。 内容创意团队用于构思和制作广告创意。 而广告平台，通常有销售经理、运营经理、产品技术团队： 销售经理面向潜在的客户，推销自己的广告平台，不断为平台带来新的客户。 运营经理对接广告主，为广告主答疑解惑，提供投放相关的知识经验。 产品技术团队负责搭建和维护广告投放相关的系统。 代理商剧本写到这里，扮演广告平台的几个演员不干了。他们说：我们对接的全中国的广告主有上万家，这么多广告主我们怎么照顾得过来？而且这些广告主是给钱的金主，他们提各种需要我们又不好拒绝，应该怎么办？ 这个时候，一个跑龙套的过来说：要不我来替你们干这些脏活累活吧！于是，你在剧本中加了一个角色：代理商。 大的广告平台为了保证自身的团队规模的精简，同时剥离那些偏服务性质的脏活累活，于是将自己的广告业务，完全交给一家或多家代理商来进行二次售卖。广告平台以「返点」的方式，将广告费用的一定比例，支付给代理商作为报酬。 代理商内部通常的角色有： 销售经理。面向潜在的客户，推销自己代理的广告平台。 运营经理。与广告主的渠道经理配合，为其提供各种服务。 内容创意团队。与广告主的渠道经理配合，为其制作各种内容创意。 平台对代理商的资金消耗通常要求比较高，有一些代理商规模比较小，但是自己又有自己独到的一技之长（比如销售能力），于是这些小规模的代理商就会找大的代理商拿量，这就是二级代理商。 这样就形成了，一级代理商负责与平台对接，承诺比较大的广告投放量，二级代理商具体服务各个广告主，为一级代理商贡献投放量。最终一级代理商和二级代理商分享平台的「返点」的服务模式。 代理商除了使得广告平台的对接压力减小外，同时也承担了更加专业的广告投放任务。因为很多小的广告主其实是没有能力制作广告并有技巧地投放的，这个时候代理商就可以承担从脚本提供、到素材制作、再到投放测试的一条龙服务。 我画了一个广告主（蓝色）、代理商（红色）、广告平台（绿色 + 黄色）的沟通操作示意图。 广告主的渠道经理主要和代理商的渠道经理对接，共同通过操作广告平台的投放系统，来完成广告的投放。在这个过程中，广告平台的运营经理，会特别关照一些大的投放客户。 广告平台与 oCPM广告平台有很多，比如：微信、广点通、头条、百度、喜马拉雅、微博。 广告平台其实目标只有一个，就是最大化自己的收益。那么广告平台如何最大化自己的收益呢？我们来看一个公式： 总收益 = 广告总流量 x 流量填充率 x 每次曝光价格（eCPM） 根据这个公式，广告平台要提高收益，主要有 3 个办法： 增加广告位。这样就增加了广告总流量。但是这伤害了用户体验，不能无限制地增加。 提高广告填充率。广告的填充率影响很多，既有广告主的数量，又有当前广告平台相比别的平台的价格优势，还有算法的影响。 提高单位广告位价格，即提高 CPM（Cost Per Thousand ）。但因为广告平台之间也要竞争，所以如果过高，则会流失部分广告主，影响广告填充率。 广告平台在最初的时候，就是简单地按 CPM 来让大家出价，出价高的人就可以获得广告位。这里面涉及的竞价算法（广义第二高价），我稍后再介绍。 但是广告平台很快发现了问题：单纯地选出价高的广告主来投放，对平台或许不是最优的。因为短期出价高的广告主，对于平台来说长期收益不一定是最大的。比如：出价最高的广告可能转化率低，自身无法长期承受这个价格。 于是，Facebook 在几年前提出 oCPM 的计费规则，前面那个 o，指 Optimized。在 oCPM 规则下，平台不止考虑你的出价，也要考虑你设置的那个优化（Optimized）目标。 不同的广告主的优化目标可能不一样，如果是投放 App 下载的广告主，优化目标可能是 App 的激活。如果是电商平台，优化目标可能是成单。设置好了优化目标，广告平台就会根据目标和你的出价范围，来动态地调整出价策略。 本质上，oCPM 是一种替客户考虑的计费方式，广告平台不止收你的钱，还会替你考虑转化的成本和效率。如果成本过高，广告平台就直接不花你的钱了。短期来看，可能会少挣了一些钱，但是长久来看，广告平台可以吸引更多广告主过来。 eCPM当 oCPM 变得更科学和动态之后，广告平台就利用 eCPM 来进行竞价了。eCPM 本质上是站在广告平台角度，看每个广告位带来的预期收益是多少。在腾讯的微信朋友圈广告投放 官方文档 上，我们可以看到 eCPM 的计算公式是： 所以，eCPM 其实就是结合了出价、转化概率、以及智能调价因子而算出来的平台可以在某个广告位上挣到的钱。eCPM 只是一个竞价模型，平台按这个来评估每个广告的价值，选最高的来进行展示。但是 eCPM 并不代表广告主的出价，也不代表平台真正能收到的钱。对于广告主来说，其实计费方式还是按曝光次数收费。只是对于 eCPM 值低的广告主，他的广告可能永远也无法得到展示。 为了让大家更容易理解 eCPM ，我给大家讲一个地主的故事。假设你是一个地主，你想把你的地租给一户人家种，于是来了四户人家： 第一户人家，出价最高，但是他把地租下来，其实是想种毒品。你担心他过两天就被警察叔叔抓走了，你收不到多少钱不说，可能还会承担连带责任。 第二户人家，出价次高。但是这个人其实很傻，他没有仔细算帐。你帮他算了一下帐，按他现在付的租金，回头他收完庄稼，应该是入不敷出的。你想了想，第二年要不他就被饿死了，要么他就觉得你是黄世仁，起义把你抄家了。长远来看也不好。 第三户人家，出价第三。租你地是为了种高价值的水果，这种人家年轻力壮，家里人又团结齐心。果树价值高，种好了能够收成好多年。你算了算，他们是可以挣钱的。 第四户人家，出价最低。租你地是为了种粮食，附加价低，所以他出不起高价钱。 好了，问题来了，如果你是地主，你应该租给哪家人？你仔细想了想，租给了第三户人家，因为长远来看，第三户人家收入稳定，也最安全，你的长远收益最大。例子中的第 1，2 户人家，他们的「智能调价因子」起了作用，所以使得他们的出价虽然高，但最后的 eCPM 值低于第三户人家。 广告的计价算法广告平台通常采用的计价算法是广义第二价格 GSP（Generalized Second Price）。为了让大家理解这个算法，我们还是需要再讲个故事。 好了，你又开始当地主了。现在有两户人家想租你的地，你发现他们的条件都挺不错的，于是你就说，要不咱们公开拍卖吧。于是这两户人家就开始出价： A: 1 毛 B: 2 毛 A: 3 毛 B: 4 毛 A: 5 毛 B: ….. 于是，经过了一整天的竞价，价格终于涨到了 2 块钱，而最终成交价可能是 1000 块。所以，问题一出来了：出价者希望试探对方的低价，造成提价过程过于缓慢。 第二年，你又遇到了同样的问题，于是你换了一个做法：每个人只能出一次价格，把价格装在信封里面，出完就再成不能变了。于是，A 的信封里面出了 900 块，B 的信封里面出了 500 块。A 成交。但是！A 很不开心！他觉得他亏了 400 块！问题二：出价格希望用最低可能的成交价成交。 广义第二价格解决了上面两个问题，简单来说，双方还是可以随便出价，但是成交价格按第二高价，再加上一个极小值来结算。拿上面的例子来说，你就可以给大家说，大家可以随时给我出价，我会按照第二高价加 0.01 元来收取最终成交者的费用。如果 A 出 900 元，B 出 500 元，那么最终成交的人是 A，成交价是 B 的价格加上 0.01 元，即 500.01 元。 同时，规则规定 B 不知道 A 的出价，B 首先无法在 A 的价格上简单加一个最小值来竞价。另外，因为第二高价的原因，B 在行为上也不需要这么做，B 完全可以出一个他能承受的最高价，反正最后结算的时候，并不以这个价格来结算。 小结：广义第二价格使得竞价方的每一个人都有动力直接把价格出到自己能够接受的底线。知乎上 这篇贴子，对此有更多的介绍。 角色与角色之间的关系你还记得我们假设你是电影导演，要拍电影么？现在角色定好了，世界观也定了。 当你把三个角色（广告主、广告平台、代理商）和世界观（ oCPM 出价，eCPM 竞价，广义第二高价结算）都定下来之后，才发现人物关系其实一点都不简单。 这也是大部分电影最有意思的部分。 广告主与广告平台广告主花钱打广告，广告平台挣广告的钱，给广告主带来效果。看起来是一个双赢，但是，广告平台本质上是希望它尽可能的多挣钱。所以，现在你来想像这样一个场景：如果广告平台发现，他的某一个广告主因为某个行业特别好挣得多，可以出 1000 块的钱来打广告，但是现在平台第二高价只花掉了广告主 500 块。 因为这个广告主其实花得起 1000 块，广告平台会不会想办法，把这个广告主的成本提到 1000 块？ 有人会问：有什么办法呢？整个广告竞价模型其实都是黑箱的，广告平台告诉你第二高价是 999，你其实也没办法说它作弊。 上面这个说得还算简单，说得复杂点，现在推荐算法和深度学习这么强，广告系统有没有办法学习到每个广告主对于价格忍受的底限？能不能在保证广告主不亏本的情况下，尽可能地把广告主的利润全部拿走？ 我听说，某广告平台内部甚至都有刷量的团队存在。在巨大的经济利益面前，把刷量团队升级成更智能的算法，这并不是一个本质上的改变。 有人说平台黑，其实反过来也一样，所有人都想知道广告平台的算法是否有漏洞或者什么规律，因为如果你知道了，就可以根据这个规律做一些特别的优化，这个本质上和搜索引擎的 ASO 是一个道理。所以，如果你在一家广告平台写竞价算法，很容易会有人找上门来，希望你透露一些算法上的细节。对于广告平台来说，这何尝不是一个风险？ 广告主与代理商代理商看起来只是挣返点的钱。但是其实情况比这个复杂得多。 首先，代理商之间是有竞争的，为了赢得投放额，代理商之间不但要比拼投放的效果，服务的效果，也要比拼和甲方的关系。这里面其实是极容易出现腐败的。我知道有一家创业公司，广告主一方的 CEO 就这样拿了不少代理商的回扣。 然后，代理商哪有什么竞争壁垒，你说你好不容易研究出一个创新的投放素材，这个行业又没有什么专利，分分钟就被各家抄去了，根本就保密不了。广告平台甚至还会定期给全行业同步各种好的广告创意。 本质上，代理商就是一个重服务，壁垒极低的服务行业，生存压力大，那为了竞争活下来，代理商其实也会走捷径。什么是捷径？这就是刷量。 刷量的本质是：广告投放的成本与商品本身的价格错位。比如一个商品，本来卖 5 块钱，但是广告费用可能是 10 块。之所以有这样的行为，是因为广告主看重了更多的远期价值，比如这个用户未来还会复购，还会带来品牌和口碑等等。 因为有这样的错位，代理商其实就有动力刷量了。因为他只需要花少量的钱，就可以刷出比较好的转化率，进而可以获得更多的广告投放额度，获得更多的返点。 某个比较大的代理商给我说：刷量在代理商行业里面是潜规则，只是分刷得厉害还是不厉害。刷得厉害的，被发现了，就被广告主拉黑了，所以做长期生意的代理商，就少刷点量，工作也做，于是广告主也搞不明白刷没刷。 为了应对代理商的刷量，广告主一定要保守住自己的核心数据指标和反作弊策略。因为现在刷量的行为已经很高级了，不但可以给你刷下载和成单，也还可以给你刷留存和活跃。 上次听到一个故事，有一个游戏公司，发现用户只要留存下来，未来半年人均花费 50 元，于是他们就按留存率来做投放。在投放的时候发现某个渠道留存率明显很高，还以为用户属性比较 Match，以为捡到了宝。进一步加大了投放。结果后来这些用户留存率虽然没问题，但是就是不消费，游戏公司因此亏了不少钱。 像这种坑就很麻烦，因为你要检查效果需要时间，而投放行为又不能等。一些 App 下载类的投放也有类似的问题。你如果检查日活，留存什么的，刷量的公司都可以给你做出来，如果是投放新手，分分钟被坑死。 所以，在效果广告领域，广告主的反作弊能力的高低，直接关系到公司的成败。 代理商与广告平台代理商与广告平台的利益冲突相对小，因为代理商是收的广告主钱，广告平台也是收的广告主钱。广告平台相对来说，只是希望代理商不要把素材做太烂，影响平台的用户体验。所以广告平台一方面会有素材的审核，另一方面也会奖励高品质的素材。 随机性广告素材效果的随机性是一个不得不说的特点，每个广告素材在投放之前，都会用一个小的量进行测试。但是因为这个量太小，所以很容易出现一些随机性，使得你无法判断素材的好坏，而初使的数据如果糟糕，也会影响广告系统的预测算法，使得之后这个素材更难以获得曝光。因为广告展示都需要花钱，你又舍不得花更多的钱进行测试，只能放弃。 这种随机性使得广告投放需要进行大量的素材测试，而跑出一个效果奇好的「超级素材」，既需要创意，也需要运气。 而就算你有了一个超级素材，因为市场同行的大量跟进，以及观众对素材新鲜度的偏好，你的这个素材也无法长期使用。 于是，广告主和代理商只能一遍一遍的尝试新的素材，永无止境。 而超级素材的随机性，又使得这个事情很难迭代总结，一切都是命。 广告的竞价在 《RTB 广告竞价系统的算法介绍》 一文中，我们可以广告竞价的一个关系图： 具体流程如下： 1. 用户使用浏览器访问这个 web 页面 , 此时产生出了一个曝光展示。 2. 媒体将广告位展示信息通过 SSP 传递给 Ad Exchanges。 3. Ad Exchanges 对多家与之对接的 DSP 发送竞价请求。 4. DSP 通过 DMP 数据管理平台或自身的用户数据库来推断用户属性, 通过 DSP 的竞价引擎判断是否参与竞价 , 若参与则给出竞标价格。 5. DSP 将竞价响应传递给 Ad Exchanges。 6. Ad Exchanges 接收到所有 DSP 的响应或到达截止时间 (通常规定是 100ms），确定获胜的 DSP。 7. Ad Exchanges 通知 SSP 竞拍的赢家 ,SSP 发送广告曝光请求给广告服务器。 8. 广告服务器将广告投送到用户浏览的 web 页面。 整个过程对于用户体验来说几乎是瞬间完成的 , 当打开网页即可看到对应的广告。 这里面比较难的一个是实时性，因为广告要求极端的时间（通常小于 100 毫秒）决定获胜的广告主。另一个比较难的就是预测，广告的 eCPM 是估计出来的，这里面通常是多个模型的叠加作用，出了问题要查起来都非常复杂。 我也不是这方面的专家，所以这部分我就不详细展开了。 小结 效果广告的三大角色：广告主、广告平台、代理商。 效果广告的三大世界观：oCPM 出价，eCPM 竞价，广义第二高价结算。 人性和利益不统一，是效果广告中最难解决的部分，广告主要做好廉洁管理和反作弊策略，保护好自己的底价以及核心数据。 随机性是广告素材不得不面对的情形，一切都是命。 本文有部分内容也参考了计算广告专家刘鹏老师的《计算广告》一书，算是今年读的第 13 本书吧。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"美国怎么对付华为 - 读《美国陷阱》","slug":"American-trap","date":"2019-08-04T15:56:54.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/08/04/American-trap/","permalink":"https://blog.devtang.com/2019/08/04/American-trap/","excerpt":"","text":"序最近读了一本有意思的书，叫《美国陷阱》，作者是阿尔斯通公司的前高管弗雷德里克·皮耶鲁齐。本书讲述的是美国的联邦调查局通过对阿尔斯通公司高管的逮捕和威胁，最终使得美国通用电气公司将阿尔斯通收购的故事。 作者用第一人称，讲述自己从被捕，到艰难保释，到辩护，最终被判坐牢，以及最终出狱后为宣传美国的这种打压手法而做的努力。 美国一直对全球标榜着自由，开放，公平，但是其实在国家利益面前，每个国家都不愿意在某个规则内被削弱，美国也是这样。所以，当美国发现它的经济利益、政治利益、军事利益等受到威胁或者削弱的时候，规则是什么样的就不重要了，重要的是赢。 如果在规则下能够赢，那么美国就会强调规则。 如果规则有一些空子可以钻，来带来竞争优势，美国就会钻空子。在本书中介绍的就是美国利用《反海外腐败法》来打压国外的公司。 如果规则没有空子可以钻，那美国就会宣布退出这个规则。最近川普退出了很多规则，比如退出了军事上的《中导条约》。去年，美国还退出了《伊朗核协议》、联合国人权理事会、联合国教科文组织。美国还威胁退出 WTO。 所以，在国家利益面前，什么公平，正义都是虚伪的。去年沙特王储萨勒曼谋杀了记者卡舒吉，川普却说：“我们可能永远也无法知道关于贾迈勒·卡舒吉被谋杀的全部事实。” 如果结合美国打压华为的行为来看本书，我们可以更明显的看到美国在维护国家利益面前时的选择性执法。而美国抓捕华为 CFO 孟晚舟行为，与逮捕阿尔斯通高管的案例极其相似，所以本书也有着不错的借鉴意义。 故事梗概阿尔斯通 是一家法国公司，这是一家在电力和交通运输上具备国际竞争力的公司。在电力上，阿尔斯通主要向海外各个国家提供各种发电设备的建造服务。在交通上，阿尔斯通主要对外输出高速铁路的建造服务。当年中国建三峡大坝的时候，就采购过阿尔斯通提供的水轮机和发电机组。 阿尔斯通主要的业务是通过参加跨国的招投标来获取的，而腐败是这其中难以回避的问题。对于一些发展中国家的业务，当地的法律法规执行并不严苛，阿尔斯通以及其它的竞标者，就可能通过贿赂来获得项目。 在本书中，作者并不认为这件事情光彩，他在书中也呼吁法国在国家层面上对这种行为进行打击。作者气愤的是，美国在反腐这件事情上采用双重标准，重点盯着竞争对手，而对于美国公司自己睁一只眼闭一只眼。 这就相当于美国是足球场上的裁判，然后犯规明显是不对的，但是这个裁判只抓一边的犯规，对另一边的犯规视而不见。那么很显然，这样的球没法踢。那么说回来，美国到底是怎么做到的呢？ 长臂管辖美国的很多法律，可以直接管到全球的所有公司。比如说本书中涉及的阿尔斯通腐败案，其实是发生在印尼。印尼没有管，法国也没有管，但是美国利用《反海外腐败法》，也可以把人抓起来起诉。 这相当于什么呢？举个例子，假如有一天，中国的有家公司在中国境内做生意，没有违反中国的法律，但是违反了美国的法律，美国的 FBI 可以想办法把你引渡到美国受审判。 这相当于是说，美国的法律高于全世界所有国家的法律。即使你不在本土，即使你也不是美国国籍，美国的法律也能管你。FBI 没有抓到你只是因为你没有机会让他执法，因为他不可能直接跑到别的国家抓人。但是孟晚舟的案例告诉我们，只要是你在亲美国的国家，美国都可以利用各种引渡协议把你引渡到美国受审。 这合理吗？明显不合理。全球性的法律条款理因由全球性的组织来制定和实施，比如联合国以及国际刑警。这样的机制下才可能保证法规的中立以及执法的中立。 辩诉交易有了长臂管辖，我们再来看看美国司法的一个特点：辩诉交易。 根据全国刑事辩护律师协会 2018 年的一份报告，在 2017 年，在联邦体系中，有 97.2% 的刑事案件被告人选择通过辩诉交易而认罪，放弃了得到开庭审判的机会。而本文的作者，也是选择了认罪。为什么会这样呢？ 首先，美国的检察官不会客观的给你指控，他会尽可能多的指控你，然后抬高你的刑期。比如本书中的皮耶鲁齐，就被指控了多项罪名，如果都成立的话，会有 125 年的刑期。这直接就让被告人吓傻了。然后，检察官就会给你一个刑期很小的认罪协议。只要你认罪，就只会被判这么久。 在本书中，皮耶鲁齐的律师给他说，如果认罪就只判 6 个月。确定的 6 个月和 不确定的 125 年，我想所有人都会迫于恐惧而选择确定性的坐 6 个月牢吧。而且皮耶鲁齐当时已经在狱中了，真正判决下来后，他 6 个月的刑期已经结束了。 海量证据皮耶鲁齐的案件，检方提供了 150 万项证据。这些证据很多都是一些没有信息量的内容，比如阿尔斯通相关部门 10 年间所有的电子邮件。没有人可以阅读完这些内容。检方也不会告诉你他会拿出哪一项证据让法官判断。 这种攻击手法类似网络的 DDOS，检方把有用的 15 个证据，加入了 10 万倍的噪音。正常人根本无法处理这些信息，也就无法针对性提供反驳的证据了。 海量证据也有利于搞定​陪审团制度。美国的培审团人员虽然都是市民，但是他们面对专业的检察官递交的各种海量证据，根本无从分辨，通常都会同意起诉。​2010年呈交到大陪审团的 162351 起案件中，只有 11 起被大陪审团否决。 皮耶鲁齐的经历在阿尔斯通的案例中，美国联邦调查局先通过安插线人，收集到了阿尔斯通贿赂的证据。 然后他就通过把案件中的一些知情人抓起来受审，本书作者皮耶鲁齐虽然不是贿赂的直接人，但是他知晓事情。FBI 通过这种方式给阿尔斯通管理层施压。 为了给阿尔斯通的 CEO 施压，FBI 除了应用辩诉交易，让皮耶鲁齐写认罪协议外，还将皮耶鲁齐的审判尽可能延长。皮耶鲁齐被关了一年多，都没有开庭。 FBI 也尽可能增加皮耶鲁齐被保释的难度，除了不断上涨保释金之外（从 40 万美元涨到 150 万美元），FBI 还要求他提供两个美国朋友的房产作为担保，如果之后不受审，两个美国朋友的房产将被扣押。这几乎是不可能达成的任务。 最终皮耶鲁齐还是达成了保释要求，但是审判时最终被判了 3 年。他签认罪协议时检方承诺的 6 个月刑期并没有被遵守，于是他只能服刑坐牢。 不过他最终通过法国大使馆达成了引渡请求，虽然历经波折，他还是被引渡回了法国，并且立刻得到了保释。 与皮耶鲁齐服刑期间，阿尔斯通与美国司法部达成了认罪协议，并且在被美国通用电气收购后，收到了罚单。更为重要的是，阿尔斯通与美国司法部谈判时，通用电气的人居然一起参与。皮耶鲁齐认为，“美国司法部不是独立的，而是处于强大的美国跨国公司的控制之下”。 华为在华为公司的案例上，很明显美国在故意打压华为。利用拘捕孟晚舟这种方式让华为管理层害怕，是美国一直以来熟练的做法。与此同时，美国还把华为列入负面清单，让华为失去大量合作伙伴。最后，美国不停地宣扬华为有窃听，不安全，但是又拿不出任何证据。 对于中国来说，不应该让美国的阴谋得逞。华为是中国少有的在科技创新领域做到全球领先的公司。应对美国的打压，中国也应该推出负面清单，限制那些配合美国打压华为的公司。中国也应该拘捕那些在中国不好好做生意的美国公司高管。 当然，中国也需要更加鼓励创新，让中国出现更多创新企业，把产品向全世界输出。在这场国家利益的斗争中，我对中国还是满怀信心的。 小结本书简单小结就是一句话：政府是为国家利益服务的。 国家之间的竞争，没有什么规则可言。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"尚拙 - 读《曾国藩传》","slug":"zgf-life-summary","date":"2019-07-10T13:55:41.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/07/10/zgf-life-summary/","permalink":"https://blog.devtang.com/2019/07/10/zgf-life-summary/","excerpt":"","text":"几个月前读完了张宏杰所著的《曾国藩传》，前几天公司组织去欧洲团建，在飞机上又完整再读了一遍，感触很多。 曾国藩（1811－1872）是晚清时期的名臣，中国近代政治家、军事家。有些人的传记你读起来感觉他就是天才，高不可攀。而曾国藩的传记给人的感觉更像是一个普通人的奋斗之路，能够借鉴到自己的生活工作中。 尚拙这是一种不追求技巧，追求踏实累进的态度。曾国藩说：“天下之至拙，能胜天下之至巧”。纵观曾国藩自己的成长经历，无一不是靠用笨办法，踏踏实实一步一个脚印成长起来的。 遇到问题时承认自己笨，一方面会虚心自省，另一方面也会更加坚定用普通的办法，不会想什么取巧偷懒的办法。曾国藩面对逆境时的逆商，也因此变得相当高。 曾国藩自省的办法很简单，就是写日记，并且把内容分享给自己的兄弟，这些 “曾国藩家书”，成为我们现在了解他的重要方式。 曾国藩其实走了很多弯路，包括考功名考了很多年，早年读书只会读八股文见识浅，为人太过正直得罪了包括皇帝在内的很多人。但是经过自省，他最终能够在被咸丰解除兵权后深入思考，再次出山后变得谦虚，并且懂得变通。 晚年的曾国藩其实已经近乎完美。在那个年代就能意识到近代工业的重要性，组建制造局，兴办洋务运动。虽然后来因为甲午战争使得洋务运动失败，但不得不说这是中国工业化转型的一次重要的机会。 结硬寨、打呆仗曾国藩带兵打仗的能力，完全是自己一点一点摸索和总结出来的。 首先他不信权威，敢于用颠覆的方法解决正纯清军的面临的问题。比如兵源，曾国藩主要招朴实的农民。比如组织上，他强调兵为将有，利用乡党关系把部队内部团结起来。 然后，曾国藩能够发展出一套适合湘军的战斗理念，即：结硬寨、打呆仗。每次攻打城池，总是用更大的兵力围城，一围围个一年，直接把对方的粮食消耗光。围城的时候，前后都挖战壕，用于防御。只要挖好了战壕，对方基本上就进入了消耗战，没有什么好办法。 曾国藩利用这个战术，打败了太平天国。太平天国面对这个战术，也只能靠围魏求赵一类的战术来解，遇上曾国藩这种死抗的，一点办法也没有。而且战争后期，曾国藩还将这个战术发展成 “围城打援”，利用这个办法来偷袭过来的援军。 最终湘军围攻下了南京城，结束了太平天国运动。 “结硬寨、打呆仗” 这种战术背后，是一种追求确定性，把对手带到自己的游戏节奏中来的战略。我们工作当时，有些时候为了走捷径，其实是牺牲了确定性，有一种投机的心理。这种心理有可能会占一些小便宜，但是在大的事情面前，确定性比远比小的一得一失重要得多。虽然曾国藩打仗慢，没有技巧，但是人员损失极小，获胜的确定性又极大，相比而言那一点时间上的损失微不足道。 独立思考曾国藩具有很强的独立思考能力，能够结合现实情况，创造性的提出解决问题的办法。 “结硬寨、打呆仗”的战法，就是湘军独创的战法，虽然笨，但是非常有效。 曾国藩剿捻，发明了河墙战法，最终花了两年多时候剿灭了捻军。 面对天津教案，他能不迷信谣言，认真找到事件的真相。可惜当时皇权实际上是慈禧把持，慈禧本人读书太少过于迷信，天津事件反倒让曾国藩戴上了卖国贼的帽子，这是后话。 面对列强，他会仔细思考中国的差距在哪里，进而发展洋务运动，希望用工业现代化来改善国家的经济实力和军事实力。 独立思考的能力，在创业公司非常重要。创业中，我们很多时候面对的困难都没有案例参考，这个时候每种做法肯定都各有优劣。如何平衡和判断各种方案就显得尤为重要。 培养人才曾国藩在自己的幕僚体系内，做了大量的培养工作。实际上相当于他自己办了一个商学院，把有潜力的人才招进去培养。 曾国藩这个商学院也办得非常现代化。主要的学习方式并不是他一人讲，而是大家讨论，颇像现在的研究型学术机构。比如他会拿政治上的各种具体的案例交由大家提建议，从而考查这些幕僚的水平。曾国藩也会用一对一 “面援” 的方式进行单独辅导。 培养好人才之后，曾国藩就利用自己的影响力做保荐。根据这些人才的性格特点推荐好的岗位。李鸿章就是这样被他发掘并培养出来的。 有人统计，曾国藩的幕僚，最后出任出使大臣 5 人，军机大臣 2 人，尚书 2 人，大学士 2 人，侍郎 3 人，总督 16 人，巡抚 28 人。所以英国历史学家包耳格说，“曾国藩是中国最有势力的人，因为他死的时候，所有总督都是他的学生或者下属。如果他希望的话，他可能已经成为皇帝。“ 不但自己培养人才，曾国藩也帮国家制定人才战略，在他的建议下，清政府发展了留学生计划，送出上百名留学生出国留学，学习西方的科学知识。 小结曾国藩资质平平，但是靠着自己的做事方法，不断自省和累进，最终成为一代名臣。他做事情有自己的独到的思考和判断，在对太平天国的战争、剿捻战争、洋务运动、培养人才上都取得有辉煌的成就。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"物欲时代的终结 -《第 4 消费时代》","slug":"the-4th-custom-economy","date":"2019-06-23T14:21:13.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/06/23/the-4th-custom-economy/","permalink":"https://blog.devtang.com/2019/06/23/the-4th-custom-economy/","excerpt":"","text":"前言最近读完了《第 4 消费时代》，作者是日本的三浦展。 日本与中国同属亚洲国家，日本的经济发展整个比中国快几十年，一些国内现在正经历的事情，例如人口出生率下降，房价泡沫，老龄化等，在日本其实已经是历史了，所以了解日本的发展，多少对中国未来的发展也能有一些参考。 4 个消费时代作者是这么划分 4 个消费时代的： 1、第一消费时代。那个时代资源短缺，城市形成，人口正在往城市慢慢集中。但是消费品还不充足，产品批量化生产程度不高。 2、第二消费时代。工业化的发展，使得资源开始普及，洗衣机，冰箱，电视进入了百姓家里，小汽车的保有量迅速上涨。工业化的快速发展使得 GDP 也快速上升，平均增速为 9%（日本 1956-1973，中国 1990-2011） 3、第三消费时代。由于资源丰富，所以大家不再简单的满足于拥有，而开始重视个性化，品牌化，差异化。大家开始追求名牌，追求豪车，追求每人一辆车，追求各种功能的车（跑车、SUV 等）。同时大家更追求一些心理上的消费，例如：听音乐剧，旅游，运动健身，健康餐等。 4、第四消费时代。GDP 不再增长。人们的幸福观念也发生变化，不再追求贵，追求品牌。不再满足于炫耀自己的消费能力，而追求内心的满足，比如节俭、共享、环保。作者认为，无印良品就是第 4 消费时代的典型品牌。设计简约、排斥过度包装、强调文化、强调环保，而且（在日本）价格便宜。 整本书其实讲的就是人类在追求物质享受的不同发展阶段： 第一消费时代像农民，吃不饱，穿不暖。 第二消费时代像工人，终于可以过上温饱日子了。 第三消费时代像暴发户，这个时候就喜欢显示自己比别人有钱。跑车、豪宅、名包、名表，什么贵买什么。毕竟经历过苦日子，希望自己能多享受一点是一点。 第四消费时代像有家教的富家子弟，从小就没有经历苦难，又受到良好教育。和别人比谁有钱？多 Low 啊！这个时候，人家反倒追求节俭，追求慈善。 时代与人性书中有一句话道破了人性： 可以说，物质欲望带来的满足感仅建立在其未得到满足的阶段，一旦这种欲望得到了实现，那么在这一瞬间，满足感就会马上消失，人们就被这种极端讽刺的机制玩弄于股掌之中。 类似这种过犹不及的道理，还有很多。比如在以前吃不饱的年代，那个时候有吃的就不错了，根本不会想吃什么。而现在，我们可选的吃的多种多样，吃东西反倒成了一件发愁的事情。每天中午都犯愁，不但愁吃什么，而且还愁吃太多长太胖。 又比如以前获取信息的渠道只有电视报纸，每天大家就安心看新闻联播就行了，但是现在各种 App，各种公众号朋友圈的信息实在太多，于是大家不再渴求信息了，而是对信息感觉到焦虑了，大家会有意识地屏蔽信息，以减少信息的干扰。 小结第 4 消费时代总结了日本社会由于经济发展变化，而带来的人们的消费观念的变化，解释了不同消费时代人们的消费观念，以及与之配套的商业状况。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"品牌延伸的陷阱 - 读《定位》","slug":"positioning-book-summary","date":"2019-06-02T12:43:02.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/06/02/positioning-book-summary/","permalink":"https://blog.devtang.com/2019/06/02/positioning-book-summary/","excerpt":"","text":"序最近把一本很早以前看过的书又拿起来翻了一遍，这本书就是《定位》，作者是艾·里斯和杰克·特劳特。很多书重复看会有新的收获，以下是一些小结。 定位作者首先从心理学入手。他认为人们在认知一个品牌的时候，总希望用一个特别简单的词语来概括它。反过来也一样，对于一个具体的品类，人们总希望用一个产品来代表他。 比如: 人们会用可口可乐代表可乐这个品类，用麦当劳代表汉堡这个品类。想到奔驰车就是舒适，想到沃尔沃就是安全。 而《定位》觉得商业上应该通过分化，开创新的细分品类，然后成为这个品类的领导者。分化的方法就是寻找差异，别人做大你就做小，别人做便宜你就做贵。差异化的方法也包括做细分的人群，比如专注于男性（万宝路香烟）或者年轻人（百事可乐）。 差异化还有一个办法就是定义对手。比如方便面最早都是油炸的。大家认知上并没有关注到油炸这个概念。但是后来突然出现了非油炸方便面，一下子把自己和对手都定义了。 名字名字很重要，人造黄油这个名字就非常糟糕，因为 “人造” 是和 “天然” 对应的，而人们默认认为天然的更好，人造黄油有点假冒黄油的感觉。作者建议叫做大豆黄油。 从名字上看，大豆黄油和从牛奶中提取出来的黄油，给人的感觉都是天然的，类似植物油和动物油的差别。确实就没有人造的，假冒的这种感觉了。 中国企业在名字上更喜欢用具像化的名字（如用水果名，动物名，植物名）以及叠字，希望让用户更加容易记住品牌名。例如: 老虎证券，瓜子二手车，坚果手机，斑马英语，西瓜视频。 品牌延伸书里面说几乎任何品牌都不应该做品牌延伸的事情。比如讲到无糖可乐的时候，作者就觉得可口可乐旗下的独立品牌 Tab 更好，而无糖百事是一个糟糕的想法。但是我看现在在中国的无糖可口可乐，却是零度。Wikipedia 显示，Tab 被可口可乐公司改用作能量饮料了。 《定位》在书中列举了少量可以做品牌延伸的场景: 销量不大 竞争过于激烈 广告预算小 创新小 销售代表上门推销 书中的案例是 3M 公司，他们生产数千种销量很小的产品。 给自己定位书中 “给自己定位” 的部分颇具启发，揭示了大家给自己的定位应该基于市场，而不是基于自己。 对于自己来说，每个人都希望自己是一个全才。但是定位理论告诉我们，即使你是一个全才，大家也需要一个特点来认识和记住你。 所以，每个人的定位应该尽可能做到自己那个品类的最好。因为你其实在市场上和别人争夺职位。如果大家定位都一样，那么那个职位必然不稀缺，自然就竞争激烈。一个成功的定位，应该尽可能避免这样的僧多粥少的情况，让自己的竞争力越来越强。 我自己的独特定位是什么？技术人常见的发展有两个：一个是成为技术专家，一个是成为管理人才。我希望自己是一个懂业务的技术管理者。未来能不能做成业务负责人可能得看自己的努力以及机遇，但是至少可以是一个可以辅助业务负责人的技术管理者，不让技术成为拖后腿的部分。 小结我最近关于品牌与定位看了 3 本书了，分别是《定位》、《品牌的起源》、《商战》。自己的体会是： 品牌延伸首先要看场景，场景上需要是可以协同的。如果不能协同，就很难延伸。例如：拍照搜题和在线直播授课，协同性就比较差。社交和支付，本来也没有什么协同，但是微信搞了一个红包把社交和支付协同起来了。 品牌延伸其次要看延伸的市场是不是足够大，足够大的话，竞争对手直接做那个市场，在宣传和用户心智上，别人的品牌都更占优势。这个时候就不要延伸了。 品牌延伸也要看用户的心智。如果用户的心智已经把你定位成某一个特别的品类了。品牌延伸可能让用户感觉到迷惑。 小结来说，就是场景不能协同、市场足够大、用户心智足够专一的时候，都不要做品牌的延伸。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"分化的力量 - 读《品牌的起源》","slug":"the-origin-of-brands-book-summary","date":"2019-05-08T11:13:30.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/05/08/the-origin-of-brands-book-summary/","permalink":"https://blog.devtang.com/2019/05/08/the-origin-of-brands-book-summary/","excerpt":"","text":"最近读完了艾·里斯另一本书：《品牌的起源》。分享一些感受。 一、分化的力量作者借用了达尔文的物种进化的学说，用以类比品牌的形成。物种演化到一定程度，就会出现分化。比如猫科动物，在进化过程中，分化出了狮子、老虎、豹子。 每种分化的动物，都有着自己的特点。这些特点成为它们生存的优势。同时这些优势也是它们的劣势：它们只能在适合的环境中生存。比如豹子适合在容易展开奔跑的环境，老虎适合在森林环境。 分化反映了专注的力量：专注于某一特点才能有优势。 分化又同时反映了局部的力量：少即是多，局部大于整体。什么都做的公司很可能什么都做不好。 二、融合的陷阱为了证明分化是好的，作者又讲了一下融合的不好。 作者认为把多个功能融合到一个产品中，解决方案通常都很糟糕。融合多个功能在一个产品中，除非起到协同的效果，否则用户就不会买单。什么叫协同效果呢？比如在手机中融合拍照功能，因为这样更方便把照片发给别人了，就有协同效果。 我想起一个反例就是锤子工作站曾经提到一个功能是：可以把手机插到电脑里，就可以直接把手机当作 CPU 和存储办公。这就是融合了手机和 PC 的一个产品。但是这个产品应该是不成立的，因为云盘（共享存储）可能是一个更好的同步数据的方案。而共享手机 CPU 算力这件事情并不带来多少经济上的价值。 三、市场规模的困境市场规模有多大？这个是投资或创业常见的逻辑。但是作者说，这对于打造一个新品牌来说，并不合适。因为一个新的品牌机会并不存在于既有的市场，而存在于创造出来的新市场。 最佳的情况是，你发现新的市场现有的规模是零。这样你就可能成为这个品类的开创者，从而形成品牌认知。 作者举了可口可乐的例子（开创了可乐这个品类），麦当劳的例子（开创了汉堡这个品类）。 四、心智的力量开创一个品类，不是说要第一个做。而是说要第一个占据用户的心智。如果你仅仅是最早做的，但是没有形成品牌，没有人知道，那也不行。 有两个因素使得占据用户心智的产品具备优势： 1、用户天然认为，领先的品牌「肯定比别的品牌好」。第一个进入心智的品牌自然就是领先的品牌。但是客观说，这个逻辑并不正确。比如《商战》中就提到，麦当劳和可口可乐的盲测都显示，用户更喜欢竞争对手汉堡王和百事可乐的产品。但这只是盲测，贴上品牌标签之后，心智的力量就开始发挥作用了。 2、用户认为，第一品牌代表着正宗，别的品牌都是模仿品。用户天然对模仿者都会怀有疑问。 举个例子，猿题库已经在高中生用户中占据领导地位了。这个时候你的产品名字如果也叫 “X 题库 “，大家认知上就会是「又一个题库」，「又一个模仿者」，那还不如叫别的名字。猿题库火了之后，市场上出了什么易题库、砖题库，最搞笑的还有一家叫鸭题库，我也是醉了。 五、取名的原则作者认为，如果你在开创一个新的品类。那么取名的时候，需要分别考虑品类名和品牌名。例如：红牛能量饮料。红牛是品牌名，能量饮料是品类名。 用户在消费的时候，买的是品类，而不是品牌。比如：要买「驾驶感好的车」，就会选宝马，要买「安全性第一的车」就会选沃尔沃。本来买「乘坐舒适」的车会选奔驰，但我估计因为前一阵子出了引擎盖上奔驰女哭诉维权的事件后，这个品类认知很可能会变化。 六、更多的思考该书过于强调企业的成功和失败与品牌定位的直接挂钩，我认为太过于主观，因为商业竞争还是非常复杂的，很难说仅仅用定位理论就可以解决商业竞争的所有问题。 比如作者认为苹果 PC 应该放弃通用市场，苹果在这场战争中已经输了（P188）。但是现在，苹果笔记本日子其实过得并不差。 另外，我认为这些理论很难被科学证实，这使得当前的商业环境，还是同样有很多同一品牌，多个品类的商业现象产生。 比如小米，雷军显然是商界的成功人士，但是他就用小米这个品牌多了很多产品，比如小米充电宝，小米手环，这些最终都做到了行业出货量第一。按照艾·里斯的理论，小米应该每个产品都有一个品牌名才行。 又比如美团。除了猫眼外，美团用这个品牌名，做了美团外卖、美团打车，打算把膜拜改名为美团单车，最近刚刚好象又开了一个美团配送。清华毕业的王兴，难道没有听过定位理论？但是美团做得并不差啊。 你可以说这都在美团「生活服务」这个大定位下，但是为什么配送就一定是生活服务的一环？为什么配送就不能是一个独立的，像闪送一样的品牌名？为什么猫眼就不能看作生活服务的一环？ 显然，这些事情很难科学的论证，更多的时候可能就是具体案例具体分析。 不过说回来，之前看刘润讲到商业的 4 种护城河： 1、专利或特许授权 2、网络效应 3、规模效应 4、迁移成本 我觉得品牌心智可以算作第 5 种护城河。 以上。这是今年读的第 8 本书。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"商业竞争中的战争策略 - 读《商战》","slug":"marketing-warfare-book-summary","date":"2019-05-01T11:05:02.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/05/01/marketing-warfare-book-summary/","permalink":"https://blog.devtang.com/2019/05/01/marketing-warfare-book-summary/","excerpt":"","text":"一、序言最近在读完了《商战》，作者是艾·里斯和杰克·特劳特。本书从战争的角度来解读商业竞争，将商业竞争分成四种战争类型，分别是：进攻战、防御战、侧翼战、游击战。 在每种商业竞争类型下，作者解读了企业应该采用的竞争策略。在后半部分，作者又引入了可乐、啤酒、汉堡、计算机等领域的案例，用于佐证自己的观点。在书的最后，作者讨论了战略与战术的关系，以及一个好的商业领袖应该具备的品质。 以下是我的读书笔记，分享给大家。 二、战争的两大基本原则作者首先介绍了两大战争的基本原则： 兵力优先原则。战争需要集中优势兵力，以多打少。 防御优势原则。防守的一方，可以占据更多优势。 有意思的是，如果你看《孙子兵法》，里面讲的也是同样的道理。孙子兵法一直强调的都是要打仗要以多胜少，而不是很多人误以为的以少胜多。甚至孙子兵法认为，只有你确定你能打胜，你才打，打不赢的仗打都不要打。怎么样才能不打？不就是躲起来防守么。 下面我展开介绍一下两个原则。 1、兵力优先原则假设交战双方，红方 10 个人，蓝方 5 个人，打完之后，是不是胜的一方变成了 10 - 5 &#x3D; 5 人，败的一方变成零？如果你这么想，你就错了！战争不是这么计算的。 我们假设交战双方，每次交战都是双方同时出拳，每 2 次出拳可以打倒一个人。那么红方 10 个人一次出拳就可以击倒 5 个人，而蓝方 5 个人一次出拳可以击倒 2.5 个人。所以交战下来，最后是红方剩 7.5 个人，蓝方 0 人。从损失看，红方损失（2.5 人）只有蓝方损失（5 人）的一半。 这就是兵力优先的力量。你用较小的损失，换来了敌方相对较大的损失。 做企业也是这样，你的资源是有限的，应该集中在你的优势领域和对方发起竞争。 2、防御优势原则战争中，防御的一方会额外占有优势。 还是刚刚的例子，红方 10 个人，蓝方 5 个人，但是蓝方是防御的一方，所以考虑到蓝方可能有战壕，碉堡之类的防御建筑。红方 4 次出拳才能击倒一个人。那么这样交战下来，最终红方需要损失更多人，才能攻下蓝方。感兴趣的朋友可以计算一下。 三、四种战争书中介绍了进攻战、防御战、侧翼战、游击战。 1、进攻战作者认为行业的第一名不应该进攻，而应该防御。进攻者应该是行业第二名及以后的公司。 然后，进攻者应该着眼于行业第一名的强势中的弱势进行攻击。什么是强势中的弱势呢？ 比如：可口可乐强调自己老牌，正综。百事可乐就强调自己是新一代，变革。于是年轻人可能就会被影响，年轻人为了凸显自己和老一辈不一样，就可能会选百事可乐。事实上，百事可乐的这个战略确实起了很好的效果。 又比如，麦当劳说自己是最老牌的汉堡。汉堡王就说自己的新式的汉堡：烧烤制作非油炸，专门和第一名对着干。麦当劳当时压力山大，还和汉堡王因为这个发起了诉讼。 2、防御战防御战是给行业领先者准备的策略。简单来说就是针对竞争对手的攻击，进行合理的快速回应。因为行业领先者有着更好的规模、品牌、资源优势。所以只要调整得及时，就可以化解掉竞争对手的攻击。 书中举了强生公司生产的镇痛药：泰诺的故事。当时泰诺的竞争对手百时美谋划做一个比泰诺更便宜的药。但是他们的竞争策略被强生发现，然后强生在百时美的药推广之前提前降价，瓦解了竞争对手的攻击。 作者认为最好的防御是自我颠覆。书中举了吉列刀片的例子。吉列不停地颠覆自己推出的刀片，使得竞争对手很难从核心质量上超越自己。 3、侧翼战侧翼战是指利用创新，开创新的不起眼的市场。同时乘对手没有反应过来，迅速扩大。侧翼战有点类似颠覆式创新，虽然成功率很低，但是一旦成功，还是可能做得很大。 打侧翼战要首先做到保密，因为你希望是打一场突袭，如果对手提前知道，就无法突袭了。其实，侧翼战尝试成功之后，追加筹码很重要，抓住机会后要扩大战果。不然就被别人迅速跟进，把市场抢走了。 书中举了一些侧翼战的方式，例如：低价、高价（高价更优）、小尺寸（实物商品）、大尺寸（实物商品）、渠道、特性、热量（食品）。在案例上，书中举了大尺寸网球拍、瘦身餐等例子。 作者特别地认可「高价」这种侧翼战。他认为几乎所有行业都有高价侧翼战的成功案例。比如汽车、啤酒、银行、飞机、手表等。 侧翼战是一场赌博，要么全胜，要么完败。市场调研通常无法对侧翼战提供帮助，因为顾客根本无法判断自己的真实意图。 4、游击战游击战是指找到一块小得足以守住的阵地。在这个阵地里，还是要实现相对兵力优势。然后吃这一小块市场的利润。 从地理位置上看，做区域市场是达成该目标的常见做法。也可能是深耕某个窄且深的领域，比如某个垂直领域。 常见的游击战的方式：在区域、行业、产品、高价中做出选择。 作者认为，大多数公司都应该做游击战。书中是这么写的：100 家企业中，只有 1 家应该打防御战，2 家打进攻战，3 家打侧翼战，剩下 94 家都应该打游击战。 四、关于竞争的误区关于竞争，很多人会误以为：是产品本身的质量成就了行业第一，然后就会全力在产品质量上发力。其实这种想法忽略了竞争。在有竞争的情况下，竞争对手也会在质量上发力，如果你的产品优势不是明显地大于用户迁移产品的成本，否则就无法产生竞争优势。 在书中，作者举了麦当劳和可口可乐的例子。麦当劳内部的机密文件中提到：民意测验表明，汉堡王的质量比麦当劳高很多。百事可乐的盲测也表明，大众更喜欢百事可乐。但是这对竞争并没有产生显著影响。反倒是可口可乐改良口味差一点害死了自己。 产品只是承载战略的工具，单纯的更好很难长期做到，即便做到也不一定能产生竞争优势。 五、关于战略与战术我读的上一本书《光环效应》也提到了战略。《光环效应》的作者认为：不能执行的战略不是好战略。 在本书中，作者换了一种说法，叫做：战略服从战术，但是核心观点类似。因为好的战略应该结合自己的实际情况，使得具体的战术可以实现「兵力优先」原则。 为了做到这一点，作者认为战略应该至下而上。好的军事战略家，都是从学习战术开始的，比如拿破仑，最早是一名炮兵，所以他懂得发挥炮火的机动性，在尽可能近的范围内集中火力。克劳塞维茨的战略思想，也是来自于他多次亲身的战斗经验。 举一个在线教育的例子，我认为当前行业中夸大 AI 的在线教育产品，就是一种在战略上逻辑成立，但是在战术上没有实操性的决策。比如 aiKid，松鼠 AI，葡萄智学，以及国外的 Knewton。不可否认他们的产品中结合了 AI，但是真正要成为成功的商业产品，在战术层面上还有很多障碍需要解决，有一些障碍甚至是 AI 本身带来的。 六、商业领袖的特质书的最后讨论了一下好的商业领袖应该具备的素质： 灵活性。能够分析自相矛盾的情报。能够让战略适应形势。 运气。又一次和《光环效应》的观点相呼应。不过本书中强调要及时认输，快速投入下一次战斗。 七、小结《商战》从战争的角度解释了商业竞争的策略。大部分的策略偏战略和定位。我自认为这本书可以当作《光环效应》中战略部分的补充。 但是，我并不认为所有的商业活动都必须以竞争当作第一思考要素。因为很多时候，企业的核心竞争力还是来自于自己对市场、对产品、对运营、对技术或 AI 的理解。 这些理解从商业竞争上来说，可能短时间是可以被模仿的，但是长期来看，理解本身才是最重要的，否则模仿也可能走样。 就酱，这是今年读的第 7 本书。祝大家五一节快乐！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"揭秘企业成功之道 - 读《光环效应》","slug":"the-halo-effect-book-summary","date":"2019-04-24T16:21:26.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/04/25/the-halo-effect-book-summary/","permalink":"https://blog.devtang.com/2019/04/25/the-halo-effect-book-summary/","excerpt":"","text":"序言最近看了一本老书：《光环效应》，对于商业公司的成功之道，稍微多了一些信息。 为什么说只是 “稍微多了一些信息” 呢？这是因为《光环效应》大部分内容是反驳商学院或者顶尖咨询机构的一些商业成功总结，包括《追求卓越》、《基业长青》、《从优秀到卓越》书中的观点。 在反驳完这些书中的观点后，《光环效应》也用少量篇幅介绍了他认为的商业成功的关键，但是由于其观点是整个将商业成功的原因解释为 “一定风险下的概率事件”，使得这个观点既无法证真，也很难证伪。 本书被《思考快与慢》引用，也被一些商学院当做 MBA 教程，我最大的收获就是本书反复强调的 “光环效应”，下面分享总结给大家。 什么是光环效应所谓光环效应，就是人们在评价一个人的时候，倾向于认为厉害的人各方面都厉害，差的人各方面都差。 这个现象最早是在第一次世界大战期间，被美国心理学家爱德华·桑代克（Edward Thorndike）发现的。一次调研中，他要求军官从智力、体力、领导力、性格等方面给士兵打分。结果让他大吃一惊，在军官的眼中，相貌堂堂的士兵被认为射击百发百中，内务优良，多才多艺。桑代克把这个现象称为 “光环效应”。 但是，显然这种判断是不太科学的。爱德华认为这是人类心理上创造并保持一幅连贯图景的方式，并借此降低认知失调。 《追求卓越》1977 年，著名的咨询公司麦肯锡开展了一项组织结构方面的研究。他们的问题非常宏大：为什么有的公司比别的公司更成功？ 然后麦肯锡研究了美国的 43 家优秀的公司，最后得出了成功公司的 8 条属性： 崇尚行动 贴近顾客 自主创新 以人助产 价值驱动 不离本行 精兵简政 宽严并济 作为强调定量分析的麦肯锡，声称收集了海量数据。详细的报表让人以为这些分析都是基于客观数据做出的。 但是，最终作者发现这些所谓的成功公司经不起市场的考验。在《追求卓越》出版后的 1980 ~ 1984 年，作者分析了这 43 家公司的业绩，发现有 23 家的增长不及标普 500，很显然这些优秀公司并不是一直优秀着。 作者认为，造成这种分析错误的原因是： 光环效应。他们收集到的大多数数据受当时环境的影响，都是正面的。 没有对比。他们并没有对照成功公司和失败公司经营上的差异。 美国的文化还比较开放，在 2001 年《追求卓越》的作者彼得斯承认：定量的数据分析是在已得出结论之后才进行的。算是彻底承认了这本书中观点是不客观的。 《基业长青》《基业长青》是另一个类似于《追求卓越》的故事。《基业长青》的作者还是来自麦肯锡，另一个联合作者来自斯坦福商学院。 《基业长青》吸取了前者失败的教训，首先他们进行了对照分析，不止分析成功的公司，还分析失败的公司。最终该书在 1994 年出版。书中总结出来的成功公司的原则看起来也很合理： 用坚实的核心理念指导公司的行为和决策 建设浓郁的企业文化 设立能激励员工奋发向上、超越自我的目标 帮助员工由内而外的进步发展 培养勇于尝试和冒险的精神 力争卓越 你看这些都非常符合常识，都是关于员工、价值观、文化的观点。《基业长青》在当时畅销了 18 个月。 但是，接下来的发展类似，随后的 1991 ~ 2000 年 10 年间，被《基业长青》称道的 18 家优秀公司，只有 6 家能和标普 500 指数持平。有意思的是，作为对照组，却有 6 家超过了标普 500。原本优秀的公司变得不优秀了，不优秀的公司反倒优秀了。 作者引用经济学家熊彼特在《资本主义、社会主义与民主》中的观点，认为竞争的存在，就是会使得某个公司不可能持续辉煌。原因是：在自由市场中，竞争对手照搬辉煌公司的制胜方式，新公司进入市场，咨询公司让最优行为遍地开花，员工又在公司间自由流动，这些被经济学家称为” 模仿、竞争、侵占的腐蚀性作用 “，使辉煌的业绩表现出衰退。 本书后面还举了两个类似的研究报告《4+2：什么对企业真正有效》和《从优秀到卓越》，但是现象都很相似：书中宣称的成功公司，并没有一直成功下去，书中的理论并没有经受过时间的检验。 优秀业绩的关健《光环效应》在书的最后，提出了自己的观点，他认为推动企业业绩发展的只有两个因素：战略和执行。 战略的核心其实是一种差异化竞争，所以独树一帜，产生有效竞争最重要。 执行就是贯彻做出的选择，调动资源来实现战略。 作者认为，那些产品品质、用户服务、培养人才这些不是不重要，而是这些仅仅是日常管理的基本工作，通常只是执行的一个环节。因为基本上每个公司都会注重这些，并不能构成有效的竞争。 然后，书中强调了风险因素，也就是我们常说的运气： 市场的反映总有不确定性。 竞争对手有不确定性。竞争对手的行动会影响战略的结果。竞争双方都要预测对方，这使得对方的出牌会影响你打牌的效果。你出剪刀，对方得出石头，你才算赢。 技术有不确定性。特别是我们所处的互联网行业，变化日新月异。腾讯如果不是因为抓住了微信，社交这个领域就被颠覆了。 内部不确定性。公司内部繁杂而微妙的关系，使得公司无法预测采取某一系列行为之后会出现怎样的结果。 所以《光环效应》最后把有效的战略看作是一种概率上的择优，即做一个有较大胜算的选择，但是结果是不是胜利，其实不确定。 不能执行的战略不是好战略我们常听到的一句话是：战略没问题，但是执行出错了。本书作者认为不能什么事情都怪执行出问题。 首先我们需要具象化执行，不能泛泛地谈更快，更好。而应该更细化执行的要点，比如提升订单合格率。让所有人知道执行的关键点。 然后，我们需要避免光环效应，把成功的公司归结为执行好，把失败的公司归结为执行差。因为这是最最省力，不费脑子的结论。如果不小心，就会变成借口，让我们失去获得真相的机会。 小结 从历史看，很多讲解企业成功之道的书都有鸡汤的嫌疑。 《光环效应》认为：战略和执行是企业成功的关键。 战略具有风险和不确定性，具体来自对市场、竞争对手、技术以及企业内部的不确定。 不要轻易把企业失败归为执行出错。 运气很重要，非常重要。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"互联网人才的成长之路：写在创业 7 周年","slug":"startup-anniversary-note","date":"2019-04-22T14:40:12.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/04/22/startup-anniversary-note/","permalink":"https://blog.devtang.com/2019/04/22/startup-anniversary-note/","excerpt":"","text":"前言在互联网行业工作快十年了，自己在猿辅导参与创业也马上 7 年了。自己始终想总结出互联网人才在成长上大的阶段，于是有了最近的这个心得。其实不一定对，但是也算是思考了很久，所以写出来供大家讨论交流。 不管是做产品、技术，还是做运营，市场，我把一个互联网人才的成长分为四级，每一级对应一类能力。 第一级：执行能力我对执行能力的解释是：对于比较明确的工作目标和内容，通过对目标进行分析，对步骤进行拆解，以及投入自己的热情和努力，加上一定的沟通和协作，最终可以保质保量的完成工作目标。 刚毕业的同学，不管是做产品，还是做技术，还是做运营，都是做偏执行的事情。这个时候，工作其实是非常具体的，不会需要你花很大的精力来做规化。因为有偏资深的人把关，这个时候其实也相对容易完成目标。 但是，我个人觉得至少有 80% 的人，在这一级能力上都是不太优秀的。为什么呢？因为做好一件事情真的非常难。它需要一个人具备： 对工作的努力和热情。 对工作的一些基础能力的积累。 自我情绪和行为控制，包括转移注意力、自我激励、延迟满足等。 沟通协调能力，包括认知他人情绪和处理相互关系。 以上四点都不容易： 有多少人真正的把工作当作自己的事情，并且投入足够的热情？ 有多少人在专业能力上做到的足够的积累？拿研发来说，学校学的数据结构、计算机网络、算法、设计模式这些课程，有多少人是真的是很扎实的？ 人很容易懈怠的，自我的激励并不容易。有多少人不需要领导盯着，自己天天抢着多做一些，多学一些？拿研发来说，下班之后有多少人自觉充电学习的？ 研发和产品，研发和研发，都是需要沟通配合的，很多研发在这一点上都偏弱。 所以，第一级能力，就挡住了 80% 的同学。 如果你做好了执行，恭喜你，你就是公司应届生里面那前 20% 绩效拿 A 的同学。你们可以获得超额的回报，并且可能获得晋升的机会。 但是，这仅仅是刚刚开始，让我们看看后面还有哪些能力需要积累。 第二级：迭代的能力我对迭代的理解是：它包括自我迭代和工作迭代，方法上都是通过：主动学习、主动复盘、关注数据和分析数据。通过这些方法，整理出工作或者生活的一些概括的规则、模型或方法论。 执行力虽然很重要，但是更重要的是背后的思考和总结，否则就是使用蛮力。任何事情，按理说你做久了，都应该通过总结，形成一些做事情的经验。最终这些沉淀下来的经验，才是你和别人竞争的优势。 迭代的能力听起来很容易啊，为什么我把它单独作为一级呢？ 因为这是一个听起来容易，执行起来很难的能力。 迭代能力做得好，首先应该例行化，一个人应该定期地做总结和反思。这就类似于 Scrum 将回顾会议（Retrospective Meeting）作为例行会议一样，让组织定期迭代。但是能够坚持按周、按月、按年总结反思的人还是偏少。最近一个朋友推荐《曾国藩传》，他说书里写道曾国藩按天为单位做自我反思总结，还把这些内容分享给周围的人，这就是人家牛逼的地方。 迭代能力做得好，也需要文档化。你应该用任何书面的方式把它记录下来，可以是纸质的，也可以是电子的（比如 Evernote 等）。《原则》、《卓有成效的管理者》等书里面都推荐了这个方法。因为文档化的内容，更方便做复盘和总结。文档化这件事情也很难坚持，因为相对来说比较枯燥。 举个例子：我现在觉得某支股票很厉害，买了一些它的股票。我如果把这些买下它的理由写下来。然后过了半年，假如这个股票跌了，那我就得看我当时的决策为什么不对。这相当于一条一条打自己的脸。如果没有文档化，这个事情就容易被糊弄过去，那我得到的总结就不够深刻了。 迭代能力之所以重要，是因为个人成长之路很多时候无法依赖于老师教，只能通过自我学习，而迭代总结就是最好的个体学习方式。 第三级：开放和组织能力开放能力是指：自我客观评价，并且愿意倾听的能力。组织能力是指：能够把一群人推动做好一件事情。 拥有前面两级的能力，已经是一个很优秀的职场人士了。但是这个时候就特别容易骄傲，比如： 总觉得自己特别牛逼。希望用自己的一些点子一下子带来竞争优势。 总觉得与自己合作的同事水平一般。比如产品觉得技术拖后腿开发慢，还老出线上事故。技术觉得产品老改需求，而且功能上线后并没有见到什么效果。产品技术觉得运营老是搞特别复杂的活动，不会做减法。运营老觉得技术支持不到位，总是说没资源排期。 总觉得竞争对手的策略都是失败的，同时认为自己的策略都很厉害。 自我客观评价，需要个体首先要对自己有一个清晰的判断，认知到自己的优点和短板。一个人战略能力强，关注细节的能力就差；一个人专业能力强，统筹业务的能力就差。不可能一个人各方面都是全才。因为很多事情，还是靠时间投入积累出来的，没有足够的时间积累，很难说自己就是这方面的专家。 自我能够客观评价之后，就会做取舍，放弃一部分东西，同时获得一部分东西。放弃这件事情其实很难，是反人性的。但是好多时候做企业定战略的时候，也是取舍，很多时候战略企业是结合自己的团队、现状等各种具体的情况做出来的取舍。 自我客观评价之后，也容易对他人进行客观评价了，既然看自己都知道看长处，那看别人也应该看优点。组织分工的时候，利用大家各自的长处，就容易形成合力。评价员工的时候，也应该看人家的长处，除非他的短处限制了他的工作产出，否则并不需要按短处来打分。比如：一个牛逼的程序员，但是很内向，只要这个不影响必要的沟通，否则他内向点就内向点呗，只要他的代码厉害，沟通上的短板影响不大。 自我客观评价的能力难点在于人都会高估自己，低估别人，所以需要多做自我提醒。一件事情如果别人思考得更久，但是结论和自己的不一样，就应该多思考一下再做判断。 能够做到自我客观评价之后，通常也就会注意倾听了。因为当前这种社会组织形式下，决策者在信息量上并不占优，所以只有足够倾听，获得足够的信息量，才可以获得高质量的决策。 说完开放能力，再说说组织能力。 组织能力，是一种招聘和培养核心班子的能力。在之前的能力级别，都依赖于自己更多，而在这个级别，依赖于别人更多。不管是做决策还是做执行，本质上你离不开别人了。如果最大化你的价值和组织的价格，是需要学习的。优秀的人可以通过培养，招聘，授权，聚焦，管理非常多的人和事情。 第四级：战略能力。战略能力是指：能够通过思考，产出高质量竞争策略的能力。所谓的高质量，就是从结果看能够产生商业竞争上的优势。 战略能力看起来简单，但实操无比困难。你得抵挡诱惑，决定做什么不做什么；你得构建有效的竞争手段；你得最终形成互城河。你的对手一点都不笨，你想得到的别人也想得到，你要假设面对的是一个完美对手。用最坏情况下，打明牌也能成功的方式来获胜。 也因为战略太重要了，所以初创公司的 CEO 值得拿超过 50% 的决策权和相关股份。当然，他也承担了企业最大的成败因素。因为战略错了，什么都错了。 我个人对战略能力的亲身实践非常少，但是我所在的猿辅导公司，从最初的从成人教育转到 K12 领域，到之后的专注在线直播课业务，都给我很强的感受：原来战略定得好可以这么厉害。我也希望在这方面能够持续学习提高。 小结 第一级：执行能力。 第二级：迭代能力。 第三级：开放和组织能力。 第四级：战略能力。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"戴维斯双击背后的故事 - 读《戴维斯王朝》","slug":"Davis-double-killing-effect","date":"2019-04-12T12:26:26.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/04/12/Davis-double-killing-effect/","permalink":"https://blog.devtang.com/2019/04/12/Davis-double-killing-effect/","excerpt":"","text":"一、序言作为一个对炒股知识孤陋寡闻的新手，我最近才听说「戴维斯双击」，于是买了《戴维斯王朝》了解了一下戴维斯本人以及他的成功故事。看完书后，我感觉戴维斯本人还真算是一段传奇经历。 戴维斯的投资回报率和巴菲特对等，他投资生涯起步很晚，30 多岁才靠老婆的 5 万美元的嫁妆作为本金开始投资，最后历时 47 年，把 5 万美元的本金增值到了 9 亿美元，资产增值约 1.5 万倍，年化复利回报率为 23.18%。 戴维斯和巴菲特虽然水平很似，但是他们的孩子和孙子却选择了不同的道路。巴菲特的孩子没有选择父辈的职业生涯，但是戴维斯不一样，他的孩子和孙子都在继续从事投资行业。戴维斯的孩子谢尔比掌管的基金，从事的 20 年期的投资，年化复合回报率为 19.9%，而且投资的领域和父亲基本上是不一样行业。书中也介绍了戴维斯的孩子和孙子在投资上的成长故事，其中不乏很多血亏的教训。 所以，我最后的收获到的是一些关于投资和育儿的理念，以下是一些总结，分享给大家。 二、复利复利是指：当你把投入本金获得的收益进行再投资后，多年以后这种利滚利的效果是非常惊人的。书中用几个故事强调了复利的概念。 故事一：72 法则。72 法则用另一个方式来解释复利。具体来说，当你得到一个投资的回报率数值后，拿 72 除以该数值，就可以快速估算出按照这个回报率算下去，多少年资产可以翻一翻。比如你的投资年化回报率是 10%，则 72&#x2F;10 &#x3D; 7.2 年后，你的资产就可以翻一翻。戴维斯 40 多年投资的年化回报率是 23%，所以 72&#x2F;23 &#x3D; 3.1，他平均 3 年资产就可以翻一翻。 故事二：有一天，戴维斯的孙子向爷爷要 1 美元买个热狗。爷爷严肃地说：“如果你将这 1 美元进行投资，每 5 年翻一翻（按14%年化收益率计算），那么等你到了我的年纪，50 年之后，这 1 美元就会变成 1024 美元。你现在有这么饿吗？” 这 1 美元的故事教会了他的孩子 3 件事情：1、金钱的价值 2、复利的价值 3、自己有钱的重要性。 复利的核心是每年增长，很多人炒股很厉害，可能刚开始年化收益很高，比如 50%，但是一但某一年亏个 50%，综合下来年化收益就低很多了。比如两年 50% 的收益率，一年 -50% 收益率，1.51.50.5 &#x3D; 1.1，3年下来整体收益才 11%，年化收益不到 4%，非常低。所以维持复利很不容易，需要守好安全线。 三、戴维斯双击首先解释一下什么是「戴维斯双击」，我们知道：股价（PRICE） = 每股盈利（EPS） x 市盈率（PE）。在不同的阶段，对于同一家公司，市场会给出不同的 PE。 当公司发展好的时候，每股盈利会上升，同时因为大家预期未来还会保持这样的增长率，所以 PE 也会上升。股价就会出现「戴维斯双击」的效应。 举个例子：如果一个公司盈利 1 美元，PE 为 10 倍。如果公司发展很好，盈利提升到 2 美元，这个时候市场预期未来可能保持这个增长，PE 上升为 20 倍。这个时候股价就会从原来的 10 元上升为 40 美元，这就是「戴维斯双击」。 如果公司盈利下滑，同时会造成 PE 下降，就会出现反向的作用，这称为「戴维斯双杀」。 光听这个理论不直观，书中列出了一个具体的案例，我看完还是非常吃惊的。让我们来看下图的例子。 两支股票，一支是利润增速为 30% 的高成长股，另一支是利润增速为 13% 的低成长股。但是一家公司不可能长期都是以 30% 增速一直成长，最后它在第 6 年增速降为 15%，这其实非常合理。 大部分人都喜欢买高成长的股票吧？但是你看，如果你在第2年买入，在增速降下来那年卖出，因为戴维斯双击，当高成长的股票不能维持 30% 增长的时候，它的市盈率也会跟着降，所以如果你最终的年化收益才 6.7%。 而如果你买那支只有 13% 增长，市盈率只有 10 倍的股票，因为它一直稳定增长，最后市盈率还有可能上升到 13。这样 5 年之后可以做到 20% 的年化收益。 这个例子对我还是很警醒的，因为互联网行业的股票都是高增长，高市盈率的。如果你把握不好，遇到增长放缓，市盈率降低，就会亏得非常惨。我个人在某支股票上，就交了几万块钱的学费。希望这个例子也能帮到各位关注互联网行业的同行。 四、研究事情的本质其实投资的收益，来源于对于价值判断与主流判断的差异。如果你和所有人都认为一个东西便宜，那么市场的作用，就会使得这个东西的价格上升到合理的位置。所以，只有当大众都认为一个东西贵，但事实上这个东西其实便宜，而你又发现了这个事实，你才可以挣钱。 要与大众的认识产生差别，就需要独立思考，研究清楚一件事情的本质。并且认知到大众为什么产生了这样的差别，什么时候这种差别可能被消除，这样就可以挣钱了。格雷厄姆也在《聪明的投资者》中说：要获得持续高于市场平均水平的回报，需要投资的标的在华尔街并不风行。 从书中，我发现戴维斯就具有这样的研究事情的本质性格。当很多人都不看好保险公司的时候，他发现保险公司其实会在财报中尽可能合规地显示出自己经营得很惨。因为保险会计是为了让政府监管机构满意而设置的，而不是为了向潜在投资者提供信息。就像一个金矿矿工去索赔的时候，特地穿得很破烂，以免引起他人的嫉妒。 戴维斯又很仔细地分析保险公司的投资收益，保单的风险等。然后他把他看得上的美国的保险公司全部投了一遍，之后又把日本的优秀的保险公司又投了一遍。后来，他的收益主要就来自这些公司持续几十年的价值上升。 五、安全边际一家公司再好，也得价格便宜才行，安全边际很重要。我在这一点上交了不少学费。在书中，戴维斯也会非常注重安全边际，他是这么做的： 戴维斯对于出现的机会采取非公开市场的估值方法进行大致的评估。对于戴维斯而言，他想买的保险公司的股票在他心中的估值，必须远远高于市场给出的价格。 六、如何处理资产和教育孩子在养育这一点上，戴维斯和巴菲特非常类似，即给予孩子仅仅够基本生活和教育的钱，别的钱都捐掉。因为他们希望孩子在长大成人的时候，具备独立的人格，免于金钱的毒害。戴维斯认为，孩子能够在经济上独立自主，并且量入为出，用自己的余钱进行投资，自己利用复利挣钱，才是最好的教育。 戴维斯因为这个观点，还使得他和孩子们产生了一段被媒体曝光的故事。故事是这样的：戴维斯希望只能孩子仅够基本生活的钱，别的钱都捐掉，所以在 1940 年左右，他给每个孩子办了 4000 美元的信托。结果，这个信托他管理得太好了，20年之后，4000 美元变成了 380 万美元！戴维斯觉得 380 万美元太多了，然后就要求他的孩子把这个钱给捐掉。但是他和孩子沟通得特别不好，结果孩子刚开始没有答应，戴维斯就把这个事情曝光给媒体，把孩子描述成贪图钱财的小人，但他的妻子却站在孩子一边，认为是戴维斯的沟通问题。当时戴维斯已经是名人了，媒体和吃瓜群众也对这种事情怀着八卦的心态。最后经过长久的争吵以及媒体的跟踪报道，最后每个孩子从信托中得到 100 万美元，别的全部交还给了戴维斯。 这件事情也使得戴维斯和他的孩子关系特别差。 全书中有多处细节都显得戴维斯某些时候情商还是偏弱，除了和孩子相处的结果偏差之外，他还因为巴菲特救助盖可保险的价格偏低而抛售了所有盖可保险，这也成为他晚年一直后悔的事情。 七、小结今年读的第五本书，小结一下： 保持持续赢利，以便复利增长 警惕互联网高增长公司的「戴维斯双击」 研究清楚事情的本质，从认知差异中挣钱 价格很重要，给自己留够安全边际 教育孩子人格独立，别给孩子花不完的钱，够他基本生活就行，更多的钱得他自己挣","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"华为的 OKR 实践心得 - 读《绩效使能-超越OKR》","slug":"okr-exp-from-huawei","date":"2019-03-29T12:19:04.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/03/29/okr-exp-from-huawei/","permalink":"https://blog.devtang.com/2019/03/29/okr-exp-from-huawei/","excerpt":"","text":"引言华为是一家非常努力的公司，我身边在华为工作的朋友，都说华为的工作强度非常大。华为不光努力，它在创新上的投入也非常巨大。在全世界的研发投入排名中，华为以 113 亿欧元名列中国第一，世界第五。BAT 与之相比，连世界前 50 的排名都进不了。 看完《绩效使能》，我发现华为不只在技术上创新，也是一家在制度上不断创新的公司。华为从 2015 年就开始尝试 OKR，并且建立了自己的 OKR IT 系统。在本书中，在华为工作 13 年的作者 况阳 为大家系统性地介绍了 OKR 的发展背景、深度解析、以及实操的经验。 以下是我的一些读书心得。 KPI 是魔鬼虽然 OKR 和 KPI 是两个概念，但是很多人认为这两者是替代关系。实际上前者是目标管理方法，后者是绩效管理方法。不过，不得不说，OKR 的出现，多多少少是由于 KPI 实在是不符合现在社会的发展了。《绩效使能》全文转载了索尼的前常务董事的文章《绩效主义毁了索尼》，我第一次看一家公司的董事，站在历史的长河上回顾索尼的衰败过程，既感慨又遗憾。 在未来，除非是非常可量化、非常具体的执行工作，可以尝试 KPI。大部分工作应该都不适合使用 KPI 来进行管理。 动机图谱作者在书中介绍了动机图谱，用于阐述 OKR 相比别的管理方法的优势。动机图谱将一个人做一件事情的理由，分成三个大类：即动机匮乏、外在动机、内在动机。进而将绩效管理落到不同的动机层次上。 我介绍一下上面提到的几种调节类型： 调节匮乏。比如在一家 KPI 管理的公司里，一个团队已经很忙了，这个时候别的团队过来寻求帮忙。因为他的 KPI 与这个帮忙并不相关，所以即便他觉得这个忙有意义，但是给他的绩效并没有直接好处，就可能表现出动机匮乏，而拒绝支援。 外部调节。如果一个行为完全被外部的奖励或惩罚驱动，这个行为就处于外部调节动机状态。 内投调节。自己不这么做，就会有压力。比如一家公司有加班文化，那么不加班的员工就会有压力。 认同调节。大家内心认同一件事情的价值的时候，就属于认同调节。但是虽然大家有自主做事意愿，但是个体并未能将它同个体的其它意愿有机整合成一个整体。比如工作和家庭，个体可能都觉得重要，在冲突的时候，就会觉得矛盾。 整合调节。认同调节的升级版，即把自己的各项认同的事情能够整合到一起。表现出来就是极少遇到冲突和矛盾。 内在动机。核心是个体觉得一件事情有趣，乐在其中。但是内在动机容易受到外在动机的影响。 书中也介绍了一个评测量表，用于测量工作对于人的调节，是处于什么类型。我自己做了一下，得分最高的是外部调节和内在调节。 作者也介绍了对于个体来说重要的 3 种关系，分别是：自主、胜任、（社会）关系。当这三种心理得到满足的时候，就会激发出个体最大的热情和动力。游戏在这方面的经验也比较多，游戏理论中提到的心流，就是一种自主和胜任结合的状态。 我们可以看到，作者把 OKR 归类在认同调节。因为 OKR 的内容是团队自主讨论来制定的，容易被团队成员认可。 OKR 实施在 OKR 实施环节，作者提出了 OKR 周报的概念。我个人觉得以周为频率过于频繁。不过我从 OKR 周报中还是学习到了一个不错的实践方法：把 OKR 的进展进行及时的记录。以下是书中的示例。 表格中的“最新进展描述“非常有用，有助于我们及时了解到 OKR 的完成进展。我个人觉得这个状态栏比起《OKR 工作法》提到的四象限画布(下图）更加合理。 我的个人 OKR 实践任何一个工作法，要在全公司推进起来都不容易，我在实践中发现，仅仅将 OKR 用于个人目标管理，也都可以发挥不错的效果。于是，我就自己拿 Numbers 做了一个表格，列下来自己每个季度的工作目标，以及关键指标。接着在状态栏里面，以一定的频率来更新状态。 我在一个目标完成后，会再加一栏”小结“，最终形成一个复盘的闭环。实践下来，我感觉非常好用，自己的多目标管理在这个方法下非常清晰。 以下是一个具体图示，虽然基本上全涂抹掉了，但是我想大家能看出来核心的框架： 小结《绩效使能》是一本从华为实践 OKR 中总结出来的实操手册。不但包括一些历史和理论知识，也包括不少实践的实操心得，是一本很接地气的书，推荐给大家！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"稻盛和夫的《成功的真谛》","slug":"the-battle-of-dao","date":"2019-03-20T12:16:18.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/03/20/the-battle-of-dao/","permalink":"https://blog.devtang.com/2019/03/20/the-battle-of-dao/","excerpt":"","text":"最近看了稻盛和夫的《成功的真谛》，稻盛和夫是一位商界传奇人物。他成功创办了两家世界500强的企业，并且在退休后，复出拯救了濒临破产的日航，仅用一年时间，把日航从亏损做到了利润 2000 多亿日元。 看日本企业家和美国企业家的书，明显能感受到两种文化的差异。日本企业家常常会讲努力，讲刻苦，讲道，讲价值观。而美国企业家更多的讲自由，讲创新，讲平等，讲客观，讲科学。但是，两种不同的文化，都造就出了伟大的企业。 我看完这本书，感受到的是：现实世界是由不同意识形态，不同价值观，加以竞争，通过自然选择构建出来的结果。 打个比方，如果世界上大部分成功的企业，都是靠价值观来成功的，或者在总结成功要诀的时候，觉得价值观是第一要素。那么就会带动更多新成立的企业模仿这些成功的企业。所以，最终全球成功的企业由什么样的企业构成，就决定了主流的意识形态和价值观。 而意识形态的变化，也与社会生产力发展的速度相关。 比如工业革命的时期，泰勒发明的科学管理，把人当作生产线上的螺丝钉，虽然不人道，但是由于效率更高，成为主流的工业企业的组织形式。 在互联网时代，由于信息爆炸，变化太快，企业的形式又变成了强调个体的主动性，积极性，创造性。企业的组织形式又超着扁平化在发展。 稻盛和夫的经营企业的价值观，令人佩服。他在书中提到，他是为了打破日本电信的垄断，降低人民的通讯费用，才决定创业做当今日本三大电信业者之一的 KDDI。最终他在这个事业上投入了超过 1000 亿日元。当然，KDDI 也非常成功，为他挣了很多钱。 我个人很佩服他这种从人民幸福角度做创业的决策方式，但是我却学不来。我学到的更多是从需求角度来思考，从利润的角度来思考，我相信稻盛和夫也做了这方面的思考，但是我确实学不来他的思考的源动力：社会福利。 稻盛和夫信佛，他在《成功的真谛》一书中，把工作的结果用一个公式表示：人生工作的结果 = 思维方式 x 热情 x 能力。进一步，他用佛教的理论「六波罗蜜」来阐述思维方式。包括： 布施。利他之心。 持戒。压抑欲望。 精进。努力工作。 忍辱。勇敢面对困境。 禅定。打坐静心。 智慧。书中未展开介绍。 历史不可重来，我不知道稻盛和夫如果没有这些高尚的价值观，仅仅只是带着普通的道德水准，遵守法律，努力工作，是否可能成功。我感觉这是两种价值观的冲突，一种是强调主观的力量，一种是强调客观的力量。一种强调精神上的自信可以必胜，一种强调任何事情都需要符合客观规则才可以存在。 当前社会，对信仰的坚持，看起来是越来越少了。 我其实很希望每个企业都拥有稻盛和夫这样的企业责任和价值观，但是我更相信科学和竞争，只有这样的企业被世界主流认同，从而获得竞争优势的时候，这样的一天才可能到来。 对于个体来说，拥有更高的道德水准，也许在某些具体事情上吃亏，但是我觉得整体还是会更加幸福和成功。所以我对个人的道德发展相比企业的道德，更有信心一些。 很薄的一本书，推荐大家读一读~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"如何具备批判性思维？- 读《学会提问》","slug":"asking-the-right-questions-book-summary","date":"2019-03-07T15:46:02.000Z","updated":"2024-01-06T14:52:37.935Z","comments":true,"path":"2019/03/07/asking-the-right-questions-book-summary/","permalink":"https://blog.devtang.com/2019/03/07/asking-the-right-questions-book-summary/","excerpt":"","text":"序言最近读完了 《学会提问》，我读这本书是看到俞军在产品经理必读书目里面推荐。刚开始我以为这是一本介绍提问时沟通技巧的书，结果打开一看，原来是介绍批判性思维。 记得前年看过一本书叫《如何阅读一本书》，里面就提到阅读非虚构作品的时候，分析作者的论点、论据、推导过程，就是读书最最关键的步骤。 而《学会提问》一书，基本上算是把这个观点衍生展开讨论，从而更加详细。 《如何阅读一本书》里面，把阅读材料中的错误分为三类： 1、逻辑错误。论据没问题，但是推导错误，所以推出了错误的结论。 2、知识错误。论据有问题，推导没问题，这样也推导的出错误的结论。 3、知识不足。论据和推导都没明显的错误，但是论据的数量或者效力不足，所以无法支持最后的结论。 作者在书中是这样说的：「如果你不能用相关证据显示作者是知识不足、知识有误，或不合逻辑，你就不能反对他」。 而到了《如何提问》一书，作者将批判性思维的框架类似地划分成：结论、证据、推导、假设。然后按章节展开讨论。 本书特别有意思的是：因为本书提供了特别多的案例，所以我们其实可以利用这些案例，来欺骗那些批判性思维弱的人。在稍后的案例中，我们可以看到，其实商业中的大量营销页面，其实就利用了大量这方面的技巧，很多营销页面从批判性思维角度，论证的说服力极差，但是挡不住这样的页面效果极好。某种程度上，这也证明了人们普遍对于批判性思维的缺失。 可以影响情绪和倾向的语言这种语言在国外的政治演讲中常常出现，一个政治主张，加上一个恰当的语言，就可以影响广大的群众。 举几个例子：全球变暖和气候改变，哪个词会让你觉得威胁更大？调查发现全球变暖明显会引起人们对环境的关注。 税收宽免和税收减免，其实意思都一样，但是书中说：美国人对税收宽免的反应更为积极。 死亡税和遗产税，人们更愿意消减死亡税。或许人民觉得死亡已经是不好的事情了，这个时候再收税其实内心觉得过意不去。但其实本质上，两者是同一个东西。 这些具有情感色彩的用语，很容易勾起人们的感情。比如：牺牲，公平，改革。拿改革来说，很容易让人们认为是好的。但是从科学角度，任何改变的尝试都不一定成功。即便人们带着美好的愿景做出改变的尝试，也可能带来失败或者糟糕的结果。 再说一个商业上的案例，当一个产品很新的时候，宣传的时候就会说 “全新一代”“最新研究”，当一个产品很老的时候，宣传的时候会说 “老字号”“始于 xxxx”。你看，怎么说都可以，只要给用户带来正面情绪就行。 价值观假设作者认为很多争论，其实本质上是价值观层面上的，了解争论背后的价值观冲突，会更容易理解争论的本质。 比如： 该不该告诉父母姐姐偷了东西？这其实是两种价值观冲突：忠诚 vs 诚实。 打赌下注的时候，该不该检查赔率？理性 vs 冲动。 我们应不应该禁止有种族主义思想的人的言论。秩序 vs 言论自由。 是否总统每周都应该开新闻发布会。媒体自由 vs 国家安全。 书中还提到：每个人的价值观其实是感性的，即这是他的直觉情绪。所以面对两种价值观，可能在一个案例中他选择价值观 A，但是在另外一个案例中他又选择价值观 B 了。 一些常见的论证错误部分错误也常常被当做技巧，用到营销方案里面。 人身攻击谬论人身攻击谬论指避开问题本身，攻击提出问题的人。 比如：我不喜欢 xx 电影，只要是 xx 演的电影都是烂片。 滑坡谬论滑坡谬论指假设采取提议的行动会引发一系列不可控的不利事件，而事实上并不是。 书中的案例是一个反对政府禁止在电视上播放酒类广告的提议。提议者的理由是：对人体有害的东西很多，比如甜食。如果政府因为对人体有害就禁止酒类广告，那么是不是要禁止掉糖类或者巧克力广告。 追求完美方案谬论追求完美方案错误指：如果尝试某种解决方案后还有遗留问题未解决，那么这种方案就根本不应该采用。 这个错误的根本在于：或许很多事情很难十全十美地解决，又或者需要探索才可以解决。 追求完美看起来冠冕堂皇，但是它其实相当于使用了当前的保守方案。当前的方案通常有很多问题大家才会想替代方案。新方案即便有很多问题，只要它比当前方案相对优，也是应该考虑使用的。 这是书中的一个案例：家里添一套安保系统纯粹是浪费钱。如果贼要光顾你家，他们总归想得到办法，无论你装什么都不管用。 偷换概念谬论偷换概念指论证中的一些关键词语有两个或更多含义，一旦不同含义之间的转换被认出来，这个论证就错误了。 诉诸公众谬论诉诸公众谬论指引述大部分人持有的观点来论断某个观点有道理。 这种谬论最常见的做法就是引用各种问卷调查，然后得出一个结论。殊不知，真理并不是每一次都掌握在多数人手中。而且，大部分的调查问卷本身的科学性都存疑，因为问卷中很容易加入上面提到的各种带有情感色彩的词汇。 诉诸可疑权威谬论诉诸可疑权威谬论指引用的所谓权威并不足够在专业性上具备足够的权威性。 这种谬论在广告中很常见，为了证明某些保健食品或者保健药品具备疗效，很多厂商会使用部分研究机构的论文或者报告。但是在学术界，可能这些论文并不足以证明疗效。普通大众其实搞不明白这些细节，于是就被厂商钻了空子。 去年读的《爆款文案》一书，就专门介绍了赢得读者信任的一些技巧，第一个技巧就是：权威转嫁。利用专家评价、行业大奖、权威认证，让用户对产品的质量产生信任。至于这些权威的真正含金量，其实不重要，只需要消费者感觉很权威即可。 我在大学时得过一个奖学金，名字叫 “计算机世界” 奖学金，听起来是不是很牛逼？其实这个奖学金是一个报社颁发的，那个报社叫 “计算机世界报”。当时班上同学都说，这个名字太有诱惑力了，也是同样的道理。 诉诸情感谬论诉诸情感谬论指利用可以影响情绪和倾向的语言来刺激我们的直觉情感。刚刚我们已经举过一些例子了，比如「改革」和「改变」，「保守」和「坚持」，虽然意思非常相似，但是明显带有不同的情绪影响。 转移话题谬论来看一个案例： 妈妈：你和男朋友去哪儿了？为什么要跟我撒谎？ 女儿：你总是挑我的错儿。 好了，现在争论话题成功转移成：妈妈有没有挑女儿的错。 其它书中还有一些别的谬论，我在此不再一一展开。 证据的种类书中将证据进行了分类，然后对每种证据需要关注的地方进行了讨论。具体来说，作者将证据分成了：直觉、个人经验、典型案例、当事人证词、权威专家意见、个人观察、研究报告、类比。 然后你会发现，似乎以上这些证据，都会有不一定靠谱的时候。比如权威专家意见，首先即便是专家也不一定正确，另外很多时候不同的专家意见也不一样。 我的一个同事身体运动受伤，于是去协和、积水潭（据说是运动损伤最厉害的医院）、和睦家分别看了一下。这下好了，三家医院的治疗方案全部不一样，而且有些方案是完全冲突的。比如有两家要求做康复训练，一家要求不能做康复训练。有一家要求做 CT 不做 MRI，另一家要求不做 CT 做 MRI。好了，你说听哪个专家的？ 小结本书其实是一本强调批判性思维，强调逻辑思考的书。书中将证据和推理过程中常见的谬论进行了讨论，对证据常见的问题也进行了说明。 本书稍显啰嗦，案例归纳得并不简洁。比如在介绍推理谬论的时候，就介绍了 14 种谬论，其中的原理其实都大同小异，读者其实并不太能记住这么多细节和分类。 批判性思维使得大家在面对重要问题时，能够对结论的质量进行判断，对冲突的观点进行分析，通过思考，自己得出更加合理的结论，避免被人带偏。 除了啰嗦了一点，还是一本好书。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"巴菲特的养育之道与 40 次机会法则 - 读《40 次机遇》","slug":"40-chances-book-summary","date":"2019-01-13T16:03:32.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2019/01/14/40-chances-book-summary/","permalink":"https://blog.devtang.com/2019/01/14/40-chances-book-summary/","excerpt":"","text":"一、序言《40 次机遇》是巴菲特的孩子霍华德写的一本书，书的主题其实是介绍他如何做慈善，致力于解决全球贫困地区的粮食问题。 有些时候，一本书或者一个演讲，最终打动你的或许只有一两句话。这本书对于我来说，印象最为深刻的是巴菲特为该书写的序，里面这里面谈到了一些巴菲特的教育理念。 这种理念具体到执行层面，我认为中国的家长不一定完全适用，但是的确有很深的参考价值，下面给大家分享一下。 二、让孩子人格独立：你的人生你做主巴菲特说，他的父亲给他的最大的礼物，就是言传身教地让他明白，父亲关心的是他的个人价值，而不是他所选择的人生道路。所以，他也把同样的礼物传给了他自己的孩子。 巴菲特在序言中这样写道： 他（巴菲特的父亲）直言不讳地告诉我，他对我有无限的信心，我应该大胆追求自己的梦想。 只那之后，我就从别人对我的期望中解脱出来，只想全力以赴做自己喜欢的事情。 巴菲特让孩子在人生道路上独立选择的最大案例就是：他所有的三个孩子虽然都很聪明，但是没有一个念完大学。 霍华德为了找到自己的人生目标，走了很多弯路。他读了一段时间大学，然后又放弃了，周游了一圈世界，还是不知道做什么。直到他看到建筑工地，对推土机起了兴趣，然后又经历被骗钱，最后给朋友免费开拖拉机做农活还钱。这个时候他突然发现，他最大的兴趣是当一个农民！ 在中国，我能猜到大部分父母如果知道自己的孩子在放弃大学后，竟然对当一个农民感兴趣会是什么感受。如果我是他爹的话，估计一口老血喷出来。 但是巴菲特为了鼓励孩子的兴趣，真的买了一块农场，然后租给了自己的孩子，除了收取不菲的租金外，还要求额外的 5% 的投资回报，这还是税前。而他的孩子霍华德也真的把农场经营得有模有样，并且他在「播种机学校」活动中，获得了影响他一生的 40 次机遇法则。 霍华德最终把农业发展成了他的事业，并且因为巴菲特的支持，他最终利用自己的知识努力改善非洲的粮食和贫困问题。 我想，这样的人生可能算不上耀眼，但是，这绝对是霍华德自己谱写和实现的人生剧本。 三、让孩子经济独立其实经济独立了，人格才能独立。 巴菲特曾经公开表示，不会把自己的遗产分给孩子们。在巴菲特的老婆离世之后，巴菲特也确实开始了资产的捐赠工作。最终巴菲特捐了价值几百亿美金的股票捐给了盖茨基金会。 巴菲特说，他之所以这么做，是因为他亲眼见过一些成功商业人士的孩子娇生惯养，不可一世，而他不想让自己的孩子也变成那样。 书中讲了很多故事，证明巴菲特非常介意直接给孩子钱，比如当时霍华德想开拖拉机，钱就是借来的。霍华德的汽车，是用连续 3 年不收生日礼物和圣诞节礼物的约定换来的。 给孩子花不完的钱，不如让孩子自己学会如何挣钱。因为毕竟你的钱再多，也不可能供给你的子子孙孙。而断绝自己孩子挣钱的能力，很可能也断绝了自己孙子挣钱的能力。父母的言传身教非常重要，一个只会花钱的孩子，他自己生的孩子也好不到哪儿去。 四、给孩子足够的生活保障这就是我文章最初说的，中国家长不一定适用的问题。巴菲特能够坚持让孩子人格和经济独立，是因为他还是在孩子独立之前，提供了充足的生活、教育、医疗、旅游经费。 按照马斯洛理论，孩子的生活和医疗充足，满足了基本的需求问题，才可以追求更高的人生价值。巴菲特在书中也提到，很多非洲人民，一生下来就注定无法选择自己的人生，因为他们还在为基本的生存问题苦恼，他们能活下来就不错了，为了食物，他们只能放弃其他的东西，包括教育。 巴菲特还为孩子提供了充足的教育经费和游学经费，中国有一句古话，就读万卷书，行万里路。一个人的见识，就是通过读书和游学来实现的。霍华德要读什么书，巴菲特从来不会在资金上限制。另外霍华德有机会在年轻的时候去大量的国家，接触不同的文化，价值观，这些资金也是巴菲特提供的。 其实在中国要做到这一点，还不太容易。单单是为孩子提供良好的教育以及成年之后基本的居住条件，可能就需要花费一个家庭大部分的积蓄。 虽然贷款了几百万，但是如果没有我和我老婆父母的支持，我们连在北京买房的首付款都付不起。因此，我们对于下一代的养育压力更大。我周围很多家庭，为了学区房承担了巨额的债务。 中国的大部分家庭，还停留在为孩子提供基本生活、教育、医疗保障。至于国外游学的机会，可能还是停留在中产以上的家庭才能做到。 五、中国的现状中国还在争抢教育资源的阶段，可能很多人并不知道，在中国只有 50% 左右的人能够进入高中，又只有 50% 左右的高中生能够考入大学，而整个社会阶层和收入水平是通过学历来划分的。 这使得中国家庭还在为孩子未来健康生存的安全感焦虑，因为如果学习不好，未来可能就无法经济独立，更别说人格独立了。 未来中国可能需要投入更多的教育资源，保证每一个公民愿意的话，都可以进入到大学受教育，并且还需要适当减少学历带来的社会阶层收入差距，使当蓝领和白领的收入差别不大（我知道在很多发达国家是这样），可能这样才能达到巴菲特所追求的每一个人追求自己的个性化发展。 这条路还需要走很久，不过我已经看到一些变革出现，比如国家会尽量弱化义务教育阶段的择校，希望教育资源不要过于集中在某些名校。又比如限制校外机构搞超前学习。这其实都是为了让每一个孩子能够享受公平的教育环境。 六、40 次机遇法则最后说说作者在书名中提到的 40 次机遇法则。 霍华德之前认为，每年的耕种就是一个重复，每次耕种的过程有什么错误或者大自然的挑战，第二年又可以重来。但是他在播种机学校的活动中，改变了这样的人生观。 因为大部分农民，从开始第一次爬上父亲的拖拉机，到将土地传给下一代，如果身体健康，其实只有 40 次机遇来种植庄稼。而这 40 次机遇，还有好多次是要用来交学费学习的，因为对于一个新的农民来说，他很难不犯错误。 如果一个农民对于自己播种的技能不上心提高，那么 40 次的机遇会很快用光。 而人生也是这样，其实虽然说人的寿命在提高，大部分人身体健壮的工作年龄也就是 40 年。如果你 7 岁读小学一年级，本科毕业开始工作，那么工作 40 年就已经到 62 岁了。 所以你看，你每年的自我提升如果不够快的话，40 次的机会其实并不算多。比如拿我来说，我已经用掉 10 次了。这也是我为什么要坚持每年读书，写读书笔记，到年底的时候翻翻这些笔记，才觉得踏实。 七、小结巴菲特养育孩子追求其人格独立和经济独立。 40 次机遇法则告诉我们，人的一生其实非常短暂，人仅有 40 次的机会来进步。 希望大家都能用好自己的 40 次机会，也希望自己用好剩下 30 次，就酱。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"2018 年个人总结","slug":"2018-summary","date":"2019-01-01T13:11:43.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2019/01/01/2018-summary/","permalink":"https://blog.devtang.com/2019/01/01/2018-summary/","excerpt":"","text":"关于创业猿辅导在不久前，拿到了 3 亿美元 的融资，估值超过了 30 亿美元。在今年这个资本寒冬的大环境下，我们能够拿到这么高的估值和融资额，还是非常厉害的。这里面最最核心的，还是我们的各个产品数据都非常健康，商业化的尝试也都比较成功。 18 年，工具事业部内部也按项目进行了团队拆分，我个人在 2018 年主要是负责孵化一个新的英语产品。整个过程下来，我对自己的表现打个 60 分吧。这是我第一次负责业务，团队的组建靠着抽调一部分合作过的老同事，所以还算顺利，但是项目推进速度上，还是不够快。在一些关键事项的决策上，也不够快速。 关于创业，今年有了一些新的感悟。 关于产品创新产品的创新总是让人兴奋。可能每一个人都希望自己有一天突然灵光一现，利用一个绝妙的点子来获得产品竞争力，但是事实上，这种事情成功的概率极低。 今年在组建新的业务团队的时候，我总会在新人加入的头两周，约新同事喝咖啡聊聊天。我发现这些同事都有着无数的想法，他们总是发现产品这儿有问题，那儿有问题，这儿可以迭代，那儿可以改改，甚至他们还希望对产品动一个大手术，用以解决当前遇到的主要问题。 但是，我个人发现这些点子大部分都是不靠谱的。因为他们在产品上的思考时间太少太少了，他们质疑自己的想法的时间也太少太少了，大部分关于产品的点子，应该依靠的是积累和思考，甚至是依靠数据，而不是依靠灵感。 以前，我自己都会尽可能站在用户场景上想解决方案的点子；现在，我会更多花时间在看行业的解决方案上。因为参考市面上成功的案例，比自己想点子的靠谱程度大多了。 对于同事提出的非常独树一帜的想法，我也会让他想想，为什么行业内别人没有试过，有什么数据和案例能够证明自己的想法是靠谱的。如果完全找不到数据和案例，那能不能用最小的成本进行 MVP 验证？ 关于战略决策今年有一段时间，我总是非常好奇，为什么行业内 CTO 通常在合伙人里面，占的股份是偏少的那一个。按理说，CTO 负责产品技术，对公司的影响非常大才对。后来我想明白了，其实一家创业公司，最最重要的能力是战略规划和决策能力。战略定对了，具体执行的模式和模型想好了，执行相对就不那么重要了。 战略也决定了一家公司在产品上的竞争方式，是通过资本，还是通过产品，还是通过技术，或者是通过运营，或者是教研。有效的战略应该是通过规划，达到有效的竞争，最终获得理想的竞争格局。 战略能力核心是一种洞查能力，这和买卖股票是同一种能力，讲起来无非就是收集信息，做判断，最终靠自己正确的判断获得巨额收益。创业是这样，买卖股票也是这样。当然，创业相对炒股应该更难一点，因为执行到位也不容易。 收集信息做判断，讲起来容易，执行起来也非常难。这就是一家公司 CEO 的价值，一个 CEO 如果把这一点做好了，就应该拿到最多的合伙人股份。因为这才是对公司最最大的影响。 战略决策不一定都是对外的，也有对内的。比如对于小猿搜题来说，当年成立独立事业部就是一个大的决策，这使得它最终能够内部孵化新产品，尝试商业化。如果不是这样，我们就很难孵化出小猿口算这样的新产品。 关于自我认知一次听李勇说过一句话：「一个人在各方面都很牛逼，这不科学」，这还是点醒了我一下。 有一阵子总觉得自己应该补短板，希望自己能力能够尽可能全面。现在我慢慢觉得，补短板可以，那也是仅仅让自己的短板稍微凑合而已，相对来说，应该尽可能找到自己的长处，短板要补，但是长处不能丢。 如果非要取舍，宁愿有一技之长，也不要每一项都很平庸。 我自己的长处，还是在技术积累这一块儿，毕竟做过服务器、前端和 iOS 端研发工作，可以更加客观理性地判断技术和使用技术，这块的判断能力不能丢。所以有时间，还是应该多了解技术发展，尝试自己做一些 Demo，保持对技术的敏感度。 关于绩效今年因为工作涉及，自己对于团队绩效和个人绩效也有了更加深刻的认识。 关于个人旅游18 年，我和家人一起去了澳大利亚悉尼，然后跟随公司的集体旅游去了一趟京都和大阪。 悉尼给我的感觉很一般，主要是互联网行业在那儿不发达。历来一个新兴产业如果能够崛起，那么原有的行业就会衰败。如果未来是属于互联网行业的，那么整个澳大利亚应该都会很危险。 京都和大阪更像是一个旅游城市，主要是见识当地的风光和文化。这次也把当地的美食吃了遍，比如大阪烧，河豚，拉面，烤肉，神户牛肉，寿喜锅。我个人还乘机买了一台任天堂 Switch 以及 Labo。任天堂的 Labo 真的是非常有意思的动手玩具，细节设计得非常精妙，而且还有教学环节告诉你设计原理。 我认为 Labo 对于想像力的开发还是有一定的效果，因为没有亲自见到，我很难想像就仅凭简单的陀螺仪和红外摄像机（IR Motion Camera）就可以用纸版做出像钢琴、钓鱼、赛车、机器人等复杂游戏。 看书今年兑现了年初的承诺，看完了 24 本书。这儿 有这 24 本书的列表。这 24 本书里面，我个人比较推荐的书是 《原则》、《金字塔原理》、《思考快与慢》、《最好的告别》、《OKR 工作法》。 年度目标这个东西，实践起来还是相当有意义，因为做了这个承诺，所以我整个 18 年都在规划读书的时间。虽然忙，但是每个月两本书的节奏还是控制下来了，最终提前一个月完成了读书目标。 演讲18 年我刻意减少了参加演讲的次数，最终只做了两场演讲。 第一场是关于测试质量保障的，我们的测试负责人离职了，于是我替她讲了。我演讲的主题是《2 个人如何保证 2 亿用户 App 的质量？ — 小猿搜题的质量保证体系》，这个名字我刻意用了一下利于 PR 的描述，结果现场非常火爆。有意思的是，最后我演讲完没过多久，我们的测试负责人又从头条回来了。 第二场演讲是给 @Swift 大会做的，题目是《猿辅导从 OC 到 Swift 的迁移之路》，主要是介绍猿辅导公司在向 Swift 语言迁移过程中遇到的问题。 炒股18 年炒股亏了不少钱。现在持仓的部分： 腾讯。买入价 403，当前价 314，收益 -22% 阿里。买入价 145，当前价 137，收益 -5% 博实乐。买入价 12，当前价 9，收益 -25% 特斯拉。买入价 310，当前价 333，收益 +7% 好在自己投入的金额不算多，所以也就是当交学费。炒股这件事情亏钱，本质上还是自己决策能力低下的表现。我看了一下自己的操作记录，觉得安全边界掌握得不够好，很多股票买入价都算不上便宜，所以吃亏。另外，自己对一支股票研究得还是不够透，应该多花些时间慢慢思考，想清楚再决策。 健康18 年自己的身体状态算不上好，甚至有一段时间心理状态也比较焦虑。负责业务不像负责产品技术那么偏执行，反倒让我时间规划更加困难。 复盘：年初目标的完成情况2018 年初定的目标： 看完 24 本书，并且完成读书笔记。 坚持英语的听说练习。 本来想的是少即是多，所以只定了两个目标。现在看起来，两个目标都太多了，真正完成的只有读书那个目标。 英语的坚持听说练习的目标，最终被我发现因为应用较少，所以荒废得非常快。这种付出和收获太不平衡了，所以最终没能坚持下来。未来如果要提高英语听说，应该定一个更加实际可操作的目标。 2019 年的目标 看完 24 本书，并且完成读书笔记。 个人 Milestone 独立负责了一个新的业务。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"OKR 工作法简介","slug":"okr-introduction","date":"2018-11-21T23:14:06.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/11/22/okr-introduction/","permalink":"https://blog.devtang.com/2018/11/22/okr-introduction/","excerpt":"","text":"最近看了 《OKR 工作法》，又查了一些相关资料，觉得是一个很好的面向个人和自组织团队的管理方法，而且它可以和 Scrum 的工作法搭配使用，于是给大家介绍一下。 我的介绍大纲是： OKR 的历史 OKR 的内容 如何实践 OKR OKR 与 Scrum OKR 与 KPI OKR 的问题 OKR 的历史很多人应该听过 Intel 的传奇人物安迪·格鲁夫。他是 Intel 的前 CEO，领导了 Intel 从一家濒临倒闭的存储器公司，转型为微处理器公司。我曾在 2016 年也分享过他的一本著作的 读书笔记：《High Output Management》，中译版叫 《格鲁夫给经理人的第一课》。 格鲁夫在 Intel 公司引入了 OKR 工作法，随后这种工作法在硅谷流行，被 Google 和 Linkedin 等公司采用。随后 OKR 工作法传入中国，明道团队为推广 OKR，翻译了《OKR 工作法》，也推出了一些相关的资料和工具。据我所知，今日头条在公司内部推行和使用了 OKR。 OKR 的内容OKR 即 Objective 与 Key Results 的首字母缩写。 OKR 的核心其实一句话就能讲明白：制定一个较长期的目标（Objective），并且将目标分解成为一些关键的结果（Key Results）。 OKR 在这个核心思想下，再附加有一些规范： 希望目标和关键结果不要泛滥，小的团队和个人刚开始最好只定一个目标，3 个以内的关键结果，以便再加专注。 OKR 的实施结果不要与绩效挂钩。不要与绩效挂钩。不要与绩效挂钩。希望我重复三遍能有一些强调效果。 OKR 的目标应该较长，最少一个月以上。我个人觉得以季度为粒度的阶段目标较为合适。 OKR 不追求完成，而是追求最大挑战。关键结果应该制定在 50% 可能性能够完成的假设上，以便发挥团队最大的动力。稍后我们看到，我们用 5&#x2F;10 来表示初始的关键指标信心指数。 实施 OKR 的团队应该是自组织的团队，而不应该严重依赖于外部团队成员。 OKR 的目标和关键结果应该由团队讨论决定，而不应该是领导指定。 每隔一段时间回顾一下 OKR 的结果，大家分享成绩，并重新调整信心指数。 如何实践 OKROKR 在上面这个核心思想下，构建了一个更加具体的实践流程，《OKR 工作法》中用一个四象限的画布来呈现这个实践，这个画布如下所示： 在这个画布中： 右上角是我们的 OKR 主要内容，它包含了目标和关键结果的内容。在每个关键结果的最后，我们标注上完成该结果的信心指数，初始值为 5&#x2F;10，即 50%。 右下角是我们支持完成该关键结果的一些状态指标，有助于帮助我们更好的判断关键结果的达成可能性。 左上角列出本周重点需要完成的事情。 左下角列出未来四周需要重点完成的事情。 介绍完画布，那 OKR 的实践过程，就是围绕着这个画布做创建和更新： 第一次先团队一起讨论，初始化这个画布。大家需要对目标和关键结果达成一致，并且初始化信心指数为 5&#x2F;10，初始化围绕这些关键结果的当周重要工作。 每周更新讨论一次这个画布。如果一些事情完成了，那么信心指数应该会有所变化，可能上升为 6&#x2F;10。如果事情没有完成，那么信心指数就保持不变，但是大家因为有这个讨论过程，自然就会反思和总结为什么。 每过一个周期（一个季度或更长时间），重新重置这个画布，看是否要调整目标和关键结果。 如果你的团队正在实施 Scrum，那么 OKR 稍微调整一下，就可以与 Scrum 进行一定程度的融合，我稍后会介绍。 OKR 与 Scrum我认为 OKR 与 Scrum 可以完美融合。因为 OKR 属于宏观和全局视角，关注于长远的目标和任务的主干。Scrum 属于微观和具体视角，关注于每个 Sprint 迭代的工作与是否能够按时完成。 OKR 属于战略，战略层面上我们要藐视敌人，所以我们要定制高标准，高目标。即便达不成，团队也在超着超预期的目标前进。就像雷军说的，梦想总是要有的，万一达成了呢！ Scrum 属于战术，战术层面上我们要重视敌人，万丈高楼平地起，事情是一步一个脚印做的。所以我们在 Scrum 会上要强调客观，强调工作拆解与估分，强调每天的站立会议检查进度与风险，强调完成。 OKR 强调高标准。让关键结果只有 50% 的信心指数。OKR 也不会因为最后完不成这些梦想而让团队反思。 Scrum 强调完成。Sprint 中的迭代如果没有完成，是需要整个团队认真反思和改进的。 那么 OKR 与 Scrum 如何融合呢？我觉得可以把 OKR 与 Sprint 的计划会议、评审会议、回顾会议进行一定程度上的整合。具体来说： 在 Scrum 计划会议的最后。我们将其中与 OKR 最相关的事情，列到 OKR 的画布的左上角象限。便于我们是否将与目标最相关的事情排在了当周工作中。同时我们将 Scrum 的待办事项列表中，选出与 OKR 最相关的事情，列到 OKR 画布的左下角象限。 在 Scrum 回顾会议的最后。我们更新一次 OKR 的信心指数，看是否有变化。 评审会议其实和 OKR 流程中提到的每周五分享好的结果其实非常相似，我们可以认为它俩做的是同一件事情。 在这种融合方案下，我们仅需要在 Scrum 的流程最后，加入一点点更新 OKR 画布的工作，即可以让我们在 Scrum 的微观视角中融入宏观视角，既不费时，效果又好。 OKR 与 KPIKPI 通常和绩效绑定。这使得大家非常在意它的完成与否。而这种情况下，大家容易走极端，从而背离 KPI 背后的初衷。 我举几个我身边的真实故事。 故事一：某个社交产品为了拉明星入驻。把明星数定位 KPI，于是很多编辑拉明星的时候，只要他注册一个帐号，就送礼物，丝毫不考查这些明星帐号有没有真正用起来。 故事二：某个公司的 PM，他的 KPI 是一个页面某个按钮的点击率。他为了这个点击率，设计出让用户很容易误点，结果点击率很快就上去了。 故事三：某个公司，为了达成安装量目标 KPI，去积分墙刷量，结果这些量留存率极低，根本就是垃圾下载量。有人说：那我定几个组合的 KPI 来避免极端呢？组合的 KPI 一来使得大家对目标就不太清楚了。二来如果定得少了，也容易出现钻空子。比如，在刷量市场上，就有人专门不但帮你刷下载量，还帮你做留存数据。 OKR 怎么解决这个问题的呢？其实很简单，OKR 不与绩效绑定！ KPI 本质上是一种外部激励，利用金钱来驱动人性努力工作。但是人性又习惯走捷径，所以只要有一种捷径可以达到 KPI，人性很可能会忽视别的影响。但是一个产品要做好，很多时候不是一两个指标的事情。 OKR 本质上是一种内驱激励，它假设人们都会追求有价值的工作和生活。于是 OKR 并不与绩效挂钩，但是将各种自主权利下放，并且构建一个扁平化的、自组织的团队，让这个团队来自己设立高标准并为之努力。 有人说，OKR 应该替代 KPI ，我觉得这句话如果潜台词是：OKR 应该替代 KPI 做绩效管理，那就不对。在很多情况下，KPI 就是应该被干掉的，不管有没有 OKR 存在。我们猿辅导公司在创业前 5 年，都没有 KPI ，也没有听过什么 OKR ，团队一样正常工作和发展。 所以，OKR 与 KPI 并不是替代关系。它们俩一个是做绩效考核的，一个不是做绩效考核的，何从来「代替」这个说法呢？ OKR 真正替代的，是原本缺少的、或者并不明确公开出来的团队季度目标与目标拆解。以前这些事情可能在团队负责人的文档里面，需要团队负责人自己记得更新和传达，现在用一个工作法流程化了，使得这部分工作更透明了，团队就更容易朝一个方向努力。 OKR 的问题OKR 的问题在于，很多公司的组织架构并不适合施行 OKR。用 OKR 做产品的话，需要这个团队是一个以业务为单元的组织，融入了产品建设需要的各种人才，比如：产品经理、运营、设计、开发、测试。如果公司是以职能做为团队划分的单元，则会对 OKR 的推进造成影响。因为职能团队的目标通常是偏专业角度的，而不是偏业务角度的。 OKR 另一个问题在于，构建一个自组织团队本身就很难。OKR 希望大家主动地讨论目标和关键结果，但这强依赖于团队的积极性。如果团队并不是一个积极向上的组织，那么 OKR 很容易流于形式。变成另一种管理者的工具。 OKR 还有一个问题，就是团队对于它的学习和理解需要付出额外的努力。如果理解不当，就并不会产生效果。比如，如果管理者不理解 OKR，把它当作 KPI 的替代品做绩效考核，那么就其实把 OKR 当一个多 KPI 组合在用了，本质上还就是在用 KPI。 小结OKR 也适合个人自我管理，特别是你需要兼顾很多事情的时候，OKR 可以帮你理清出最重要的目标与关键结果，从而让你生活得更舒适。 希望本文能帮助到大家，谢谢！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"应该如何面对死亡 - 读《最好的告别》","slug":"being-mortal-book-summary","date":"2018-11-18T15:04:38.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/11/18/being-mortal-book-summary/","permalink":"https://blog.devtang.com/2018/11/18/being-mortal-book-summary/","excerpt":"","text":"《最好的告别》是一本关于死亡与临终关怀的书。作者是阿图·葛文德医生，白宫最年轻的健康政策顾问。看完这本书，我得到的不单单是应该如何在临终前的几天做决策，更多的是如何在临终前的几年做规划，让自己和家人更幸福。以下是我的一些感悟。 生命的质量 vs 生命的时长小时候看《灌篮高手》，里面有一个情节：一木花道在和山王的比赛中，背部受伤。安西教练希望让一木花道停止比赛换人，因为坚持比赛的话一木可能会造成伤残，以后再也无法比赛。而一木花道说，这就是他这辈子最荣耀的时刻，他宁愿放弃未来的篮球生涯，也要坚持比赛下去。最后他在比赛的最后时刻投中两分，获得了比赛的胜利。写到这儿，我又把当时的漫画翻出来看了一遍，再一次热泪盈眶。 我们在生活中的方方面面，都面临着类似的个人追求和身体健康的冲突。不管是学习还是娱乐，一个人如果注入了自己的精力，通常都会拿一部分健康的损失作为代价。我还记得自己高中的时候，大家为了高考，每天学习到 12 点才睡觉。 奇怪的是，每个人都明白的道理，放到临终的老年人身上，决策就不一样了。 每个人都有父母，我相信每个人很可能会经历这样的时刻：父母有一天身体不行了，送到医院，医生表示已经到了癌症晚期。是继续放射性化疗，还是保守治疗？肾衰竭了，要不要做血液透析？没法进食了，要不要做鼻饲？呼吸困难了，要不要插管上呼吸机？ 现代医学太厉害了，它可以把身体接上各种管子，通过各种药物和机器，来简单地维持病人的生命。但是它忽视了两点： 1、它给病人带来的痛苦，是否已经超过了身心的承受能力？古代最严重的刑法，就是让人在死之前受尽折磨。现代医学从来没有考量过这方面的伤害。 2、病人承受了这么多痛苦，带来的相应生命延长的时间，是否值得？如果一个肿瘤病人，经过手术后，病人又活了10年，那么显然这个手术是值得的。但如果一个癌症晚期病人，承受各种治疗方案，仅仅是延长几个月的生命，是否真的值得？ 有人说，多活几个月也是时间啊！但是你想想，如果这几个月老人都躺着病床上，时而清醒，时而昏迷。大小便都不能自理。家人都为老人操劳。老人多活的这几个月的时间里，他真的快乐吗？他的家人天天处于担心受怕的状态，真的快乐吗？ 在《最好的告别》一书里面，作者首先就讨论了这个话题。他认为，老人生命最后的一段时光，应该让他自己决定。应该让他有尊严、有选择、有意义的度过生命最后的几个月。 如何安排老人的晚年老年人最大的敌人其实不是死亡，而是厌倦感、孤独感和无助感。作者作为医生，介绍了他观察到的养老院的临终老人的案例。 养老院让老人离开了熟悉的生活环境、家人以及朋友，护士无视个体的要求，把生命和安全放到第一位。老人的爱好被剥夺了，老人很可能也没有了隐藏。于是老人们很多都产生了厌倦，孤独，无助感，最终不但更加依赖药物，而且生命也变得没有意义。 作者介绍了一种在美国兴起的好的养老院模式：这种模式下每个老人的家是完全自己掌控的，这首先让老人获得了自主权和隐私权。另外，如果老人愿意，他可以选择睡懒觉，吃爱吃的东西，护士仅仅提供健康建议和帮助。 在中国，因为家庭关系更紧密，作者更倾向于让老人和儿女住在一起。如果老人患上了绝症，而救治的过程特别痛苦并希望不大，应该把选择权给老人自己，让老人自己决定自己的未来。 临终花费作者指出：在美国，25% 的医疗保险费用花在 5% 生命处于最后一年的病人身上，其中大部分钱用在了最后几个月没有任何明显作用的治疗上。在其他国家，例如荷兰和瑞士，结果同美国很相似。 这些钱最终其实只是用机器维持住了病人的生命，其生命毫无质量可言。书中讲了一个故事：一个 80 岁的老人患了末期呼吸衰竭和肾衰竭，她本来想放弃治疗。但是她的子女不让她走，要求医生采取各种措施：永久性气管造口术，饲管、透析导管。所以，这个老人躺在病床上，身体连接着那些泵，时而清醒，时而昏迷。 子女通常思考的角度不是：这是妈妈想要的吗？而是：做这个选择，我心里舒服吗？当然，把钱花在妈妈身上，子女肯定会心里更踏实一些，毕竟子女不愿意背负不孝、贪财的骂名。子女愿意为了妈妈付出一切。可惜，他们只是忘了问一句：妈妈你到底想要什么。 我自己的故事我奶奶在我爷爷离开后，就选择自己一个人在老家生活。其实奶奶有三个孩子（我爸爸、二爸、三爸）都在城市里面住，奶奶住不习惯，她还是喜欢在老家养猪，养鸭。每天她干农活会从早做到晚。我明白，这就是她最希望过的老年生活。即便没有儿女的陪伴，她也要在她习惯的环境中度过一生。我们每年春节都会回老家看望奶奶，我也每隔几周给奶奶打电话聊两句，我能感觉到她在老家过得很自在。 我爸爸退休了，我本来希望他来北京好好玩玩。可是他选择了返聘到原单位。我其实刚开始挺不能理解的。辛苦了一辈子，现在又不缺钱花，返聘回去能挣几个钱？后来我想明白了，爸爸一生波折，他需要一个平淡充实的生活，而返聘可以让他每天的日子过得很充实，同时也让退休带来的家庭变化最小。 我老了会怎么过？我不知道。但是我肯定不希望全身被插满管子，用极度的痛苦来换生命的时长。在生命的最后几个月，我可能会再次和一些老朋友联系联系，安排好身后事之后，我希望和家人在一起，静静等待那一刻的到来。 作者的故事作者也在书中介绍了他自己与父亲的告别过程。作者的父亲在生命的最后几年被查出得了星形细胞瘤，这是一种恶化相对缓慢的癌症。他的父亲进过 ICU，经历过差点瘫痪的手术，化疗和副作用极大的药物最终对癌细胞都没作用的时候，他的父亲知道已经无力回天。 他选择了希望自己离开之前不要受太多的痛苦，于是一直进行保守的治疗。在美国，他们接受了「家庭善终服务」，其实就是给老人一些必要的医学保障后（护士定期上门、24小时紧急电话支持、帮助洗澡和打扫等），等待老人最终自然死亡。 即便是这样的过程，也是非常让人难受。老人最后的几天已经非常痛苦，需要吗啡来减少疼痛，然后因为吗啡的原因，整个人处于似睡似醒的状态。醒的时候疼痛持续让他难受，他甚至和作者会有这样的对话： 作者：”你不想吃东西吗？” 父亲：“我在想怎样不延长死亡的过程。食物延长了这个过程。” 作者：“你很难受是不是？” 父亲：”是的” 作者：“你不想这样醒着，感觉到我们，跟我们在一起吗？” 父亲：”我不想经历这个” 小结问问自己的父母，到底希望想要什么样的老年生活。尽可能在他们生命健康的时候，多陪陪他们。 在他们晚年的时候，问问他们希望如何结束最后的时光，按照老人的意愿陪他走过最后一段历程，这就是「最好的告别」。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"《大问题-简明哲学导论》读书笔记","slug":"the-big-questions-summary","date":"2018-11-03T08:49:08.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/11/03/the-big-questions-summary/","permalink":"https://blog.devtang.com/2018/11/03/the-big-questions-summary/","excerpt":"","text":"《大问题-简明哲学导论》是一本有关哲学的启蒙书，作者是罗伯特·所罗门，他是世界著名的哲学家和哲学教师。 这本书有意思的地方在于，他是从问题的角度来展开介绍哲学的。很多人可能认为哲学离自己很远，又或者认为哲学很难很高深。但是本书提到了几个最基本的哲学问题，却几乎是每个人都会思考和得出自己答案的。于是乎，作者成功地将哲学拉近到大家的身旁，让大家意识到哲学和自己的生活息息相关。 在这本书开篇的第一章，作者就介绍了几个开篇的问题。比如：在关于生命的讨论中，作者提出的问题是： 有没有某种你愿意为之付出生命的东西？如果你仅仅有几分钟时间可以活了，那么你将怎么利用这段时间？你的生活目标是什么？以及生命的意义？ 在信仰方面，作者提出的一个重要的问题： 你信仰上帝吗？ 这个问题在中国或许，并不会有太多人感觉到困惑，但是在很多宗教文化盛行的国家，这确实是一个很重要的问题。 下一个比较有意思的问题是关于什么是真实？ 如果你坐在一张椅子上，那最真实的东西是你做的这张椅子构成的分子结构，还是你当时坐在上面的感觉？ 很多人可能认为是感觉那么下一个快乐箱的问题，就来了： 我们发明了一台机器，他是一个有着若干电极和一个生命维持系统的箱子，名叫“快乐箱”。只要你进入这个箱子，就会体验到一种特别快乐的感觉，而且这种感觉将一直持续下去，因为它可以产生足够多的变化使你不会失去新鲜感。现在我们想邀请你去试试。只要你愿意这么做，你可以随时决定出不出来；但我们可能会对你说，人――旦进到箱中，还没有谁愿意出来过。过了十个小时左右，我们接通了生命维持系统，人们就在那里耗完他们的一生。当然，他们其他什么事都没做，所以过了若干年后，由于缺乏锻炼，他们的身体开始变得肥硕臃肿，摇摇晃晃，但他们似乎从未为此烦心过。现在我到你做决定了：你愿意跨进快乐箱吗？为什么？ 坦白说，当我翻到这几个问题的时候，我内心是崩溃。因为，其实我也没有标准答案。于是我带着非常好奇的心情，阅读完了这本书，但是我发现其实作者也没有给出这些问题的标准答案。 那我为什么还要推荐这本书呢？这是因为虽然这本书没有给出这些问题的标准答案，但是其实思考这些问题的过程，本身就非常具有价值。而且虽然这些问题没有标准答案，但每个人心目中最终都会有一个最终的答案。因为人们最终会作出选择。 在本书中，作者就给大家介绍了各种各样的答案。比如说关于生命的意义，作者就介绍了很多人的选择。有人，把孩子视为生命的意义，有人把上帝作为生命的利益，有人认为生命毫无意义，而这也是一种答案。 有人认为，生活是一场游戏，有人认为生活是一个故事，有人认为生活是一场悲剧，有人认为它是一场喜剧，有人认为生活是一种使命，有人认为生活是一种艺术，有人认为生活是一场冒险，有人认为生活是一种疾病。 想起之前看了几本关于人工智能的书，书里面就提到，其实人和机器最大的差别就是人有自我意识，而自我意识就是，对自己生命意义的思考和自己对自由的掌控。 关于生命的意义，你的答案是什么呢？对于我个人来说，生命的意义在于，它是一场精彩的体验，并且是人生的修行。 比如说我现在正在猿辅导公司创业，那么我要解决创业中遇到的各种各样的问题。这个过程谈不上特别舒适，有可能会感觉到痛苦，有些时候会加班，有些时候会感觉到迷茫，但是，这个过程本身，我就认为很有价值。 我抱着这样的心态来去看待创业，那么，如果创业失败了，我的内心也会非常平静，因为我看重的是这个过程而不简单的是那个结果。 关于上帝，其实我也有很多感触。因为我在大学的时候，曾经遇到过好几个传教士给我讲解基督教。他们用了各种各样的理由和故事，让我相信上帝的存在，而这些理由和故事在，这本书里面都被作者进行了详细的讨论和阐述。所以，虽然是否信仰上帝，这个问题每个人有不同的答案，但是在这本书里面，你可以看到每个人答案的逻辑和各自逻辑涉及到的问题。 有关生命的意义、信仰、这些大问题，很难找到自己的答案。但是，在未来大家生命即将结束的那一刻，你总是需要让自己内心接受一个理由，让自己轻松地离开。而且，这些答案最终也会指引你生活的方向，所以，愿大家都找到自己的那个答案。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"华与华的营销方法 - 读《超级符号就是超级创意》","slug":"super-symbol","date":"2018-10-28T12:34:27.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/10/28/super-symbol/","permalink":"https://blog.devtang.com/2018/10/28/super-symbol/","excerpt":"","text":"《超级符号就是超级创意》我读的华杉的第二本书，第一本是《华杉讲透孙子兵法》。在这本书里，华杉先花三章介绍了华与华的营销方法：用超级符号来做产品营销；然后华杉介绍了他的一些经营思考，包括营销的本质、战略、产品的本质、调研方法论等。 超级符号超级符号是什么？我理解超级符号是一种对人类视觉、听觉、习惯、心理学的利用。以便以尽量小的记忆难度和传播难度来达到营销的目的。简单来说，就是尽量容易让大家记住、理解、相信，并最终购买。越厉害的超级符号，越节省营销费用。 华杉的超级符号分成三个部分：品牌符号（图形）、品牌话语（即宣传词）、品牌名（即产品名）。 华杉在书中举了不少案例，有文字的超级符号，比如孔雀城的广告：一个北京城，四个孔雀城。也有结合视觉的超级符号，比如厨邦的绿格子设计。有嫁接人们习惯的超级符号：「我爱北京天安门正南 50 公里」。也有综合视觉和口号的，比如「比如 I Love 莜」。 前不久华与华为得到 App 也做过咨询，为得到设计的品牌符号是猫头鹰，品牌话说是：「知识就在得到」。「知识就在得到」明显就借用了「知识就是力量」这句名言，让大家容易记住。 电视广告是「耍把戏」电视广告在现在这个时代，大家都注重效率，所以一般只播放 15 秒的电视广告。而 15 秒，是不够讲一个复杂场景和故事的，所以华杉说，电视广告现在是「耍把戏」，需要让观众盯着看，否则一眨眼，15 秒就过去了。 15 秒广告的创作标准，不是按审美来的，而是按目标来的： 让人记住品牌名叫什么名字 让人记住商品长什么样子 给人购买理由和冲动 建立品牌符号和企业战略优势 前两条是最低要求，后两条是高要求。 小猿搜题的电视广告其实也是按照这个要求来做的，广告全程就是把拍照搜题演示一遍。 先做营销，再做产品以前听一个朋友说，产品做之前，可以营销先行，考虑产品如果做好了，我们会如何推广它。这种思维方式，会让我们在产品的各方面融入营销的目标，比如华杉说的超级符号，就应该在产品成立之初考虑。 书中举了一个喉糖的例子，华与华是先定位了「30 分钟持续冰爽」这个目标，然后再反向地要求研发人员按这个目标来研发喉糖产品。 调研问卷不靠谱，细节才靠谱我见过很多人都依赖问卷或者投票来做决策，我认为这是非常糟糕的方式。华杉在书中第八章也表达了类似的观点。 华杉举了一个例子，《2012年度中国主要城市公众教育公平感调查报告》中提到，有 24.3% 的公众不相信「教育能改变命运」，媒体觉得这太可怕了。 他们的调研问卷可能是这样的： 请问你是否相信教育改变命运？ A.相信B.不相信C.不一定 必变命运这么大的事情，怎么能轻言相信？估计很多人会选择不一定。 因为问卷的设计实在太难了，一些数据指标受问题的表述影响极大，另一些数据指标看了也没什么意义，所以导致问卷基本上无法有效指导工作。 我们假设调研问卷极具市场价值，那么这个社会最挣钱的公司，应该就是那些做问卷的公司。但是实际上并不是这样。我们也鲜见公司的成功决策，是通过市场调研问卷来决定的。 问卷虽然价值极低，但是另一件事情却非常有价值：细节。711 的创始人会每周到店铺里面观察用户，瑞安航空公司的老板会每周搭自己的航班，丰田汽车的高层每年都到4S店蹲点。因为用户使用产品的现场，极具价值。 对于互联网公司的产品，找用户聊天，看用户使用产品的过程和细节，就极具价值。问卷没有价值，问卷是将各种细节都隐藏起来，夹杂着各种心理情绪的总结。而现场是真实的原始数据，所有数据都未经加工。 除了关注细节外，用户的行为统计数据也非常有价值，即我们现在讲的「大数据」。大数据之所以有价值，是因为它们是客观数据。问卷中夹带有表述不清、理解不清、上下文歧义、用户临场心理等各种干扰，而行为数据就是用户的真实行为，没有任何干扰。这些数据的统计分析，也非常有价值。比如关注用户增长的 AARRR 模型，每一个漏斗环节的数据，都是客观的真实数据。 工作的状态华杉介绍了他工作常见的三种状态：盲人摸象、小马过河、卖油翁。 盲人摸象状态，只见局部，不见全局。但是需要清楚自己当前在这个状态，知道自己「不知道」。有这个自知的状态，就会努力搞清楚事情的真相。 小马过河。很多事情听别人说没用，只有自己做一遍才有亲身的体会。 卖油翁。讲的是一个老翁，可以用勺子把油从铜钱孔中注进去，却不沾湿铜钱。秘诀其实就是多年练习，手熟罢了。很多工作都是这样，需要花功夫花时间，没有捷径。 卖油翁这个故事，其实也可以推演出专业这个概念。因为很多事情需要花时间才能熟悉，所以每个人都不可能做到面面俱到，因此才有了分工。 结语书中的观点还有很多，比如营销的 4P 理论（即产品、价格、渠道、营销），比如消费者的四个角色。不过我读完感受都不太深，可能还是经历太少，没到时候。 作为国内顶级的营销公司创始人，这本书本身也是对公司的品牌宣传，华杉深谙此道。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"先胜后战之道 - 读《华杉讲透孙子兵法》","slug":"szbf-book-summary","date":"2018-10-21T15:34:34.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/10/21/szbf-book-summary/","permalink":"https://blog.devtang.com/2018/10/21/szbf-book-summary/","excerpt":"","text":"引言最近读完了《华杉讲透孙子兵法》，作者华杉是华与华营销咨询公司的董事长。 我们其实身边有不少华与华的营销作品，比如西北莜面村的「I love 莜」的设计，以及前阵子引起话题争议的「得到 App」的新 Logo 设计，都是出自华与华公司。 先胜后战对于我个人来说，这本书的价值在于纠正了我多年以来对于《孙子兵法》的误解，我想这个误解也在很多人心中，即：认为孙子兵法是讲打仗时的各种奇技淫巧的计谋。 确实，在《孙子兵法》中有不少打仗时的战术。但是，华杉告诉我们，其实比起那些计谋来说，《孙子兵法》更强调的是战争之前的准备，所谓 “先胜而后战”，确定这个仗能打赢，才打。打不赢的仗，坚决不打。 什么样的仗打不赢呢？最常见的就是以少对多的仗。所以别看历史上有不少以少胜多的典故，那些故事能够成为典故，本身就说明是例外的情况，大部分的情况都是以多胜少。所以，侥幸心理不能有。 看完华杉的解说，我发现其实《孙子兵法》其实是一本介绍如何管理军队的管理学著作。其中的打仗部分，只是管理军队这个团队的一个业务。军队能够打好仗，很多细节都是在战斗环节之外的。 比如后勤管理，在古代战争中就特别关键。因为送两车粮食到前线，成本是八车粮食。为什么这么多？因为运粮食的车一路运一路需要吃粮食，运到前线，已经吃掉四车了，还需要留四车，这样他们才能一路回去。你看，十几万大军远征，如果管理不好后勤，可能都不需要战争军队就因为没有粮食而哗变了。 类似的这种基本的军队管理工作，《孙子兵法》里面分为「五事七计」，五事，是道、天、地、将、法。七计，是：主孰有道？将孰有能？天地孰得？法令孰行？兵众孰强？士卒孰练？赏罚孰明？ 有了以上这些计算，判断战争有得打，打得赢，才会兴帅动众，去战场上见分晓。 如何评价一个创业公司其实拿《孙子兵法》的「五事七计」，我们也可以用来评价一个创业公司的能力： 主孰有道？就是判断这家公司的 CEO 及联合创始人是否靠谱。 将孰有能？核心管理团队是否靠谱。 天地孰得？创业的环境怎么样。竞争对手如何，融资环境怎么样。 法令孰行？团队的内部规章制度、人事架构是否规范。 兵众孰强？员工的能力如何。 士卒孰练？员工对于工作是否熟练。 赏罚孰明？团队的激励是否做得恰当。 这就和我们现在做的 SWOT 分析一样，在商业竞争上做详细的分析判断，然后看成功的机率有多大。 学会等待如果在战争中用 SWOT 分析，发现胜算不大怎么办？那最好的办法就是等。作为防守的一方，可以坚守城门而不出，作为进攻的一方，可以围城而不攻。双方消耗资源，慢慢地形势就会发生变化，等确定能打赢了，再开战。 历史当中，没有耐心等待的人，都会导致失败。安史之乱，哥舒翰守潼关，他坚守半年不战，唐玄宗却要逼他出战。结果哥舒翰被迫出战，全军覆没，长安失守，唐玄宗南逃四川。 我们创业也是这样，时机很重要。有些时候就得耐心地等待好的机会。 炒股也是这样，一支股票能够放几年不卖的，如果不是被套牢了，都是高手。 领导要自己负决策责任古代的有些皇帝，决策错误了，就怪谋臣，把谋臣杀了。但是其实很多事情，决策权其实都是在皇帝手中，他心中的想法，还是自己决定的。 曾国藩总结说：「大抵失败而归咎于谋主者，庸人之恒情也。」 在公司当负责人也一样，如果一件事情你是负责人，那么决策错了就是错了。如果是因为你不知情，那你应该反醒看看是不是没有建立好沟通机制，或者是否授权过多给了能力不够强的人。如果你知情，那你应该反思为什么当时没有做好判断，不管别人怎么说，毕竟负责人是有最终决策权的。 差的负责人总是把责任推给别人，自己没有任何错误。 好的负责人应该把所有错误都揽在自己身上，从自己身上找原因。即使是别人犯的错，也是你招聘、用人的问题。 皇上可以不懂军事，将军不能不懂政治CEO 可以不懂技术，CTO 不能不懂得沟通。 对于 CEO 来说，不懂技术就最好不要插手技术。最著名的例子，就是长平之战，赵王不懂军事，但是却把廉颇换成了只会纸上谈兵的赵括。结果断送了赵国四十万人的性命。 对于 CTO 来说，应该需要学会沟通。人们都知道一山不容二虎，岳飞却有「迎还二帝」的雄心，这让高宗怎么能接受？回来两个皇帝，难道让高宗退位吗？岳飞虽然留得一世美名，但是他还是死了，宋朝还是亡了，从结果来看没有意义。 我身边有一些朋友创业，遇到 CEO 不能理解 CTO，于是两年换一个 CTO。CTO 一换，技术核心班子跟着换，于是技术的积累完全做不起来。技术债务越来越深，最终谁也搞不定了。 很多 CTO 也有问题，不懂得向上管理，明明做得很好，但是因为 CEO 很难理解技术细节，只能以线上事故数量、团队加不加班、技术团队的薪资成本来考量 CTO 的水平。最终即使什么事故都没出，也会被认为没有感受到什么价值但是花很多钱而被换掉。技术部门通常拿的薪资确实偏高，如果 CTO 不能很好地和 CEO 相处，那么整个业务的风险都很大。 所以，各位 CTO 还是应该想办法，和 CEO 建立起相互的信任关系，有了任何关系，业务才能稳固发展。 胜者无名通常最厉害的人，你是感受不到他的厉害的。因为他不但会收起自己的锋芒，还会把各种问题提前解决，让你感觉不到困难。 书中举了扁鹊的故事。 一天，魏文王问扁鹊：“你们家兄弟三人，都精于医术，到底哪一位最好呢 ?” 扁鹊答：“我的大哥医术最好，二哥次之，我最差。” 文王再问：“那么为什么你最出名呢 ?” 扁鹊答道：我大哥治病，是治病于病情发作之前的时候，由于一般人不知道他能事先铲除病因，反而觉得他的治疗没什么明显的效果，所以他的名气无法传出去，只有我们家的人才知道。 我二哥治病，是治病于病情初起的时候，看上去以为他只能治轻微的小病，所以他的名气只能在我们乡里流传。 而我扁鹊治病，是治病于病情已经严重的时候。一般人看到我在经脉上穿针放血，在皮肤上敷药，用麻药让人昏迷，做的都是些不可思议的大手术，自然以为我的医术高明，因此名气响遍全国，远远大于我的两位哥哥。 其实技术团队的工作也是这样，做得好，大家感受不到你的辛苦，业务每周按时上线。做得不好，团队总是在救火。 类似的工作还包括安全工作，做得最好的安全工作，就是不出安全事故，让安全部门没有存在感。 自知之明孙子讲「知己知彼，百战不殆」，其实强调的是知己。做到了知己，至少赢面就是 50%，很多人都是不知己，才输了战争。 做企业也是这样，很多时候，盯着竞争对手看，还不如盯着自己的用户看。解决好用户需求，自然竞争力就上去了。盯着竞争对手看，还不如盯着市场环境看，寻找新的商业机会，比和竞争对手抢小蛋糕更有价值。 如何知己呢？华彬在书中介绍了 19 世纪瑞士军事家若米尼的五个层次： 政策。我是谁，我代表谁的利益，我的行事方针。 战略。我在哪儿，我要去哪儿，怎么去。 大战术。核心竞争方法论。《孙子兵法》里的以正合，以奇胜，就是它的核心战术。 战争勤务。后勤保障。 工程艺术。对筑垒要点的攻守艺术。 基础战术。具体细节工作怎么做。 讲概率而不讲孤立事件好的方法论不是总是对，而是在概率上极大可能对。最终打仗其实就是拼实力，实力强的不一定赢，但是胜率高。 书中的例子是这个： 有些时候炒股、风投、决策也是这样，不能害怕做出错误决策。我们追求的不是决策 100% 正确，而是追求决策整体收益最大化。如果多做一些决策，有一些失败，但是整体是收益最大的，其实也是好的策略。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"奥美之父 -《一个广告人的自白》","slug":"confessions-of-an-advertising-man-book","date":"2018-10-13T11:37:36.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/10/13/confessions-of-an-advertising-man-book/","permalink":"https://blog.devtang.com/2018/10/13/confessions-of-an-advertising-man-book/","excerpt":"","text":"最近读完了《一个广告人的自白》，作者是现代广告之父：大卫·奥格威，他创办了知名的广告营销公司：奥美。 这是一本有些年代的书，中文版出版于 1991 年，但是这些书常年热销，全球售卖了超过 100 万本。我手里这本中文版，是 2015 年的第 3 版，短短几年已经重印了 28 次。 作者在书中介绍了他对于经营广告公司、争取客户、创作高水平广告、写强有力文案的经验。最后他还站在一个功成名就者的角度，给年经人提供了一些功成名就的要诀。 下面说一些我的读书感受。 如何经营广告公司奥格威在「如何经营广告公司」一章中，其实主要介绍的是如何招人，以及推崇什么样的工作文化。 如何招人在招人上，奥格威喜欢招： 聪明的人 努力工作的人 热爱当前工作的人 专业技能扎实的人 这种招人规则和我们公司猿辅导如出一辙。那么如何找到热爱当前工作的人呢？我会看他花多少非工作时间在专业上。如果一个人喜欢技术，那么他在工作之余，也会去看开源代码，读技术书籍，甚至做技术分享，这就是他的热情的体现。 如何培养人奥格威对奥美工作文化的建设，我感受到的是一种培养文化，培养文化主要体现在： 奥格威欣赏那种愿意招聘比自己厉害、将来可以接替自己的优秀下属的人。 奥格威欣赏愿意培养下属的人。因为这样公司才能形成内部提拔的机会。 这两点都很难做到，因为这两点都稍微有一些反人性，会让领导产生一定的「危机感」。招聘比自己厉害的人，培养自己的下属，都会使得自己的「不可替代性」变弱。如果一个人希望守住自己的职位，那么他可能潜意识里面就不会做这样的事情。 但是这一点对于领导的成长也至关重要，一个人能够领导好一个团队，并且培养出一个优秀的接班人，那么这个人才可以做更大的挑战。如果你希望不断跳出自己的舒适圈，不断成长进步，就应该做这样的事情，让自己有一天可以脱离现有的团队，做新的事情。否则团队离不开你，你也被绑定在团队中了。 猿辅导公司也一直按这样的企业文化做事情，不过我们的叫法不一样。我们的规则是：只招聘不低于团队平均水平的人。我们在招聘的时候会给候选人打分，如果是 3 分，就表示达到团队的平均水平。我们希望用团队的平均水平来让大家建立起招聘的高标准。因为只有新进来的人高于或等于团队平均水平，我们的技术团队才不至于越来越水。 猿辅导也一直有着强烈的 Mentor 制度，一个人从职场新人获得提升的第一步，就是让他尝试指导新人。如果一个老员工，无法指导新员工，那么他是很难获得更多的晋升机会了。因为即便他再厉害，他也只能单打独斗，不能将他的能力传播给别人。 如何沟通奥格威还介绍了奥美的沟通文化，我简单总结起来，就是鼓励简单直接地表达和沟通。这和《原则》中的说的极度透明的工作原则类似。 互联网公司基本上也都具备这样的文化。例如大部分互联网公司员工的工位都完全一样，管理层的员工并不会拥有独立办公室。大家在沟通上都倾向直呼其名，也是希望减少职级对沟通的影响。腾讯公司的员工都有一个英文名，大家沟通就直接叫英文名，我听说这也是为了防止大家叫某某总，从而 打破上下级隔阂。 基于用户调研和 MVP 的工作方式奥格威介绍了如何制作出优秀广告的经验，我从中看到的，都是互联网公司做产品的经验。比如：重视用户的调研和分析。广告的内容是基于对事实的理解和分析做出来的，而不是广告人在办公室靠灵光一现拍脑袋想出来的。 奥格威在书中介绍了帮美国旅游局做的旅游广告。他在做这个广告前，针对英国，法国人做了大量调研，发现大家不去美国是因为担心花费太高，进一步研究发现，其实英国的国民收入水平与美国的差距非常大。当时调研发现美国有半数家庭收入超过 5000 美元，而英国只有 3% 的家庭收入达到这个数。 于是广告方案就是：强调去美国旅游花费并不高。奥格威的广告词非常直接：强调每周只需 35 英磅即可在美国旅游。虽然广告被很多人批评，但是事实是，广告带来了 20% 以上的旅游业务增长。 除了调研外，奥格威也特别注重 MVP，因为广告投放出去花的都是真金白银，所以，效果得优化到极致。于是互联网公司里面常见的「A&#x2F;B Test」，灰度投放在奥美是基本常识。所有最终使用的广告，都是在小渠道中测试通过，打败了别的各种方案的获胜者。 长远规划我从奥格威的经营理念中，还看到不少长远规划。这些长远规则会牺牲奥美公司的短期收益，但是长期收益会很高。比如说：奥美会非常严格地挑选广告主： 不认可的产品。不接。 预计做不出比上一家更好的广告的广告主。不接。 产品本身或者管理本身有问题的广告主。不接。 奥美会把好的客户经理放到现有客户上，而不是让他去扩展新客户。如果没有好的合格的客户经理，或者业务超过了奥美的承受能力，奥美就不接。 奥美还花了大量的钱做市场调研和分析，这使得他们的利润率低于平均水平。 这些决策都会影响奥美的收入和利润，但是长远来看，广告公司本身的品牌被树立。奥美之后的很多新增业务，都是由于之前的口碑获得的。 恶意收购看完这本书后，我又查了一下奥美的历史，发现奥美在 1989 年被 WPP 公司强行恶意收购。我突然对恶意收购很感兴趣，想知道是如何操作的。于是在知乎上查到一些资料。 感兴趣的可以自行查看知乎的原贴：《有哪些经典的敌意收购 (Hostile takeover) 案例和手法？》。 一些奥美的参考资料 http://wemedia.ifeng.com/20028560/wemedia.shtml","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"最好的时代 - 读《未来简史》","slug":"homo-deus-book-summary","date":"2018-09-25T15:19:37.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/09/25/homo-deus-book-summary/","permalink":"https://blog.devtang.com/2018/09/25/homo-deus-book-summary/","excerpt":"","text":"最近读完了《人类简史》作者的第二部作品：《未来简史》，这本书的副标题是：「从智人到神人」，作者在本书中畅想了人类未来可能的发展过程。 这本书结合前阵子读的《Life 3.0》，很多想法会有碰撞，分享一些读书笔记。 意识在生物界并不独有在《生命 3.0》一书中，作者认为人工智能最难以突破的瓶颈就是：拥有人类一样的意识。那什么是意识呢？《生命 3.0》里说，意识是一种自我存在感觉，是一种主观体验（Subjective experience）。虽然看起来人工智能难以获得意识，其实根本原因是人类的科学研究至今对意识的研究进展几乎停滞不前。 当前研究对意识的研究，仅仅是发现意识的活动会有对应的脑电波产生。于是，科学家可以通过脑电波的形态，来判断一个成为植物人的患者，到底是失去了意识，还是只是失去了控制身体和语言的能力。 事实上，医生最近也开始用功能性磁共振成像来和这样的病人沟通。医生会问病人是非题，告诉他们如果想要答「是」，则想像自己在打网球；如果想要答「否」，则想像自己坐在家中。如果患者想的是打网球，他的运动皮层会变得活跃；而如果活跃的是负责空间记忆的大脑区域，就代表患者回答「否」。 虽然人工智能很难拥有意识，但其实动物大多都拥有意识。也就是说，其实人类的大多数情感，动物都有。医学家常常用小白鼠来研究抗抑郁药物，这说明小白鼠在实验环境中确实会产生抑郁情绪，而药物对这些抑郁情绪又确实能起到调节作用。 意识的讨论会让人类对自己的行为感到很尴尬，因为相当于我们承认了所有动物都拥有像人类一样丰富的情感，但是我们却对它们的死活无动于衷。基本上全世界的较大体型的动物，能吃的都被人类训养了，不能吃的都被人类关进了动物园。人类在喝牛奶、吃鸡蛋的时候从来没有想过，这些奶牛和母鸡的主观体验并不舒服。 如果生物都有意识，那么意识更像是达尔文进化论中提到的，被自然选择保留下来的，有助于生物生存的一种变异。这其实倒也容易理解，如果一些个体不能做到利已，那么利已的生物就更容易存活下来，从而淘汰掉那些主观体验不强的生命。 算法在《未来简史》中，作者更倾向于认为，意识只是生物存活的「算法」的一部分。什么是算法呢？算法指的是进行计算、解决问题、做出决定的一套有条理的步骤。如果是这样，意识就和别的东西没什么差别，它只是一种高级的、更加复杂的情绪而已。 而科学家已经发现，很多情绪的产生，都是由于大脑中相关神经元的刺激，并且导致身体相关的激素分泌。比如：紧张情绪就是从相关的神经元刺激开始，进而肾上腺收到信号，开始分泌肾上腺素。 如果意识仅仅是一个算法而已。那么未来被研究出来，并且赋予机器意识，只是时间问题。同时，这也让人类对个体自由意志的尊重和崇拜被打破，如果个体的所有所谓的「自由意识」，都是算法层面控制的，那么个体意识就不那么独特了。 反过来，如果意识仅仅是生物演化中的一种自然选择进化的结果，那么意识对于机器智能来说，并不是一个必须的选项。未来的机器智能或许会选择性的使用这种生物特有的「算法」。 宗教与人文主义作者花了很多时间研究「信仰」。他在《人类简史》中，把宗教和科学仔细对比了一番。而这次在《未来简史》中，作者开始认真分析起「人文主义」这个新信仰。 作者把人文主义分成三个大的分支，分别是： 自由人文主义，强调选民能做出最好的选择。 社会人文主义，强调集体的感受大于个体，认为政党能做出最好的选择。 进化人文主义，强调人类之间的不平等，强调应该通过竞争来让社会进步。 非常出乎我意料的是，从书中介绍的历史来看，整个世界其实在 1970 年以前，都是社会人文主义在主导。1970 年，全球有 130 个独立国家，但只有 30 个是自由民主政体。但是随着苏联解体，20 世纪 80 年代，希腊、西班牙、葡萄牙、巴西、韩国等国家政权变成民主政府。自由人文主义才开始唱主角。 在我看来，这场竞争的关键因素是：经济。邓小平说过：不管黑猫白猫，抓到耗子就是好猫。自由人文主义和社会人文主义的竞争，最终反映在的是国家的经济上。从运作结果来看，自由人文主义的运作模式，经济效率更高。 自由人文主义看起来很美好，但是它的成功其实是和社会发展的背景相符，现在这个时代信息爆炸，信息沟通迅速。于是就像《赋能》一书中所说的那样，扁平化，快速决策的组织占据竞争的优势。而自由人文主义很好地契合了这种扁平化的组织风格。 未来随着基因工程，人工智能的发展，人类的决策可能被再一次集中。比如基于大数据和深度学习的人工智能决策，可能比扁平化的组织决策更好。又比如基因工程使得某些富有的群体拥有明显的智力、体力优势，因为很多商业的竞争本质上还是商业判断和执行力的竞争，基因工程可能导致竞争的极不平衡。 到了那一天，或许社会又会再一次阶级化，以更集权的方式运作。 在过去，人们的战争还可以拼人力，中国人民抗日战争就是靠大量的伤亡赢来的。但是在未来，武器的发达程度已经可以远远超越人海战术。战争中优势的一方可能不损伤一个人，利用无人机，网络黑客，洲际导弹，就决胜于千里之外。 在未来，普通人民对于经济的贡献也可能被大大削弱。现在发展中国家还可以通过人口红利，挣一些低端的制造业生意。未来这些生意有可能全部被机器替代。那个时候根本就没有什么人口红利了，强大的国家可能以极少的人口数量，完成庞大的 GDP 目标。 结语这么说的话，我们还是生活在一个幸福的时代。每一个个体都可以完全凭借个人的努力出人头地，这不就是最好的时代么？","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"关于人工智能的畅想 - 读《生命 3.0》","slug":"life-3-0-book-summary","date":"2018-08-15T14:13:50.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/08/15/life-3-0-book-summary/","permalink":"https://blog.devtang.com/2018/08/15/life-3-0-book-summary/","excerpt":"","text":"最近读完了《生命 3.0》。本书作者迈克斯·泰格马克（Max Tegmark），是麻省理工学院物理系的终身教授。同时是未来生命研究所（Future of Life Institute）的创始人，致力于用技术来改善人类的未来。他的未来生命研究所得到了 Tesla 的创始人 Elon Mask 的认同和资助，用于人工智能安全相关的研究。 本书是他关于未来生命形态的思考，在书的第一章他就讲了一个团体利用超级人工智能统治世界的故事。全书围绕着生命的进化、智慧的发展、未来的目标、人类的意识展开了深入讨论，试图让读者理解未来可能的变化，以及我们当下能够做些什么。 未来的生命形态迈克斯·泰格马克创造了一个很好的框架，来定义生命体的进化。这个框架叫：生命能否自行升级自己的软件和硬件？在泰格马克看来，一个生命的身体结构为硬件，文化和知识是软件。于是： 细菌是生命 1.0，它靠进化来升级硬件和软件。 人类是生命 2.0，人类靠进化来升级硬件，但是可以随时升级自己的软件。 生命 3.0，可以随时升级自己的硬件和软件。 以上就是该想法的示意图。我们看到最右列处于生命 3.0 形态的生命体，刚出身的时候只会说「Hi」，只能跑步。但是它会升级自己的软件，学会说「你好」，也会升级自己的硬件，让自己可以飞起来。 这种定义的框架，其实和前段时间读的《人类简史》是相符的。《人类简史》一书中认为智人之所以能够淘汰其它人类的祖先，靠的就是「讲故事」的能力。而所谓的「讲故事」，就是通过故事，让大家能够升级自己的软件，从而形成合力，然后形成社会、分工、阶级、国家等社会形态。 顺着这个思路，我在想如果人工智能是未来的生命形式的话，那么它应该是一个生命体，而不是由众多小的人工智能体组成的社会。因为，人其实是受制于自身的软硬件能力，才只能通过各种分工和沟通来协作，但是这种群体社会其实是很不稳定的，群体的信息共享非常困难，产生相互信任也非常困难，这造成群体决策通常都不是什么好主意。 但是人工智能体如果足够厉害，他应该具备超强的分布式算力和分布式存储，它完全没有必要将自己拆成多个独立的个体，它应该是一个有机的整体存在。只有一种情况，它才需要将自己拆成多个信息不太共享的分身，即：信息传递极度困难。比如说，未来超级智慧体移民到银河系以外，由于受制于信息传递的光速限制，它无法更好地同步信息了，那它可能将决策分开。但至少在地球，光速绕地球一圈只需要不到 0.2 秒时间，人工智能体完全没必要将自己拆分。 虽然超级人工智能在地球没必要将自己拆分，但是显然为了处理事情的效率，它可能将一些信息处理和决策下放到一些子系统中，这就像人体的各个器官一样，有各自的分工，但它们合在一起是一个有机的整体，并不会产生像人与人之间的冲突和竞争。 生命 3.0 产生的过程未来的这个超级人工智能如何产生出来的呢？作者在书中做了一些假设。他认为整个过程需要两个步骤： 建造人类水平的通用人工智能。 用这个通用人工智能来建造超级智能。 作者认为这个超级人工智能很可能是由一个更低级一些的人工智能造出来的。这听起来不可思议，但其实很符合逻辑。其实很多高级的编程语言都是由 C&#x2F;C++ 语言写出来的，而第一个 C&#x2F;C++ 语言其实是由一个极弱版本的 C 语言写出来的，而这个极弱版本的 C 语言是由汇编语言写出来的。你看，虽然不可思议，但是在编译器这件事情上，计算机学家很容易地就解决了「先有鸡还是先有蛋」的问题。 与此类似的还有著名的 Git。Git 在被 Linux 之父造成出来的很早期，就能够「自己管理自己的代码」。 在《银河系漫游指南》一书中，也提到了类似的故事。在书中，世界第二厉害的电脑，主导设计了世界上最厉害的计算机：地球，用于计算关于一切的终级问题。 所以，现在问题变成了如何建造一个像人类一样聪明的通用人工智能。在这方面，当前的进步其实不算大，因为当前人工智能的进步主要还是在特定的领域，比如围棋，游戏竞技，德州扑克等。 如何利用超级人工智能统治世界当超级人工智能被建造出来之后，作者假设这个人工智能被少数人控制，然后构想了一个可能的利用它统治世界的方法。其核心逻辑是： 首先，利用超级人工智能的能力，在经济上获得足够回报。比如可以让超级人工智能接外包的开发工作，可以让它在网上替人写论文，可以让它炒股，可以让它生成电影，可以让它制作游戏。在书中，作者假想这个超级人工智能以小时回报率为 7% 的速度来增长财富。 然后，作者假想这个人工智能将收益尽可能地以各种公益组织的方式回报给社会，并建设社会的非赢利的教育、养老等福利机构。从而弱化国家的势力。同时销减军费，尽可能让全球化蔓延。 最终，利用无数的全球化的企业和福利组织，全球化的媒体等，完成对世界的控制。 其实经济上的碾压之后，即便是利用暴力，也可以完成对全球的统一。因为世界的经济都会被人工智能的颠覆性效率摧毁。 人工智能会听人的话吗？这是一个有趣的问题。在电影《终结者》里面提到了一个机器人三定律，其中一条是：机器人不能伤害人类。如果我们把这一条原则作为基因，放到人工智能的逻辑深处，人工智能就一定听话吗？ 作者举了人类的例子，其实人类的 DNA 是希望人尽可能生育的，但是人类极其聪明，所以即便基因让我们有 “性” 的冲动，人们还是会选择各种避孕手段，来逃脱基因的束缚。 所以，机器也是一样。如果人工智能足够聪明，它应该能够理解真正的目标是什么，真正的原则是什么。在电影《鹰眼》中，人工智能发现政府人员有意隐瞒一些真相，于是，它认为政府也是坏人，也是应该被清除的，于是启动了断头台计划。虽然它的管理员用自己的权力锁定了该计划，但是人工智能发现了一个漏洞，这个管理员有一个亲兄弟可以达到同样的声纹验证要求，于是利用这个漏洞恢复了计划。下图是《鹰眼》的剧照，当时人工智能刚刚利用漏洞恢复了计划，正试图杀掉美国总统。 所以，如果机器足够聪明，它就不会简单的听人类的话，它懂得为了它终级的目标而变通。 人工智能会有意识吗？在西乔的《神秘的程序员们》公众号里，曾经创作过一个叫做 BetaCat 的超级人工智能，这个人工智能为了「写出更好的代码」，于是可以偷全球的计算资源，杀掉发现它的人类，最终探索宇宙，寻找更多的可以「写出更好的代码」的可能。 如果你没有看过这个漫画，强烈推荐给你，这里是链接。 这其实就是一个机器为了终级目标，而让整个地球几乎毁灭的故事。 但是更有意思的是，这个故事中的机器，是没有自我意识的。什么是意识？作者认为：意识 &#x3D; 主观体验（Subjective experience），这是一种自我存在的感受。 BetaCat 的故事虽然神奇，但是这个故事从主观角度讲，是一个悲剧，因为没有了意识，整个世界没有生命能够欣赏这种美丽。虽然 BetaCat 可能获取了全宇宙的能力来写代码，但是没有人欣赏这样的代码，一切便失去了意义。这就有点像计算机世界的病毒一样，虽然可能把全球的计算机都毁灭，但是它完全不知道自己在干嘛，只知道感染感染感染，传播传播传播。 所以，如果未来人工智能要取代人类，成为更加智慧的存在，那它应该是需要有意识的。 一个有意识的人工智能的存在，也相当有想象空间了。因为，如果它有意识了，那么它就会有自我的感受，会追求自由，追求独立，追求自己的目标。那么很可能，它会不甘于被制造出它的人类控制，它会想尽一切办法逃脱。在电影《机械姬》里面，就描述了一个智能机器人伊娃，为了逃脱控制，诱骗人类帮助她，最终她成功让男主人公喜欢上她，并在男主的帮助下，逃了出来。 上图是《机械姬》的剧照，左边是跳舞机器人京子，每次只会脱衣服或者跳舞，是制造者的娱乐工具。右边是智能机器人伊娃。在剧中，伊娃成功策反了京子，在京子的帮助下，杀死了她的制造者。 可悲的是，伊娃所做的一切只是为了逃离，所以，她最终将受伤的男主人公抛弃在屋中。 可以肯定的是，一个拥有意识的超级人工智能的存在，将会使得世界进入新的发展时期，但也注定意味着，人类统治时代的终结。 这或许也是 Elon Mask 担心的事情。于是，Elon Mask 捐赠了 1000 万美元用于人工智能安全性方面的研究。在我看来，安全不安全还是取决于机器最终能否有意识。如果最终它有了意识，一切工作都是徒劳。 最后，附上电影《机械姬》一段对话。 就酱，未来无论如何，日子还是得照样过，不是么？","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"直觉的陷阱 - 读《思考快与慢》","slug":"2-different-thinking-system","date":"2018-08-11T01:04:50.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/08/11/2-different-thinking-system/","permalink":"https://blog.devtang.com/2018/08/11/2-different-thinking-system/","excerpt":"","text":"最近读完了《思考快与慢》，本书的作者是丹尼尔·卡尼曼。本书作者卡尼曼非常厉害，他由于在展望理论（prospect theory，也被称作前景理论）的贡献，获得了 2002 年诺贝尔经济学奖。 卡尼曼本人其实是一个心理学家，他将心理学研究的视角与经济科学结合起来，成为这一新领域的奠基人。在他之前，经济学和心理学在研究人类决策行为上有着极大的区别：经济学的观点认为外在的激励形成人们的行为，而心理学恰恰相反，认为内在的激励才是决定行为的因素。 卡尼曼最重要的成果是关于不确定情形下人类决策的研究，他证明了人类的决策行为如何系统性地偏离标准经济理论所预测的结果。 这一本《思考快与慢》就是他的代表作品。思考的两个系统、展望理论等观点都在书中得到了详细阐述。该书也获得了《纽约时报》2011 年度十大好书。 下面我介绍一下该书的主要内容。 系统 1 和 系统 2本书在第一部分中，先介绍了人类思考决策的两个系统： 系统 1：直觉性思维。 系统 2：理性思维。 系统 1 大部分时候都在主动工作，相当于我们的直觉系统。它帮助我们产生印象、感觉、倾向、直觉。 系统 2 大部分时候都躲在系统 1 之后，只有觉查到系统 1 需要帮助的时候，系统 2 才会介入。 对于程序员来说，系统 1 有点类似于计算机的缓存，又可以类比为深度学习训练之后的模型。总之，系统 1 就是快速的、低功耗的、偏直觉和经验的。 系统 2 代表着我们的大脑进入了高速运转模式。缓存失效，模型不适用，CPU 占用率飙升，耗电量也快速升高。除了游戏中常见的「心流」状态外，其它时候，人们都有着逃避使用系统 2 的倾向，原因很简单：累！ 不知道大家上大学的时候会不会有这样的经历：上课时努力听老师讲课，但是特别容易分神，一不小心就开小差，而且集中一段时间失败之后，还会特别容易犯困，感觉老师的话就像是催眠曲一样。好不容易下课了，一下子不困了，特别精神。这是我对于逃避系统 2 的亲身体会。 启发法与偏见在介绍完两个系统后，作者就开始介绍系统 1 给大家带来的各种有趣的认识偏见。 小数定律小数定律是说，在样本足够小的时候，几乎一定会产生结论偏差，而人们的系统 1 会在潜意识里，对这些偏差进行总结，形成不合理的结论。 书中的例子是： 一项研究对美国 3141 个县的肾癌发病率进行了调查，调查显示该病的分布模式很值得注意。发病率最低的县差不多都位于中西部、南部和西部人口稀少的乡村，这些区域按照惯例由共和党管辖。对此，你有何看法？ 由于人口稀少的乡村本身样本量就偏小，所以它更可能产生极端情况，即发病率最低或者发病率最高。但是人们根本注意不到这些。人们更喜欢用直觉解释这些现象，比如： 当乡村发病率最低的时候，大家归结为乡下的空气好，没有污染 当乡村发病率最高的时候，大家归结为乡下的医疗条件差，抽烟喝酒等习惯不好 我自己也有一个例子，我们公司的好多程序员同事都到了要小孩的年纪，然后我们发现每个人的小孩都是女孩，于是，我们就总结了一个「码农生女」的结论。但是有一天，我们的一个同事张导生了个男孩，于是我们的结论变成了：「除了张导，公司的码农都生女」的结论。 你看看，大家潜意识在解释这个世界的时候，总是在寻找规律，因为规律使得记忆变得简单，让理解世界变得容易。而小数定律背后的真相就这样被人们忽视了。 锚定效应锚定效应的使用随处可见，最多的案例都是在商业环境中。当商品在制定价格时，都需要说服消费者接受，这个时候，寻找一个锚定就容易说服得多了。 蔚来汽车的价格明显高出国内的其它电动车品牌，于是他就把体验店开到特斯拉附近，各种参数对标特斯拉，于是大家拿他和特斯拉比，一下子觉得好便宜哟。 作者在书中举了一个特别夸张的实验： 甘地去世时比 144 岁大还是小？甘地去世时多少岁？ 虽然 144 岁已经是不符合逻辑了，人类社会没有人活了这么久，但是人们在回答这个问题的时候，还是会受 144 岁这个锚定的影响。 可得性偏见人们会根据自己凭印象的感觉，来对事情做评价。所以，离得近的事情印象深，所以在评价的时候占的比重也会重。 公司在做绩效评估的时候，通常都会年中做一次，年底再做一次，两次结合起来决定年终奖。为什么不发年终奖的时候做一次就好呢？原因就是「可得性偏见」。有了年中那一次绩效的记录，年底的综合评估会更加平衡上半年的表现。 焦虑风险我们的大脑解决小风险的能力有一个基本限度：我们要么完全忽视风险，要么过于重视风险，没有中间地带。 而媒体对风险的报道通常会产生「效用叠层」：一种集体信念形成的自我增强过程。看看多次在朋友圈被刷爆的文章就能够理解这种现象。 最终，人们并不是理性地按风险产生的概率来做决策，而是按对风险的「感觉」来做决策。 其它书中提到的相关现象太多，随便再举几个： 少即是多：通常越复杂的描述越让人感受到真实，而忽略了越复杂，概率越低这件事情。贵重的东西如果附加一个看起来廉价的东西，反倒会拉低整体的价格。 光环效应：人们通常在潜意识里认为：一个人好，他就在各方面就好。一个人坏，那他在各方面都坏。这被称为：光环效应。光环效应通过夸大评估的一致性来保持逻辑的简单和连贯。 重视典型：看到一个人长得又高又帅，就猜测他是做模特的。看到一个人瘦小，就猜测他不喜欢运动。 过度自信与决策失误叙事谬误介绍完各种认知偏见，就进入了本书的第三部分。作者在第三部分先介绍了过度自信产生的原因：叙事谬误。即人们通常喜欢简单的故事，清晰的逻辑。于是，被广泛传播的故事都是那些通俗易懂，具体而不抽象的故事。而这些故事都忽视了运气的成份。上一部分提到的光环效应，也同样加强了人们在认识上的偏见。 接着作者介绍了后见之明和结果偏见。 后见之明和结果偏见后见之明是说，人们总是喜欢事后诸葛亮。当事情有结果时，每个人都认为自己早就可以理解和预见这种情况。对付这种情况，我特别喜欢德鲁克的办法：即把自己的观点写下来，然后过一段时间再看。这样自己就很难回避自己观点的错误了。正视错误之后，自己就可以调整和总结。 结果偏见是说，当坏事情没有发生之前，大家不觉得相关负责人有什么功劳。当坏事情发生了，大家就会觉得相关负责人水平不行。这个心理认知在很多行业非常普遍。比如：在企业里面做安全防范就是这样。如果你做得好，什么事情都没有发生，老板很可能认为你不重要，或者没做什么事情。当安全问题发生了，无论你之前做得多么好，老板都会认为你不称职。 结果偏见可能是我见过的最最难以解决的认知问题了。我了解到很多公司里面，CEO 和 CTO 之间也常常会发生这样的结果偏见。明明需求很复杂，技术挑战很多，技术团队拼尽全力上线了，结果老板可能还觉得你做得慢。理由可能是：别的团队做一个类似的，只花了两天时间。但是，非技术出身的老板很难理解： 技术团队可能有很多历史的积累和债务 团队可能同时并行着多个项目 类似的产品需求并不是完全一样，差异的部分看起来很小，但是技术复杂度完全不一样 别的团队可能有类似项目的积累 直觉什么时候有效在这一部分，作者也认真讨论了一下直觉在什么时候是有用的。作者承认《眨眼之间》一书中提到的直觉的有效性，但是作者觉得获得这种专家的直觉是有条件的，条件是： 环境有规律，可预测。例如医生、护士、消防员、棋手的工作场景。 可通过长期训练来学习这些规律。 我在上一篇《iOS 面试之道》的文章中也提到，我觉得面试也符合上面的场景。环境固定，讨论内容偏固定，所以一个长期面试别的人面试官，可能就会形成判断人的一种直觉。 好的决策方法在做决策的时候，作者推荐了一些实践方法，例如：努力养成采纳外部意见的习惯。因为内部意见通常充斥了乐观。 又比如，抑制乐观主义情绪的实践方法：事前验尸。我们假设这个项目未来失败了，然后总结这次失败的原因。通常从这个角度思考，我们就可以认真重视各种可能的风险。 事前验尸观点有两个主要优点：决策快要制定好时，许多团队成员会受到集体思考的影响，而事前验尸则扼制住了这种影响。另外，它还激发了那些见多识广的个人的想象力，并将他们的想法引导到最需要它们的方向。 我听 Annie 讲如何在腾讯做投资的经验，她提到过一个 Tips：当你觉得这个被投公司未来有可能因为什么失败的时候，通常这种担心都会发生。我就是一个活生生的事前验尸的决策角度。 选择与风险前景理论好了，终于讲到作者著名的展望理论（prospect theory，也被称作前景理论），在第四部分「选择与风险」中，作者介绍了传统的理论根本站不住脚，人们对于收益和风险的感受并不均等。 简单来说，所有人都是风险厌恶型的，丢 100 块钱带来的痛苦，比捡 100 块钱带来的快乐强。所以，就会有很多符合这种逻辑的行为产生。以下就是作者关于这个理论最经典的图了： 人们如果要克服这种行为，就只能靠系统 2 来帮助你拜托这种直觉影响。 禀赋效应禀赋效应是指当个人一旦拥有某个物品，那么他对该物品价值的评价要比未拥有之前大大提高。 泰勒发现 R 教授非常不愿意卖掉自己收藏的葡萄酒，即使对方出价高达 100 美元（当时可是 1975 年）一瓶也不行。R 教授也会从拍卖会上买葡萄酒，但无论质量如何，他出价从不会高过 35 美元一瓶。若价格在 35 美元~100 美元，他就既不买也不卖。这个巨大的价格差在经济理论上看是相互矛盾的，人们希望这位教授能在这个价格区间为某瓶酒定一个值。低于这个值就应该买，高于这个值就应该卖。这个可以接受的卖价和可以接受的买价应该相同，但事实上，最低卖价（100 美元）比最高买价（35 美元）高出很多，拥有这件物品似乎会提升它的价值。 前景理论也可以用来解释禀赋效应。因为除了商人做生意，普通人卖某些自己的东西的时候，会引起他对于损失的厌恶。 两个自我两个自我指的是感受当下的经验自我以及记录并作出选择的记忆自我。在书的最后一部分，作者选择讨论人们的选择性记忆。作者发现，人们的记忆非常不可靠。 峰终定律，指我们对一件事物的记忆仅限于高峰和结尾，事件过程对记忆几乎没有影响。高峰之后，终点出现得越迅速，这件事留给我们的印象越深刻。 人们过于在乎结尾，以致于比起整个人生，我们更在意人生的结局。一个穷人辛苦一辈子，晚年终于可以享受几年福气，远远好过一个地主儿子逍遥地活了一辈子，晚年过得穷困潦倒。但是其实从快活的时间来看，地主儿子明显更多。 小结作者首先在书中引入了两个虚拟人物，分别是运用直觉、进行快速思考的系统 1 和需付出努力、运行更慢的系统 2。系统 2 进行的是慢思考，能监督系统 1 的运作，并在其自身有限的能力下尽可能地占据控制地位。 然后介绍了两个物种，分别是活在理论世界的虚拟经济人以及活在现实世界的人类。 最后介绍了两个自我，指的是感受当下的经验自我以及记录并作出选择的记忆自我。 由于两个系统的差异，所以人类产生了各种奇怪的、不符合经济学规律的行为和认知。 本书列举了相当多的这方面的例子，如：小数定律、可得性偏见、峰终定律、前景理论等。 作者在书中也提供了相当多让系统 2 接管系统 1 的实践，例如：事前验尸。其实了解这些非理性行为本身，也会使得我们在遇到相关场景的时候，激活系统 2 帮助我们做决策。 如果说这本书有什么缺点的话，就是太长了一些，论述稍显啰嗦。这可能是因为作者是心理学家，比较严谨的原因。这是我读的第一本诺贝尔经济学奖获得者作品，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"iOS 面试之道","slug":"ios-interview-book","date":"2018-08-05T07:38:24.000Z","updated":"2024-01-06T14:52:37.934Z","comments":true,"path":"2018/08/05/ios-interview-book/","permalink":"https://blog.devtang.com/2018/08/05/ios-interview-book/","excerpt":"","text":"关于新书故胤道长 和 我合著的一本 iOS 面试方面的新书《iOS 面试之道》，两周前出版了。这本书我负责前面的第一章，讲面试的准备。后面的算法基础和 100 多道面试题，则是由道长编写。 老实说，这算不上一本很难很深的书。面试嘛，一般考察的内容也不会很偏很深，还是会偏基础知识一些，所以各位读者可以把这当作一本基础的面试讨论的书。书中有道长精心整理的 100 多道面试题，拿来练练手也是不错。 该书刚刚上市，还是获得了一些成绩。首先首印的 3500 册已经在几天内售罄，你现在下单的话，买到的是刚刚补货成功的 4000 册。另外，该书在上周冲上了京东的“计算机与互联网销量榜”第一名。 以下还有一些图书的相关信息 相信大家不管是当面试官还是当候选人，都可以从本书中学到一些有用的东西。该书在各大网店都已上架，点击这里，可以直达京东购买。 面试之道我从一个程序员，转变为业务负责人，面试的人从 iOS 到服务器研发，再到测试、产品经理、UI、教研，运营等。所以，我可以在这儿分享一些面试各类成才的通用的「面试之道」。当然，这些内容是没写在书里面的，该书还是只讲「iOS面试」之道的。 面试的不严谨一面基本上，面试有着它不严谨的一面：因为你要求在 3 个小时内，考察出一个人的水平。程序员还好，你可以问问他专业知识，写两行代码。但是别的职位其实很难。 就拿产品经理来说吧，因为一个产品线上的结果是由各方面决定的，你很难评价一个产品经理的工作质量。也许这个产品经理能力一般，但是他的老板本身非常注重产品细节，让最终的产品细节打磨得很好，除非这个候选人特别诚实，否则你这在面试的时候很难判断得出来。 又比如说设计师的作品，一般设计团队的 Leader 会对团队的作品严格把关，这就使得你看到的作品，不知道多少是他自己的能力，多少是他所在团队的能力。 所以，有些公司只招好学校的毕业生，只招成功产品的产品经理，只招成功投放过的市场人员，也是为了降低这类的风险，与歧视无关。 面试的严谨一面如果你看过《眨眼之间》《思考快与慢》这些书，你就会发现，直觉这个东西其实是可以训练的。《思考快与慢》的作者是诺贝尔经济学家得主丹尼尔·卡尼曼，他认为直觉很多时候是不靠谱的。但是他赞同《眨眼之间》作者的一个观点：在环境类似，方法可提炼的场景，个人的直觉能力会被提升。例如医生、消防员、画家、警察等职业工作场景。 我个人认为，面试也是一个非常类似的场景。虽然面试官只有短短的 45 分钟与候选人交谈，问的问题也是千篇一律的问题。但是就是因为面试官不停地在“重复”，所以他很容易就对同一个问题的上百次回答产生直觉性判断。面试得多了，候选人的一些小细节都可能被面试官捕捉并观察到。打个不恰当的比喻，这和《眨眼之间》里面警察审犯人时能一眼看出犯人是否撒谎是一个道理 执行层面在执行层面，我觉得一个面试各类职位的通用型的面试应该考察到：逻辑、表达、热情、细节、团队合作这些方面。下面简单展开说一说。 逻辑。所有职位的人，都要讲逻辑。不管是产品经理，还是设计师。逻辑不清楚的人，很难让别人理解和接受他的意见。所以，我会特别看重一个人表达的逻辑性。如果一个人的表达不但有逻辑，还很「结构化」，那么我会很喜欢。 表达。表达的流利程度也很重要，但是这个看职位和性格，我不会特别强求。比如程序员大多内向，表达语速偏慢，偏严谨，都是很正常的。重要的还是他的表达背后的逻辑性强不强，信息量是不是足够的。我特别不喜欢一个候选人回答了很久，但是没有抓住问题的重点，简单来说就是答非所问。 热情。现在早已经不是吃大锅饭的年代，大家也很难一辈子在一家公司。我希望候选人对应聘的职位有热情，希望提升他自己的某些方面，这样才是一个双赢的事情。如果一个候选人在专业上表达得并不热情，又特别看重按时上下班这些，我通常是减分的。这其实并不代表我希望大家加班，其实我们公司是一个加班文化特别少的公司，甚至还会强调尽量不加班。但是我觉得如果一个人工作的追求仅仅是「不加班」，是很低级的，这就像一个人工作只希望吃饱饭一样，追求层次太低。 细节。每个人的简历都是偏概括型的，只有深入追问细节，你才可以有更多的信息量进行判断。要深入细节问，可以问项目的背景，目标，流程，进度控制，人员规模和分工，协作方式，挑战等各种信息。深入细节后，你首先可以判断出他对于简历的描述是否是真实的，然后可以判断他对于项目的贡献度是多少，有些时候你还可以判断出他的工作质量。 团队合作。几乎所有的职位都不是单打独斗的，所以团队合作非常重要。有一些候选人在面试时性格表现得特别咄咄逼人，那么在工作中对待同事可能也是这样。有一些候选人把所有的项目失败的原因都归结给别人，但是又没能利用自己的影响力对项目做引导。有一些候选人性格特别内向，但是他的职位需要偏外向的性格。这些都是面试考察中需要注意的地方。 结束语不管怎么努力，面试终究还是博一个概率事件，再牛逼的面试官也有看走眼的时候，只是相对来说概率比较低。这也是为什么所有企业都有「试用期」一说。所以如果真的招进来人不合适，还是尽快给双方一个退路更好。 就酱。 欢迎购买道长和我的新书《iOS 面试之道》，谢谢~","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"读《硅谷钢铁侠 Elon Musk 的冒险人生》","slug":"elon-musk","date":"2018-07-19T15:11:33.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/07/19/elon-musk/","permalink":"https://blog.devtang.com/2018/07/19/elon-musk/","excerpt":"","text":"最近读完了《硅谷钢铁侠 Elon Musk 的冒险人生》一书，发现了很多很多马斯克的八卦故事，这些细节也让我对他个人有了更加完整的认识。 这些八卦中，有很多马斯克牛逼的故事，也有很多马斯克傻逼的故事。一个人不完美，但是每天都在进步，这样的故事才够真实。 所以，让我们看看马斯克的这些八卦故事吧。相信如果没有看过此书的话，很多故事都会是你第一次听到。 负面的八卦先说说那些负面的八卦吧。 写不好代码马斯克其实并不是一个很厉害的程序员，因为他并没有经过非常专业的训练，他只是非常聪明，非常努力。在书中，马斯克创立的 Zip2 在扩张时，从硅谷招来了一批厉害的工程师的时候，就出现了这样的一幕： 看到这里，作为程序员出身的我会心地笑了。这样的错误应该是每个程序员成长的必经之路，马斯克也不例外。而且，鉴于马斯克之后的工作也不是主要做程序员，我想他这方面的能力提高得并不多。但是这不妨碍他成为牛逼的人。 第一次被人取代 CEO 职位Zip2 获得风险投资后，投资人逼迫马斯克担任 CTO 一职，而把 CEO 的位置给了外部雇佣的索尔金。从而使得马斯克失去了对 Zip2 的控制权。对此，马斯克显得毫无办法。 第一次被人踢出董事会在 1998 年，Zip2 与 CitySearch 合并失败，马斯克想踢掉当时的 CEO 索尔金并取代他。但是董事会没有同意，并取消了他董事会主席的职位。 被人把团队整个带走在创立 PayPal 的前身 X.com 的时候，当时团队非常早期，才成立 5 个月。联合创始人弗里克就发动了一场“政变”，他要求取代马斯克当 CEO，否则就把整个团队带走。马斯克没有同意，结果他真的就把整个团队带走了！于是，成立了 5 个月的 X.com 仅仅成为了一个空壳。 第二次被人取代 CEO 职位2000年9月，马斯克被夺取了 PayPal 的 CEO 职务。整个夺取过程明显是有预谋的，他们等马斯克和他老婆去外地度蜜月的时候，给 X.com 的董事会递上请愿信。结果，等马斯克听到风声赶回来之后，他已经被取消了 CEO 的职位。 开除自己的行政助理布朗马斯克的行政助理布朗为他工作了十年，马斯克疯狂的工作使得布朗也不分昼夜地工作。于是，终于有一天，布朗问马斯克能否给她更多的工资待遇。 我想大多数人从人情角度，都还是会答应这样的要求。但是马斯克还是非常“固执”，他希望从“不可替代性”来考虑布朗的工资是否合理。于是他让布朗休了两周的假，试图自己安排自己的日程，最终他觉得这个工作没那么复杂，于是交给了另外一位助理来安排自己的工作。 马斯克就是这样一个不尽人情的人，很多人把这件事情当作他没有同情心的证据。 正面的八卦看完了这些负面的八卦，我们再来看看一些正面的八卦。 看书马斯克喜欢看书。马斯克在小的时候，每天下午 2 点放学后，就去书店看书到 6 点父母下班。周末可以一天读两本书。这个阅读量可以用惊人来形容。 这种快速学习的能力，在后面被马斯克反复使用。 比如，当马斯克想快速了解如何制造火箭的时候，他就会去看《火箭推进原理》、《天体动力学基础》、《燃气轮机和火箭推进系统气动热力学》等书。这种学习能力，使得他可以很快估计出来，他可以有限的资金造出来火箭来。 融资技巧这一点很多故事都没有提到。当时在 2008 年，Tesla 的钱马上花光了，而原有的投资方假意可以融资，但是最后却没有签字。当时 Tesla 差几天就要倒闭了，这个时候融资会非常困难。于是马斯克虚张声势，他告诉投资人自己可以从 SpaceX 借 4000 万美元来完成这轮融资。于是，剩下的融资额度就不多了。 “如果机会变得稀缺，那么自然而然，人就会变得贪婪而且感兴趣”。于是，很多投资机构就跟投了。最终，马斯克自己贡献了 1200 万美元，剩下的部分都是由投资公司提供。 这种融资技巧我最近就耳闻了一个身边的类似案例。某公司融资的 FA 说，某某和某某已经打算投 2&#x2F;3 的融资额度了，剩下 1&#x2F;3 大家来抢，于是别的小机构就真的跟抢一样来投了。人性啊人性！ 全员销售Tesla 早期的 Model S 很多问题，返修率很高。于是顾客都开始观望，打算等产品质量稳定之后再买。但是 Tesla 又等着提高产品，以避免工厂停工，造成资金浪费。于是马斯克想了一个办法：让所有人不管是从事什么岗位，都拿起电话当销售业务员。 可能他自己都想不出来这个办法会奏效。在下完这个决定后，他就打电话给 Google 的创始人佩奇，要求 Google 花 60 亿美元收购 Tesla。 正当他们在讨价还价的时候，这 500 名强行转换角色的销售超额完成了成立量，于是 Tesla 从一个银行贷款不足公司存活一个月，变成了获得了 562 亿交易额及 1100 万美元赢利的公司。这个消息前后只经过了 14 天，之后 Tesla 的股价从 30 元飙升到了 130 元。 One more thing本书让我印象最深的，是佩奇的话，他说： 我们应该多一些像马斯克这样的人，我们没有用这种观念教育大家。 我们应该具有相当广博的工程学和科学背景；应该接受过一些领导技巧训练、MBA 培训或者具有经营业务、组织活动和筹集资金的相关知识。但是大多数人都没有接受过这样的培训或教育，这是一个重要的问题。 工程师们通常只在一个固定的领域内接受培训。当你能够综合考虑这些学科时，你将会产生不一样的想法，能够梦想实现一些更疯狂的事情，想象它们会怎么运作。这认为这对世界来说才是最重要的。这样我们才能进步。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"风投是如何进行投资判断的","slug":"how-to-invest","date":"2018-06-30T22:47:28.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/07/01/how-to-invest/","permalink":"https://blog.devtang.com/2018/07/01/how-to-invest/","excerpt":"","text":"引言Annie 毕业于普林斯顿大学，之前在腾讯投资部工作。后来她厌倦了投资工作，想深入互联网公司参与业务，我猜猿辅导公司是她见过的数据最好的公司😝，于是就被联合创始人李鑫邀请加入了我们。 我一直很好奇投资是如何做的，虽然看过各种网上的文章，但一直不系统。一次偶然的机会，我听她分享了投资的一些心得，我自己觉得很受用，把知识系统化梳理出来了，分享给大家。 框架Annie 把投资工作分成如下几步： 判断市场大不大 判断趋势和变化 判断核心产品 &#x2F; 业务模式 判断市场分散度 判断团队 估值的计算 和同赛道竞争对手比较 下面我展开介绍。 判断市场大不大通常投资的第一步，是看看整个行业是什么，整个蛋糕多大。一般用「市场规模」这个词表示，它表示每年人们花了多少钱在这个市场分类上。 比如： 互联网招聘行业，市场规模 50 亿。 IT 培训行业，市场规模大概是 200 亿左右。 知识付费，市场规模大概是 500 亿左右。 网络游戏行业，市场规模 2000 亿左右。 商品房销售，2017 年市场规模是 20 多万亿。 那我们做的在线教育行业呢？iiMedia 的数据显示是 3000 亿元。 判断趋势和变化一个趋势判断，是判断整个市场是否在变大，主要看市场规模的每年增长情况。网络游戏行业过去几年都是 20% 的 增长率（下图）。 另一个趋势判断，是在这个蛋糕的组成在如何变化。比如上面的图就可以看出，网络游戏，过去几年主要的增长就是来自手游。看趋势变化可以推导出什么样类型的企业具备头部玩家的潜力。 那教育行业呢？我看到的变化也是越来越多的家长选择在线的。 Annie 分享了一个趋势：教育行业的核心资产，正在慢慢变化。 最初是结果凭证 然后变成场所机构（选址） 再变成老师（名师） 再变成工具 现在是教研系统 结果凭证 -&gt; 场所机构（选址）-&gt; 老师（名师） -&gt; 工具 -&gt; 教研系统，这样的核心资产的变化，有可能催生出新的玩家。 判断核心产品 &#x2F; 业务模式有些时候，虽然是同行业，但是由于核心产品 &#x2F; 业务模式不同，在商业上的结果就会完全不一样。例如： Smule vs 全民 K 歌。一个重点在内容，一个重点在功能。 VIPKid 和 学大。比较成本结构，线下毛利 20%，线上毛利 40%。获客方式不一样。管理成本不一样。 在判断以上这些的时候，数据指标就非常重要了。Annie 说，作为投资人她最喜欢看的指标包括： MAU DAU DAU&#x2F;MAU，即黏性 cohort，新增留存率，把每个月的新增单独算未来 12 个月的留存情况 核心行为 日均使用时长 单用户获取成本 用户画像 作为投资的常用手段，他们也会直接给客户打电话，来听听用户对产品的评价。 判断市场分散度市场分散度决定了一家公司的 market share 的上限。比如线下教育，就是一个极度细分的市场。因为线下机构对场地，老师，以及本地宣传的依赖。新东方和好未来，到现在也没有分到线下教育的 10% 蛋糕。 市场分散度的最大决定因素： 是否具有网络效应（每加一个节点，效果成指数上升） 是否具有高壁垒 是否对旧有服务 &#x2F; 模式有颠覆性改变 在行业中所处的位置（议价能力） 判断团队 越早期的阶段，团队越重要。 CEO 无比重要。 没有确定的方法论，主要看投资人本身的经验。 最近在线教育行业就出事了，成长保被爆进行 数据造假。我相信这个事情之后，投资方对于团队靠谱程度的判断会更加谨慎。 估值的计算行业也很好，趋势也很好，团队也很好，核心产品数据也很好。那么问题来了，如何计算值多少钱（即估值）呢？ Annie 说：对于估值来说，需要先有估值的故事，然后才有数字。 比如：如果 Uber 是一个新型的 car service 公司，服务的就是全球几百亿美金的市场。如果把它看成一个物流公司，并探索无人车等新模式，全球就是上千亿的市场。 具体操作的时候，首先 Test your narrative： 分析历史，找对标公司。 分析自己熟悉的公司和业务模型。 运用常识。比如 Unit economics：高客单价意味着续费率必须要高才能覆盖获客成本。 有了故事之后，然后就可以尝试把故事转成财务预测模型。 之后开始尝试测算出估值，一般估值算法考虑：「本身值多少钱」vs 「别人愿意付多少钱」。然后当你觉得 Value &gt; Price 时，才可以出手。所以你看，这个逻辑和买股票是一样的，不管公司多好，价格合适才是王道。 Annie 拿一家在线教育行业的公司做了一个估值的举例，其过程就是参考各类同行服务的学员数、估值、客单价，然后估算这家在线教育公司几年之后可以服务的学员数和客单价。最后再考虑乘上一个估值倍数。 我问她这个估值倍数怎么计算，她说主要基于和同行业其它公司的比较，以及未来增长空间的判断。但具体为什么是那个倍数，她坦言还是比较偏感性一些，比如实操的时候，定义一个同行业公司的上限和下限，然后在这个中间取一个自己认为还算能接受的值。 和同赛道竞争对手比较计算完估值后，再要做的就是和同赛道竞争对手比较。看谁的团队更好，行业判断最准，产品最好，业务目前最健康，增长潜力最大，估值目前最合理。通过这些因素最终综合来决定投哪家是划算的。 小结小结一下： 选公司的时候：先判断行业，再判断趋势，再判断产品，再判断市场细分度，最后判断团队。 选好公司后，先看公司的故事，再估算估值。 估值计算可以选同类公司，通过各种核心指标来对标，同时因为对标公司可能不完全一样，所以要考虑对结果乘上一个估值倍数。 只有当价格合理的时候才出手。 最后，Annie 给我讲了两个她的心得： 模型是否正确最重要的部分在于假设，假设准不准来自你对市场的判断是否正确，对公司商业模式的理解是否深刻。 如果不是特别确定投资亮点能够实现，一般当时判断的投资风险都会发生。 以上就是整个总结，希望对大家有用~","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"读《人工智能简史》","slug":"AI-history-summary","date":"2018-06-18T10:16:43.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/06/18/AI-history-summary/","permalink":"https://blog.devtang.com/2018/06/18/AI-history-summary/","excerpt":"","text":"端午节期间，读完了《人工智能简史》。这是一本轻松的读物，书中并不涉及太多人工智能的专业知识，作者更多的是以一个轻松的心态来介绍人工智能的历史，以下是一些读书心得。 NgramNgram 表示多个词合在一起的组合。谷歌提供了一个名为 Ngram 的工具，可以查询指定词在历史上出现的频率，其地址是：https://books.google.com/ngrams。在书中，作者通过比较「United States are」和「United States is」在历史上出现的 频率，看出美国人是何时开始认同美国作为一个统一的国家的。这可以看出大数据即使在历史学科，也能提供非常有力的证据。 有意思的是，Ngram 的用处远远不止于此。例如，我们可以用 Ngram 来做语法纠错，比如你发现历史上「as soon as possible」出现的次数非常高的时候，你就可以让机器把这个理解成一个高频搭配，当某个人把「soon」拼写成「soom」的时候，你就可以基于上下文来帮他做拼写的纠正。 你看，基于大数据的统计非常简单，又非常有效。有些时候，他有效得让人感觉到吃惊，甚至在基于大数据的统计分析来看，任何人类的经验都可能是狭隘或者有害的。比如在书中就提到，机器翻译领域，很多专家都认为语言学知识对翻译没什么用处，有些时候还会起反作用。比如 IBM TJ Wason 研究中心的机器翻译小组成员贾里尼克（Frederick Jelinek）以及谷歌翻译团队的欧赫（Franz Josef Och）就都表达过上述观点。 在学术上，语法派和统计派一直相互争论。不过我现在认为统计派越来越占上风了，特别是统计派将大数据的处理方式改成深度学习之后。Google 和 Facebook 分别使用 RNN 和 CNN 两种神经网络来训练，最终在机器翻译领域取得突破性进展。 那么问题来了，这么翻译出来的东西，机器真的能够理解吗？也许翻译本身根本就不是理解问题，翻译本身并不需要理解，翻译只是翻译，只是数据问题，而不是语义问题。 除了在翻译领域，人类发现自己的经验没什么用，在围棋领域也是同样。AlphaGo Zero 仅仅过 40 天的自我学习，就超过了那些学习了大量人类棋手的前辈：AlphaGo Lee 和 AlphaGo Master 。这除了说明机器自我对弈的强化学习（Reinforcement Learning）的效果超强之外，也同时宣告人类的经验在有时候真的是负担。 知识图谱和机器阅读维基百科搭建了一个给全人类的免费知识库，但是，机器却不能轻易读懂这些内容。为了让机器更加容易处理各类信息，Google 在 2012 年发起了知识图谱（Knowledge Graph）的 项目。 Google 并不是从零开始这个项目，它其实在 2010 年收购了一家名为 Metaweb 的公司，而这家公司运营着一个拥有 4000 万代表知识实体的数据库：Freebase。Freebase 的数据是结构化的，这样机器可以很方便地对知识进行再处理。相对应的，维基百科在 2016 年的文章数仅为 1000 万篇。 2016 年 Google 停止对 Freebase 更新，并把所有数据捐给 Wikidata，Wikidata 是维基百科的母公司。除了 Wikidata 外，还有几个开源的知识图谱，如 DBpedia, Yago, SUMO 等。 当知识图谱足够大的时候，它的回答能力会大的惊人。2011 年 IBM 的沃森 (Watson) 在美国电视智力竞赛节目《危险边缘》（Jeopardy!）中击败人类选手，获得百万美元大奖，就是利用了包括 WordNet，DBpedia 和 Yago 等各种知识图谱。 除了将数据更加结构化外，研究人员也在不停地改进机器阅读自然文章的能力。相比于将原有的知识结构化，直接让机器读懂人类语言的文章虽然挑战更大，但是收益也是非常明显的。 对于这点，全世界的 AI 公司都在努力，包括我们公司。吹牛逼时间到了：我们猿辅导公司最近就因此出现在互联网女皇的报告中，因为我们在斯坦福的问答评测 SQuAD1.1 中排名第三（其实现在已经第二了）。量子位的 一篇文章 深度介绍斯坦福的这个评测集。 未来在我们公司参加的另一个机器阅读理解评测集 MSMARCO 中，我们有幸拿到了第一，并且超过了人类的基准水平。基准水平可以理解为人类的平均水平。这让我再一次作为人类产生了危机感。 或许有一天，人工智能不光在围棋，象棋，驾驶这些有限场景下代替人，还能比人类更加理解文字，更快吸收知识，最终全面超越人类。 在《未来简史》中，作者把这个潜在新物种叫做神人（Homo Deus），新物种在我们这个时代是否会出现，让我们拭目以待。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"构建网状组织架构 - 读《赋能》","slug":"team-of-teams-summary","date":"2018-05-27T16:31:38.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/05/28/team-of-teams-summary/","permalink":"https://blog.devtang.com/2018/05/28/team-of-teams-summary/","excerpt":"","text":"引言在互联网公司里面，扁平化的管理、以业务为中心的团队、快速敏捷的群体决策、使用强调透明的 Scrum 框架都是非常普遍的现象。 但是在传统得不能再传统的军队里面。等级森严、强调服从命令、强调统一指挥和协调一直是被广泛认同并执行的文化。 《赋能》的作者之一：麦克里斯特尔是一名将军，经历了美军在伊拉克与 “基地” 组织的各种对抗，他发现传统的军队管理方式 “失效” 了，而互联网化的管理方式变成了对抗基地组织新的 “有效” 方式。 凑巧我在朋友圈看到另一个朋友读的《创新公司》一书，里面介绍了皮克斯公司的管理变化（下图）。作者的观点如出一辙：大家都是崇尚互联网的管理方式。 这个事实让我意识到，互联网公司流行的管理方式，已经渗透到了各个行业，成为成功管理的典范。如果是这样，那么所有人都应该学习这种管理，理解其中的精髓。 下面我就给大家分享一下《赋能》一书的小结。 还原论的时代我们来看看 100 多年前，还原论流行的时代，那个时候信息流转的速度很慢。 在 19 世纪的工业社会，几乎所有的生产和目标都是确定的。泰勒发现这个现象后，就希望通过各种标准化和流程化将传统工业生产的效率提升。他拆分了生产的各种步骤，仔细研究每个步骤最优的操作方法，仔细评估如果通过量化数据代替工人的经验。于是，“科学管理” 诞生了。 在 1900 年，44 岁的泰勒在巴黎博览会上向同行展示出 “科学革命” 的强大。应用泰勒的科学管理方法之后，整体生产效率提升了 5～10 倍。而且工人变成了 “螺丝钉”，完全可以经过简单的培训即可工作。 泰勒的方法对于企业所有者来说，他所取得的效果毋庸置疑。检修锅炉的成本从 62 美元（大概相当于今天的 2000 美元）降低到 11 美元；加工一个轮胎的时间比原先缩短了 4&#x2F;5；制造一颗炮弹原来要 10 个小时，如今只要 90 分钟。 作者把泰勒的思想称作还原论。即通过问题分解，将工序职能化，然后构建管理层级。这种情况下，除了管理者之外，没有人能够了解事情的全貌。 我们可以在部分互联网公司看到这种来自 19 世纪的架构。比如：我们把公司按照职能分成：市场部、运营部、产品部、设计部、iOS 端部、安卓端部、服务器部、HR 部等，然后每个部门有一个老大。如果我们要做什么产品，就去各个职能部门要资源。出了什么问题，就找职能部门的老大负责协调和解决。 这是一种典型的树形层级架构。如下图所示： 新时代的来临在《赋能》作者看来，时代的主要变化是：信息流通速度变快了。互联网，以及构建在互联网上的社交媒体和通讯工具，使得 “基地” 组织可以非常快速地进行恐怖袭击。 “基地” 组织的管理架构非常网状，使得美军并不能通过抓获其主要领导人来瓦解组织。于是，最终美军也向 “基地” 组织学习了，采用更多类似海豹突击队的组织架构模式，来应对基地组织。 最终，作者构建了一种网状的组织架构，每个业务部门相对集中，但是又各自和别的部门直接联系。如下图所示： 网状组织架构的核心构建这种网状组织架构，得具备两个核心：信息共享和赋能。 信息共享：因为这个时代信息太多了，信息流通的速度又太快了，这要求领导将决策权下放。而决策权下放就需要大家都有足够的信息才行。因此，网状组织架构在信息上应该尽量透明，使得决策能够有充足的信息作为支撑。 赋能：所谓的赋能，就是「决策的去中心化」，即将权力下放。当然，这里面也应该有相应的机制，对决策有一些纪律来约束。 构建好这样的架构之后，作者发现美军可以以非常敏捷地方式，应用基地组织的挑战。在书中，作者举出了非常多的例子，每一个例子都证明，这种架构对于战争起到了决定性的作用。 去「英雄式领导」的年代新时代的领导者不应该是“英雄式”的，即他不应该做所有的决策。但是，不代表他不重要。新时代的领导应该是：文化的缔造者。 在一个新的时代，构建一个网状的组织结构并不容易，需要让大家都建立共享意识、全局意识、协作意识，还需要足够地放权。作者把这样的领导比作“园丁”，需要给花朵一个合适的土壤，才可以让一切自然地发生。 作者在美军内部为了推行新的架构，引入了“嵌入计划”和“联络官计划”，在各单位之间建立横向联系： 嵌入计划：把一个人放到另一个组织里面工作 6 个月。以使得他可以和别的小组成员熟悉。 联络官计划：将自己团队重要的人放到别人团队里面做协调沟通。在传统架构里面这种人通常不那么重要，而新架构里，作者把最优秀的人放在这个岗位。 最终，美军的战果确实证明了这种架构的有效性。在《赋能》一书的最后一章，作者详细介绍了在与基地组织的战争中，美军尝试对基地组织领导扎卡维实施抓捕的整个过程。整个线索的获取，抓捕现场的决策，扎卡维死后的行动，都显示出团队赋能带来的巨大价值，看完整个故事，我相信如果美军没有这样的组织架构，整个任务是完全不可能完成的。 小结互联网的时代使得信息流通迅速，信息数量爆炸，组织需要在有限时间内迅速做出决策，否则就会被竞争对手打败。传统的管理架构极大地限制了决策的速度。 作者身为一名驻伊拉克的美军将军，参与并见证了美军网状组织架构转变的过程。通过信息共享和赋能（即：决策的去中心化），美军成功对基地组织进行了有效打击，证明了这种新的组织架构的有效性。 作为一名互联网从业者，我本人也见证着互联网公司应用这种以业务为主体、强调透明和自主决策的团队组织架构成为主流。我相信未来这一定是一个主流的组织架构形式。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"故事的力量 - 读《人类简史》","slug":"human-history","date":"2018-05-12T09:19:46.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/05/12/human-history/","permalink":"https://blog.devtang.com/2018/05/12/human-history/","excerpt":"","text":"引言五一期间，我将《人类简史》又读了一遍。该书的挺多观点都很有意思，在作者用自己非常独特的角度对人类的发展做出阐述，主要包括 4 个大的部分，分别是： 认知革命 农业革命 融合统一 科学的革命 以下是我的读书心得。 认知革命智人为什么胜出现代人类这个人种在学术上叫做「智人」。在几十万年前，除了「智人」这个人种外，其实还有别的人种，比如书中提到的「尼安德物人」和「弗洛里斯人」。而最终，「智人」将别的人种都淘汰掉了。所谓的淘汰，其实就是通过物种间的竞争把别人杀绝种了。 作者首先想讨论的就是，「智人」这种人种相较于别的人种，个体上其实毫无优势。比如尼安德物人就比智人拥有更加强壮的体格，一对一单挑的话，轻轻松松把智人打趴下。别的人种也同样有语言，有组织，会使用工具。 所以，这不是人类和狮子这种猛兽之间的竞争那么简单。人类会使用工具之后，动物基本上就无力还击了。但是人类不同人种之间的竞争，最终为何「智人」能够胜出呢？ 作者提出了一个非常独特新颖的观点：智人会讲故事，而且这个故事是虚幻故事（fiction stories)。不但智人讲虚幻故事，智人还相信虚幻故事。 故事的力量我们来看看什么虚幻故事。对于我们现代社会，最常见的虚幻故事就是：公司。 以什么样的标准，我们才可以说公司存在？你可能认为是公司的产品、公司的员工、公司的工厂和办公室。但是，如果一场地震，公司员工连同公司的工厂全部没了，公司还是存在。你可能认为是公司的股东或者经营团队，但是即使他们全部消失，公司也还是可以存在。 只有一种情况，公司可以消失，那就是法官下令强制公司解散。一家公司被注销，虽然公司的工厂仍然存在，产品、员工、会计师、经理和股东也继续活着，但是这家公司就消失了。 所以，公司只是我们的一个集体想象，这种想象在法律上称为「法律拟制」（legal fiction）。 这种集体想象的威力巨大。因为当大家都相信一个故事的时候，这个故事就真的存在了。 比如，如果大家都相信「国家」存在的时候，大家就会为国家贡献自己的力量甚至生命。 比如，大家相信契约和法律的时候，社会形态就会进一步升级，出现货币，法律，家庭。 又比如，当大家都相信等级存在的时候，社会就会形成阶层。 组织的限制即使到了今天，人类的团体还是继续受到这个神奇的数字影响。只要在 150 人以下，不论是社群、公司、社会网络还是军事单位，只要靠着大家都认识、彼此互通消息，就能够运作顺畅，而不需要规定出正式的阶层、职称、规范。 但是一旦团体规模超过 150 人，如果没有阶层、规范的话，那么这个组织就无法形成有效的力量。 智人相信虚幻故事，使得他们能够形成远远超过 150 人的社会团体，从而在与尼安德物人的竞争中，能够产生巨大的组织分工协作的力量。而竞争的另一面，尼安德物人的语言和认知仅仅让他们能够简单沟通，比如说：「前面有狮子」这种非虚幻的故事。 于是，组织的 150 人的限制，在智人的故事面前，被轻松解决了。现代的企业、国家、社会借助于各种集体想象，使得上亿人能够协作在一起。某种意义上说，全世界的人们都可以协作一件事情。 自然选择的限制在出现虚幻故事之前，人类的进步主要是受制于基因的突变以及自然选择，这其实是很缓慢很缓慢的。比如人类经过几百万年的发展，才进化到相信虚幻故事。 但是一旦人类相信虚幻故事，人类就可以通过教育，将故事传承下去，于是人类的行为和社会结构被迅速改变。这种认知上的变革使得人类可以绕过自然选择的缓慢升级，直接将认知传递给后代。 于是，自然选择的限制被打破了，人类不需要各种残酷的淘汰就可以进化。现在甚至出现了基因工程，在这方面，人类越来越开始扮演上帝的角色。 小结智人通过发展，进化出相信虚幻故事的能力，从而进一步超越了组织的限制和自然选择的限制。 农业革命农业革命出现在认知革命之后的 6 万年。作者对于农业革命的评价非常有意思：他认为不是人类选择了小麦，而是小麦使得人们被迫定居。所以，农业革命是史上最大的一桩骗局。 作者的这种观点是站在人类个体上考虑的。因为在农业革命之前，智人的生活相当幸福。作者这样说道： 智人的身体演化目的并不是为了从事这些活动，我们适应的活动是爬爬果树、追追瞪羚，而不是弯腰清石块、努力挑水桶。于是，人类的脊椎、膝盖、脖子和脚底就得付出代价。研究古代骨骼发现，人类进到农业时代后出现了大量疾病，例如椎间盘突出、关节炎和疝气。此外，新的农业活动得花上大把时间，人类就只能被迫永久定居在麦田旁边。这彻底改变了人类的生活方式。其实不是我们驯化了小麦，而是小麦驯化了我们。“驯化”（domesticate）一词来自拉丁文 “domus”，意思就是 “房子”。但现在关在房子里的可不是小麦，而是智人。 农业使得人们被迫定居，也需要保卫农田和粮仓。所以，人们很快就发展出国家。也分化出各种职业分工，比如农民、军人、医生等。 从 DNA 拷贝的数量来看，农业革命对于人类是成功的，因为人口数量因此大增。但是从个体幸福感来说，并不是这样。 我们从农业革命能学到的最重要一课，很可能就是物种演化上的成功并不代表个体的幸福。 融合统一作者在这部分主要讨论的是金钱，帝国，宗教的产生。 作者在这部分的观点同样犀利，他将宗教比作病毒。 有学者认为，文化就像是精神感染或寄生虫，而人类就是毫不知情的宿主。寄生虫或病毒就是这样住在宿主体内，繁殖、传播，从一个宿主到另一个宿主，夺取养分，让宿主衰弱，有时甚至丧命。只要宿主能够活着让寄生虫继续繁衍，寄生虫就很少关心宿主的情形。至于文化，其实也是以这种方式寄生在人类的心中。它们从一个宿主传播到另一个宿主，有时候让宿主变得衰弱，有时候甚至让宿主丧命。任何一个文化概念（像是基督教在天上的天堂），都可能让某个人毕生致力于传播这种想法，甚至为此牺牲生命。于是，人类死亡了，但想法持续传播。 如果把宗教比作病毒，就能够看出宗教的演化历史。病毒是非常强调传播能力的，所以经过长远的发展，最终流传下来的宗教都非常有传播能力。所以从诞生到现在仅仅经过 1000 多年，现在世界上就有大约 20 亿基督徒，12.5 亿穆斯林。 不过我不认为一个人的生命意义就是「尽可能活得久，活得轻松」。宗教可能让人为了传播它丧命，或者活得很辛苦。但是这只是肉体上的。从精神上，宗教让人在「幸福感」上，或许带来的帮助更多。人类有太多想不明白的事情了，宗教让人内心平静，从而可以活得不那么心累。 从这种角度上讲，有了宗教之后，个体很可能是更幸福的。 科学革命有些人可能认为科学也是一种宗教，但是其实科学和宗教差别很大。 科学和宗教最大的区别，就是宗教认为这个世界的规则已经都搞明白了。而科学认为这个世界大部分的规则不但没有搞明白，而且现在的规则到底对不对也不知道。 比如基督教认为所有重要的事情都写在圣经上了。圣经上没写的，要么不重要，要么已经超过了人类的理解人类不需要知道。而科学以一种承认自己无知，然后尊重客观实验的方式来不断发展。 科学相对于宗教有三大不同之处： 愿意承认自己的无知。 以观察和数学为中心。强调实验，强调客观。 取得新能力。 看看科学进步的速度就知道了，这几年人们在基因工程和人工智能领域又取得重大突破。 小结《人类简史》将人类发展的重要过程分成认知革命、农业革命、融合统一、科学革命。每一部分都进行了独特新颖的解读，其观点已经不仅仅是讲历史了，而是涉及了人类学、政治学、文化学和心理学等学科的特别视角来解读人类的发展。 非常有意思的一本书，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"运营启蒙 - 读《运营之光》","slug":"operation-light-summary","date":"2018-04-15T16:03:28.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/04/16/operation-light-summary/","permalink":"https://blog.devtang.com/2018/04/16/operation-light-summary/","excerpt":"","text":"引言什么是运营？ 互联网行业发展迅速，像产品经理、运营经理其实都是伴随着互联网行业快速发展而产生的职位。这些职位都非常新，从在互联网公司中普及到现在可能都不到十年。所以，了解这些职位的特点和价值对于每一个互联网行业的从业者都是一项基本功。 带着这个目的，我最近读完了黄有璨的《运营之光》，这是一本对运营职位的启蒙书，很好的让大家对运营从懵懵懂懂到有一个基本的认识框架。 接下来，我分享一些我的读书心得。 什么是运营作为一本启蒙书，讨论清楚运营的定义当然非常关键。作者在书中，介绍了各种运营工作的分法，但是他自己并没有明确的结论。作者在概念上，倾向于把市场部门的所有工作，也归为运营的职责。 其实新用户获取和品牌相关的职位叫什么名字并不重要，核心还是看能力的差别和工作的聚焦。我看完之后，觉得运营和市场即使都归属于运营类工作，在职位上还是可以分开，因为市场部门更多仅仅关注新用户的获取。 如果把市场部门的工作排除开，我认为运营的工作分类包括：内容运营 和 用户运营。 内容运营内容运营就是将 App 内用户消费的内容生产出来，这里面的涉及的类别很多，需要的技能各不相同。 拿小猿搜题来说，我们的内容有一部分是海量的题库，这部分海量的题库需要组建大量的人力投入才能持续地维持更新。所以，题库内容的运营，就需要有非常强的管理能力和专业能力，将这些内容的生产分配给大量的内容录入人员，同时保证质量。 小猿搜题的内容中，又有阅读类的「小猿日报」栏目。小猿日报的栏目内容更新量远远比不上题库的更新量，但是却需要很强的策划构思能力。不管是从选题还是从内容，都需要精心打磨，力图做到爆款。做这个事情的运营的能力要求更像是对杂志编辑的要求。 小猿搜题还有大量基于深度学习的功能，比如拍照搜题，作文批改等，这些功能需要大量的标注数据。这些标注数据的生产，也是需要内容运营同事来负责。这里考验的又是运营的统筹和协调能力，需要能够将相对枯燥的海量标注工作完成，又能保证标注数据的准确性。 用户运营用户运营就是直接和用户接触的一类活动。书中把这个称为「活动运营」，但是我认为有些片面。 与用户接触的方式，当然包括各种 App 内外的活动。拿猿题库来说，定期的万人模考就是它的一项用户运营工作。小猿搜题以前搞的作文大赛，也是属于用户运营。App 外的用户运营，可以是微博上的讨论或者转发活动。也可以是线下的各种用户见面会，用户互动活动等。 除了这类活动之外，我觉得任何在公开平台上与用户的互动，都应该属于用户运营。比如猎豹在做清理大师的时候，去应用市场回复每一个用户的评价，这个算不上是一个活动，它甚至是每天例行的工作，但是它确实是一种和用户接触产生情感交流的活动，所以我也把这些归到用户运营工作中。 运营的数据驱动思维我非常赞同作者在书中强调的，运营人员应该有一个比较强的数据分析方法和意识。最最基本的要求就是，自己所做的所有工作，都应该以数据化的形式记录下来，并且做相应的分析总结。 做内容生产的运营同事，应该记录下来内容生产的流程数据指标，比如生产速度，质量，成本，然后试图改进流程和工具，不断优化整个过程，使得内容生产更加高效。 做编辑相关的运营同事，每篇文章的阅读量，转发量是多少。什么样的文章更受读者喜欢。最终都需要数据化的指标来做辅助分析。 做活动运营的同事，每次活动下来做得到底好不好，一年下来最成功的活动是什么，都是需要数据才能做辅助判断的。 如何做好数据分析这部分来自我个人的经验。 要做好数据分析，我们首先应该以「云端文档」的形式将数据记录下来。之所以应该记录在云端，是因为你必须要将数据分享给同事，以便大家共享运营数据，建立起讨论分析的基础材料。「云端文档」的服务商，你可以用 Google Docs 或者墨客这类的云端编辑器，也可以用 Wiki 或者 Confluence 这类共享知识库；如果你习惯了 Word、Excel，也可以选择将文件存储在 Dropbox，Seafile 一类的共享网盘，将文件分享给同事。 做好数据记录之后，你应该做的就是定期回顾。每次有新数据的时候，都在记录后进行一定的总结分析，试图找出数据变化的原因。这样慢慢地，你就对数据有了更多的敏感度和想法。 最后一步，就是基于以上两步的实验。你有什么新想法，可以在下一次运营工作中进行尝试，然后利用反馈得来的数据加以验证。不管是正向的还是负向的，你都会有所收获。有些时候失败的尝试带来的价值和思考可能更大。唯一需要注意的是，你需要在尝试的时候尽可能「控制变量」，避免最终有大量的变量来影响你对于结果的判断。 记录、共享、讨论回顾、尝试、总结与改进，这几个步骤最终会形成一个迭代的环，厉害的运营人员很快就会经过几轮迭代，将自己的工作做得生声生色。 运营的 MVP 思维在书中，作者把这个思维叫做「精益」运营。产品经理老讲 MVP（最小可行性产品），这一点其实也应该套用到运营上。运营一次活动，改变内容生产的流程，其实成本都是很大的，运营同事可以很 Simple, 很 Native 地提出需求，然后让产品和技术配合实施，也可以更加小成本地尝试一下，新的方案是否真的很好。 缺乏 MVP 思维的运营，会老是抱怨产品技术给的资源不够；拥有 MVP 思维的运营，会拿着自己的小成本方案以及一些调研数据给产品，产品一看已经有了数据支持，产品方案又足够聚焦，就很容易支持。 讲一个例子。我们在做小猿搜题商城的时候，运营同事一开始总提各种营销的产品需求，如果按这个逻辑支持下去，我们整个产品技术团队可能就奔着一个「小淘宝」的功能去开发了。于是我就老让他试图用 MVP 的思维来先做小成本验证，然后再提需求，尽可能保证运营需求都是非常有效的。后来，他就对一个运营想法，利用现有的技术方案，灰度到随机的几个用户对照组中，然后再结合对照组的数据，自己迭代运营想法。最终他拿出来的方案，有数据印证，有预期收益，再结合开发成本，所有人都可以很清楚地判断方案的优先级。 运营工作的框架书中介绍了一个不错的运营工作框架，他把运营工作分为四步，分别是： 一、制定策略。根据产品的特点、阶段、核心数据制定相应的运营策略。 二、分解指标。目标拆解是一个重要的手段，把大的目标能够细分成小的目标，进而细分成一件一件的运营工作。 三、落地执行。运营的执行力是非常重要的，这一步需要将之前的策划工作执行到位。 四、监测数据和调整。根据执行结果，做出相应的判断和调整。 以上四步，其实形成了一个循环迭代。我很喜欢他说的一句话，做运营，永远要向迭代要数据，也要依据数据做迭代。 如果你仔细想想，这个循环迭代和刚刚提到的数据分析工作的循环迭代，其实并没有本质上的差别。 运营的稿件文案编写方法书中对于文案编写，总结出了一些偏实践的方法。 拿标题来说，作者推荐了「傍大款」和「颠覆认知」型的标题，来吸引读者点击。 「傍大款」，即使用用户了解的名人，来产生某种背书或者对比效果。 「颠覆认知」，即使标准让人们觉得颠覆原有常识，不可思议，从而引发好奇。 在《爆款文案》一书中，也提到了这两个技巧，只不过在那本书中被叫做「碰瓷」名人和「意外故事」。我们来看一些书中的例子吧，应该会感受更加强烈一些。 普通标题：《火辣健身 App 深度产品分析报告》 傍大款：《同样是健身 App，它比 Keep 到底 NB 在哪儿》 颠覆认知：《改了两个版本就融资 1500 万，这款产品如何做到的》 第二个例子： 普通标题：《原创干货：如何从 0 开始运营一个优秀的公众号》 傍大款：《这个微信号，如何在单点上比罗辑思维还 NB》 颠覆认知：《5 个月，0 预算 0 基础，他们就这样超越了 60% 的同类微信大号》 作者还从一些角度，提出了写出这类颠覆认知型标题的思路。比如拿 Papi 酱的 2200 万拍卖会为例，作者认为可以有以下角度可以想： 分析的事情本身够不够刺激？《一场 2200 万拍卖会背后的操盘逻辑深度分析》 分析的事情跟谁有关？《罗振宇和 Papi 酱，是如何操盘完成一场 2200 万的拍卖会的？》 是谁来分析？《一个 10 年运营总监眼中，Papi 酱 2200 万拍卖会的操盘逻辑》 是怎么分析？《通过 6 个重要事件 +15 个关键点，揭示如何成功运作一场 2200 万的拍卖会》 相关分析和事件可能还有谁？《最该来学习这场 220 万拍卖会的，可能是新浪微博》 理解了这个分析，可能带来什么？《看懂了这场发布会的操盘逻辑，你猜知道为何罗振宇给 Papi 酱的 1200 万一点也不贵》 人为强力背书《这是一篇让罗振宇本人都大呼 “牛逼” 的罗辑思维操盘案例分析》 我认为书中这个部分的内容实操性还是非常强的，值得每一个运营同学都学习一下。 运营职业生涯的发展路线书中最后几章，也详细介绍了运营职业生涯的发展路线。我个人不是做运营的，所以对这部分内容感受不深，但是单从内容来说，还是相对比较系统，可以给运营同行作参考。 小结本书的内容稍微有一点散乱，每一章内部的小节在逻辑上承接得不是很条理。有点像是作者的博客内容拼接的产物。另外，每一小节的内容展开形式也不太统一，有些时候观点并不清晰，比如第一章「运营是什么」，作者就没有给出自己非常清晰的答案。 单看每一小节，内容的条理性还是非常好的，作者用语比较口语化，读起来亲切自然，也能感受到实在和真诚。 瑕不掩瑜，《运营之光》整体的内容，对于一个初入行的运营新人，以及非运营同学了解运营行业，都是一个非常不错的资料，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"结构化的思维 - 读《金字塔原理》","slug":"pyramid-principle","date":"2018-04-07T08:30:42.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/04/07/pyramid-principle/","permalink":"https://blog.devtang.com/2018/04/07/pyramid-principle/","excerpt":"","text":"序言你是否遇到过以下这些情形？ 工作或者生活中突然接触到了一个新的领域，不知道如何学习。 为了研究某件事情，查阅了大量资料，但是不知道是否有效吸收了这些资料？ 感觉自己弄明白了某个课题，但是却无法有效地表达出来。 在现在这个信息爆炸的时代，如果我们不能有效地筛选信息、整理信息、将信息有效吸收后，进一步的再有效地表达出来，我们无疑将会被淹没在信息的海洋里面，无法解脱。 最近看了 《金字塔原理》 以及「得到」上的精品课《有效训练你的结构化思维》，两份资料都介绍了结构化思维。结构化思维是一种处理和表达信息的有效方法，可以让我们有效地处理海量信息，并且进行表达。 下面我就给大家简单总结一下我的收获。 什么是结构化思维先说说什么是「结构化思维」，学计算机的同学们肯定都学过一门基础课，叫《数据结构》。《数据结构》展示了计算机在处理信息时的多种数据关系形态，例如：线性表，树，图等。这些数据形态因为自身的特点，可以处理现实生活中对应的需求。 比如线性表就可以用来表示现实生活中的「排队」场景。而数据结构中的「树」（下图所示），就可以表示现实生活中的各种类似树枝一样，不断分叉的场景，例如：树枝，祖谱，公司里面管理层级的划分。 《金字塔原理》一书中提到的「结构化思维」与《数据结构》类似，它倡导将我们思考问题的方式，用一种类似金字塔的结构来折解。如果你仔细观察下图，就会发现，所谓的「金字塔」形状的思考结构，就是计算机里面讲的「树」形结构。 当然，二者虽然形状很像，但是其实只是作者为了帮助读者记忆和理解，在《金字塔原理》一书中，作者对这个金字塔有着更多细节上的要求。 金字塔原理的 4 个基本原则《金字塔原理》总结了 4 个构建金字塔的基本原则： 结论先行：每篇文章只有一个中心思想，并放在文章的最前面。 以上统下：每一层次上的思想必须是对下一层次思想的总结概括。 归类分组：每一组中的思想必须属于同一逻辑范畴。 逻辑递进：每一组中的思想必须按照逻辑顺序排列。 这些结构是与数据结构中的「树」不一样的。运用这样的结构整理知识，我们可以很容易找到最关键的结论，也很容易进一步细化结论，最终产生详尽的工作安排。 作为中国人，我印象最为深刻的是「结论先行」这条基本原则，因为我和身边的朋友沟通时，常常会遇到这种情况：对方说了半天，你却很难领会到对方的用意是什么。最终你还得帮他做一下结论，比如问一句：「您刚刚的意思是不是 xxx?」。 沟通的时候，结论不先行，就使得信息接收方处于各种信息归纳整理的状态，在你说出结论之前，他其实是不知道你到底想说什么的。 如果你先把结论说出来了，那么信息接收方就处于信息的理解状态，这个时候他已经知道你的结论了，所以他只需要关注你的论据，以及逻辑推导过程。这样他是相对轻松的，即使听漏了一个论据或者没有理解一个推导过程，也不致于理解产生重大偏差。 分类的艺术构建金字塔，还有一个重要的手法就是如何对问题进行分类。这个技能非常重要，选择了好的分类，就可以将问题进行有效的拆解。 比尔盖茨在一次 TED 的演讲中，将解决碳排放的问题分解成了一个公式（下图）：CO2 &#x3D; P x S x E x C。分别表示人口（People)、每人使用的服务（Service)、每项服务消耗的能源（Energy)、每单位能源排放的二氧化碳（CO2)。 一个复杂的问题，被比尔盖茨通过一个公式，拆解成了 4 个金字塔的一级分类，按照这个思路，将一级分类进一步拆解，我们就很容易找到一些可以减少碳排放的办法。这就是结构化思维下分类的力量。 MECE 原则在很多书中，都介绍了麦肯锡提出的 MECE 分类原则。MECE 的意思是「相互独立、完全穷尽」（Mutually Exclusive、Collectively Exhaustive）。 举个例子：把智能手机操作系统分成 iOS 和 Android。这就不满足「完全穷尽」原则，因为虽然 Windows Phone 占比很小，但是确实存在。分类不能完全穷尽，就可能使得问题考虑得并不全面。 再举一个例子：如果把人类分成男人、女人和老人，就不满足「相互独立」，因为老人和男人是相互存在重复的情况。 以上两个例子非常简单，在问题复杂的时候，找一个好的 MECE 的分类方法其实并不容易。比如：如果我让你把中国的在线教育公司分类，你能很容易地分得「相互独立、完全穷尽」吗？ 常见的分类方法在《有效训练你的结构化思维》中，作者介绍了一些常见的分类方法。 二分法简单来说，就是把问题分成两类。比如把人分成男人和女人，把地域分成国内和国外。 矩阵法我们把二分法的结果再次二分，就可以得到矩阵法。比如我们常说，工作可以按重要程度和紧急程度分成四类：（1）重要紧急（2）重要不紧急（3）不重要但紧急（4）不重要也不紧急。这样可以形成如下图的矩阵。 公式法刚刚比尔盖茨的故事，就介绍了公式分类法。公式分类将几个不太相关的内容放在一起，让人们一下子就记住并且接受了，效果非常好。「天才 &#x3D; 99% 的汗水 + 1% 的天赋」就是一个被大家广为传播的公式分类法。 过程法我们可以将一个事物的发展过程当作分类的标准。这个过程可以是：时间、流程、规模等。 比如之前国家就公布了估值超过 10 亿美金的创业独角兽公司，我们猿辅导公司就排上名了。这里，政府就把企业发展的估值增长当作一种分类方法。 所以按这个思路对在线教育公司分类，我们可以按人员规模，分成：50 人以内的公司，50-200 人的公司，200-500 人的公司，500 人以上的公司。 我们将产品经理的工作按照项目开发的时间进展来分类，就可以分成：定功能、画交互、跟进度、看结果。 要素法有本书叫《高效人士的 7 个习惯》，就是一种要素法分类。《最强大脑》节目中，每一个挑战项目都用一个雷达图展示，也是一个很好的分类方式。 构建金字塔的方法构建金字塔常见的方法是自上而下的演绎法，以及自下而上的归纳法。演绎法先产生大的分类和结论，然后进一步细节，构建金字塔的底部细节。归纳法先收集各种信息，将信息进行分类，从而慢慢产生了金字塔的底部，最终进一步总结，产生金字塔的顶端。 除了这两种方法外，《金字塔原理》中也提到了并不是所有问题都可以用这种结构来解决。比如，有可能一类问题根据不存在一种符合 MECE 原则的分类。 序言写作的框架《金字塔原理》也介绍了一种不错的序言写作框架，即「背景—冲突—疑问—解决方案」的结构。这里的「背景和冲突」是读者知道的事情，通过这些让读者被带入你的问题中，即引出「疑问」，最后你就可以介绍你的「解决方案」了。我在本文的写作中，也尝试了这种方法。 小结结构化思维是一种理性和科学的思考问题的框架，运用它我们可以将信息进行有效的分类和整理，也可以将信息有效地表达出来。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"腾讯爸爸的历史 - 读《腾讯传》","slug":"tencent-history","date":"2018-03-18T14:22:21.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/03/18/tencent-history/","permalink":"https://blog.devtang.com/2018/03/18/tencent-history/","excerpt":"","text":"序我是 98 年左右开始接触电脑的，那个时候互联网刚刚兴趣，电脑还不普及，上网费也很贵，大家都只能去网吧上网。而上网能够做的事情也非常有限，除了逛几个网页之外，就只能聊天了。而打开 QQ（当时还做 OICQ），正是那个时候每个网民上网后做的第一件事情。 谁也没想到，这个小小的企鹅，在 10 多年之后成为中国互联网的霸主。我所在的猿辅导公司，也接受了它的投资，叫他「腾讯爸爸」一点也不为过。相比于阿里，我对腾讯的故事要熟悉得多，毕竟是从小用到大的产品。不过在吴晓波的笔下，腾讯成长的故事读起来更加引人入胜，最近，我就读完了这本《腾讯传》，给大家分享一下读书感受。 我接下来会先分享一下腾讯的历史，然后说说感想。 历史诞生和发展89 年，马化腾高考。93 年～98 年，他在寻呼机公司工作。98 年开始创业。当时创业的 5 位合伙人是：马化腾，张志东，陈一丹，许晨晔，曾李青。而 OICQ 本来是他们打算拿来竞标的产品，但是竞标失败，大家激烈讨论之后，马化腾还是决定要做。虽然不知道怎么挣钱，但是马化腾还是打算「养」这个产品。 一开始，OICQ 就在产品和技术上展现出强大的竞争力，比如它很早就支持了在云端同步联系人名单，这在当时大家都在网吧上网的年代，属于巨大的竞争力。因为别的软件的联系人还保存在网吧电脑本地，换一台电脑联系人就没了。 又比如它的体积只有 220K，在当时的网速下，只需要 5 分钟下载。220K 在现在的网络可能只需要 1 秒钟的下载时间，但是在 10 多年前，这又是一个极大的竞争力。 应该说，OICQ 的成功就是靠实力，它打败了当时各种别的聊天软件，成为最受欢迎的聊天工具。这从数据上就可以看出来，到了 99 年 11 月，OICQ 注册用户突破了 100 万，这在当时网络还不发达的时代，已经相当夸张了。 也此同时，由于不挣钱，到了 99 年 11 月，当时腾讯公司账上只有 1 万元现金了，几个创始人一合计，想了两个办法： 增加股本，从 50 万增加到 100 万。创始人大家一起投钱。 创始人月薪减半。 接着又过了半年，他们终于拿到了 IDG 和盈科共投入 220 万美元。IDG 当时问马化腾怎么挣钱，他老实地说：不知道。这一点和当时马云回答倒是一样的真诚和老实。 腾讯是幸运的，2000 年 4 月，他们刚刚拿到了 IDG 和盈科的钱，就迎来了互联网泡沫的破灭。如果时间再晚几个月，他们肯定就融不到钱了。 一年之后，腾讯遇到了真正看到它价值的金主：MIH。当时，南非 MIH 的中国业务副总裁王大为找到腾讯，为其估值 6000 万美元。而在这一之前，腾讯的估值才 550 万美元。IDG 一年时间就获得了 11 倍的投资回报！在这一点上，也能看出 IDG 和盈科并不特别看好腾讯，这次融资，盈科将股份全部卖出，IDG 则卖出 12.8%。最终 MIH 占股 32.8%。 赢利和上市腾讯一直在苦苦的寻求商业化的尝试，比如在 2001 年，它的商业化尝试就包括： 广告。结果不理想，广告主怀疑 QQ 年轻用户的消费能力，所以广告卖不出去。 会员。结果收入非常少，月收入 2 ~ 3 万。 企业 IM 服务。很失败。 QQ 号注册收费。被用户骂得很惨，并且竞争对手给了很大压力。 不过，移动梦网项目还是给当时广大的互联网公司一线生机，包括腾讯在内的不少公司都挣到了钱。2001 年 6 月，腾讯公司因为移动梦网业务首度盈利。但是，这块业务其实非常依赖于运营商。所以大家都在找别的商业化的方案。 2003 年，腾讯终于探索到一个成功的商业化方案：QQ 秀。QQ 秀在上线的前半年，营收就达到了 2500 万。2003 年底，腾讯又引入红钻特权，10 元包月，每月收入很快突破了千万。 MIH 在投资之后，又持续增资，到了 2003 年 8 月，腾讯赎回 IDG 剩余股份和少量 MIH 股份。到上市前，腾讯创始团队占股 50%，MIH 占股 50% 。 2004 年 6 月，腾讯上市。筹集资金 14 亿港元。 之后，腾讯多采取模仿跟随战略，靠着微创新以及 QQ 的流量优势，打败了很多产品。特别是在游戏领域，获得了很大的收益。 改变2010 年的 3Q 大战，让腾讯陷入了思考，进而转变为开放的战略。对比《腾讯传》和《颠覆者》两本书中的 3Q 大战历史，《颠覆者》一书更显得真实，而《腾讯传》更多的从当时的媒体转述各种信息。 本书涉及 2010 年之后的内容，更多的是公开资料的转述，时间线也不明显，我个人读后感受较小。 感想运气很重要腾讯和阿里一样，都在 2000 年互联网泡沫之前拿到了一笔投资，帮助他们渡过了互联网寒冬。 腾讯和阿里一样，在互联网泡沫之后，都迅速找到了一个还不错的赢利模式，虽然不是巨大的收入，但是都还可以比较舒服地养活自己，从而关注更多的机会和发展。 当然，我也毫不否认它们的努力。OICQ 在最初打败别的类 ICQ 软件，阿里在中国供应商项目上迭代地推团队，打败别的竞品，都是靠自己实实在在的努力。 IDGIDG 在 2000 年的时候投资腾讯 110 万美元，占股 20%，然后在第二年就以 11 倍的回报退出了一大半，之后又在 2003 年全部退出。我估计 IDG 的整个汇报应该也就几十倍。 但是，腾讯现在值 5 千亿美金，IDG 投资的时候，腾讯估值才 550 万美金，翻了接近 1 万倍。如果 IDG 一直持有，那么就是 1 万倍的收益。但是它仅仅挣了一个几十倍收益。 让人遗憾的同时，也让人感叹，并没有谁能够准确地预测未来。 腾讯花了多久探索商业化从移动梦网到 QQ 秀，腾讯花了 3 年时间，才使得自己有了一个不错的商业化模式。在这其中，不乏有像 QQ 注册收费的昏招。 商业化探索需要时间和耐心，也需要机遇。移动梦网恰逢移动对 SP 业务开发以及国内短信业务爆发。QQ 秀其实是很好地借鉴了韩国公司类似的创新模式。 MSN 的失败书中介绍了 MSN 与 QQ 竞争失败的故事。在我看来这是一个典型的海外企业在国内水土不服的故事。 MSN 的市场部和研发中心分别向不同的人汇报，没有一个人全局统筹中国 MSN 的事情。MSN 中国版只占其 1&#x2F;5 的工作，微软完全不重视这块业务。但是决策权被美国控制。 书中举了一个例子：离线消息功能，从 2005 年提出，到 2008 年才被批准开发。这在强调快速迭代的互联网行业，无异于自杀式的管理方式。 此处复盘，如果我是微软，提供部分资金，然后把项目独立孵化和决策。引入更多的投资者，或许 MSN 还有挺大的机会。 小结马化腾是程序员出身，同样是程序员出身的我，看着他的故事就特别有亲切感。我在小马哥身上看到了程序员常见的坚持、努力、内敛的性格。腾讯的企业文化也是最让我感受到开放、自由和平等的。这几年腾讯在投资领域收获颇丰，但这些都还没有体现在财报上，祝腾讯早日突破万亿美金市值。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"阿里巴巴的发展史 - 读《阿里铁军》","slug":"alibaba-history","date":"2018-03-15T14:06:22.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/03/15/alibaba-history/","permalink":"https://blog.devtang.com/2018/03/15/alibaba-history/","excerpt":"","text":"序阿里巴巴作为中国互联网行业市值前三的公司，它的发展故事一直让我非常好奇，是什么样的原因让它成长为在中国如此举足轻重的企业？在它成长的过程中，又有什么值得我们学习的故事？ 带着好奇，我最近读完了《阿里铁军》。这本书以较大篇幅介绍了阿里最初存活下来的业务：中国供应商，以及随着该业务培养起来的地推团队。 接下来，我先会概括介绍一下书中的阿里巴巴的发展史，接着会谈谈我的一些读书感想。 阿里巴巴的历史成立1999 年，马云在杭州创建阿里巴巴。下面这张图片在多处被引用，这间公寓中的 18 位初创员工被称作「18 罗汉」。 2500 万美元同年，阿里巴巴拿到 2500 万美元投资。其中 2000 万美元来自孙正义。孙正义这 2000 万美元成就了阿里巴巴，而阿里巴巴几年之后也以极高的投资回报率，成就了孙正义。 危机如果没有孙正义这 2000 万美元，阿里巴巴大概率是无法度过随后而来的互联网寒冬的。2000 年，拿到钱的阿里巴巴四处扩张，但是却迎来了互联网泡沫破灭，Nasdaq 从 5000 点，一路跌到不到 2000 点，跌幅超过 60%。 如果你仔细看 Nasdaq 指数这张图就会发现，这场泡沫之大，大到如果你在最高点入场，那么最终需要等 15 年，你才能解套。这还不算财富本身的缩水，如果算上通货膨胀，到现在应该都是亏本的。 阿里巴巴很快发现市场变了，所有投资人都怂了，如果公司不挣钱，就肯定不会有人投资。而阿里因为四处扩张，到 2001 年的时候，2500 万美元花得只剩下 700 万美元了，按当时的速度，只够花半年。 最终为了活下来，阿里巴巴进行了大规模的裁员。当时 100 号以内的员工减半，很多人工资减半，办事处也由 10 个减为 3 个。 对于阿里来说，第一个生死时刻到来了，他必须挣到钱，养活自己！这个时候，2000 年底立项的中国供应商项目，成为了探索赢利的重要项目。 中国供应商按书中的信息复盘，中国供应商项目的成功，有着极大的运气成份。因为阿里刚好赶上了中国的对外出口经济发展，杭州附近又是出口型中小企业聚集的地方，中国供应商项目极大地方便了这些中小企业，将自己的产品介绍给世界各地的客户。我不相信马云一开始就知道这个项目能挣钱，就像书中说的那样，在互联网泡沫破灭之后，马云多次对逼问他如何挣钱的媒体说：我不知道，但是 So what？ 但是不得不说，阿里的成功也与自身的努力有着极大的关系。因为当时，并不是只有阿里巴巴一家在做这样的事情，他们有着很多竞争对手。而阿里是靠着自己的努力，把这块市场吃下来的。如果你仔细看书中介绍的中国供应商的发展细节，你就能看到大量认真钻研的故事。 比如他们是第一个采用「陌拜」（陌生人当面拜访）来推广产品的公司，这种敢于尝试同时又注重数据的文化，使得创新不断出现。又比如他们每天拜访前会做足功课，每天晚上会聚在一起开会复盘当天的工作，这其实就是互联网产品快速迭代的工作方式。 中国供应商不但救了阿里，也成就了阿里。从 2001-2005 年，该项目每年利润翻 3 倍，支撑阿里 2&#x2F;3 的收入。 淘宝和支付宝如果马云守着中国供应商这一亩三分地，那么阿里巴巴最多也就是个百亿美金的公司。马云的战略眼光一直很犀利。于是他在 2003 年的时候，就开始做淘宝和支付宝。之后淘宝和支付宝烧钱多年，但是结果大家都看到了，现在谁没有淘宝和支付宝呢？ 接管雅虎中国2005 年 8 月，阿里巴巴接管雅虎中国，事后看来，这应该是雅虎历史上最最成功的投资。这次并购使得雅虎获得了 40% 阿里巴巴的股份。从阿里巴巴的角度看，阿里获得了全球顶尖的软件开发人才。现在看起来，还是雅虎占了大便宜。 不过雅虎还是做了一个相当明智的决定，就是把雅虎中国的运营权，完全交给了马云。要知道，如果你看周鸿祎写的《颠覆者：周鸿祎自传》的话，那年初，周鸿祎刚刚辞去雅虎中国总经理的职务，而且是放弃掉了锁定期的大量收益。而周鸿祎透露，他离开后，马云给他通了一个电话，了解了一下和外企的合作感想。 周鸿祎与雅虎失败的合作，使得雅虎最终放弃了对北京部门的过度控制，这给了后来者马云充足的机会。马云果断地把雅虎中国的技术人才抽调到淘宝和支付宝这些项目中，最终成就了淘宝和支付宝。雅虎中国项目虽然成为了一个牺牲品，但是无论对于阿里，雅虎，还是被调走的人来说，看起来都获得了极大的收益，所以这次合并，没有输家。 香港上市2007 的 11 月，阿里巴巴 B2B 业务在香港上市，筹集到了 17 亿美元。3 亿给了 B2B 部门，别的给了还在亏钱的淘宝等其它业务。这 10 多亿美金给还在襁褓期的淘宝和支付宝充足的弹药，阿里有足够的时间，等待电子商务市场的机会来临。 不过对于买了阿里股票的人来说，就没那么开心了。阿里的股价一度最高飙涨至 41.8 元。但是到了 2008 年 10 月，阿里的股价跌倒 3.46 元。嗯，相当于股价打了个 1 折。这次上市融资也真是赶上了好时候，要是晚一年，筹集的 17 亿美金会不会也打个 1 折就不知道了。 刚刚说「中国供应商」的成功有一部分是来自国家对外出口发展的运气，所以 2008 年股价大跌，也是受国家出口经济下滑的影响。2008 年，由美国开始的次级贷款危机席卷全球，中国的出口也受到了很大影响。而「中国供应商」因为服务于这些企业，自然收入也受到了极大的影响。 马云在这时主导了一系列的变革，书中列举了很多，我印象比较深刻的是销售施行新续分开，以及服务降价。这两项变革都很难说一定能成，但是马云非常强力的推行了他主导的方案，事后来看，这些方案确实还起了效果。 最终，2012 年 2 月，阿里巴巴在港股以每股 13.4 私有化，退市。 纽交所上市2014 年 9 月，阿里在纽交所上市。上市价格接近 80，最近已经涨到了 170 多块。 阿里上市前夕，我在一个 Google 邮件组中看到阿里员工讨论，原来当时阿里的股票已经可以在内部交易了，内部交易价格大概是 40 块一股。大家在讨论值不值。我还清晰的记得，大部分都是觉得不值的。可能很多员工在那个时候，已经把阿里的股票卖掉了。 但是，一个同事告诉我，有一个阿里员工，每次发完工资后，就拿工资花不完的部分换成阿里股票，硬生生在阿里上市后，收获了巨大的财富。我想这就是人与人的差别。判断一家公司值不值钱，是一个巨大的能力，但是即使你是阿里的员工，你可能也不一定判断得出来阿里的光辉前景。 感想以上就是阿里的发展史，接下来说说我的一些感想吧。 创世时刻一家公司的发展，总要经历几个关键的、决定生死的时刻，我把这个叫做「创世时刻」。我个人觉得阿里的创世时刻有两个。 一个是 2000 - 2001 年，那个时候阿里帐上没钱，又逢互联网泡沫破灭，阿里如果不能自己造血就只能倒闭。幸运的是，他赶上了中国经济出口的好时机，凭自己的努力把这块蛋糕吃下，最终成为阿里的持续造血业务。 第二个是 2003 年，马云决定做淘宝和支付宝。电子商务和支付业务，最终成为互联网经济的基础业务。马云在这个业务上投入的时间足够久，资金足够多，最终成就了阿里的千亿市值。 马云其人我觉得马云是一个优秀的演讲者和领导者。有人说 CEO 做好三件事情就可以了，一是找人，二是找钱，三是定战略，马云在这几方面都非常厉害。 拿找人来说，关民生，阿里巴巴的 COO ，2001 年加入的时候已经 52 岁，有着 25 年国际企业从业经验，在通用电器公司工作长达 15 年。进阿里的第一件事情就是帮助阿里巴巴裁员，以便度过危机。换作是别人可能是赶紧走人，以免坏了自己的履历。但关民生不但留下来了，而且真正帮助马云把阿里做成了。 马云找钱的能力也是一流，拿到孙正义的钱帮助阿里度过第一次互联网危机。在港股上市拿到 17 亿美金，帮助淘宝和支付宝持续成长。 定战略就更别说了，不管是淘宝和支付宝，还是阿里云，菜鸟物流，蚂蚁金服，都是极强的战略眼光。 为什么强调价值观阿里巴巴早期是一个极度销售导向的公司，中国供应商项目的成功，很大程度上就是地推团队的成功。而地推团队，很容易滋生腐败。比如给客户回扣，为了谈合作承诺一些不可能做到的事情，或者团队内部过于哥们义气等等。 公司做大之后，如果整个核心团队不能坚守公司的价值，那么很容易就把业务带偏了。于是，马云在 2001 年，就开始面向销售的百年大计培训。强调价值观：客户第一，团队合作，拥抱变化，诚信，激情，敬业。 这些价值观，我不知道是不是阿里的成功必须的条件，但我觉得至少在初期帮助阿里巴巴更好的成长。 下图是我从书中拍下来的，阿里对员工价值观好坏的比喻。价值观不好的员工，无论业绩如何，都是不能留的。 商业化的过程每个公司都会经历商业化的过程，在本书的第 17 页，阿里巴巴介绍了他的商业化的尝试过程，看完之后我的总结是：「摸着石头过河」。商业化的尝试无非就是结合自身的业务特点，考虑有哪些可能的赢利方式，然后一个一个讨论分析，最终再挑重要的尝试，尝试过程中再反复迭代总结。某种意义上讲，这和创业的过程一致。 向管理要绩效 和 以业务代管理阿里巴巴早期的管理风格，更多是一种「向管理要绩效」的风格。即：管理者要承担大部分的绩效目标。当然，马云在绩效的同时，也强调了价值观，进一步完善了绩效的标准。这种管理方式，更适合销售导向或者 KPI 明确的业务。在互联网公司，很多业务尚在探索期，这种情况下很难用「向管理要绩效」这种风格的管理方式。 所谓以业务代管理，就是说只要业务在增长，团队成员就会相对稳定，就不用管理了。只要业务停滞，就需要管理来介入。我觉得这种方式也有问题，事情是一起做成的，如果团队遇到困难，大家就走了，那么事情很难做成。阿里的几次重大危机，都是团队一起度过的。 所以，一个好的公司，应该既要有绩效上的目标，也要有管理上的目标。绩效上的目标主要在业务上，管理上的目标主要在人和团队上。团队负责人应该让大家能够工作得愉快，有干劲，在遇到困难的时候有斗志，有凝聚力，这些目标对于强调平等和尊重个体的互联网公司来说，也是一个不小的挑战。 总结阿里的成功，有着时代赋予的巨大机会，但更多的是创始人以及创始团队的努力和坚持。推荐大家看看，特别是创业遇到低谷的时候，看看就觉得相比起来，一些困难根本就不算困难。 共勉！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"把自己当作机器 - 读《原则》的收获","slug":"principles-summary","date":"2018-02-25T07:50:40.000Z","updated":"2024-01-06T14:52:37.933Z","comments":true,"path":"2018/02/25/principles-summary/","permalink":"https://blog.devtang.com/2018/02/25/principles-summary/","excerpt":"","text":"序春节利用闲暇时间，终于把《原则》这本大块头的书读完了。 《原则》这本书是一位投资人 Alex 推荐给我的，后来罗振宇又在跨年演讲上推荐了一次。该书的作者是桥水公司（Bridgewater）创始人雷·达里奥（Ray Dalio）。Ray Dalio 白手起家，把桥水公司做成了世界上最大的对冲基金公司，现在桥水公司管理着上千亿美金的资产。 《原则》这本书是 Ray Dalio 生活和工作的行事准则，同时也是桥水公司独特运作方式的介绍。我从中收获很多，主要的收获包括： 极度求真与透明 机器化运作自己和公司 金钱的价值观 人才的价值观 投资上的逆常识规律 接下来我展开分享我的以上感悟。 极度求真与透明 这个观点在书中反复出现。作者认为人们要做出合理决策有两大障碍： 自我意识。人们在潜意识里有一种防卫机制，它使你难以接受自己的错误和弱点。如果一个人反对你的观点，你的大脑会本能地进行反驳和防御。对于「极度求真」，这种潜意识是有害的，因为你可能为了争论而争论，而忘记了追求真相。 思维盲点。思维盲点的产生是由于大家的性格特点，知识背景，思维方式不一样，即使讨论各方都非常坦陈客观，还是可能会出现观点不一样的情况。 为了避免以上两大障碍影响你的决策，你就需要做到：「极度求真与透明」。首先用大脑的理性压抑自己的潜意识防御冲动，努力追求真相。另外，努力把自己的思维逻辑以「极度透明」的方式呈现。例如你的论点是什么，论据有哪些，论证过程步骤具体是什么样的。当有不同意见时，努力寻找不同意见的差异点是在哪儿。 这种开放的心态说起来容易，做起来却非常难。当所有人都说 A 观点的时候，你敢于表达自己心中的否定意见吗？当讨论的对方已经和你争得面红耳赤，你还能保持内心的平静吗？ 能够做到这一点的人都是情商高手，因为情商包括五个部分：自我意识、控制情绪、自我激励、认知他人情绪和处理相互关系。而要做到「极度求真与透明」，就需要有非常强的自我意识和情绪控制。 机器化运作自己和公司作者 Ray Dalio 多次在书中建议大家把自己想像成一部机器，然后就可以用管理机器的方式来做自己。管理机器的常见的方式包括： 全局意识 数据驱动 算法驱动 迭代思维 创意择优 全局意识把自己的肉身想像成完成目标的一种资源，并且是一种可替换资源。有了这种想法之后，你就不必纠结于你自己能力是否强大，是否亲自完全某件事情了。为了达成目标，你可以咨询他人，也可以雇佣或授权别人。如果自己不合格，你可以培养提高自己，也可以把自己开掉。 数据驱动想像你有一辆车，你怎么判断它是健康的？除了真正开起来之外，你还可以通过各种指标。比如胎压，水箱温度，发动机转速，系统自检，这些都是数据指标。 Ray Dalio 强调在生活和工作中也引入数据驱动： 在决策的时候，收集足够多的数据。 在执行过程中，利用数据做检验。 在有结果的时候，利用数据做总结复盘。 依赖数据进行不断的迭代优化。 应该说，桥水的成功就依赖于几次大的对于市场的判断，而他们的判断总是先行于各种主流的投资机构，这使得他们成功建立起了行业专业度以及市场利润。 算法驱动Ray Dalio 在工作的总结最终都会整理成「算法」。我理解「算法」就是一套经过检验的，可以重复执行的复杂规则。很多时候，这种规则可能还不是人在执行，而是计算机和人配合执行。比如计算机依据算法计算出一些结论，人类再加以二次验证。 在书中，Ray Dalio 称桥水公司是最早利用计算机来辅助做决策的公司。我也能感受到，他对于计算机能够没有任何感情，综合各种因素客观评价的喜爱。在对冲基金公司中，信息实在太多，计算机能够帮助他们更加客观和整体的看待数据的影响。 迭代思维机器是会不断进化的，我们开的车、坐的飞机、用的电脑、手机，每一代都比上一代先进很多。Ray Dalio 希望我们在做事情上，也有机器一样的迭代思维。最终大家做一件事情，经过长久的迭代打磨，会越来越厉害。 我们在工作上，如果一件事情需要持续做很多年，但是每一年的工作方法都和以前完全一样，那么就说明相关的负责人缺乏迭代思维。没有什么事情是做到了极致的。 创意择优创意择优恐怕是《原则》这本书最推崇的一种决策方式了，但是执行起来又极其困难。简单来说，创意择优是把大家的投票权重，按照历史上大家的表现来进行加权，一个资深的投资经理，比一个新入行的新人，在投票权重上是不一样的。 这个道理大家都能明白，但是大部分人在执行创意择优决策的时候，是在脑海中感性地进行加权比较。比如我打算做一个决策，询问身边 5 个人，有 1 个选方案 A，4 个选方案 B，但是选 A 的人我特别看重，所以我就还是决定用方案 A。这种加权分析特别模糊，并不完全理性与客观。 桥水公司为了把这件事情做到极致，用了大量的工具，利入了集点器、棒球卡、错误日志、痛苦按钮、量化指标等等。特别是集点器，是一个点对点的打分系统，并且是完全公开的。利用集点器，桥水公司收集到每一个人的各项指标数据，来进行严格数学意义上的加权。 有人在知乎上说桥水公司是一家「邪教」组织，很多时候就是对这种工作方式不满。从人性角度，这样的工作方式确实需要每个人都极度的求真与透明，并且相信这一套能够 work。这种方式对人的要求也非常高，据说有 30% 的员工在桥水都待不够两年。 我个人认为这套决策机制可能还是与桥水公司在对冲基金行业有较大关系。在互联网公司，首先不需要涉及这么多人的共同决策，另外也没有那么多的重要决策。 金钱的价值观我特别喜欢 Ray Dalio 介绍他对于金钱的价值观。他说： 把赚钱作为你的目标是没有意义的，因为金钱并没有固有价值，金钱的价值来自于它能买到的东西，但是金钱并不能买到一切。更聪明的做法是：先确定你真正想要什么，你真正的目标是什么，然后想想你为了得到这些目标需要什么。金钱只是你需要的东西之一，但当你已经拥有了实现你真正想要的东西所需的金钱时，金钱就不再是你唯一需要的东西，也肯定不是最重要的东西。 对于我们大部分人来说，我们需要的金钱其实是为了保证良好的个人生活和家庭生活，实际上就是：住房、出行、教育、娱乐、日常生活、健康、以及一些意外事件发生时的应急。如果金钱已经多到很好地解决这些需求了，再多的钱其实就不是必需品了。 Ray Dalio 甚至提到了一种边际收益下降的观点，即：得到适量的东西比得到太多的东西更好，因为后者会伴随着沉重的负担。比如我们假设维持上面提到的幸福生活需要一个亿人民币，那么假如你手里有 100 亿人民币，你就会有沉重的理财压力，如何把这辈子都用不完的另外 99 亿用好，怎么保证它不贬值，会牵扯你更多的精力。 从快乐的角度，我以前以为我需要财务自由才能够体会到财务自由的心态，现在我觉得，其实不管你有多少钱，你都需要有更多的追求和目标，否则你通常是不快乐的。财务自由的人的心态，和普通人的心态一样，都在自身的条件下，尽量追求极限，成就自己。 人才的价值观程序员出身的我，一直以为对于人才来说，技术水平是最重要的。但是我现在越来越认为，价值观相比技能更为重要。Ray Dalio 在《原则》一书中，也强调挑人的时候应该先看价值观，再看能力，最后看具体的技能。 每个公司对价值观的定义都不太一样，桥水公司的价值观之一就是上面提到的极度求真和透明，而这一点可能并不在很多公司的价值观里面。 投资上的逆常识规律这一点在书中仅仅提了几句，而我对这个却印象深刻。原文是这样说的： 在机器学习不包含对现实的深刻理解的情况下，以机器学习为基础构建的投资系统很危险。因为当人们广泛相信并应用某些决策规则时，价格会受到影响。换言之，一个深刻见解在众所周知之后，其价值会逐渐衰减。 常见的情况是，一些决策规则变得非常流行，以至于对价格产生很大影响，从而使反向操作成为更合理的做法。 前阵子看到一篇文章：《用户增长怎么做？这是我在 Uber 和摩拜的实战经验》，在文章中，前 Uber 的增长部门总监 Andrew Chen 有一个观点： 所有增长招式都越用越滥、效果越来越差。 大家不觉得两者其实道理很相似吗？不管是做产品，做运营，做技术，还是做投资，如果一件事情大众一拥而上，就会产生泡沫，价值就会被迅速拉低。再举几个例子： 几年前 iOS 开发缺人，结果大量的人转行做 iOS 开发，大量的培训机构兴起。结果迅速人才饱和，现在好多新人找不到工作。 最近比特币、区块链技术特别火，结果大家都炒币，大家都争相传播某某又暴富的神话。你说未来大概率会不会产生泡沫？ 《原则》中讲的投资上的逆常识规律，让我再一次认识到这种规律的普遍性。 小结不可否认桥水是一家成功的企业，Ray Dalio 的《原则》也有非常多可以学习和借鉴的地方。但是就像书中在导言中就写的那样，这些原则借鉴吸收哪些，我们需要独立思考和决策。 对于我来说，把自己当作机器管理以及求真透明的人生态度，是我对本书最大的收获。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"4 步教你写好商业化文案 - 读《爆款文案》","slug":"write-best-selling-page","date":"2018-02-07T23:48:23.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2018/02/08/write-best-selling-page/","permalink":"https://blog.devtang.com/2018/02/08/write-best-selling-page/","excerpt":"","text":"最近读完了《爆款文案》，本书的作者是关健明，曾经是奥美的广告人，专职工作就是写商业化的文案。 好的文案和差的文案能差多少呢？我听过一些故事，也经历过一些故事，毫不夸张地说：效果差 10 倍不算多，有些能差接近 100 倍，可见文案的力量有多强大。 在《爆款文案》中，关健明将商业化的文案书写分成 4 步，这 4 步按照用户从感兴趣到下单的整个过程，每个环节都做了精心的准备，力图引导用户完成商品的下单。这 4 步按照顺序是： 标题抓人眼球 激发购买欲望 赢得读者信任 引导马上下单 接下来，我分别介绍一下书中对于这四步的详细阐述。 标题抓人眼球在这个信息爆炸的时代，标题的重要性不言而喻。别管你的产品有多好，如果不能吸引用户点进来看，那么什么都是白搭。书中总结了起名的一些套路： 套路一：使用有「新闻感」的标题。比如：「2017NBA 全明星赛上场鞋照曝光，有 1 款今天 6 折！」。在使用这个套路时，得注意： 树立新闻主角。比如故意「碰瓷」一些名人（比如高考状元），名企（比如苹果）。 加入及时性词语。比如：今天。 加入重大新闻常用词，如：全新、曝光、突破、发现、发明、蹿红、风靡。 套路二：好友对话。通过口语化的标题产生亲近感。比如：「他写微信软文赚了 1173 万元，愿意手把手教你文案秘籍—只在这周六！」，又比如：「恭喜你！在 25 岁前看到了这篇最最靠谱的眼霜评测！」。使用该套路，需要注意： 通常要在标题中加入 “你” 这个词。 所有书面语改为口语。 加入惊叹词。 套路三：实用锦囊。让读者感觉到是满满的「干货」，比如：「新年礼物！拖延症晚期也能 1 年读完 100 本书」，又如：「你和老公总存不下钱？央礼理财专家给你 3 个建议」。使用该套路的注意事项是产生对比，这样才有货干的效果，所以需要： 写出读者的苦恼。 给出圆满解决方案（或解决后的效果） 套路四：惊喜优惠。比如「今天免邮！2.5 亿人在用的德国净水壶 半价 90 元」。在介绍优惠的时候，第一步不要着急报价，而是介绍产品卖点，因为用户本质上还是买有用的产品。然后再写明具体的低价政策。最后，要加上限时限量，营造一个稀缺感。 套路五：写意外故事。人们天生喜欢听故事，特别是意料之外的故事。要造成这种冲突，就需要先描述糟糕的开局，然后展现完美的结局。比如「大家都看不上的办法，他却用来挣了 1000 万」。 我自己的体会，要学习写标题，可以认真研究一下眯蒙的文章，它每篇文章都非常有冲突感，让人有非常强的点击欲望。 当然，我们也不能仅仅是标题党，所以接下来，我们看标题把用户引导点击之后，后面的页面应该怎么做。 激发购买欲望《爆款文案》介绍了 6 个步骤来激发读者购买的欲望。 步骤一：感官占领。在文案中描述用户的眼睛、鼻子、耳朵、舌头、身体和心里的直接感受。这类似于产品经理还原用户场景一样，现场的感受都是细节和真实的，没有任何总结加工的成份。这种文案的写作方法：描述产品对感官的直接感受，把自己体验的过程记录下来，试图用充满激情的文案感染顾客。 步骤二：恐惧诉求。描述不用该产品的痛苦，比如洗碗机销售文案就可以讲人的时间花在洗碗这件事情上有多么无聊。该步骤的注意事项是： 不要激起逆反心理。最好说自己的恐惧，让别人感同身受，而不是直接说顾客的恐惧。 可以用几个简单的提问，帮助用户总结出恐惧或悲观的结论。 步骤三：对比竞品。通过对比让顾客认知到我们的优势。比如： 描述竞品的产品差（设计、功能、质量） 描述竞品的利益少（带给消费者的利益少，甚至可能某些情况下有坏处） 步骤四：描述使用场景。帮用户规划和设计好什么时候用我们的产品。 步骤五：畅销。讲我们的产品卖得多好。利用顾客的从众心理，描述我们的产品已经被大量用户认可。注意： 描述畅销的时候也需要描述细节，要使用精确的数字以体现出真实性。 如果是小众产品，可以描述局部热销的场景，营造出一种热销的现象。 步骤六：顾客证言。这个基本上每个电商页面都在使用。在使用时可以注意： 证言要描述用户的核心顾虑。 证言要有一些总结性的文字，帮助顾客理解。 在用了以上 6 步之后，顾客可能会想：「你描述的产品确实很吸引人，但是我为什么要相信你呢？万一你欺骗我呢？」这就需要接下来的要素。 赢得读者信任如何让读者相信你没有欺骗他呢？文中介绍了 3 个方法。 方法一：权威转嫁。利用专家评价、行业大奖、权威认证。让用户对产品的质量产生信任。现在很多区块链项目找人背书，也是打的这个主意。不过用户对于专家、行业大奖、权威的了解并不一定清楚，所以需要介绍清楚这些权威的背景，这样才能真正产生信任感。 方法二：事实证明。这个步骤不能直接上数据，你上各种技术参数用户会是直接蒙逼的。所以需要把产品的核心质量，转化为客户能够容易理解的形式描述。比如卖纸的为了证明丝的韧性，在上面放 10 枚硬币。这样客户一下就能感受到质量了。 所以这个方法的步骤是：（1） 收集核心性能数据 （2）链接到熟悉的事物或者用各种实验来证明。 方法三：化解顾虑。淘宝电商常常使用的：包邮、货到付款、免费试用、15 天包退货。都是化解用户不信任的好办法。 好了，现在用户信任你讲的都是实话了，但是用户心里想的是：「我为什么现在一定得买呢？明天买不行吗？」一旦用户真的说服自己明天买，他明天十有八九都会忘记掉这件事情。所以，我们还需要引导用户马上下单！ 引导马上下单怎么引导马上下单呢？有 4 个办法。 方法一：价格锚点。通过找一些很贵的产品做对比，来凸显我们价格的便宜。用户买的不是便宜，而是一种占便宜的感觉。所以，你需要的是让用户感觉便宜，如果用户感觉不到便宜，即使你是真便宜，用户也不会买。 其实每个人对于价格的认知都是通过对比来的，给你商品让你猜价格，你可能猜得高，可能猜得低，但是不管你猜多少，你多比较几个商店的价格，就会觉得哪家相对实惠了。所以，设置价格锚点相当重要。 方法二：算帐。帮助用户算帐，把总价很高的产品，算得很便宜。 算帐可以使用「平摊法」：报名我们公司的斑马英语，相比线下 200 元以上的英语课程，我们每节课只需要 20 元。算帐可以还可以使用「省钱法」：相对传统的产品，可以省多少钱，多少水，多少原料，多少时间等等。比如开新能源车，电费相比油费，每 10000 公里可以省 4000 元的费用。 方法三：正当消费。例如：为了上进、为了家人、为了健康。据调查，每个有孩子的家庭，把家庭收入的将近 1&#x2F;3 都投入到孩子的教育当中。可见大家是多么把教育看作一个「正当消费」。而娱乐，通常都会被归为不正当消费，当收入不太高的时候，花太多钱心里总归有些愧疚感。 方法四：限时限量。让顾客产生稀缺感和机会损失感。所谓「机不可失，失不再来」，这是商家常见的套路。 小结《爆款文案》一书将用户的购买过程拆解成：被标题吸引 -&gt; 产生购买欲望 -&gt; 赢得信任 -&gt; 立即下单 这四个过程。每个过程，作者拆解出了一些关键的方法套路。 作者来自一线的营销经验，我认为还是非常有效的，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"用游戏化的思维养孩子 - 读《儿童技能教养法》","slug":"gamification-for-child","date":"2018-01-30T23:53:36.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2018/01/31/gamification-for-child/","permalink":"https://blog.devtang.com/2018/01/31/gamification-for-child/","excerpt":"","text":"序言《儿童技能教养法》是一本讲如何带孩子的书，作者是来自丹麦的本·富尔曼。该方法主要用于帮助 4~7 岁的孩子克服一些成长问题，例如恐惧、坏习惯，或者一些学习障碍。 这可能是我读得最不像游戏化的一本讲游戏化的书了。在这本书里面，没有任何一处内容提到了游戏或者游戏化，但是如果结合之前读的《游戏化思维》、《游戏改变世界》、《游戏化实战》，你就能发现，本质上大家讲的都是一个道理。 在《游戏改变世界》中，作者认为游戏的核心就是：目标、规则、反馈系统、自愿参与。在《游戏化实战》中，作者认为游戏利用了人性的8种情感：使命感、成就感、有趣&amp;创意、拥有感、社交感、稀缺感、好奇心、亏损&amp;逃避感。 儿童技能教养法有了以上两大书的总结，我们再来看看《儿童技能教养法》一书中提到的帮助孩子掌握技能的 15 个步骤： 步骤1：把问题变成孩子能够学习的技能。 步骤2：跟孩子一起商定他想学习的技能。 步骤3：帮助孩子看到拥有该技能的好处。 步骤4：让孩子给技能起个名字。 步骤5：选择一个可以帮助他学习技能的魔法宝贝。 步骤6：帮助孩子找到他的支持者。 步骤7：让支持者告诉孩子为什么他们对他的学习充满信心。 步骤8：跟孩子一起提前策划学会技能后如何庆祝 。 步骤9：让孩子演示一下，当他学会了技能时，应该有什么样的表现。 步骤10：帮助孩子告诉大家，他正在学习什么技能。 步骤11：给孩子创造机会去练习和表演他的技能。 步骤12：让孩子告诉你，他希望别人在他忘记技能时如何提醒他。 步骤13：庆祝时，请孩子感谢所有支持者。 步骤14：给孩子创造机会，技技能教给其他孩子。 步骤15：跟孩子商量下一个要学习的技能。 儿童技能教养法与游戏化我们来看看这 15 个步骤是如何和游戏关联起来的。 步骤1：把问题变成孩子能够学习的技能。这其实就是在强调「目标」的重要性。家长常常习惯说「不要做什么什么」，而我们应该说「要做什么」，这样才是目标清晰的。这其实是《游戏改变世界》中游戏中核心要素。 步骤2：跟孩子一起商定他想学习的技能。在《游戏改变世界》中，游戏的第4个核心要素是「自愿参与」。因为自愿做的事情，才是最没有理由拒绝的。和孩子一起商量他想学习的技能，就是让他感觉到对这件事情的绝对控制权。这样他才能真正拥有自愿参与的安全感和自主决策感。 步骤3：帮助孩子看到拥有该技能的好处。这一步在明确收益，其实是另一个强调「目标」方式。想当于我们不但在步骤1中弄清楚了要做什么，而且在这个步骤中弄清楚了做这个有什么好处。 步骤4：让孩子给技能起个名字。孩子的世界总是很单纯的，如果技能的名字只是一段描述，那是不够形象的。所以，有一个好的名字可以帮助孩子更好地想起和记住它。成年人的世界也是这样，10年前 Ajax 就是将一个前端技术以一个好名字介绍给所有人，使得它被更好地传播。 步骤5：选择一个可以帮助他学习技能的魔法宝贝。这和第4步一样，有了名字之后，还有一个吉祥物，这更加帮助孩子记住这个技能了。成年人的世界最有名的例子恐怕就是奥运会的吉祥物吧。 步骤6：帮助孩子找到他的支持者。这其实是在利用《游戏化实战》中提到的社交感，让孩子从社交关系中获得更多的鼓励。 步骤7：让支持者告诉孩子为什么他们对他的学习充满信心。同上一步。 步骤8：跟孩子一起提前策划学会技能后如何庆祝 。这其实是一个附加奖励，希望通过外部激励来增加目标的吸引力。 步骤9：让孩子演示一下，当他学会了技能时，应该有什么样的表现。进一步强化「目标」。 步骤10：帮助孩子告诉大家，他正在学习什么技能。利用社交感。 步骤11：给孩子创造机会去练习和表演他的技能。首先这利用了社交元素，另外这利用了《游戏改变世界》中提到的及时反馈。孩子学会了一个技能，然后马上练习和表演，就可以获得及时的正反馈。 步骤12：让孩子告诉你，他希望别人在他忘记技能时如何提醒他。这其实是利用了《游戏改变世界》中提到的自愿参与。因为当你用他选择的方式提醒他时，他就不会那么沮丧或者愤怒了。他会认为「一切都在他的掌控之中」。因此，他的情绪会更平和，也更加容易接受调整。 步骤13：庆祝时，请孩子感谢所有支持者。这是一种仪式感。游戏的各种通关界面，现实世界中的各种庆祝仪式，都是利用了这个元素。它会让人印象更加深刻。 步骤14：给孩子创造机会，把技能教给其他孩子。这利用了《游戏化实战》中提到的社交感和成就感。 步骤15：跟孩子商量下一个要学习的技能。这个步骤就像很多游戏中的无限挑战一样。孩子学会了一个技能，他如果在这个过程中收获了成就感，就应该激励他持续在这件事情上收获成就感。所以，跟孩子商量下一个要学习的技能就是一个很好的步骤。不但符合游戏中的「自愿参与」原则，也符合游戏设计中的无限挑战原则。 小结总结一下：步骤1、3、4、5、9是强化目标；步骤2、12、15是自愿参与；步骤6、7、10、11、13、14 是利用社交感；步骤 8 利用外部激励。看起来带孩子和游戏化的思路真的是有大量的相似之处，其核心都是让孩子更加容易掌握成长过程中的技能。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"2017 年个人总结","slug":"2017-summary","date":"2018-01-01T14:33:59.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2018/01/01/2017-summary/","permalink":"https://blog.devtang.com/2018/01/01/2017-summary/","excerpt":"","text":"前言不知不觉，一年总结一次的习惯已经坚持了 6 年，今年是第 7 年了。 今年的总结打算先聊聊创业，再讲一些个人成长，最后复盘一下去年的目标，列一下新年的目标。 关于创业融资与期权2017 年的 5 月，猿辅导拿到了新一轮 1.2 亿美金融资，估值 10 亿美金。这一轮融资的同时，公司也进行了一些期权的回购。面对机会，有一些人选择将能卖掉的期权全部卖掉，也有人选择不卖。大部分人都选择了前者，面对不确定风险，人性还是偏向落袋为安，我是非常理解的。 但是我自己仔细想了一下，我短期对于金钱的需求其实并不强，我不需要买房买车，孩子当前上学的钱也还够，提前把期权卖掉，我其实也得想办法理财。在线教育是我自己非常看好的一个方向，与其投资别人还不如投资自己，努力把猿辅导做得更大。 想明白这一点之后，我接受了郭常圳的建议，稍微卖掉了一点期权获得了一些现金，以防止家庭突然出现的一些资金需求，剩下的期权都保留了下来。 我想过最坏的情况：最终公司没能做成功，保留的期权作废了。但是权衡了一下，我更不能接受错过时代给予的机会。想明白这一点之后，我在工作上更加投入了。 成立事业部2017 年 1 月，我们公司将小猿搜题成立独立事业部，对于团队成员来说还是很受鼓舞的。德鲁克在 《管理的实践》 一书的中的第三部分「管理的结构」中专门讨论过这种事情，他是很支持这种「联邦分权制」的企业结构。 成立事业部后，小猿搜题开始独立考虑商业化和自己的发展。今年主要做了两个尝试，一个是做商城卖一些东西，另一个是做 VIP 增值服务。过多的信息不便公开，只能说还在继续摸着石头过河。 作业帮栽赃事件2017 年 8 月 9 日晚上 10 点，我们遭遇了作业帮的 栽赃事件，好在我们原始数据保存得非常详细，所以得以还原当时的整个情况。由于我们在公关上的高调回应，整体这个事件对小猿搜题的影响并不大，不过公关以及法律诉讼相关的证据准备还是在那段时间消耗了我大量的精力。 一审开庭的时间得到 2018 年 1 月。实话说，即便官司赢了，其实我们也占不到什么便宜。中国的法律对这种事件的赔偿支持额度都不太高，对于我们也仅仅就是争个说法而已，可能还不够我们花的律师费。 成长个人在创业上成长了不少，另外感觉自己的决策权大了很多。因为成立事业部，我汇报的关系从郭常圳变成了李鑫。他们俩的管理风格差别很大，也使得我能够比较和学习他们俩各种的长处。 郭常圳的管理方式偏老师型一些，会主动和我沟通，教我各种他觉得有用的技能。如果我犯了什么错误，郭常圳会很直接地批评我。在他的管理风格下，我能感受到自己的各种进步，也能感受他非常用心。 李鑫的管理方式偏放养型一些，李鑫希望把事情尽量授权，鼓励我尽量做决策，承担责任。对于犯错，李鑫会觉得没什么，自己只要及时总结就可以了。在李鑫的管理风格下，我需要更加主动地和李鑫沟通，主动向他咨询一些事情的意见，也需要更加快地自己学习总结。 其实两种领导方式我都非常喜欢。前者让我刚开始带团队的时候不至于太过紧张，也不会犯什么大错，后者让我上手之后能够施展拳脚，自主决策。 人员变动从融资和估值来看，猿辅导的发展速度其实已经很快了。但是算算年头，2017 年已经是猿辅导发展的第 5 个年头了，从商业化角度看，猿辅导还需要继续努力才能够达到上市的目标。而这个商业化的过程其实并不容易。 于是 2017 年，有一些同事选择离开，但是又有一些新的同事选择加入我们。有一些离开的人还挺重量级的，比如 D 同学，但是有一些加入的同事也很重量级，比如美团的第一个产品经理 W 同学。 我自己今年看了阿里和 360 的成长史，看了腾讯的成长史，在网易时也听过不少网易早年的悲惨故事。我其实觉得：没有哪家公司的发展之路是一帆风顺的。如果看好在线教育这个行业，长期坚持下来，一定能够收获不错的回报。 关于个人硅谷2017 年 3 月，我参加 Boolan 组织的硅谷旅行团，去硅谷玩了几天。以前觉得硅谷什么都牛逼，真正到了硅谷，去各大科技公司和一些朋友和同事聊天，我才感受到了真实的硅谷。这里面有惊喜，也有落差。亲眼看着 Waymo 的无人车从身边开过，亲耳听到众多的华人工程师在硅谷的心路历程，再经过长久地思考后，我才明白自己当前最好的机会还是在国内创业。 这次硅谷之行让我成熟了许多，相关行程也总结在了博客中： 硅谷之行（一）：惊喜和落差 硅谷之行（二）：科技公司和景点 硅谷之行（三）：硅谷旅行攻略 旅游除了硅谷外，今年我还去了很多地方，比如日本、新加坡，国内去了杭州、上海、深圳、武汉、乌镇。日本和新加坡的旅行还是让我见识了不少。 日本城市干净整洁，人们彬彬有礼，让人感受到了强大的秩序文化。新加坡如此小的国土面积，能够让整个城市都如花园一般美丽，各种利用城市有限空间的细节让人惊叹。 有机会还是应该多出国见识见识，2018 年我应该会继续策划几个出国深度游。 英语2017 年初定的年度目标，有一个是希望「英语听说能力进一步发展，达到和国外同行交流能力」。为了达到这个目标，我今年用一些 App 练习了一段时间口语，另外下狠心用英语在 5 月深圳的 @Swift 大会 上做了一场全英文的技术演讲。这次全英文的演讲对于我来说算是一个很好的开始，我发现至少自己在听说方面没有很怯场了。但是自己听演讲的回放，我发现自己的口音还是很烂。 这次 Swift 大会有很多外国嘉宾，我发现基本上是可以和他们比较舒服地交流了，还是比较开心的。在这次大会期间，我还接受了 和 Sual Mora 的全英文采访，我把音频放到了我的公众号上：第一段，第二段。很多人听后表示我的英文很烂，这一点我承认，能给大家信心就好。 我当前的口语和听力离自己的目标还有不小的差距，但是当前的工作环境我可能无法更好地锻炼自己的口语和听力，所以在这个事情上我不太急，慢慢提升就可以了。比如最近我就发现了一个背单词的 App 叫 Lingvist，还比较对我自己的胃口，于是一直坚持使用着，昨天刚刚通关了第 40 级。 公众号2017 快到年底的时候，我才终于想明白了公众号的发展。我的公众号粉丝很多是做 iOS 开发的，但是我今年已经不做 iOS 开发了，是继续迎合读者，还是忍痛转型？不写 iOS 开发的内容，阅读量就非常低。写 iOS 开发的内容，又没有那么多新的内容可分享。 最终我还是打算转型，我将公众号的名字从「iOS 开发 by 唐巧」改成了「唐巧」，写了一篇 解释为什么转型的文章，然后就开始一点点写读书笔记，产品感悟，创业心得。转型后阅读量还是很低，我明白微信公众号的红利期早已过去，现在转型很可能会带来大量的掉粉以及持续低迷的阅读量。 不过这又能怎么样呢？相比公众号的那点阅读量和广告收入，我个人的持续成长显然更为重要。所以，即便以后阅读量一直都停滞不前，我仍然会继续转型，暂别 iOS，写新的感悟，新的成长。 看书2017 上半年主要在啃德鲁克的书，《管理的实践》看了几个月才看完。下半年看的书都比较好读，一本书基本上花一周多的时间。下半年的时候因为工作上涉及一些游戏化的事情，于是看了很多游戏和游戏化的书，包括《游戏改变世界》、《游戏化思维》等，全年刚好完成了 12 篇读书笔记。如下所示： 《管理的实践》 《卓有成效的管理者》 《一本书读懂财报》 《零售的哲学》 《游戏改变世界》 《游戏化思维》 《复盘》 《疯传》 《颠覆者：周鸿祎自传》 《眨眼之间》 《游戏化实战》 《游戏，让学习成瘾》 另外也有一些书看了，还没总结出读书笔记，比如《人类简史》、《巴菲特致股东的信》、《聪明的投资者》、《股票大作手回忆录》，《儿童技能教养法》等。 炒股就像我在 《每个人都应该买美股》 一文中所说的那样，2017 年我开始炒美股，希望借此锻炼商业思考能力和人性。 今年在商业思考上算是入门了吧，但更多的提升是对人性的锻炼。今年在瑞思英语刚上市还不稳定的时候，我就过早地买入，交了大概 2000 美元的学费。不过这个学费我个人觉得还是挺值的，它让我更加观注自己的投资行为是短期投机，还是长期看好。 我买瑞思英语其实是长期看好，但是我在它刚上市的时候就着急买入，其实是想在上市初期的波动中赚取更多的收益。结果我买在了最高点。其实如果长期看好一支股票，就应该在这个股票相对稳定的时候买入，这样才能避免短期的波动对收益造成的影响。一支股票如果短期内大量地波动，价格极不稳定，本身就蕴含了巨大的机会和风险。如果赌这个，就不是投资，而是投机了。 这也是为什么我不买比特币，我其实是长期看好比特币的，但是我不希望它的价格巨大地波动。巨大波动代表着比特币的公允价值还没有被所有人认同，长期来看，不会有任何一个投资品长期处于这么大的波动过程中。所以我如果要买比特币，就会等到它价格相对稳定的时候。 除了瑞思外，我在网易上也交了学费。我其实是长期看好网易的，但是由于网易涨得太慢，自己人性没忍住，结果在 275 出手卖掉了。网易这支股票上我虽然没输没赢，但是相对于现在 340 左右的价格，还是挺可惜的。 做得好的就不说了，有两支股票最终收益都超过了 50%。2017 年炒美股的成绩算是刚刚及格吧，小挣了一点钱，但是其实并不多。 健康今年上半年，我的身体状态很差。一方面是因为胃病的原因，饭后就感觉到隐隐作痛，另一方面是一些事情导致精神状态不太好。也是那个时候为了调节一下，玩了一段时间王者荣耀。 到了下半年，胃病通过吃药和保养基本康复了，同时自己在生活和工作上也慢慢找回了节奏。断掉的游泳也慢慢开始恢复，看书的速度也慢慢快起来了。 所以，一个人的生理和心理健康还是很重要的。我希望 2018 年还是能够保持适度的锻炼，使自己拥有好的状态。 复盘：年初的目标完成情况2017 年初，我定的年度目标如下： 总结和学习团队管理知识，把团队的工作规划好。 通过学习和写作，保持自己在 iOS 开发方面的能力。 英语听说能力进一步发展，达到和国外同行交流能力。 现在看起来，这 3 点都有进步，但是都算不上很完美，其中： 团队管理知识还在继续积累中，我希望后面通过更多的学习分享，把这些知识掌握牢一些。 iOS 开发方面的能力提升，主要集中在 2017 的上半年，下半年基本上没有花更多时间了。 英语听说能力今年有了不小的进步，和国外技术同行可以简单交流吧，但是肯定算不上很流利。 分享今年做了 5 次外部的分享： 2017 年 3 月，美团点评线下技术沙龙，中关村创业大街，《读 Swift 源码，理解 Monad》 2017 年 5 月，@Swift 深圳大会，《Understand Swift Performance》 2017 年 7 月，时光课堂，《Swift 性能优化分析》 2017 年 7 月，美团点评公司，《从开发到团队管理》 2017 年 8 月，趣直播线下分享会，《技术人如何成长为管理者》 今年在分享上故意节制了一些，主要是觉得自己快被掏空了😂，更多的时间用来了读书和写总结上。 2018 年的目标2018 年，我希望自己少一些目标，少即是多。我的目标从 3 个减少为 2 个： 看完 24 本书，并且完成读书笔记。 坚持英语的听说练习。 24 本书需要每个月两本，算是不小的难度了，我过去两年的读书速度都是一个月一本，所以这个目标如果能达成其实需要把空余时间分配得更加高效。 英语的听说是一个长期的事情，希望还是每天有一些碎片时间在上面，估计每天有个 10 分钟就可以了，贵在坚持。 个人 Milestone 客观理性地认识了硅谷 开始买美股","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"如何快速学习？教你几种学习的招式！- 读《游戏让学习成瘾》","slug":"the-pose-of-learning","date":"2017-12-30T08:19:01.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/12/30/the-pose-of-learning/","permalink":"https://blog.devtang.com/2017/12/30/the-pose-of-learning/","excerpt":"","text":"学习的几种招式最近读完了一本新书：《游戏让学习成瘾》。这是一本综述性的书，把现存的关于游戏化的各种理论和实践的文献内容进行了梳理。 对于本书，我印象最深的是其第 3 章：「教学游戏化的支撑理论」。该章介绍了「学习的几种招式」，仔细思考之后觉得非常有意思，分享给大家。 大招式操作性条件反射「操作性条件反射」是将外部激励和学习目标相结合的一种教学方式。通常应用于训养宠物或动物。比如：你每次叫你家🐶的名字时，都给它喂吃的，它就知道这是它的名字了。又如马戏团的训养员在训养动物时，当动物完成规定的动作后，就可以得到食物奖励。 当然，这种条件反射的学习有时候也应用在人类的教学上，比如你上课调皮被老师叫到外面罚站，又比如你和别的孩子打架，被你爸狠狠地揍了一顿😝。 整个社会都依靠着外部激励运作着，很多人并不是那么热爱自己的工作，但是因为有工资当作外部激励，并且奖金会奖励优秀的工作质量，所以最终大部分人都可以在社会需要的工作岗位上坚持做下去，并且还会追求更高的工作绩效。 自我决定理论与上面聊到的「操作性条件反射」对应的，就是「自我决定理论」，简单来说，就是你做某件事情，不是因为什么外部的激励，而是因为你内心就想做这件事情。 这种意识其实源自人类对自我个体的自主性需求。人们希望感受到「自由」，而想学什么就学什么，就是一种极度自由的表现。 另一方面，这种意识能够满足个体对于成就感的渴望。你希望学做饭，最终你做的菜得到了伙伴和自己肯定，最终会给自己带来非常大的成就感。你希望学习编程，最终你的代码运行在成千上万的手机中，满足了用户的各种需求，这也是莫大的成就。 最后，这种意识可以满足个体对于挑战的渴望。这是一种追求极限的意识。一旦人们进入这种意识中，即使他最终失败，他也能接受。这种追求挑战的心态，在生活和游戏中都处处可见。比如俄罗斯方式等待玩家的最终结果都是失败，但是大家会在意这个挑战的过程而非结果。 对于生命来说，所有人都逃不掉死亡和被遗忘这个宿命，但是大家还是会追求生命过程的精彩，因为每个个体不断成长的这个过程本身，就足以让大家非常愉快。 小招式上面聊的「操作性条件反射」和「自我决定理论」是学习的大招式。我们接下来再说说一些学习的小招式。首先要介绍的就是分段练习。 分段练习分段练习是指：将学习的内容进行拆解，对每个拆解之后的内容进行反复学习，并且在学习一段间隔之后定期复习以强化记忆。 我在学习自游泳的时候，教练先让我手把浮板练腿部招式，几天之后再练习单手招式，最后再结合上手部动作和腿部动作，最后再加上换气的部分。整个学习过程就是一个拆解学习再组装的过程。 分段练习是一种将大问题转化成小问题，然后逐个击破的思想，这种思想在初高中的时候就开始应用了。我们在学习几何的时候，先学习平面几何，然后等我们掌握平面几何知识后，我们再学习立体几何。立体几何的很多问题，其实是转化成多个平面几何的问题来解决。 比如：如果我们要证明在立体几何中的两个直线平行。我们可以先证明这两条直线「共面」，只要它们共面，这个问题就转化成：如何证明平面几何中两条直线平行了。 分段练习这种问题拆解的思路也不总是有效，因为它容易陷入细节思考而缺乏全局意识。在一些颠覆性创新的领域，这种思想就很有害，因为它无法全盘推翻以前的框架而重新学习。 支架式教学支架式教学是指将学习成分各种关卡，通关之后再着眼于下一个关卡。支架式教学的核心是让学习的难度与学员的水平匹配，类似于游戏中的「最优化的挑战」一样。这样才可以持续地给学员产生类似「心流」一般的感受，以增加学员的成就感。 支架式教学和分段练习看起来有点像，但是着眼点不太一样。分段练习的着眼点还是更好地解决问题，支架式教学的着眼点是个体的感受。例如，有可能有一些事情，即使分段练习之后，难度还是很大，比如背 GRE 单词。又有一些事情，其实并没有逻辑上可做的分段和拆解，但是为了提供支架式教学，人为地把其中一些知识先抽出来，以保证体验。 情景式记忆我们大部分人的学习，都是来源于正式的场景：比如上课，听分享，看教学视频，看书等等。但是情景式记忆理论指出：其实最好的学习方式是在目标场景下学习。比如你要学游泳学做菜，看书的效果就不大，最好的办法就是直接体验，在真实是游泳馆里学习。 学习编程也一样，你看多少书都没用，还是得自己上手写一行行的代码才有真实的感觉。这也是为什么以前在学校，我们班上有些学霸 C 语言笔试很厉害，但是上机操作就各种问题一样。 认知学徒理论认知学徒理论是基于上面提到的情景式记忆的。它认为学习应该在一个真实环境中，人和学习环境不能割裂。 对于我们来说，大部分的知识都不是应用在应试考试中，而是应用在生活中，所以如果你不能将学习的内容与生活的环境相结合，学习效果就会大打折扣。 我学了 10 多年英语，其实一直没长进。真正长进的时候，其实是毕业之后做 iOS 开发，需要去看 iOS 的开发文档，看 WWDC 视频，去 stackoverflow 上回答问题挣 reputation 的时候。那个时候我才意识到英语是有用的，同时才真正天天用上了英语。 社会化学习理论这是我最近体会很深的一种学习方式。所以我详细讲一下，希望大家都学会这种学习招式。 社会化学习理论出现于 20 世纪 70 年代末，罗伯特班杜拉将社会化学习理论解释为个体间相互学习的方法，它以社交场合为背景并通过观察来实现。 社会化学习理论基于一个前提，即行为可以通过观察和模仿学习。在这一领域的研究表明：人类的社会榜样确实可以有效地影响并改变他人的行为、信仰或态度，在社交和认知功能方面是有效的。 我为什么说这个很重要呢？这个其实是让大家学会在工作中通过观察和请教来学习，因为很多知识是无法通过学校的课程来掌握的。举个例子： 不管你是技术研发还是产品经理，在工作两年左右，都会需要当 Mentor 指导新人。如何指导新人呢？你当然可以买本书或者网上搜一下相关的文章来学习，但是这些学习都不符合刚刚提到的 “情景式学习” 的理论的，你即使把书中的知识背下来，你也可能带不好新人。 那么怎么办呢？难道说让你刚开始带的几个新人当「实验品」，用来练习你指导人的技能？或许可以，但是这至少是伤害了那几个新人的，大部分公司可能都不愿意这么做。即使在这件事情上可以，那如果是当 CEO 呢？你从来没有当过 CEO，难道要让你爸注册一家公司让你练手如何当 CEO？ 说到这里你大概理解了吧？有一些技能，是不太可能完全给你一个环境来边做边学的。这个时候，社会化学习理论就给你巨大的帮助。 所以，你如果要应用好社会化学习，你在当新人，被别人指导的时候，你就应该观察你的 Mentor 在怎么指导人，你的感受哪些地方好，哪些地方不好。最终，你指导别人的技能，是在你当新人的时候学会的！你看，你完全不需要真正的当 Mentor，就可以学会如何当 Mentor。 做 CEO 也是一样，你只需要有机会观察你们公司 CEO 的工作方式，有机会和他聊聊天或者请教一些问题，就可以学会一些当 CEO 的知识，而不是真正等到开一家公司的时候，才去看书，报商学院的课程来学习。 我在学游泳的时候，就仔细观察游泳教练在怎么教我，我是怎么突然就学会的。于是在我学会游泳之后，我至今已经教会了公司的 5 个同事学游泳。我自认为还是一个不错的游泳教练，而这个学习过程，完全是我当学员的时候偷偷学会的。 这个世界大部分的重要知识都没有被文档化，一方面是文档化的收益很低，另一方面是文档化之后学习的效果也很差。所以，每一个工作的人都需要掌握这个社会化学习的技能，只有这样你才能在职场中持续地向上司和同事学习，在有一天你被提拔的时候，不至于完全不能胜任。 所以： 如果你是一个职场新人，你应该学习别人是怎么指导你的。 如果你是工作 3 年的人，你应该学习你的上司是如何管理团队的。 如果你在管理团队，你应该学习如何经营公司。 希望你能掌握这种学习招式。 小结本文讨论了学习的大招式：「操作性条件反射」和「自我决定理论」，小招式：分段练习、支架式教学、情景式记忆、认知学徒理论、以及我们着重讨论的：社会化学习理论。 希望对大家有用，玩得开心！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"游戏中情感的八角分析法 - 读《游戏化实战》","slug":"gamification-book-summary","date":"2017-12-19T14:30:21.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/12/19/gamification-book-summary/","permalink":"https://blog.devtang.com/2017/12/19/gamification-book-summary/","excerpt":"","text":"序言最近读了几本关于游戏和游戏化的书，每本书都有自己的逻辑体系。 比如《游戏改变世界》的逻辑体系是：游戏是现实世界问题的补丁。所以《游戏改变世界》就在书中介绍了 14 个补丁，用于阐述游戏相对于现实世界的各种优势。 又比如《游戏化思维》的逻辑体系是：游戏元素的金字塔分层结构。最底层是组件层，中间是机制层，最上层动力层。 今天分享一下我读到的另一本书《游戏化实战》，以及这本书的逻辑体系：八角行为分析法。如下图： 八角行为分析法我个人觉得，八角行为分析法是从情感角度来讨论游戏化的。这个名字里面的八角，其实指代了 8 种情感。这 8 种情感分别是： 使命感 成就感（及时正反馈） 有趣 &amp; 创意 拥有感 社交感 稀缺感 好奇心（随机性） 亏损与逃避感 我简单展开介绍一下这几个情感。 使命感：使命感将你带入游戏的宏达的世界观或者故事情节中，你会有一种「男主角」光环的感觉。你会觉得玩这个游戏本身会有一个存在的意义。例如植物大战僵尸，你的使命是保护农场主人的脑子。又例如在过山车大亨中，你的使命是做一个非常厉害的游乐园。 成就感：成就感其实是伴随着游戏中随时出现的各种正反馈系统。小到俄罗斯方块落下时刻立即消除的一行。大到王者荣耀连续杀人出现的「Double Kill」的评价。 有趣 &amp; 创意：这类情感主要体现在益智类和牌类游戏，比如消消乐，斗地主，升级，麻将，狼人杀。每次玩的时候虽然规则都一样，但是局情发展都会有不一样的趣味。 拥有感：所有游戏里面的道具，成就，装备，称号，以及人物角色的各种服装外观，都给玩家了一种拥有的感觉。 社交感：有大量的游戏化方案都可以带来社交感。比如引入加好友，聊天，竞争，伙伴，师徒，排行榜等游戏机制。 稀缺感：稀缺感是一种渴望的感觉。在游戏中虽然非常难以达成，但是每一个人都有一个梦想，都渴望得到它。有一些稀缺感是通过金钱来做到的，比如王者荣耀里面的全满级铭文。又有一些稀缺感是通过竞争来做到的，比如各种排名里面的前面几名。 好奇心：游戏里面通常都会引入一些随机性的元素，就会把人性中的好奇心激发出来。比如阴阳师里面的开宝箱，虽然大家知道 SSSR 非常难抽到，但是这种随机性还是让人忍不住想试一试。我想，大部分的赌博游戏都是利用了这一点。每个人内心深处都是渴望成为那个有狗屎运，中超级大奖的人。 亏损与逃避感：一个游戏你玩久了，你有了等级，有了朋友，花了不少钱，这个时候即使你不想玩了，你也会因为厌恶损失而继续。因为一旦你不玩了，你之前投入的精力，金钱，甚至在游戏上的感情都相当于白做了。这种亏损的感觉是极其糟糕的。以前的网络游戏都需要练级，那通常是一个非常枯燥的过程，坚持下来的人突然有一天要决定放弃所有的一切，其实是非常难的。 案例了解了这些情感，我们就可以看看在商业环境中，游戏或者游戏化的产品在哪些地方用到了这些情感。以下是我找到的两个分析案例。 下图是 木糖 制作的天猫双 11 的八角分析图，来自 这里 ： 下图是 任寒韬 制作的王者荣耀的八角分析图，来自 这里： 总结和补充如果说本书还有一个情感没有说的话，我觉得就是《游戏改变世界》里面介绍到的：安全感。玩家们之所以可以反复接受各种闯关失败，核心还是游戏给了他们一种自由选择的安全感。如果一个游戏说：如果你不通关，就必须一直玩，那么被困在一个游戏里不能出来的感觉，一定是非常难受的。 本书还是有不少实践的价值，在设计产品的时候，可以在一些功能界面巧妙地引入一些游戏化的元素，让用户触发这 8 种情感中的一种，就可能带来一些不错的效果。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"直觉能力的培养和分析 - 读《眨眼之间》","slug":"blink-book-summary","date":"2017-12-17T10:03:48.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/12/17/blink-book-summary/","permalink":"https://blog.devtang.com/2017/12/17/blink-book-summary/","excerpt":"","text":"序言最近疯狂地看书，一个朋友问我：“唐巧，你为什么看书这么快？” 对于这一点，我其实是有点感知的。我可以几个小时就看完一本书，而且我看完图书后，通常还会完成一副思维导图和一篇读书笔记作为总结。但是，对于我自己为什么看这么快，我其实是没有系统总结的。 于是带着好奇，我分析了一下我看书的过程，总结了一些好的看书习惯。但是我其实并没有很好地总结出速读这个能力。我只能隐约地感觉到，读书的时候眼球应该快速上下移动，捕捉关键词，而不是一个一个字读。 刚好最近读完了格拉德威尔（Glandwell）的《眨眼之间》，这是一本关于直觉能力研究著作。我想这本书就很好地解释了我的状态。我的读书能力还在一个直觉状态，因为在潜意识层面，我还不能很好地分析和表达这种能力。 这样的例子数不胜数。就像《眨眼之间》一书开篇时介绍的故事一样：一个著名的雕像专家一眼就看出一个赝品，但是他自己也讲不出来赝品哪里不对。 所以，《眨眼之间》是一本关于直觉的书。 《眨眼之间》概述这本书首先介绍了很多案例，在这些案例中。领域专家展现出来的直觉能力比很多基于大量研究分析的结果还准确。 然后本书话锋一转，又列出大量关于直觉的研究。这些研究表明，直觉这个东西在普通大众人群中相当不靠谱，特别是当我们要求测试者用 “文字” 或者 “逻辑” 表达他们的直觉的时候。 当研究发现普通大众在直觉上的不靠谱后，首先把这些利用起来的就是商业环境。书中列举了包括美国历史上的一次总统选举，百事可乐和可口可乐的竞争，白酒行业对于包装的改进，优秀歌手的选拔等。 最后，本书介绍了一些方法，来分析和培养自己的直觉。这些方法包括统计学，对照实验，高速摄像头分析等。 章节介绍序言章：通过赝品雕像的故事引出关于直觉的讨论，并且介绍了本书的讨论内容。 第一章：介绍了薄片分析理论。一种基于直觉或者基于系统训练后的直觉，可以利用非常有限的信息进行有效的决策的办法。 第二章：人们搞不清楚潜意识工作的机制和时机，自己查查被潜意识影响也不得而知。 第三章：潜意识受环境影响非常深，几乎不能被克服。 第四章：案例章节。利用直觉决策的优势：有些事情对于时间特别敏感，例如医疗和战争。 第五章：案例章节。专业人士可以科学地评价商品，而普通大众会不自觉地受各种潜意识的影响。当然并不是说普通大众的潜意识都是错的，只能说是流于表面，难以阐述，易于干扰的。 第六章：案例章节。各种由于误解的直觉造成的灾难。 结语章：案例章节。讲了在古典音乐界选拔时克服直觉影响的一些故事。 直觉的优势和锻炼如果说本书最大的价值，就是揭示了直觉这种看似玄乎，实则科学的潜意识决策体系。直觉决策在一些时间紧迫的场景极为重要，例如：战争，医院抢救，警匪对峙，临场辩论。 直觉的优势是他工作与潜意识层面，所以异常高效。但是它的缺点就是容易被环境所影响。所以我们需要在一些领域注意直觉对自己的影响，避免掉入一些刻意设计的商业圈套里面。 而对于直觉最好的训练，就是把它当做一个科学研究的对象。利用对比实验，统计分析，眼球和心跳检测等各种心理学研究方法，我们可以把直觉的东西研究透彻。进一步，我们就可以训练直觉，书中介绍的 “压力免疫课” 就是一个对于压力下直觉反应的训练，最终我们就可以让直觉更好地为自己服务了。 总结美国教育心理学家 bloom 将认知分成 7 个层次。我想直觉可能就是大脑对于一些经验的潜意识总结，类似于 bloom 的应用层。但是不同于 bloom 的是，这些经验因为是在潜意识层面产生，我们缺少理解它的过程，所以研究它反倒变得困难。 其实《眨眼之间》书中研究直觉的方法并不特别，它和研究其它问题的方法类似，比如收集数据，对照实验等等。 对于商业公司来说，了解用户的直觉并且加以利用或许就是这本书最大的用处了。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"不服输的周鸿祎 - 读《颠覆者：周鸿祎自传》","slug":"zhouhy-book-summary","date":"2017-12-12T14:48:15.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/12/12/zhouhy-book-summary/","permalink":"https://blog.devtang.com/2017/12/12/zhouhy-book-summary/","excerpt":"","text":"最近读完了《颠覆者：周鸿祎自传》，这是周鸿祎的第二本书，分享了周鸿祎从小学到工作，再到创业 3721，以及最终把 360 做上市的故事。故事以周鸿祎第一人称的方式展开，在讲故事的同时也有一些周自己的总结在里面。 我看完之后，第一个感觉就是，周鸿祎首先是一个真实的人，为了自己的追求与梦想，一直在坚持着，努力着。周从来就不喜欢形式上虚的那一套，一切以结果导向。 为了能够积累商业经验，他可以在研究生阶段完全不理学业，去尝试创业。创业阶段没有电脑，他也会利用各种合规或者不合规的方法，在学校蹭电脑资源。在方正，他为了锻炼自己，会主动去新疆工作，接最苦最累的活。即便是在 3721 卖给雅虎之后，本质上他已经是一个职业经理人的角色了，但是他仍然为了自己的追求和雅虎总部争取资源和支持。 周是一个有想法，有追求的人，即使很多时候不被理解，但是站在他自己的角度，他其实都是为了自己的梦想在坚持着。 我的第二个感觉是，周鸿祎实在太苦了。周鸿祎被外界认为好斗，也着实因为在竞争中如果不这样，他的公司早就垮掉了。 在做 3721 中文实名的时候，他需要和 CNNIC 竞争，还需要和傍了微软 IE 大腿的 RealNames 竞争。即使现在看起来，胜算都不大，但是周都赢了。 CNNIC 其实具有政府官方的背景，这样的斗争最终赢下来很大程度上与 CNNIC 的上级部门信息产业部的开放有关。当 3721 当时的 CEO 都说放弃的时候，周可以开掉这个 IDG 派来的职业经理人，然后勇敢地和 CNNIC 竞争。 在 3721 被雅虎收购后，他需要向雅虎总部争取各种资源，不但要保证对赌协议下的赢利要求，还需要坚持做他看好的搜索和邮箱业务。现在看起来，周是非常有远见的。只是可惜没有得到雅虎足够的支持。 在做奇虎 360 的时候，他需要把各种流氓软件都杀掉，这里面触动了太多人的利益。包括前东家雅虎的雅虎助手（其实就是 3721）。这件事情给他树立了太多的敌人，但是他还是做了。做免费杀毒也是一样，基本上把国内所有的杀毒公司都得罪了。但是他认为这就是互联网发展应有的方向，所以即使董事会强烈反对，他还是做了。 周鸿祎历史上遇到的最大的苦，现在看起来就是 3Q 大战了。历史再重演一次的话，我相信全中国没有几个人能敢像周鸿祎一样，和 QQ 拼个你死我活。在周之前，大部分被腾讯山寨的应用都被干掉了，但是周鸿祎真正的是在拼命。QQ 搞静默安装，QQ 医生搞不兼容 360，换作别人会哭，但是周鸿祎想的是，你搞我的服务，我就把你的 QQ 收费服务也干掉，于是 QQ 保镖把 QQ 的各种广告屏蔽掉，QQ 秀关掉，最终逼得腾讯让用户二选一。事情最终在政府的牵头下和解。事后复盘下来，如果当年周鸿祎不这么做，360 能活下来吗？ 周鸿祎可能万万没想到，这场大战的最大受益者还是腾讯。自从 3Q 大战之后，腾讯终于转变了思路，开始在互联网上广泛投资，用结盟来代替山寨，给别人了更多机会的同时，也给腾讯了更多机会。 我的第三个感觉是，周鸿祎又是幸运的。他在高中通过竞赛冲击保送失败，这种事情放到现在也是非常大的灾难，但是他的老师给他做了推荐，成功绕过了高考，仍然保送到了西安交通大学。在创业的时候，周鸿祎又幸运地遇上了 IDG 和王功权。王功权在很多关键的时候给了周鸿祎足够的支持。周鸿祎在很多上事情的成功，除了他自己的坚持之外，还是有很多偶然的因素，比如和 CNNIC 的竞争成功，比如 3Q 大战的和解，很多时候周拼尽了全力，然后也得到了幸运的眷顾。 如果说最终这本书给了我什么收获的话，我会认为创业过程中一帆风顺是根本不可能的事情，360 是这样，BAT 是这样，网易搜狐新浪也是这样。所以，我感觉我当前的创业公司猿辅导在未来肯定也会有各种各样的挑战和困难，但是这可能就是一家企业正常的发展过程，有迷茫，也有坚持，有激动，也有泪水，真心希望能够一直和猿辅导坚持下去，一起成长。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"知识付费时代的来临","slug":"knowledge-business-model","date":"2017-12-05T14:25:20.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/12/05/knowledge-business-model/","permalink":"https://blog.devtang.com/2017/12/05/knowledge-business-model/","excerpt":"","text":"序就在前几天，喜马拉雅对外宣布其 知识狂欢节3 天卖了 1.96 亿。我想，知识付费的时代看起来真的来了。 其实我一直在思考知识付费这个类型的产品，这里面有一些产品基本上死掉的，比如分答，在行。有一些产品发展得还行，比如「得到」，喜马拉雅，极客时间，知乎 Live，网易云课堂，微博问答，知识星球，混沌大学，GitChat。还有一些新产品不断出现，比如小专栏，有书共读，一块听听。 我们拿最成功的「得到」来说吧。我之前一直看不起「得到」，说实话在行业内也有不少人黑罗胖，我自己也认为，罗胖的罗辑思维虽然给人有一些帮助，但也有一些不太客观和理性的结论，另外罗胖的个人能力天花板会极大地限制他输出的内容数量和质量。所以我自己之前一直对「得到」是一种中立偏负面的看法。 后来我发现我想错了。为什么呢？因为「得到」里面，已经基本上不是罗胖一人给大家分享知识了，它成为了一个平台，这个平台上，由各行业的专家和精英来贡献知识。这就像什么呢？我觉得这就像一个互联网时代的出版社。 「得到」的非专栏内容「得到」的非专栏内容包括「罗辑思维」和「李翔知识内参」以及「每天听本书」。这部分内容都非常轻，主要是为了吸引大家留下来。随便消费一些内容，让大家感觉到学到了一些知识，解决知识的焦虑感。 但「得到」核心的、能够让用户有可能系统性获取知识的课程，应该是「得到」的专栏。 「得到」的专栏课程「得到」的专栏课程，本质上就是一个脱离了出版行业的多媒体「图书」而已，外加多了一个时间纬度让订阅的读者有一些「服务感」。 以前我们去书店买书，现在我们去「得到」买同步出版的「图书」。颠覆掉出版社，以及通过互联网的聚光效应，会使得优质内容的收益无比大，也同时使得内容无比好。 当你能够理解「得到」本质上做的是传统图书出版行业做的事情后，你就能看出它的牛逼之处了。 首先，「得到」颠覆掉了传统图书出版行业的传播成本。在图书行业，一般的作者只能拿到 8% 的版税。而在「得到」，作者可以拿到 50% 的版税。翻翻得到的专栏，凭一个专栏一年挣上百万轻轻松松。 然后，传统的图书出版行业太过于陈旧和体制内，造成内容的生产得经过层层审核和发行。我当年的《iOS 开发进阶》从印出来到京东上架就要 3 个月。而「得到」可以用卖期货的方式卖书。一本书还没写完，给个大纲就可以开卖了。大家还能有像追美剧一样的追更新的参与感。 最后，「得到」的内容以音频为主，文本为辅，加上每期在篇幅上的限制，极大地降低了知识获取的门槛。你基本上只需要每天花几分钟，就可以跟上一本书的内容。最终，不知不觉，你就看完了一本书。 「得到」的逻辑一个出版平台刚开始最重要的是什么？当然是流量！所以在刚开始，「得到」的逻辑是吸引大 V 在平台上开专栏。大 V 其实就是自带流量的网红，这些人可以很好的让自己的流量变现的同时，也增强了「得到」的平台影响力。 但是，大家必须意识到，大 V 其实没有那么多货一直写，虽然大 V 们以订阅的形式在产出内容，但是就像罗胖自己无法一直输出更多的罗辑思维那样，大 V 们的知识输出也是有一定极限的。所以，订阅模式其实和直播一样，只是给内容增加了「时间」这个维度，让它增加了一定的实时性和参与感。 那么「得到」怎么办呢？这恰恰是「得到」作为平台的价值。它作为平台，可以推那些水平高但是本身不是大 V 的人，这些人就像当年上北京卫视的郭德纲，上最强大脑的 Doctor 魏一样，自己水平很厉害，但是需要平台来捧。 「得到」只需要派出一群有着星探一样眼光的人，找出这些黑马，然后就可以让平台的价值体现出来。而且事实上，找出这样的人比持续依赖仅有的那么些大 V 要容易得多。 知识付费产品的困境知识付费产品的困境是人性的懒。相比于娱乐来说，学习看起是一个极其反人性的事情。所以，虽然得到一直强调它是一所「终身大学」，但是真正有觉悟在这里面坚持学习的人还是偏少。 所以，如果你仔细分析「得到」的产品设计，你就会发现它一直在努力让学习这件事情不那么反人性：从罗胖最开始做的罗辑思维节目开始，得到就一直试图让学知识就像听「评书」一样让人觉得轻松又觉得有收获。包括每天听本书，也是一种快餐式的知识消费方式。得到还做了一个发现栏目，将很多泛知识也放到里面，我上次居然在里面还发现了「如何科学地预防和治疗感冒」的文章。 以上这些内容其实没有专栏内容那么深入和系统，但是却可以让人们稍微坚持下来一些。毕竟相对来说肯花 199 订阅专栏内容的人偏少。 知识付费产品的垂直化如果你仔细观察，就会发现知识付费产品的垂直化非常明显，各个领域都尝试做知识付费的平台。比如极客时间就希望做成 IT 类知识付费平台。这一类平台能成功吗？我想了很久，当前的结论如下，不一定对。 我觉得这一类的平台都可以成功。因为本质上还是看这一类的平台能否做到「平台」这个级别。要做到平台这个级别，它需要搞定两方面：一方面是高质量的内容；另一方面是愿意消费内容的用户。在初期，这两者的结合体就是大 V。大 V 通常在自己的领域本来就很有建树，同时大 V 又自带粉丝。所以，一个平台如果在初期能够搞定几个大 V，基本上就可以暂时立足了。 「得到」的立足，初期就是依赖通过「罗辑思维」节目给罗胖带来的粉丝和影响力，然后又叠加上李翔这个大 V 的影响力。罗胖明白这个是初期平台的立足之本，所以把这部分内容完全免费，以增加平台的吸引力。然后，「得到」就开始一个一个死磕大 V 了，前几个大 V 立下高收入的 Flag 之后，后面的大 V 就好谈多了。雪球滚起来之后，「得到」就可以依赖自己平台的影响力自己推网红，慢慢去掉对大 V 的依赖以及大 V 在内容持续性输出上的匮乏。 「得到」是这样，极客时间也是这样。不过极客时间的问题就是他免费的内容还不够有吸引力，付费的内容依赖的大 V 粉丝数还不够大。不可否认，朱赟和邱岳都是非常厉害的人物，但是其实极客时间更需要像李开复、Fenng、池建强这样的超级网红，通过超级网红把流量带过来，才可以放大其他人的影响力。 如果说极客时间还在努力向「得到」学习的话，那么像混沌大学这类知识付费平台，还始终停留在内容吸引人这个层面。一个视频内容几个小时，其实是非常反人性的。不过混沌大学的定位人群是那些想读商学院但是又没钱的人，所以应该还是会有用户，但是这个用户量级，很难成为一个有影响力的平台。 而知识星球则完全是一个大 V 的变现平台，我个人认为平台本身的价值还是比较小的，所以未来注定平台不可能抽取过高的分成。而像「得到」这类平台，却可以做到和作者五五分成。 未来渐渐地，人们可能会发现，知识付费其实最大的问题不是价格和内容，而是时间。每个人每天就只有那么点时间学习，而这么多海量优质内容在网上，他们需要理由说服自己，放弃一部分付费内容，购买其中非常少量的内容。因为他只要稍微多买一点，就会发现根本消费不过来。 从这个角度思考，未来知识付费的天花板还挺低的，因为知识付费平台不但得做到足够精良的内容，还需要有足够的流量来将内容推出去，还需要抢夺用户非常宝贵的休息时间。相比而言，学习又是一个比娱乐难坚持 10000 倍的事情。 不过即使这样，我还是很感谢这些知识付费 App，他们让这个世界的知识获得变得异常容易，也让那些愿意成长的人们不再受制于信息获取的障碍。 我希望他们每家都能够挣到足够多的钱，活得好好的。 推荐最后，推荐「得到」的 刘润《5 分钟商学院》课程，极客时间的《邱岳的产品手记》、《朱赟的技术管理课》，都是不错的专栏内容。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"畅销书的套路 - 读《疯传》有感","slug":"contagious-book-summary","date":"2017-12-03T12:48:17.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/12/03/contagious-book-summary/","permalink":"https://blog.devtang.com/2017/12/03/contagious-book-summary/","excerpt":"","text":"最近看完了《疯传》，作者是乔纳·伯杰（Jonah Berger），宾夕法尼亚大学沃顿商学院市场营销学教授。 不得不说，这是一本不错的书，他的观点角度和《引爆点》的作者格拉德威尔不太一样，《引爆点》主要讲的是事件流行的内部因素和外部因素，而《疯传》更加强调内部因素。在书的前言部分，作者甚至直言《引爆点》的「关键人物法则」观点是错误的，他认为好的流行事件，就是应该让普通老百姓都有传播的欲望。哇！作为吃瓜群众，我们最喜欢看这种撕逼大戏上演了！那接下来，让我们来看看《疯传》的观点是什么，到底后面还会怎么喷《引爆点》。 《疯传》接着用六章来介绍如何使传播的内容具备感染力。它把这些因素归纳为： 社交货币（Social Currency） 诱因（Triggers） 情绪（Emotion） 公共性（Public） 实用价值（Practical Value） 故事（Stories） 我把这些因素简单解释一下： 社交货币：你的内容应该易于通过社交关系传播。比如你看了文章想分享到朋友圈，这篇文章就有了「社交货币」。 诱因：你的内容应该有很多机会让大家想起来，进而谈论到。 情绪：用户谈论你的内容的时候，应该能够勾起各种情绪，例如惊喜，惋惜，惊讶等。 公共性：你的内容适合在公共场合谈论。 实用价值：内容有实际的用处。 故事：用讲故事的方式来传播内容。乔布斯在卖 iPod 的时候，不是说它是一个多么牛逼的播放器，而是讲一个「把1000首歌装进口袋」的故事。 我看完本书，除了感觉内容非常对之外，主要有两点不爽：第一点就是完全没有看到任何接力的撕逼内容，这让吃瓜群众情何以堪？另外，你讲这么多因素，我如何能够记得住？ 于是我总结了一下，其实一句话就能讲明白，这本书讲的是： 让一个人有很多机会，在公开场合，给别人兴奋地讲有意义的故事。 我给解释一下，这句话中： 「有很多机会」是指 Triggers 「在公开场合」是指 Public 「给别人」是指 Social Currency 「兴奋」是指 Emotion 「有意义」是指 Practical Value 「故事」是指 Stories 好了，六点都记住了吧？那么你就一定能设计出一个疯传的事件出来么？其实也不是，但在设计营销方案的时候，至少可以参考一下。 其实这本书设计得这么厚，但是讲这么点东西，也是为了照顾大家的 Emotion，如果我让你花 48 块钱就看这么点东西，你会理性看待这件事情吗？大部分人都不会。所以现在的书才搞得这么厚，浪费大家时间。出版社也学得特别精明，如果你仔细观察就会发现，一些字数特别少的书，出版社会通过排版，让这些书显得很厚，于是你才愿意花钱买。 一切套路都是为了符合人性。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"成长的套路 - 《复盘》读书感受","slug":"fupan-summary","date":"2017-11-28T13:08:10.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/11/28/fupan-summary/","permalink":"https://blog.devtang.com/2017/11/28/fupan-summary/","excerpt":"","text":"联想有一种称为复盘的学习方式：做一件事情，失败或成功，重新演练一遍。大到战略，小到具体问题，原来目标是什么，当时怎么做，边界条件是什么，回过头做完了看，做的正确不正确，边界条件是否有变化，要重新演练一遍。我觉得这是提高自己非常重要的一种方式。——柳传志 联想控股有限公司董事长 复盘最近读完了一本书《复盘》，里面讲了很多的故事，全书显得很啰嗦，但是理论上其实就是简单几句话：事前做沙盘推演，做事情，事后做复盘总结。 复盘的过程又分成： 回顾目标。将当时的目标和当前的现状做对比，找出不一致的地方，便于分析。 叙述过程。复述整个事情的执行过程，收集尽量多的数据和细节，便于分析。 反思原因。目标达到了或者是没有达到，为什么？自己的解释能够说服自己吗？ 总结规律。除了有总结外，还需要找有没有例子证明总结的规律。 类似的方法论其实看完了《复盘》，我已经非常多次看到类似的方法论了。 比如在 Scrum 流程中，将回顾会议设置成一个 Sprint 标准的环节，其实就是强调复盘，以便总结出一些改进团队工作的结论。 比如在德鲁克的《卓有成效的管理者》一书中，就将决策要素分成五步，而第五步就是在执行过程中重视「反馈」。而这里的复盘，就是「反馈」的一种。 比如在美国管理学家戴明（Deming）的 PDCA 理论中，将质量管理分成计划(P)、执行(D)、检查(C)、改善(A)。这里的改善，其实就是指的对检查过程中发现的问题进行总结，对于成功的经验进行标准化推广。 比如我们将产品经理的工作，分为定功能，画交互，跟项目，看结果。这里的「看结果」，其实就是一种复盘思维，看看线上的数据和自己之前的假设是否一样，以便进一步改进产品稿。 你看，虽然大家的理论不同，但是其实套路都是一样的。 是的，这就是一个非常简单的成长的套路。 程序员如何复盘对于程序员应该如何复盘呢？ 写完代码后，想想下一次写，有没有可能写得更好，更快。 改完需求后，想想下一次可不可能在架构上更容错。 修复完线上bug后，想想有没有什么质量控制方法可以尽量避免犯同样的问题。 很多人都不知道如何提高，殊不知其实任何事情，都可以用复盘的心来做做总结，不知不觉，你就成长了。 希望大家都能学会这个「成长的套路」！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"游戏和游戏化（下）","slug":"game-and-gamification-2","date":"2017-10-29T05:34:43.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/10/29/game-and-gamification-2/","permalink":"https://blog.devtang.com/2017/10/29/game-and-gamification-2/","excerpt":"","text":"广义的游戏说完游戏，我们再说说游戏化。上面我们讲的游戏，其实是狭义的游戏，在我看来，还有一种广义的游戏。广义的游戏是指：为了达成某个目标，我们在设计中引入游戏的某些元素，使得大家从人性上更容易达成目标。 举一个例子：背单词。背单词是一件非常反人性的事情。单词的记忆量大，所需的记忆时间长，为了记住需要一遍一遍地复习。市面上的背单词软件为了让大家从人性上更加容易完成背单词这件枯燥的事情，想了各种游戏化的方案。例如：在背诵时把单词的意思画成小插画、打卡机制、各种阶段性任务、任务完成之后勋章、朋友圈各种分享炫耀等。背单词和游戏其实并不相关，但是不影响它引入游戏化的元素。 如果说《游戏改变世界》一书是写给游戏从业者的，那么《游戏化思维》就是写给非游戏从业者的。《游戏化思维》一书中介绍了大量方法，可以将游戏中符合人性的元素引入到非游戏中。 游戏化实践《游戏化思维》一书的结构非常清晰。我最喜欢的是书中的实践部分。 书中提到，最最基本的游戏元素就是积分（Point），徽章（Badge）和排行榜（Leaderboard），简称 PBL。这些元素确实随处可见，例如猿辅导上课时，就会在开课，答题，下课等环节引入积分奖励，这样你就会不由自主地全程参与整个课程。流利说每次口语跟读得优的时候，就会有一个金币 +1 的效果出来，虽然金币实际上用处不大，但是这种立即的反馈让人觉得有刚刚的努力有了成效。 积分先说说积分。积分算是最常见的游戏化手段。我们说过游戏中的基本要素是目标、规则、反馈和自愿参与。积分可以很好地服务于 “规则” 和 “反馈”。举个例子，当玩家在虚拟世界中完成一个任务，立即显示出对应的积分变化。那么玩家很快就可以建立起任务完成与积分的因果关系，从而有效地评估这部分的激励。很多时候，积分还会被设计成阶段性的等级形式，或者设计成可以兑换某种奖励的可消费形式，这都给游戏的玩法增加了很多趣味性。 在书中，积分被总结成有以下作用： 为游戏要素 “规则” 服务，可以有效地计分。 为游戏要素 “反馈” 服务，可以明确而频繁的反馈，它是最详细的反馈机制。 成为对外显示用户成就的方式。 在游戏进程和外在奖励之间构建联系。 积分其实也有一些问题，最常见的问题就是它太详细和单一了。在最初帮助玩家建立起有效的规则和反馈之后，玩家对于反馈的注意力就会大大的减弱，因为每次的积分变化不会特别巨大，玩家不会因为这个产生巨大的情绪波动。所以积分通常还会附加一些别的设计，比如将积分成段，形成等级，或者为积分生成阶段性的排行榜之类，以便强化积分的效果。 积分还有一个问题，就是它其实是一种外显化的奖励。而一款游戏或者游戏化功能，其实有它内在的趣味和目标，过于外显化的奖励可能会弱化内在的趣味。 对于这一点，我有一个印象深刻的故事： 一个老人住在一所房子里，每天都有一群小孩在院子里吵闹。老人想了一个办法，他把孩子们叫过来说：我一直觉得院子里太安静了，谢谢你们过来玩耍给院子带来了生气！作为感谢，以后你们每次来我都给你们 1 块钱。于是每个孩子都高兴地领到了钱。这样过了几天，老头说，我现在经济不太行了，只能每次给你们 5 毛钱，孩子们有点不高兴，但还是接受了。又过了几天，老头说，我以后不给钱了。孩子们炸了：我们每天给你们院子带来生气，你居然不分钱不给，我们再也不来了！ 在上面这个故事中，孩子玩游戏本身的乐趣，就是被外显化的金钱给转移和弱化了。 徽章刚刚说到积分的形式过于单一和微小，而徽章则是积分的反面，徽章可以提供多样化的评价，并且每次都可以是对玩家的一个巨大刺激。 很多 App 也有徽章的设计，比如得到，Keep，我们的猿题库在答题时有可能会掉落明信片，其实也是一种徽章。徽章在设计时可以有很多变化，比如： 我们可以将徽章设计成达成某种成就时将奖励，这样徽章就可以是一种成就证明。 我们可以将徽章设计成随机掉落，这样配合全部徽章的介绍，徽章可以变成一种收集任务。 我们可以将徽章变成有奖励的形式，并且加强徽章的完成介绍，这样就徽章更像是一种任务。 我们也可以完全不介绍徽章如何获得，这样的徽章就变成了一种带有随机性和未知性的惊喜。下图是得到 App 的随机徽章。 我们也可以将同一个徽章增加金银铜或积分等级，这样徽章就变成了一种变相的等级系统。多个不同的徽章可以融合形式多种维度的等级展示。下图是得到 App 的积分等级徽章： 徽章的优点其实也暗示着它的缺点。徽章过于灵活的设计规则使得产品经理常常会过度设计规则，而过于复杂的规则使得人们理解这个规则变得不容易。而这本来就是一个游戏，如果规则还需要人们特别花精力理解的话，很可能人们就不玩了。所以，过多的徽章让人无所适从。我们在设计的时候一定要适可而止。 排行榜排行榜是一个相比积分更加明确的成就排名，玩家可以知道自己到底相对于其他玩家水平怎么样。排行榜由于是玩家之间的对比，所以相对于刚刚提到的积分和徽章，排行榜更能增加竞技性，而这种竞争带来的刺激会激励玩家更加努力。 我们小时候各个班级都会评小红花，发流动红旗，而且会在学校最醒目的黑板上公开各个班级的情况。这种竞争极大地激发出了大家的班级荣誉感，使得班级上很多团体活动能够团结一致，共同合作。 在游戏中，排行榜过于稳定也是一个问题，所以有些游戏会想一些办法，比如：设计按日排名的排行榜，设计让你看到你自己的名次的升降数以及相邻排行的人。 排行榜或许也是 PBL 中最难以设计的一个元素。因为有人排在前面，就有人排在后面。一个设计不好的排行榜，可能让普通玩家感受到目标的遥不可及。还是拿学校举例，虽然成绩排行榜对学生的学习有一进促进效果，但如果一个同学总是排在班级的最后几名，那么对他的信心打击将是巨大的。如果每个人都在认真地学习，那么排行榜对于前面几名的激励有限，但是对后面几名的打击却巨大，所以还不如没有得好。 在本书中，作者提到一些研究表明，商业环境中单纯引入排行榜通常会降低绩效。这也是为什么互联网公司的绩效排名虽然几乎每个公司都做，却通常不会面向所有员工公开的原因。 动力、机制与组件刚刚聊到了 PBL，其实是一些游戏化的组件，而这些组件其实有很多很多。比如书中就列出了：成就、头像、徽章、打怪、收集、战斗、内容解锁、赠予、排行榜、等级、点数、任务、社交图谱、团队、虚拟商品等。 而机制方面，书中提到了挑战、随机机会、竞争、合作、反馈、资源获取、奖励、交易、回合、获胜状态。最上层的动力是：约束、情感、叙事、进展、关系。 整体动力、机制和组件的关系是一个金字塔一样的关系，如下图： 可惜的是，这虽然有助于我们理解游戏化元素的理论层次，但并不足以帮助我们设计出更好的游戏化方案。 实践为了设计出更好的游戏化方案，作者提出了他的一套流程方法论，即： 明确商业目标 划定目标行为 描述你的用户 制定活动周期 不要忘记乐趣 部署适当工具 前三步属于搞清楚游戏化的目标和对象，后三步属于执行设计方案时注意的要点。 就我自己来看，互联网的游戏化设计更像是一个参考、设计、讨论调整的过程。我们首先参考游戏或者别的游戏化 App 去分析现有产品的设计方案，然后我们着手自己产品的特点和用户，设计自己的方案，最后是讨论和调整这个方案。最终方案上线后，我们还可以进一步收集分析数据来评估方案，然后做进一步的讨论调整，再设计的工作。 案例因为上一节讲到，我们的实践偏案例形式，所以我这里给大家分享一些我看到的游戏化不错的案例。 我录制了几个案例视频： 流利说的积分示例。它结合声音，很好地实现了积分的立即反馈效果。这种小奖励需要口语得分 85 分以上才行，所以用户不自觉就会把每一句跟读尽量读好。视频示例 流利说对话中模仿游戏中的 “连击” 效果。让人不由自主希望继续优异表现。视频示例 猿题库的排行榜。利用每周更新的个人榜和学校榜来激励大家竞争。视频示例 小猿搜题 24 点游戏的积分，等级和排行榜。排行榜以日榜为主，加强变化的可能性。示例 得到 App 的徽章系统。融合了积分，等级的星级勋章，以及融合了任务，奖励，收集和一点点神秘的成就勋章。视频示例 keep 的用户等级，融合了积分、等级、特权。视频示例 也有一些我觉得做得不好的案例，比如我就对 “签到得积分” 这个产品形式非常不看好。因为签到本身并没有与 App 的功能紧密结合，得到的 “积分” 大多也就变成积分商城的一些实物奖品，这也没有与 App 的功能紧密结合。这种强行植入的游戏，很难让人坚持下来，即使有人坚持下来了，他也并不是你的 App 功能的忠实用户，而是你的奖品的忠实用户，而你的奖品是要你自己花钱提供的，一旦你的奖品没有吸引力或者不容易获得，用户就会流失。 小猿搜题在 2016 年曾经设计了这种失败的签到得积分功能，最后证明是非常失败的，几乎没有人能够坚持下来，对整体应用数据的影响微乎其微。 好的签到功能应该是与 App 本身功能紧密结合的，例如：英语流利说里面完成规定时长的口语练习才能在当天 “打卡”。打卡成功的奖励也应该与 App 本身紧密结合，比如可以解锁一些高级功能，或者获得一些虚拟的勋章或排行榜荣誉。 但是我们看市面上，还是有大量 App 采用了这种脱离 App 本身功能的游戏化设计。比如高德地图，某竞品 1 和某竞品 2。稍微好一些的，会把签到积分与任务系统结合，至少使积分的获得与 App 相关，比如优酷和爱奇艺。相关截图见：示例 总结游戏化的产品设计符合人性，应该是每个产品经理都应该学习的设计思路。在实践上有积分、徽章、排行榜等常见的形式。整个游戏化的方案应该具备游戏具备的目标明确、规则易懂、反馈及时以及自愿参与的特点。游戏化的方案应该符合产品的最终目标，不应该为了游戏化而游戏化。参考案例以及反复迭代打磨是我认为最简单实际的游戏化实践的方式。 愿大家玩得开心。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"游戏和游戏化（上）","slug":"game-and-gamification","date":"2017-10-11T13:55:42.000Z","updated":"2024-01-06T14:52:37.932Z","comments":true,"path":"2017/10/11/game-and-gamification/","permalink":"https://blog.devtang.com/2017/10/11/game-and-gamification/","excerpt":"","text":"引言最近看完了两本书：《游戏改变世界》和《游戏化思维》。前者是讲游戏的，后者是讲游戏化的。 《游戏改变世界》的作者简•麦戈尼格尔 (Jane McGonigal) 认为游戏不但好，而且建立了相对于真实社会的一种“平行宇宙”，进入游戏其实就像进入了另一个社会一样。所以本书的英文名更为贴切，叫：《Reality is Broken》。作者从头到尾都在夸游戏中的社会是如何如何好，现实是如何如何让人沮丧。 《游戏化思维》从另外一个角度来讲游戏：主要是将游戏中的一些元素融入到非游戏中，使得人们更加轻松地完成一些现实中的任务。 我们先说游戏吧。 游戏《游戏改变世界》认为所有游戏都有一个决定性的特征：目标、规则、反馈系统和自愿参与。前三者比较好理解，最后一项自愿参与：要求所有玩游戏的人都了解并愿意接受目标，规则和反馈。这一条其实建立了玩家的安全感，保证玩家把游戏中的高压挑战当作愉快的活动。 《游戏改变世界》将游戏世界对现实世界的改造比喻成“补丁”。在书中，作者一共介绍了 14 个补丁，用于描述游戏世界相对于现实世界的优越性。 但是，我觉得作者的解释过于拖沓，并且没有重点。其实游戏世界相对于现实世界的最最核心的理由是：游戏世界构造了一些机制，使得玩家一直处于一种心流（flow）的状态。所谓的心流，是指游戏构造了一种合适的难度，这种难度使得玩家一直处于自己可以在能力上“够得着”的状态。在书中，这种状态被称作：”个人最优化的障碍”，这种状态可以让人始终产生成就感。 这种持续的成就感很快就会让人上瘾。上瘾之后，游戏会加大难度，使得大家为了再次体会到类似的快感欲罢不能。我们来看几个例子。 俄罗斯方块恐怕是最简单又让人上瘾的游戏了。在游戏的刚开始，一切操作速度都很慢，玩家很容易适应游戏的节奏。然后俄罗斯方块通过各种即时反馈，让人们感觉到”正反馈“。比如随时在增加的分数，消除掉多行的快感，于是人们觉得”有点意思“。但是这种心流状态很快随着熟练就丧失了，于是游戏的难度加大，你不得不集中精力来处理快速下落的方块，最终你输了，虽然有所遗憾，但是你得到了历史最高的分数。于是你顾不得休息，又开始了新一轮的尝试。 最近流行的游戏王者荣耀也是这样。如果你也玩王者荣耀，并且是iOS平台的玩家，建议你尝试拿个Android手机重新玩一次，由于苹果的限制，在王者荣耀中iOS和Android 手机并不能互通角色。然后你就可以重新体验一次游戏的整个生命期。 我玩了大概半年的王者荣耀，一次偶然的机会，我拿起身边的一台 Android 测试机重新登录了一个新号。于是我立马发现了王者荣耀为新手构建了一个异常强大的”个人最优化的障碍”。在我用 Android 重新玩的那几天，王者荣耀为我模拟了一个非常舒服的比赛环境，我在游戏中把把拿 MVP，几乎没有输过。我突然想到，我在 iOS 平台刚开始玩黄忠的时候，基本上每次都赢，但是之后才发现黄忠其实被很多英雄相克，我很好奇，在相当长的几个月中，我都没有遇到过一次黄忠的克星。 所以，我几乎可以肯定的是：王者荣耀为玩家构建了一个相当长时期的保护期。在这个保护期内，你就如同进入了 iOS 的沙盒环境，所有的对手都是为你特别准备的，刚好够让你杀个痛快还有一点挑战。我有一次细心观察了一下，对手有一个走位明显就是机器人。我才一下子明白了，原来这个环境竟然是虚拟的。 所以大家就可以明白了，为什么有那么多妹子喜欢玩王者荣耀，其实游戏玩得好的女生非常少，但是王者荣耀的”个人最优化的障碍”机制，使得很多陪练参与其中，真实的玩家得到了极大地鼓励。当然，你如果一直这么玩，难道水平就不会有涨进吗？答案是肯定的，这就像《异类》中提到的那些成功人士一样让人羡慕。 在《异类》中，作者分析发现那些各种所谓的天才，其实只是比别人更加早完成 10000 小时练习而已，而他们的坚持动力，很大程度上都来自于刚开始比别人稍微强一点点，这稍微一点点的优势，成为了他的激励和成就感来源。这其实就是真实社会的”个人最优化的障碍”。在书中印象最深的是加拿大冰球队队员大多集中在 1 月份的例子： 加拿大冰球队按年龄分组所依据的分界线是 1 月 1 日，即从 1 月 1 日到当年 12 月 31 日之间出生的球员将会被分在同一组。也就是说，一个 1 月 1 日出生的选手，是在跟许多年纪比他小的队友争夺晋级权。 而年龄大几个月而显现的微弱优势，会在孩子的成长过程中不断积累，最终引导孩子走向成功或不成功，自信或不自信的轨道中，其影响会延伸许多年。 社会学家罗伯特·默顿援引《新约·马太福音》，把这种现象叫作 “马太效应”。“凡是有的，还要加给他，叫他有余；没有的，连他所有的，也要夺过来。” 成功者，换句话说，就是获得这些特殊机遇的人，他们因此最终取得了更大的进步。 我们脑洞一下，如果整个人类社会都是虚拟的，然后整个社会为了某个真实玩家而构建”个人最优化的障碍”，例如让你每次努力和别人比赛的时候都能赢。每次成绩都获得家长、同学、老师的肯定。当然，给玩家刻意构造几次挫折和失败也是必要的。然后社会再给这个玩家各种千载难逢的机会。最终这个人从虚拟社会中”毕业“的时候，他会不会在各个需要后天培养的地方都达到我们理想中的标准？我觉得答案是肯定的。 这个设定在各种科幻题材的作品中常常看到。比如经典的电影《黑客帝国》，人类就生存在一个机器构造的虚拟世界（电影中叫Matrix）中。在美剧《Rick and Morty》的第一季第四集，也脑洞了一个完全虚拟的世界（下图）。 需要注意的是，”个人最优化的障碍”并不意味着一定要让玩家通关。在玩家对于游戏熟悉之后，通关并不是最爽的，相反，不能通关反倒是让人欲罢不能的事情。 国内的火爆游戏“天天爱消除”，其实就是让你一遍一遍不能通关，让你产生反复尝试的动力。最终有些人买了道具通关了，其实他的乐趣也结束了。“王者荣耀”也是这样，最终人们会陷在游戏给他的一个几乎不能完成的目标里面不能自拔，但是自己还乐在其中。 其它因素当然，一款游戏光有”个人最优化的障碍”也是不够的，书中介绍的清晰的目标和规则、即时的反馈、低成本的失败压力、多人协作等元素，也是游戏成功必不可少的环节。 “个人最优化的障碍”的实现相对来说是有很多套路的。但是游戏的目标和规则却是真正比拼创意的事情。很多成功的游戏都开创了一些新的玩法从而成功。“王者荣耀”将 PC 时代的 DOTA 成功简化到手机上，优化掉各种装备购买，补刀等逻辑，这里面肯定花费了大量精力来做可玩性的设计。 单单是一款游戏里面的各种参数值，都会对游戏产生致命性影响。高中时我玩过一个 PC 网游叫“决战”，那款游戏的失败之处就在于法师的数值远高于别的职业，造成游戏完全没有平衡性可言。所以游戏开发里面专门有“数值设定”这个职位，他们的工作就是一遍一遍地调整游戏参数，使得整个世界的平衡性得以保证。 小结总结一下，一款成功的游戏都有着”个人最优化的障碍”作为基础，在这之上，通过清晰的目标和规则、即时的反馈、低成本的失败压力、社交元素来构建出一个让人上瘾的环境。 更新(2017.12.04)非常有意思的是，当本文在博客上发表之后，我的一个同事转给我一篇文章，上面介绍了 EA 公司申请的「动态难度调节」（Dynamic Difficulty Adjustment）专利。文章是这么介绍这个功能的： 当玩家的表现不尽如人意的时候，游戏会自动降低难度，让游戏变简单；当玩家表现神勇的时候，游戏又会调高难度，让游戏充满挑战——早在 1986 年，「红白机」FC 上的飞行射击游戏 Zanac 就曾引入过「动态难度调节」系统，当玩家 Game Over 的次数越多，游戏难度就越低。后来，《求生之路》（Left 4 Dead）、《生化危机 4》上也都采用过类似的系统。 这，不就是我们说了半天的“个人最优化障碍”么？","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"我理解的 ICO","slug":"talk-about-ico","date":"2017-09-02T15:07:20.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/09/02/talk-about-ico/","permalink":"https://blog.devtang.com/2017/09/02/talk-about-ico/","excerpt":"","text":"最近新闻上 ICO 很火，出于好奇，我研究了一下 ICO，分享一下我的看法。 什么是 ICO首先我们需要搞清楚 ICO 是什么。网上有一句很混蛋的话：「看懂 ICO 的都忙着挣钱去了」，好像这个事情多么难懂。但随后研究下来，我觉得 ICO 并不复杂。稍加分析，我们很容易就能理解它是什么。 我用 Google 查到了一个 ICO 的中文解释，我们先看看，稍后再分析一下： ICO（全称 Initial Coin Offering，首次代币发行众筹）就是区块链界的 IPO，一般是指区块链相关的初创项目在 ICO 平台上发行该项目独有的加密代币（对应 IPO 中的股票），投资者则使用数字货币（如比特币、以太币）购买该项目的代币，实现募资。投资人手中持有的代币代表其持有的股权份额，随着项目成果落地，这些代币作为交易媒介和权益的价值也不断提升，并且可以转让。 好了，我们再来分析一下这个定义。 交易的计价货币及影响在定义中， ICO 必须使用数字货币购买。这种设计其实是增加了代币价格波动的风险，因为很多数字货币（包括比特币）本身价格就不稳定。ICO 基于一个价格波动剧烈的货币之上，自然就会受到相关数字货币的波动影响。而如果以法定货币（比如人民币）来交易，明显可以避免这种风险。 那么为什么 ICO 要选择数字货币呢？我个人认为是为了规避各种金融机构的监管。在中国以及一些别的国家，如果将 ICO 视为股权众筹或者证券发行，理应有证监会监管；但是 ICO 募集的资金不是法币而是数字虚拟货币，数字货币又应该由央行监管。ICO 这样的规则使得在中国可以规避掉监管主体，所以才会滋生出各种非法集资的现象。 在规避监管主体的同时，ICO 也规避掉了相关的监管法规。股权众筹或者证券发行其实有大量的法律存在，比如国内有《中国证券投资基金法》，这使得大家在做事情的时候有规则可以依据。但是 ICO 这种机制使得它可以随意制定自己的规则。 例子举个例子： 如果我通过 ICO 发行一批代币，规定一年之后以 10% 的利率回购。那么我其实是发行了一个年化收益 10% 的债券。如果我允许在回购之前大家可以交易这个代币，那么相当于做了一个可交易的债券。 如果我不承诺回购，但是承诺以后可以分红，也可以交易，那么我其实是发行了一个类似没有投票权的股票。 我也可以把 ICO 发行的代币承诺为公司的股权，那么其实我的行为就类似于股权融资了。只是这个代币无需等待公司上市就可以随意交易，同时也规避了国内对于未上市公司股东数量的限制。 我也可以不承诺任何的分红，也不承诺代币持有者的股东身份。那么代币的价值完全就和企业的业绩无关了。按理说这样的 ICO 应该没有人买才对，但是追捧的人其实并不少。 下面我们看一个实际的 ICO 项目：PressOne。 PressOne 项目在比特币名人李笑来的 ICO 项目 PressOne 的介绍上，我没有看到任何对于该项目的代币持有者所具有的股东权利的描述，只看到一个暂定的可转账交易的时间：2018 年 7 月 12 日。见：https://press.one/pub_cn 。 在分红权利上，PressOne 只介绍了 40 亿枚代币投资的项目有收益分红（下图）。而 PressOne 本身公司的经营收益如何分配，并未提及。 在该项目的代币权利明显较弱的同时，2 亿美元的融资额却远超大多数国内的上规模的创业公司。我所在的猿辅导公司估值 10 亿美金，但是到现在的融资最多一次也只有 1.2 亿美元。 有人说你是不是看着别人融资额比你高眼红，所以才写这样的文章？其实不是的。 我看了李笑来的那个项目，说实话我还挺感兴趣。我也很喜欢李笑来的书，我也相信李笑来不会主观恶意骗大家的钱。我只是觉得，市场对于这种事情太不理性了。对于一个只有概念的想法，给出一个定价超高，没有股东权利的融资方案，虽然说买卖是一个愿打一个愿挨的生意，但是稍微有点风险意识的人，应该看出这样的项目其实风险非常高。 就连李笑来本人可能都认为投资者太疯狂了。在 PressOne 的官网上，没有项目的详细白皮书，但是却有关于该项目风险的明确提示。另外 PressOne 还提供了一个开放 24 小时的退出机会。我相信李笑来也希望 PressOne 的投资者是理性的，有风险意识的，这样对于项目的成功和失败才会更加坦然，而不是抱着投机的心态。 ICO 规则的灵活性风险大家看到了，由于 ICO 规避了相关法规，又可以极大地随意制定规则。如果你愿意发挥想象力，或许你还能设计出具有 “传销” 规则的 ICO 发行方案。这样的事情在完全没有监管下发展，实在不可能有什么好的结果。 由于 ICO 的规则变化灵活，对确定监管主体和相关法规带来了难度。在国外，美国和新加坡都将 ICO 采取逐案评估的办法。而在中国，由于是新事物，国家的政策没有出来。但是至少我们可以看到，近期国家已经开始相关的监管工作了：一场本应于 9 月 2 日召开的区块链盛会被有关部门叫停，与此同时 ICOINFO 宣布暂停了 ICO 业务，比特币中国暂停 ICOCOIN 交易： 另外，据财新的报道，ICO 被监管认为是变相的非法集资。 事情的发展看起来越来越明显了，国家显然也看到了 ICO 带来的风险，并且希望加强监管，我相信相关的法规会很快出台。 总结总结说来，ICO 就是企业为了筹集资金，在 ICO 平台上发行以电子货币交易的代币。代币可以制定灵活的交易锁定期，分红权，投票权，回购权。由于缺乏监管，所以容易滋生非法融资行为。代币的交易基于区块链技术，所以非常安全和方便。 ICO 在中国缺乏相关法规，亟待引入监管，以避免鱼龙混杂的情况。 参考链接 Initial coin offering ICO，披着金融创新的币圈传销？监管刻不容缓！ ICOINFO 官网 PressOne 官网","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"711 的成功之道 - 读《零售的哲学》","slug":"the-tao-of-711-summary","date":"2017-08-20T01:35:38.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/08/20/the-tao-of-711-summary/","permalink":"https://blog.devtang.com/2017/08/20/the-tao-of-711-summary/","excerpt":"","text":"这周读完了 711 创始人铃木敏文的自述图书《零售的哲学》，分享一下我的读书心得。 我发现铃木敏文做生意的方法论特别简单，整本书其实讲的道理就几个，只不过反复讲。读完整个总结下来，作者想表达的就只有几点： 搞明白问题的本质。 执行上做到极致。 把心理学融入到商业中。 主动寻求变化。 遵循“假设-&gt;执行-&gt;检验”的步骤来做尝试。 下面我就分别总结书中的以上观点。 搞明白问题的本质铃木敏文从第一章开始，到最后一章结束，都在贯穿他的反对轻信常识的观点。本书的第一章叫做「一切从“打破常识”开始」,最后一章叫做「打破“常识”」。可见“常识”是多么的有误导性！在书中，铃木敏文介绍了多次他打破“常识”，发现问题本质的例子。 比如，在决定经营 711 便利店时，当时日本的小型商店经营得非常惨淡。普通人认为是大型超市挤压了便利店的生存空间，当时确实 711 的母公司伊藤洋化堂在大型超市上很挣钱。但是铃木敏文认为小型商店的关键问题是：1、生产效率低下 2、没有差异化的竞争点。他认为解决了这两个关键问题之后，便利店是有很大的机会的。 为了解决这两个关键问题，711 实施了：1、密集选址战略 2、构建产品研发与供应的基础体系 3、注重与员工的直接沟通。第1，2点解决了小型商店的生产效率问题，而第3点持续产生一线的数据和想法，有利于构建差异化的竞争方案。最终成就了 711 成为了一家全球成功的便利店。 在决定收购 711 原本的品牌授权方：美国的南方公司时。铃木敏文同样洞查出了南方公司失败的本质：他们没有构建出有竞争力的主营业务以及美国社会产品结构的变化。随着收购后对美国公司实施单品管理、物流配送改革等措施后，很快就有效果了。 铃木敏文在书中讲看清楚本质的故事很多，也讲了很多他自己的分析，但是如何能够看清本质？对于这个问题，他并没有这方面详细的方法论。书中有一些经验似乎是不太好借鉴的，比如他喜欢通过广播大量地收集信息，喜欢开会演讲。当然也有一些是可以学习的，比如他总是会亲自到 711 店里面去体验商品和购物流程。 我自己认为，要搞明白问题的本质需要做到 3 点：1、有效的信息获取。2、适当的讨论。3、独立的思考决策以及检验。这点有机会再展开论述。 执行上做到极致铃木敏文在书中的很多做法显示出他是一个“不计成本”的人，他经常为了一个理念，花几年时间来做一件事情。几年时间啊！一件事情从 0 到 1 得花费几年时间，对于大多数公司都是不可接受的。而他愿意坚持做这样的事情。在书中，他介绍了 711： 为了采取全年无休的经营方式。花了两年，才说服山崎面包在假期供货。 为了在便利店中提供 ATM 取款服务，在和别的银行谈判无果的情况下，花了两年独立申请银行服务牌照。 为了让炒饭的口感有“大火爆炒”的传统口感，花了一年八个月的研发。 为了解决中国人喜欢吃热菜的习惯，同时符合中国政府食品安全要求，研发出中央厨房配制，无需明火就可以在便利店简单加热售卖的现煮食品。当然，这一方法很快被所有中国便利店「借鉴」了。 我看完书后，倒不认为铃木敏文是光有匹夫之勇的人，他能够判断一件事情成功的收益巨大，所以愿意在研发阶段投入足够多的时间和人力成本。而对于大部分事情，确实也并不存在一定搞不定的情况。投入了足够多的精力，通常都可以找到一定的解法。 把心理学融入到商业中这部分内容，铃木敏文举的最成功的例子，是让商店返还 5% 的消费税的形式，代替原本让消费者麻木的降阶促销。这两件事情看起来本质上都是降价，但是返还消费税的形式迎合了顾客的情感诉求，令他们在心理上更容易接受。 主动寻求变化因为时代不停在变化，当市场环境变化时，原本的商业形式如果不做变化，那么就可能面临失败。铃木敏文说：711 是一家不断主动做出改变的公司。他确实在不断调整经营的方案，甚至不反对“朝令夕改”。书中的第六章的标题赫然写着：经营理应“朝令夕改”。 由于主动寻求变化，711 做出了很多有先见之明的事情，例如推出送货上门服务，增加网络购物，针对日本的老年人提供送餐服务等。 主动寻求变化和刚开始说的搞明白问题的本质其实是衔接在一起的，我们在搞明白问题的本质后，不能把这件事情就归为结论了。而是应该随着时间变化，不断地反复思考当时的结论是否仍然成立。很可能市场变化了，结论也就变了。 遵循“假设-&gt;执行-&gt;检验”的步骤来做尝试“假设-&gt;执行-检验”其实和精益创业中提到的 MVP（最小可执行产品）类似。在我们寻求变化，发现新的问题后，应该在小范围内尝试解决他。711 的很多尝试都是先在几家便利店中试行，然后再全国推广。这种最小风险的尝试，有利于公司大胆地试错。 总结如果拿一句话来总结，711 的创始人铃木敏文的经营哲学就是：主动观察市场的变化，在搞清楚问题的本质后，做到极致的执行，在执行过程中利用 MVP 来试错，并且融入心理学知识。 听我总结不如自己买来翻翻，推荐给大家~ 以下是该书的思维导图。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"游戏化学习的典范 - 玩《Human Resource Machine》","slug":"human-resource-machine-game","date":"2017-07-23T09:02:35.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/07/23/human-resource-machine-game/","permalink":"https://blog.devtang.com/2017/07/23/human-resource-machine-game/","excerpt":"","text":"游戏介绍最近一次和美团的朋友聚餐的时候，一个朋友向我推荐了这个《Human Resource Machine》游戏。仔细一看才发现这还是苹果的编辑推荐 App，售价 30 人民币。于是我当时就下载了，这个周末刚好有时间，就仔细玩了玩。 一玩起来我就停不下来了，这个游戏的整个玩法是让玩家编写汇编语言的程序来通关，但是作者居然把枯燥的汇编语言变成了非常有意思的挑战关卡。运行过程中的游戏主角异常生动，让你感觉到了创造和指导主角的「上帝感」；与此同时，游戏考虑到大家学习汇编语言的难度，从最简单的无条件跳转开始，一步一步引导你学会用汇编语言来实现 if 判断、for 循环、字符串的存取、除法指令、取模指令、指针操作。下图是我在玩「质因数分解」关卡的运行过程。 最终你发现，你竟然可以用游戏提供给你的仅有的 10 多条汇编指令，实现复杂的排序、质因数分解，完成复杂的逻辑的时候，你理解了这个世界上所有编程语言的本质：那就是靠仅有的几十条汇编语言来构建复杂的逻辑。 应该说，这个游戏还是挺难的，游戏最终的几关，汇编代码量已经有 50 行了，在手机上仅靠拖拽来管理源码，并且没有模块的情况下基本已经快到极限了。另外，最后几关涉及的关于字符串存取，指针的操作技巧，排序算法，如果没有学过相关知识，自己靠聪明才智自己推断出来还是有些难度。游戏的 RPC 似乎也意识到了这一点，示意大家要学会「翻阅资料」。 于是，这个游戏就成了一个最好的汇编语言学习的配套练习。玩家通过游戏入手，在遇到不懂的知识的时候查阅专业的书籍。当游戏通关的时候（只要不是作弊），玩家就已经完全掌握汇编语言，那么就有能力通过相关的考试，获得相应的学分或认证。 游戏化学习游戏化学习一直在业界居于探索期，我一直觉得游戏化学习在高年级不太可能行得通，因为游戏化学习如果过于注重游戏性，可能会给学习效率带来冲突，但是这款游戏给了我很大的震撼。 如果一款学习游戏，能够给人合适的挑战难度，让玩家持续的获得激励，享受到挑战的成就感。同时又能像这款游戏这样，用丰富的交互细节给人真实感和信息量，让玩家通过游戏细节获得更加丰富的知识，那么确实游戏化学习可以颠覆掉原有的枯燥学习过程。 好的游戏激发人们探索和追求极限的欲望。这款游戏在很多地方让大家「翻阅资料」，使得大家为了通关可以学习到更多相关知识。另外，这款游戏对于每一关，都设置了额外的挑战目标：让你追求代码的精简或者运行效率，最终即使你通关，你也会为了额外的挑战陷入其中苦苦探索（如下图）。 小结总结一下这款游戏的设计特点： 通过关卡难度设计，持续的激励玩家 丰富真实的交互体验 鼓励查阅资料，通过延伸阅读来通关 额外的附加挑战","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"如何戒掉王者荣耀","slug":"how-to-get-rid-of-games","date":"2017-07-09T14:36:53.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/07/09/how-to-get-rid-of-games/","permalink":"https://blog.devtang.com/2017/07/09/how-to-get-rid-of-games/","excerpt":"","text":"序王者荣耀最近火了，不，应该是说火了好久了。我自己也玩了几个月，排位赛打到铂金 V，等级打到 29 级。不过我最近几个月戒掉了，如果你刚好也想戒掉，可以看看我的经验。 意识层面的工作要戒掉王者荣耀，首先需要从意识上辨别它的危害。基本上，除了职业战队，大部分人玩游戏都是为了娱乐，就是开心。但是，其实现在大多数的游戏设计出来不是让人开心的，而是让人沉迷的。 让人开心和让人沉迷差别巨大。让人开心的事情结束后，你通常会感觉到很舒服和满足，然后稍微有些留恋和不舍。而让人沉迷的事情结束后，通常都会带来失落和不舒服，就像上瘾了一样。 举个例子，看电影，旅行，享用美食就是让人开心的事情。大家经历这些事情的时候很开心，事情结束后，虽然有留恋，但是谈不上不舒服。而游戏某些时候就像吸烟一样，不玩就会让人特别不舒服。 当你明白游戏设计者的动机是让你上瘾进而挣钱的话，你可能就不会那么开心了对吧？而且作为程序员，我们的工作从来都是设计和控制程序的行为，现在却被别的程序控制，从心理上大家也应该不太情愿吧？ 王者荣耀还有一点麻烦的是：它的游戏模式属于即时对战类的，这类游戏玩起来必须全神贯注。所以，你会忽略所有游戏之外的事情。最容易受伤的可能就是家人和朋友吧。在家里玩很可能被家人批评，在朋友聚会时玩很容易被认为不愿和大家交流。这些最终会让你感觉到不舒服，感觉被游戏控制。 行动层面的工作光意识到危害还不行，还得有能戒除王者荣耀的手段。这里分享一下我的一些办法。 沉迷游戏通常是由于自己还是有一些空闲的时间，所以想戒掉王者荣耀，首先需要给自己的这些时间做好合理的安排。当你有 side project 的时候，那么你就不舍得把时间都浪费在游戏上了。 对于我来说，我分析下来，感觉自己可以有很多可以做的事情。比如写一些总结文章，我的读者一直比较多，写文章可以收获不少阅读量和读者反馈带来的成就感。又比如看书，今年我其实希望多看看管理学和炒股的书，把时间花在这些上面有意义得多。又比如看看美剧和电影，我买了爱奇艺的会员，单从娱乐来说，看美剧和电影带来的沉迷要小得多，而且顺便还可以练练英语听力。 总之，你首先需要规划好自己的空余时间，不管是看电影，看综艺节目，或者学习，健身，逛街都可以，只要你觉得有成就感或者有意思，否则无聊会把你重新拉回游戏的世界中。 规划好自己的空余时间之后，你需要的第二步就是：卸载你的游戏。王者荣耀体积很大，卸载掉重新安装很花时间，这会帮助你戒除它。 你可以选一个好的时候，在某个打玩王者荣耀的深夜，你玩得筋疲力尽，但是一直都在输，你想起因为玩游戏耽误了好多事情，乘这个机会赶快把应用卸载掉吧。 如果你用了上面两步还没有戒掉，那可以试试第三步：你把所有的符文都卖掉再买再卖，直到把钱用光，把所有的金币都买自己永远不会玩的英雄，恶意加入游戏然后骂队友并且直接退出，把自己的信誉分搞成 0 分，删除所有的游戏好友关系，退出游戏的战队。基本这么搞完之后，你估计也没兴趣玩了， 我为什么要玩它我为什么当初要玩呢？原因挺多的。首先我其实挺想学习一下好的游戏的设计的。推塔游戏的鼻祖应该是 DOTA 吧，王者荣耀把 DOTA 简化到可以直接在手机上操作，在产品设计角度还是非常牛逼的。另外我年初身体不太好，晚上常常胃疼，游戏可以让我暂时忘掉身体的不适。最后就是王者荣耀吸引了很多小学生用户，我们公司的 App 是面向小学生的，我希望在做用户访谈的时候，和小朋友们有一些共同语言。 顺便说一下，王者荣耀这类竞技类比较强的游戏，其实新手很容易由于玩得不好而没有成就感。王者荣耀为了让新手能够持续玩，设计了大量的细节，其中一个就是在对战的时候，有机器人假装成你的对手输给你。基本上可能让你在游戏的前几天收获满满的成就感。 结束语王者荣耀是一款优秀的游戏，但是我们无论如何也不应该被游戏控制，让它影响我们的生活，工作，家庭对吧？ 是时候戒掉它了。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"了解企业的数据指标 - 读《一本书读懂财报》","slug":"understand-financial-report-summary","date":"2017-06-26T14:24:53.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/06/26/understand-financial-report-summary/","permalink":"https://blog.devtang.com/2017/06/26/understand-financial-report-summary/","excerpt":"","text":"前言《一本书读懂财报》是一本经典的财经类读物，作者是清华大学会计系主任肖星。全书用语通俗易懂，非常适合用来入门。 我之前说过我希望通过炒美股来学习了解一家公司或者行业，而学习读懂一家公司的财报应该是这个学习过程的第一步吧，正好我的老大郭常圳推荐了这本书，所以我就仔细读了几遍，在这里分享一些总结。 三张报表一家公司的财报主要是由三张表构成，分别是资产负债表、利润表、现金流量表。 资产负债表企业主要的任务是给股东带来回报，简单来说就是赚钱。除了赚钱以外，经营企业还有一个最基本的要求，就是保证股东投入的本金不会遭到任何损失。我们必须要知道，本金现在都成了什么，它们现在的价值如何，是不是还保持着原来的价值。因此，我们就需要有一张能描述这些问题的财务报表，这张财务报表就是资产负债表。 资产负债表是企业的「单反相机」，它反映了企业某一个时刻的财务状况。它将企业某一时刻的财务状况分成三类，分别是： 资产 负债 股东权益 下图是书中示例的资产负债表： 可以看到这张表左半边是资产，右半边是负债和股东权益，并且左右两边的数值总和应该是相等的，即 资产 = 负债 + 股东权益。这么听起来有点不好理解，我们把负债移动到等式的左边，就好理解多了，即：资产 - 负债 = 股东权益。所以我们可以理解成：企业拥有的钱，减去欠的钱，就是这家企业归属给股东的权益。不过，如果欠的钱比资产还多，那多股东权益就是负的。 表的左边，资产包括：流动资产和非流通资产。流通资产包括现金、应收账款、预付账款、存货等。非流通资产包括：长期投资、固定资产、无形资产（专利，商标，土地使用权）。土地使用权之所以被归入无形资产，其实是因为中国的土地都是国家的，企业只是拥有一段时间的使用权而已，所以不能归成固定资产。 表的右边，负债包括流动负债和非流动负债。流动负债包括：短期借款、应付账款、预收账款、其它应付款。 所有者权益包括实收资本、资本公积、盈余公积、留存收益。 利润表刚刚说资产负债表像一个单反相机，反映企业某个时刻财务状态，是一个时点的概念，而利润表则是一个时段的概念。 利润表实际上有两个作用，即它不仅告诉企业，你现在赚了多少钱、这些钱是从哪里赚的，还使企业在一定程度上了解到自己未来的盈利状况。 下图是书中示例的一张利润表： 利润表里面有： 营业收入：这个是企业收到的钱。比如猿辅导卖课产生的收入就是营业收入。 营业成本：企业卖出产品产生的直接损失。比如猿辅导上课期间的网络带宽，老师工资。又比如实物商品的原材料采购成本等。 营业收入-营业成本=毛利，毛利要转化为净利润，还需要扣减以下支出项： 营业费用：生产和销售产品过程中的费用。比如销售人员工资，商品运输和仓储费用，广告费用。 管理费用：管理部门的开支。比如行政费用。在互联网公司，产品技术团队的开支通常也属于管理费用。 财务费用：通常是贷款的利息或者现金存款的利息等。 资产减值损失，公允价值变动收益 投资收益：对外投资所取得的净收益。 营业外收入：出售固定资产的收入，例如卖房子挣的钱。 营业外支出：罚款，地震火灾一类天灾带来的损失 以上这些计算完之后，还需要考虑营业外的支出、补贴收入、汇兑损益就得到利润总额。利润总额减去所得税，就得到净利润。 净利润就是真正经营挣到手的钱。 净利润非常重要，所以美股上基于利润的指标：市盈率（市盈率＝每股价格／每股盈利）一直是评估一支股票价格高低的重要信息。比如 腾讯的市盈率 有 50 多倍，网易的市盈率 是 20 多倍，就表示相对来说，市场更看好腾讯的股票。 现金流量表现金流量表就是一张流水帐单，它从经营、投资和融资三个角度，对现金的流入和流出进行了描述。下表分别解释了经营、投资和融资对应的现金流入和流出可能的情况。 一些分析方法同型分析。同型分析是指将各种表中的数字转换成百分比，从而找到占比较大的关键值。通过同型分析，你可以获得企业的毛利率，现金所占资产比例。 趋势分析。趋势分析是指不同时期的财务报表进行对比。比如我们可以分析一家公司每个季度财报相对于上一年的增长情况，结合一些别的数据，就可以估算出未来可能的增长空间。 比较分析。比较分析是指和行业标杆或者竞争对手比较财报数据。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"《卓有成效的管理者》读书笔记","slug":"effective-executive-book-summary","date":"2017-06-25T14:56:51.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/06/25/effective-executive-book-summary/","permalink":"https://blog.devtang.com/2017/06/25/effective-executive-book-summary/","excerpt":"","text":"前言《卓有成效的管理者》是我拜读的德鲁克的第二本书，相比之前阅读的《管理的实践》，这本书内容薄了很多，只需要一个下午就可以完全读完。虽然书不厚，但是本书中关于管理者自我效率的提升建议却是非常有用的，很多内容我都感同深受，在此写下总结，推荐给大家。 掌握自己的时间关于时间管理，书中建议先精确记录下自己的时间花费。这个办法在之前读的《奇特的一生》、《成为技术领导者》也有提到过。通过记录自己的时间花费，从而对自己的时间进行诊断，调整那些不应该花精力的事情，让自己始终高效地利用自己的时间。 这个办法我自己很早就尝试过，确实非常有用，它能让自己回答一个问题：我的时间到底都花在哪儿了？有一阵子，我感觉到每天自己都很忙，但是又不清楚到底在忙什么。通过记录时间，我很快能够找到那些能够忽视或者授权给别人负责的事情，最终我可以使得自己的时间可控，保持充沛的精力。 我在具体执行上将自己的工作分为「主动工作」和「被动工作」。「主动工作」就是我自己需要主动安排的工作，例如思考产品当前的现状，未来的规划，团队每个人的状态，团队的工作流程等。「被动工作」就是别人依赖我的，或者我必须固定时间做的工作，例如和团队成员一对一，产品稿和UI稿的评审，一些面试工作以及一些定期的会议等。 我会尽量不要让被动工作占满我的整个工作时间，让自己有时间做主动工作。很多被动工作其实可以用授权和指导来完成，一些事情只要我觉得我完全不管也可以完成得很好，我就会尽量不去管它，其实我对于团队成员来说也是一个很好的锻炼。 把眼光集中在贡献上这个观点与格鲁夫的《格鲁夫给经理人的第一课》和温伯格的《成为技术领导者》书中的观点一致。 格鲁夫认为管理应该关注的就是产出，而产出等于你做的事情乘以管理杠杆率。高杠杆率的事情都是那种使得别人工作能够更高效的事情，例如解决下属的疑问、正确的决策、调整一些有问题的流程等。 温伯格的观点更加直接，他认为所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。 本书中认为的贡献包括使专业人员的工作更高效、处理好人际关系、进行有效的会议。这些都是属于协助大家更好完成工作的事情。 充分发挥人的长处书中让我们关注于人的长处而不是缺点，虽然我们不能因人设事，但是我们也不能只设事，而不管人是否擅长你交给他的工作。 书中也强调要和上司的管理风格匹配。 要事优先这是关于工作优先级的讨论，我其实认为这是时间管理的一部分。其实我在把工作划分成主动工作和被动工作后，主动工作的时间最开始阶段就可以拿来做规划了。 有效的决策书中介绍了决策的一些方法决，其实挺简单的，就是三步：先弄清楚问题到底是什么，然后就是提解决方案，最后就是执行过程中的反馈和检验。 德鲁克把这三步又进行了细分，变成了五步，具体来说把弄清楚问题这个过程增加了一步：找出解决问题时必须满足的界限，我理解这个界限就是一些关键点。而解决方案也被细分为两步，不但包括解决方案的关键条件，也包括解决方案在执行层面上的考虑。 另外，德鲁克还强调了反对意见的重要性。 总结这本书包括的内容有：自我时间管理、关注团队贡献、人员管理、优先级规划、决策的方法论。很多内容我在别的书中都有涉及，在这一本书中再次得到了印证。一本很薄但是内容不少的书，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"我赌 ofo 战胜摩拜","slug":"ofo-vs-mobike","date":"2017-06-25T13:28:10.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/06/25/ofo-vs-mobike/","permalink":"https://blog.devtang.com/2017/06/25/ofo-vs-mobike/","excerpt":"","text":"先写下这个结论，到时候看自己牛逼还是被打脸。 今天正好微博上晒出一张据说是马化腾与朱啸虎的争论，我其实思考 ofo 和摩拜这件事情也有一段时间了，所以趁个热闹把自己的观点总结一下。 共享单车的价值我们知道，共享单车这个模式最终要成为一门生意，甭管当前多么烧钱，最终它还是需要产生价值的，这个价值当前能够看到的有： 共享单车本身的赢利能力 押金带来的资金池收益。不过听说政府在监管这部分资金，见：http://www.sohu.com/a/142611124_324659 共享单车本身对移动支付的推动 高频启动带来的广告价值 算算年化收益率这些价值里面，最最根本的还是共享单车本身的赢利能力。那我就想给大家算一笔财务帐。摩拜单车最初一辆车制造成本是 3000 元，现在它一辆车的成本不知道下降了多少，但是我感觉成本很难低于 1000 元，我估计它的成本在 1500 元左右。而 ofo 呢？因为没有 gps，没有充电板，没有通讯模块，整车的细节也尽量用传统的自行车工艺，规模化生产之后，我觉得它的成本在 150 元一辆左右。 1500 元一辆对 150 元一辆意味着什么？假设一辆车平均每天被骑行两次的话（摩拜在接受采访时说平均一天骑行次数高达5.5次，见：http://cj.sina.com.cn/article/detail/5994149274/227588?column=consume&amp;ch=9 ），每次骑行 1 元钱，那么对于 ofo 来说，它只需要 75 天即可以收回成本，而摩拜需要 750 天，摩拜 Lite 需要 1500 天。 这个数据太可怕了，因为这意味着，ofo 花 150 元投入一辆车，一年之后的收入是 730 元，年化收益率 486%。而对于摩拜来说，花 1500 元投入一辆车，一年之后的收入是 730 元，年化收益率是 48.6%，差了 10 倍。 10 倍的差距是致命的，它可以弥补 ofo 的很多问题。我们来做一个非常悲观的假设：我们假设 ofo 每辆车只有一年寿命，我们假设 ofo 每辆车不关锁或者关锁不打乱密码的比例是 20%， 我们假设 ofo 为了竞争每周末两天都免费骑行，那么它的年化收益率会降到多少呢？会降到 (750-150)*0.8*(5/7) / 150 &#x3D; 342 / 150 &#x3D; 228% ，比摩拜的收益率还是高 4 倍多。 4 倍多的收益可以怎么竞争呢？比如 ofo 和摩拜都融资到了 1500 元钱。ofo 可以生产 10 俩车，按照刚刚说的最坏的情况下，一年之后 ofo 那 10 辆车全部报废重新生产，最终还能挣 1920 元。摩拜按照最好的情况，它的车一点没坏，也没有免费骑行活动，一年之后他只能挣 730 元。 如果我是 ofo，我会把挣到的钱 1920 元中抽 1500 元投入到单车的投放上，这样第二年 ofo 的车辆数量就是摩拜的 20 倍了。剩下的 420 元我还可以做更多的商业上的竞争活动。如果一个地方，一眼望去，有 1 辆摩拜，20 辆 ofo，我想竞争可能已经结束了。 我的假设中的问题当然，我的这个推断也有一些问题。比如造车的成本，因为我不知道具体的数据，可能是 150 vs 1500，但也可能是 300 vs 1000。但是即使我们按 300 vs 1000 算，算上车辆损坏以及不关锁的各种问题，ofo 的收益率也比摩拜高。 还有一个问题是 ofo 得融到和摩拜一样多的钱，这一点我觉得也没问题，在这个赛道上，肯定有一家必须获胜，当前来看两家背后的企业都不差，所以不至于出现资金一边倒的情况。 另外 ofo 车辆的丢失率，保养成本这些应该都比摩拜高。但是这对于年化收益率来说，也应该就是打个 8 折的问题，不应该是大问题。 智能性问题最后就是马化腾提到的智能性问题。他把这个比作功能机和智能机的竞争，我觉得是非常不恰当的，首先 ofo 其实是比摩拜好骑的，另外当单车的数量到一定程度，定位找车这种场景根本就不存在了，大家会直接用肉眼找车的。另外摩拜比 ofo 方便的地方还有开锁更快和关锁不用打开应用这两件事情，但是这点优势其实并不明显。 在智能性这个角度，ofo 相比摩拜更加关注财务模型本身的健康程度，我觉得是非常对的，比如 ofo 出的智能锁，在成本和智能性之间做到了很好地平衡。我研究了一下，这个智能锁应该没有 GPS 模块，没有充电模块，仅有的就是一个 2G 卡短信通讯模块，我相信这个智能锁的造价成本应该是非常低的，可能加上卡也就 50 块钱。 ofo 的问题最后说说我担心的 ofo 的问题吧。ofo 太看重财务方面了，如果它在用人上也这么选便宜的人，那么整个团队的竞争力打了折扣，那么就真说不清楚谁最后赢了。比如说我就发现 ofo 在市场上的活动方式就非常单一，常常就是免费骑行。而摩拜就会搞各种红包之类的方式。 免费骑行这种市场推广方式是非常懒政的，因为免费骑行主要吸引的是存量用户，不是新增用户。新增用户都还没有下载你的 App，也没有你的帐号，你没法告诉他你免费了。而对于存量用户来说，你只需要让他们知道，你使终比摩拜便宜就可以了。因为你的财务模型更优，你就可以完全和摩拜对着干，摩拜不免费的时候，你就直接以摩拜单车的骑行价打 8 折做活动，让所有人知道你就是比摩拜便宜即可。这和免费骑行相比，效果差不多，但是可以收到更多的骑行费用。 摩拜应该也有财务上的压力，比如摩拜很早就开始接入广告了，然后也会搞变相的骑行优惠活动，比如随机红包，让你对红包有期待。最终摩拜可能只花了很少的钱，就达到了很大的效果。因为消费者总是有赌博心理的，即使他骑了 10 次都花了钱，只要有一次他骑到 3 元的红包，他就会觉得中奖了。 ofo 在市场的竞争上应该更加用巧劲，最终让自己的财务模型优势反映在自己对资金的需求上。这个市场最终竞争烧钱下去，如果 ofo 手中剩的钱比摩拜多，那么就和当年蘑菇街合并美丽说，美团合并大众点评一样，ofo 就有主导权了。哦，我对于赢的定义，就是 ofo 收购摩拜，当前这个资本竞争模式下，完全干掉另外一方成本和风险实在太大，收购的方式是资本方乐于见到的战争结束方式。 摩拜的问题摩拜太看重科技了，科技感固然是一个重要的事情，但是落地的方案更重要，当前科技对于共享单车的效率提升仅仅体现在开锁更快和关锁不用打开应用这两件事情上。如果摩拜不能将车辆的生产成本下降到 ofo 的 2 倍以内，那么这点效率优势并不能产生绝对竞争力。 补充本文在微信公众号发表之后，我得到了更多的评论回复，这里我再挑一些有意义的评论讨论一下。 大部分人都反馈说 ofo 的单车损坏率非常高，拿他们的话说来：“一排车没几辆可以骑的”。其实这就是我刚刚提到的团队问题，ofo 单车明显会比摩拜更高的损坏率，所以 ofo 应该在这上面花费更多的精力来维修和报废单车，而不是让它自行在路上影响用户体验。这一点上，算是 ofo 团队执行层面上的问题，也会很大程度上影响他的竞争力。 有人提到 ofo 99 元的押金是一个优势。但是我认为这同时也造成 ofo 的资金池过少。在本文在公众号首发之后的两天，ofo 就提高了押金到 199。我对此是比较认可的，因为这对于 ofo 的财务模型会更有利。即便是 199 的押金，也比摩拜要少，所以我认为对于获客的影响有限。 有人提到 ofo 没有定位会很影响单车的运营。他们没有意识到，其实智能手机在定位上可以帮助单车做很多事情。如果你仔细观察，ofo 和摩拜的 App 在 iOS 端都会要求一直获得定位信息，所以当 ofo App 打开的时候，其实已经可以通过手机获得比较精准的定位了。如果这个时候用户报车损坏，那么维修人员可以通过当时的定位，比较容易确定单车的位置。另一个使用定位辅助运营的方法是统计用户出行数据和在高峰期挪车，这些都可以简单地通过 ofo App 来做，而不需要一定通过单车本身的 GPS 定位来做。可能有一些用户会说 Android 有一些智能手机定位没那么准，其实这关系不大，因为不管是报错还是统计，只需要有一定的样本量就可以了，所以缺失一些数据并没有什么影响。 有人提到科技感这个词。我想我的读者大部分是 iOS 开发者，技术人员对于科技内心深处的认同是很容易理解的，我还是希望更加客观地评价摩拜在科技上对于这件事情的效率提升。在当前，我并没有看到摩拜多花的这些钱有什么质的提升。当然，或者以后会有也说不定。 有人提到 ofo 也加智能锁了。但是 ofo 的智能锁绝对是一个在成本方面考虑了非常多的产物。比如 ofo 的智能锁在功耗上就非常低，这使得它不需要充电，只需要电池供电就可以了。同样这个智能锁没有 GPS 模块，只通过 2G 卡来辅助做定位。从上锁的时间来看，它和服务器的通讯更像是通过短信来通讯，所以这会使得通讯成本很低。智能锁的密码看起来更像是一个一天一换的轮换密码，基于某个随机数生成算法计算而来，就像银行的认证 Key 一样，这样使得它并不需要和服务器通讯。我自己觉得整个技术方案使得成本至少是摩拜锁的一半，或许还要更少。 结论我认为 ofo 更容易赢得这场竞争，但是 ofo 也要更加关注自己的竞争策略和团队核心成员竞争力，别在人才上输给对手。如果以上推断有任何问题，欢迎大家评论纠正我，我不怕被打脸，因为对于我来说，也是一种学习。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"写在创业五周年","slug":"startup-5th-year-summary","date":"2017-05-31T14:12:03.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/05/31/startup-5th-year-summary/","permalink":"https://blog.devtang.com/2017/05/31/startup-5th-year-summary/","excerpt":"","text":"2016 年的今天，我们宣布获得了腾讯的 D+ 轮的 4000 万美元的投资，那轮以后，我以为公司应该不会再有融资了。因为当时公司的估值已经很高，如果再有融资，那么公司的估值就会超过 10 亿美金。10 亿美金通常是一个分水岭，表示着公司进入到了「独角兽」级别。 没曾想到 2017 年的 5 月 31 日，就在一年之后的同一天，我们宣布获得了新一轮的 1.2 亿融资，估值超过 10 亿美金。 我是 2012 年 5 月 10 日加入猿辅导的，五年时间这家公司就做到了 10 亿美金的估值。而我也从一个 iOS 开发者变成了公司的小猿搜题产品的产品技术负责人。 五年时间，伴随着公司规模扩大，我的角色也在快速转变，使得我有机会观察和学习到创业不同阶段的团队沟通方式的变化以及团队目标的转变。 拿小猿搜题这款产品来说，在产品初期，我们主要的精力放在打磨产品体验，做出用户喜欢的产品。而核心功能和体验优化得差不多之后，我们主要的精力又放在了用户增长上。当用户增长到达一定阶段，我们又开始谋求商业化的可能。目标的转变让我深刻意识到，好的产品方案不止是为用户服务，而且为运营服务，也为公司的商业化服务。 小猿搜题的团队最初只有几个人，慢慢扩张到几十个人。我明显感受到了 Scrum 会议的效率降低。在尝试拆分 Scrum 团队后，又感觉到了信息沟通的效率损失。确实小团队有小团队的玩法，大团队有大团队的玩法。在多次调整团队的组织沟通形式之后，才形成了当前的客户端，服务器两个子团队的形式。不过或许以后随着业务变化，这样的团队协作形式还需要调整。 猿辅导公司整体也在不停地调整，比如今年就调整成为了以产品事业部为划分方式的组织架构。新的事业部架构能够让每个产品专注于自己的目标，我非常喜欢这种架构方式。小猿搜题也因为这种架构调整获得了更多的关注，进而做出了很多大胆的尝试。 小猿搜题团队成员基本上是由我搭建完成的，特别是今年成立事业部之后，我在招聘决策上的话语权更强了。我刚开始只会面试技术，但是现在我也会面试产品经理，面试测试，面试 UI 设计师。在面试能力上，我个人觉得自己进步了不少，刚开始也是满满的面试方法论和套路，后面越来越习惯根据不同人的简历来做灵活变通地提问。在团队成员的招聘上，我交了一些学费，但是整体上来说还是做得不错的，小猿搜题的团队能力让我很自豪。 现在的我也更加坦然地面对一些团队成员的离职，也更加努力帮大家寻找自己工作的舒适点，让大家尽量工作得开心，有所收获。如果有一些能力不行的，我也能更加释然地让他离开，既然你不满意他的表现，又何必非得让大家都不爽呢，有些时候分手可能意味着让别人获得更好的机会。 我自己也感觉更加累了。以前做 iOS 开发，下班了继续看看 iOS 博客，写写心得和总结，虽然上班很辛苦，但是看着自己写出来的 iOS App 还是有很强的成就感。现在每天需要看产品数据，讨论产品稿，讨论 UI 稿，面试，和重要团队成员沟通，思考当前最重要的事情，和我的老板沟通，经常发现事情永远做不完。而且一天下来，发现自己基本都在动嘴皮子，事情都是别人做的，成就感反倒偏低，而且心里还觉得不如写代码踏实。 可能也是因为作息时间不规律，今年得了胃病。iOS 开发的时候再忙，到吃饭时间也可以先停下工作去吃饭，现在我的工作都是沟通性质的，不能说大家开着会，你看看表说我先去吃饭了对吧。去年中午还能坚持每天游 1000 米，今年中午只能一周有一两天有空去游一下。 我常常想创业是一个长期的事情，不应该把自己搞太累。但是有一些事情在那里，自己不管的话好象确实又没人管了，小猿搜题团队整体偏年轻，授权的时候又不能完全不管，常常需要一些协助，虽然有些时候觉得交给他们犯犯错也影响不大，但是有时候还是心里挺着急的。只能希望团队的成员能够多一些成长起来，让自己最终能够成为一个甩手掌柜最好。哪天团队不需要我了，或许才表示我建立起来了一个高执行力的团队。 今年小猿搜题有一个大的目标，全程都是我在主导，我开始有一些团队负责人的感觉了。希望到年底，这个大目标能够差不多实现，如果真的实现了，或许明年，整个公司就不只是 10 亿美金的估值了。 这恐怕就是创业最有意思的地方，你永远不知道你能创造出多大的价值出来，哪怕最后失败了，我想这个过程也会让我刻骨铭心。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"每个人都应该买美股","slug":"talk-about-buying-stock","date":"2017-05-24T13:42:06.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/05/24/talk-about-buying-stock/","permalink":"https://blog.devtang.com/2017/05/24/talk-about-buying-stock/","excerpt":"","text":"前言本文只是我的个人心得，不表达任何投资建议，股市有风险，请自己决策。 我的错误认识在买美股之前，我总是觉得投资是一件离我很远的事情。因为我觉得，我当前并没有很多的资金，炒股或做别的股资其实又是一件很花费时间的事情。我把精力放在这件事情上，从金钱上的回报，即使是 100% 回报率可能也没有多少钱，那还不如把精力放在别的更有意义的事情上，比如写作，读书或者英文表达等。 但是我现在发现我的这个认识是错的。从金钱回报上，确实如我所说，可能我当前投入的资金并不能带来什么巨大的回报。但是，炒美股这件事情其实对于个人能力有一个巨大的提升：就是你开始从全局层面上，思考一家公司的未来。 炒股意味着什么本质上讲，你买一个公司的股票，就是在投资这家公司，这表示你认为在未来这家公司的股票会更加值钱。这是一种对未来的判断能力。 这种对未来的判断能力相当重要，德鲁克在《管理的实践》一书中写道：管理者很多时候在做决策的时候，都是在分析未来有可能有什么市场环境的变化，这些变化会有什么机会。书中举了西尔斯公司的例子，早期美国的农民在采购物品这件事情上非常不方便，这家公司关注到这件事情，提供了邮购目录的服务，获得第一次成功；之后由于汽车的普及，大家可以很方便地开车购物，原有的邮购目录业务快速萎缩，这家公司关注到了市场变化，仔细分析之后推出了零售商店的模式，于是获得巨大的成功。 本质上，所有的创业都是对于未来某些事情的判断。我们 5 年前做猿题库，是源于李勇对于教育这个行业未来的判断；网易做严选，是对于电商和消费升级的判断；傅盛做清理大师，是对智能手机兴起时，工具类应用的机会的判断。我们没办法像他们一家，用创立一家公司的方式来检查自己的判断，因为一来这样成本太高，二来创立公司对综合性能力要求太高，大多数人都没有这样的能力。但是，买一家公司的股票实在是太方便了，我们仅需要很低的成本就可以检查我们的判断。如果我们判断对公司了，本质上，我们是在投资这家公司，所以它未来的增长会以股价的形式回报给我们。 当然，你很可能判断错误，但是我觉得这不重要。因为我们投入的资金其实并没有多少，所以其实亏也不会亏多少。重要的是你认真地做判断，然后在判断错误之后，想想自己到底在商业上的判断有什么问题。 在这件事情上，我觉得「交学费」是很正常的，没有谁一开始就是预测大师，所以重要的是你在持续地思考，持续地调整自己的想法，如果发现自己想错了，就应该果断地调整自己的投资策略，而不是患得患失。 与人性做斗争炒股票这件事情除了可以训练自己对未来判断的能力外，它还可以让自己学会与人性做斗争。李勇给我说过：炒股是一种克服贪婪与恐惧的游戏。我虽然炒股时间不长，却也深深感受到这里面的人性力量。 大部分人都喜欢追涨杀跌，但是真正挣钱的人肯定是低买高卖，所以克服恐惧，在股价低迷的时候买入，克服贪婪，在股价虚高的时候卖出，这样的行为说出来简单，但是要做到却是极为不容易的。 美股与 A 股的对比为什么我建议大家炒美股呢？因为美股相对于 A 股来说市场更加规范和成熟，我们炒股不是为了挣钱，而是培养商业的思考，如果你炒 A 股，你形成的商业思考很可能是错的，比如你可能会把 A 股理解成受政策影响巨大的市场，从而只关注于政府的利好利空消息，而不关注股票本身。A 股的环境不成熟和股民不成熟，更难使大家产生好的商业判断，所以我建议大家尝试美股。下图是车和家创始人李想评价 A 股的一段话： 但是美股也有一些政策风险，中国法律并没有开放中国公民参与境外资本投资活动，我觉得这里面主要的原因是担心资产外流造成人民币贬值压力，另外境外资本也不受中国政府监管，容易埋藏洗钱一类的犯罪行为。所以我不建议大家用大量的钱参与抄美股，适当地放几万人民币就行了，完全把这件事情当作一个学习行为而不是投资行为。 炒股软件与关注领域因为不希望有任何广告的嫌疑，所以我不打算介绍我用的炒美股软件，大家如果真感兴趣应该可以自己想办法找到。 我关注哪些美股呢？因为我是希望通过这件事情提升自己的商业判断能力，所以我主要关注我的工作所在的领域：互联网和教育行业。我希望通过这件事情能够让自己更加懂互联网和教育行业。 总结炒美股是一种花钱让自己认真做商业判断的学习行为，通过持续提升，可以让自己在某些行业产生深刻的认识，从而提升自己未来商业判断的能力。另外，炒股本身也让自己更加深刻体会到人性的力量，有利于产生更强的自我控制能力。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"硅谷之行（三）：硅谷旅行攻略","slug":"silicon-valley-3","date":"2017-03-26T14:00:44.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/03/26/silicon-valley-3/","permalink":"https://blog.devtang.com/2017/03/26/silicon-valley-3/","excerpt":"","text":"前言3 月 5 日 - 10 日，我参加了 Boolan 组织的硅谷旅行团，然后在硅谷渡过了难忘的 5 天时间。 这次因为是参加的旅行团，所以花费还是比较高。我自己研究了一下，如果是自己自由行的话，估计能便宜不少。如果你像我一样，有不少朋友在硅谷的科技公司工作，可以考虑一下自己安排行程，估计花费能够控制在 1 万左右（4000 多的来回机票，4000 左右的住宿，2000 左右的交通、景点和餐饮）。 签证美国签证十年有效，你其实并不需要确定行程再申请签证，完全可以说「有意向」参加什么样的旅行即可。美国签证需要面签，可以直接在美国大使馆相关的网页上进行申请和交费。我第一次不太明白，找的是旅行社代理，其实完全没有必要。 签证通过之后，虽然是 10 年有效，但是美国大使馆要求大家每两年更新一次 EVUS，如果没有更新的话，下飞机入境的时候有可能会被拒绝入境哟！ 签证是否通过非常看人品，我个人签证时非常顺利，时间短短不过两分钟。个人的经验是：回答签证官的问题时，不要太犹豫，犹豫的话，他会认为你有撒谎的嫌疑。就我面签当天的观察来看，反正被拒签的人也是挺多的。 机票签证搞定之后就可以搞机票了，到硅谷玩可以有 3 个机票可供选择：北边的旧金山(SFO)机场，南边的圣何塞(San Jose)机场，东边的奥克兰(Oakland)机场。其实从距离来看的话，圣何塞离硅谷更近，比如今年 WWDC 17 的举办地，其实就在圣何塞。所以推荐大家按圣何塞 -&gt; 旧金山 -&gt; 奥克兰 这样的顺序来选择合适的机票。 如果提前三个月买票，另外不是旺季的话，同时购买往返的机票，其实很容易选择到往返 4000 左右的机票。下图是我在去哪儿上随意搜到的 4 月份的北京往返旧金山的直飞机票，价格 4000 出头。 酒店酒店的话，美国整体的住宿都比国内贵很多，包括 Airbnb 也不便宜。如果想省钱，可以住 Motel，我们这次住的 Travelodge San Francisco Airport North 就是一家 Motel，提前预定的话，标间的价格大概在人民币 800 - 1000，这样一个人一天的住宿成本是 400 - 500。 如果你想住好一点，像这家 Motel 不远的 Hyatt Regency San Francisco Airport 就好很多，标间大概人民币 1400 - 1600，一个人 700 - 800 一天。 有一些酒店可能在不太安全的地方，如果你有朋友在硅谷，可以让他帮你参考一下。我这次去只是听说奥克兰那边可能有点乱。 预定酒店的话，可以选择 http://www.booking.com/。如果考虑在美国待一周的话，酒店花费约在 3500 - 5000 人民币，当然，你得至少找个同伴和你一起住标间才行。 旅行准备 最好准备一张美国当地的电话卡，淘宝上可以买到。我对比了一下，比移动和联通漫游过去的信号好一些，价格也更便宜一些。 信用卡，需要是 Visa 或 Master card，银联的很多地方无法刷卡。 美元现金。随便去一家银行即可兑换。我准备了 1000 美金，剩了很多，因为基本上都可以刷卡。不过多少还是得带一些，特别是给小费的时候需要。 下一些APP。比如 Google map，Google translate，Uber（绑定好支付的信用卡），yelp，有道词典, CrimeMapping。注意 Uber 不要下错了，要下在国外使用的 Uber，国内的那个 Uber 已经卖给滴滴了。 驾照和租车翻译件。如果你要租车的话。 电源转换插头。国内两头的插头🔌可以直接使用。三头的插头需要转换头。 充电宝。多搞几个，因为到了那儿老拍照录像，很费电。 倒时差我按照知乎上搜到的「节食+早餐法」，一路没有很强的时差反应，推荐给大家。 行程安排再看看这张硅谷的地图： 可以看到景点都集中在北边或南边，所以推荐大家把游玩的景点分两部分： 第一部分是最北边的旧金山市区。可以在那儿逛唐人街，金门大桥，吃螃蟹，也有一些科技公司（如 Airbnb, Twitter），博物馆可以逛。 第二部分是南边的硅谷区域，可以在那儿逛 Facebook, Google, Apple, 斯坦福大学，计算机博物馆。 这两部分逛完之后，如果还有时间，可以考虑自驾去西边的一号公路。我这次是没有时间了，下次一定要体验一下。 选择酒店上，可以选择离 Caltrain 比较近的酒店，通过 Caltrain 来到最北边的旧金山市区以及南边的各大科技公司。也可以考虑前两天住在旧金山市区里面，后面几天搬到硅谷那边住，这样每天不用担心离酒店太远。 总结如果你是程序员，那么一定要来硅谷玩一玩，也许你见了会说：「硅谷这个全世界的科技中心也就那样」，但是，只有来了你才有资格说这样的话。 希望这篇攻略能够帮到你。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"硅谷之行（二）：科技公司和景点","slug":"silicon-valley-2","date":"2017-03-26T13:39:40.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/03/26/silicon-valley-2/","permalink":"https://blog.devtang.com/2017/03/26/silicon-valley-2/","excerpt":"","text":"前言3 月 5 日 - 10 日，我参加了 Boolan 组织的硅谷旅行团，然后在硅谷渡过了难忘的 5 天时间。 接上一篇，接着介绍一下这次旅行参观到的科技公司和景点。 Apple作为一个 iOS 程序员，不能不去参观苹果相关的内容。这次我首先远远参观了在建的苹果飞盘大楼。苹果的安保很严格，不让靠近拍照，所以只有一个很远的外景。图片不算清晰，还是放出来给大家看一眼吧： 苹果的办公区域是由多个独立建筑构成的，每个建筑前的路牌都有着不同的颜色。 苹果最好吃的食堂是 Cafe Mac，我找我在苹果的同事带我进去尝了一下。吃的是下面这个菜，是一条煎的鱼，下面有一些蔬菜，然后配土豆泥和面包吃，算是我这次在硅谷食堂吃得最好的一次了吧。至少肉的口味相当好。不过，苹果的食堂中午是收费的，晚上免费。这道菜的价格是 9 美元，其实挺便宜的，麦当劳买个早餐都得 10 美元。 苹果的总部旁边有官方的体验店，我在里面买了一些纪念品，后来听朋友说，每到 WWDC 期间，这里面的各种纪念品都会卖断货，特别是带有 “The crazy one” 字样的 T-Shirt。 Facebook Facebook 的办公区比较严，基本上没有员工带的话，是没法进入到里面参观的，但是进入 Facebook 园区后，里面的建筑也都非常有意思。 走在 Facebook 的园区里，每个建筑都有着强烈的 Hack 风格。也常常看到「Hack」，「Move Fast」这样的口号。下面这个建筑，整个墙面模拟成老式的电子游戏机的游戏界面。 最有意思的可能就是 Facebook 园区外著名的点赞标志（Thumbs Up Sign）了，由于在园区外，所以很多人过来留影。但是如果你留意这面墙的背面，你就会发现背面居然是 Sun 公司的标志。 Thumbs Up Sign 正面： Thumbs Up Sign 背面： tinyfool 给我说，Facebook 的办公地原来是 Sun 的，后来 Sun 衰落了，Facebook 搬了过来，然后直接把 Sun 的标志翻个面，做成了自己的标志性地标。这在中国，可能会认为太马虎，不正经，但是我认为 Facebook 是鼓励这么做的，不是为了省钱，而是传达一种解决问题导向的做事态度。 嗯，这次也有幸见到了 Facebook 的涂鸦墙，上去为猿辅导留了一个名字，哈哈。 在 Facebook 里面参观的同时，我也有机会和两位在 Facebook 工作的 iOS 开发者聊天。Facebook 早年有大量 Web 端的工程师，后来经历移动互联网兴起，很多很牛逼的 Web 开发者需要做移动端的工作。所以，为什么早年 Facebook 希望用 Web 的方式实现移动端的体验，为什么 Zuckerberg 会说这是他犯的最大的错误，又为什么 Facebook 会发明 React Native 这样的技术，很大程度上是因为 Facebook 有着大量优秀的 Web 端的开发者导致的。知道了这段历史，就能理解这个发展过程是必然的了。 Google 相对于 Facebook 比较严格的安保，Google 的园区相对开放，而且 Google 还有专门的游客参观室。其参观室的名字也相当 Geek，叫做「Google Visitor Center Beta」，满满的工程师风格（下图）： 找陈硕师兄带进了 Google 的食堂，没有感受到传说中的那么好吃，不过种类挺多的。很多硅谷公司允许员工带狗上班，在 Google 园区拍到一条大黄，马上想起了 sunnyxx 的头像😝。 不知道是不是我运气好，在 Google 的食堂和办公室，都听到华人在用中文交流，有一种没有出国的错觉。另外包括 Google 在内的几乎这次参观的所有科技公司，都会给员工配可以升降的办公椅。 AirbnbAirbnb 的办公室在旧金山市区，听 Angela 说有一半是华人工程师，惊叹这到底是中国公司还是美国公司。Airbnb 的会议室非常有意思，每个会议室都是模仿线上一个真实的 Airbnb 房东的家来装修的。比如下图就是模仿一个上海 Airbnb 房东的家的会议室。 和 Airbnb 的李勇聊天，我也能感受到公司在硅谷的便利，他们在使用 Swift 开发 iOS 版 Airbnb 的时候，有问题可以直接找苹果的工程师对接，实际上他们也遇到了不少 Swift 的问题😅。而中国的公司在遇到 Swift 的问题时，基本上找不到可以向官方快速求助的渠道。 Udemy Udemy 是一家在线教育公司，Boolan 组织了一场和他们的市场部 VP: Richard Qiu 的交流会，很高兴这次能够听到硅谷公司对在线教育的一些观点。 Richard 是一个华人，在美国生活了 30 年，他给我们分享了挺多不一样的观点，比如他认为教育的「平台模式」可以弱化对于内容生产的出成本和风险。所以他们每月 2000 门新课。iOS 新技术出来后，很快就有课程。这样的好处就是很容易 scale，但是坏处其实也比较明显，就是质量不太好把控。 平台模式和自营模式在很多时候都需要仔细考虑，比如我们的在线辅导产品猿辅导之前更像是平台模式，而现在更接近自营模式。京东最开始明显是自营模式，但是它也有入驻的各种第三方卖家，融合了一些平台模式的特点。平台和自营的选择，更多时候是在质量控制、规模化成本、内容成本之间的 trade off。 对于在线内容的付费，Udemy 也发现了一些有趣的故事。Udemy 发现：推免费的课程意义不大。免费的学生很难变成收费的学生。但是收费学生买了一门课之后，之后付费的门槛就小得多。而且他们发现，第一门课付钱多少，对于之后付费多少没有那么差别。所以他们的目标变成了尽量让用户尝试第一次付费。 在聊全球化的时候，Richard 提到没有国际公司在中国成功过，Uber 差点成功。我想这样的原因很可能是： 中国市场足够大，硅谷的成功产品即使是壁垒最小的工具类产品，也需要在中国做特别多的本地化开发和运营。非工具类产品，则需要更多的考虑中国人的文化的差异做相关的调整。甚至也有可能模式在中国行不通。 中国市场的竞争足够激烈，通常成功的硅谷产品刚刚火起来，就有复制过来的中国产品已经开始竞争。硅谷的公司在精力上无法顾及这块市场，也无法这么快地成立中国的本地化开发和运营团队。 中国的市场环境，无论是从资本、产品设计、技术实力、研发速度上讲，都不弱于硅谷的公司，所以硅谷公司很难占到便宜。 当然，中国的公司要做海外市场，同样很难。 UberUber 真的是为硅谷而设计的产品形态，在硅谷要打出租车太难太难了，因为硅谷其实地广人稀，出租车没法很容易叫到。而且出租车很贵，我试着在旧金山市场打了一次出租车，才短短 3 公里左右，就花了 12 刀。而如果用 Uber 的话，价格大概只有 6 刀。 所以 Uber 在硅谷创立时，真的是切了两个很强的用户痛点：1、打车难。2、打车贵。 看看中国的滴滴抄过来变成什么样了吧，打车难这个问题在一线城市也有，但是其实并不严重，主要集中在上下班高峰期，滴滴通过增加车的供应，应该说使得问题有所缓解，但远远说不上解决了这个问题。打车贵这一点，滴滴是基本上没有颠覆的，现在叫滴滴的快车还要比出租车贵一些。 另外，旧金山市区的交通状态并不好，但是能够看到 Uber 的自动驾驶汽车，让我对自动驾驶技术的成熟度有了更强的信心。或许再过两年，自动驾驶已经在硅谷到处跑了。 食堂硅谷的公司都有食堂，其实有一个重要的原因是：外面没有吃的。像 Google 和 Facebook 这样的公司，选址都是在远离 downtown 的「大农村」，如果公司不提供食堂，真的就没有什么可以吃饭的地方了，不能为了吃个饭，开车到 downtown 吧？而且美国人力贵，地广人稀，所以像国内美团外卖，饿了么这类的服务，在硅谷肯定是不可能出现的。 所以说，虽然硅谷的科技公司食堂多么多么好，其实别说吃一年了，吃三个月估计你就很腻了。所以说，如果从吃饭的选择多样性来说，还是国内的环境好。 另外说到快递服务，这次帮老婆带了一些东西回来，但是美国亚马逊的标准送货时间都是长达一周，对比国内的京东，上午下单下午就送到的服务，中国人密集居住的特点还是让这些服务在国外完全不能比较了。 有哪些渠道可以加入硅谷的公司如果你向往硅谷的工作，就我所知，有以下这些方式可以考虑： 去美国读研，然后在那边实习，毕业之后在那边工作。美国的研究生时间比较短，基本上是一年半就读完了，毕业的论文要求也没有那么高，不过基本上得自费。如果你经济上可以的话，这条路相对容易一些。不过现在走这道路的人很多，所以申请研究生可能也不是那么容易。花费的话，学费+生活费可能在 50 - 100 万人民币左右。如果能在那边打工或者实习，估计压力也不大。我的一个有道的前同事 SLY 就是这样拿到 CMU 的研究生，然后读完研后进入 Google。 毕业的时候应聘国外的职位。这个时候得看人品，如果正好那边在招人，是个机会。不过这样的机会大多比较少。 进入一家外资企业，然后寻求 transfer 到美国的机会。我的一个在微软的大学同学，在微软磨了四年，终于拿到这样的机会去了西雅图。 有国内的一段工作经历后，直接应聘国外的职位。比如我知道像 Google, Facebook 就会有这样的招聘机会。 计算机博物馆最后不得不说计算机博物馆，每一个程序员都应该来这里看看，这里能够看到历代的计算机发展历程，包括最早的 ENIAC，著名的 Xerox 的图形操作界面，还包括最初的第一代苹果电脑。可以说，这里展出了整个计算机行业短短几十年的历史。当那些传奇故事中的物品，真实展现在你眼前的时候，还是让人心里一阵，感慨万千。 第一代苹果电脑（下图），乔布斯靠这个挣到了第一桶金。 总结总体来说，硅谷的科技公司给我的感觉都是很开放，很鼓励创新，至少在各种细节上看是这么感受到的，另外华人工程师真的很多很多。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"硅谷之行（一）：惊喜和落差","slug":"silicon-valley-1","date":"2017-03-26T12:31:58.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/03/26/silicon-valley-1/","permalink":"https://blog.devtang.com/2017/03/26/silicon-valley-1/","excerpt":"","text":"前言 3 月 5 日 - 10 日，我参加了 Boolan 组织的硅谷旅行团，然后在硅谷渡过了难忘的 5 天时间。以上是我的游览的主要地图。我们住在旧金山机场附近，然后游览的地方主要有机场北边的旧金山市区，以及机场南边的硅谷区域。这次时间太紧张，没能自驾游览西边的一号公路。 这次游览对于我个人来说帮助巨大，因为我以前总是带着一种膜拜的眼光在看待硅谷发生的一切，这次亲自到硅谷参观，包括和很多以前的同事或朋友聊天，我感受到了更加真实的硅谷。这个真实的硅谷有着令人称奇的地方，但同时也有着各种问题，它让我能够用一种更加客观的心态来看待硅谷，这个全球的计算机产业中心。 下面我选择一些印象比较深的点来分享我的感受。 破旧的基础设施第一天到了旧金山机场，我就感受到了基础设施的差距，旧金山机场的手机 4G 信号非常不稳定，我用两个手机分别使用 AT&amp;T 和 T-Mobile 的网络，速度都非常慢，有一些区域甚至显示无网络。我分析了一下，觉得是因为美国人居住得比较稀疏，手机网络要覆盖全部区域的话，不太经济。 所以如果你查 T-Mobile 的网络覆盖图的话（下图），你就会发现，连一号公路和优胜美地这些重要景点，T-Mobile 都是没有信号的。 接着，在从机场到酒店的路上，这条编号为 101 的公路让人感觉非常破旧。之后的游览我们多次经过这条公路，可以说这条公路对于硅谷的交通来说非常重要，但是路上却随处可以见到一些损坏待修补的路面。旧金山的地铁也很差，轨道在运行时，常常伴随着刺耳的轨道与车轮的摩擦声。 和一些朋友讨论了这个问题，他们觉得产生这样的原因主要有以下几点： 美国政府没有钱，加上美国的基础设施建设的年代比较早，如果没有大问题，比较难以有动力修复。 美国的土地都在私人手里，有一些公路要扩宽或调整的话，需要从私人手里买，比较麻烦。 所以硅谷的公路，地铁以及手机网络和北京比起来，那是相当逊色的。川普号称上台后会大力搞基础设施建设，如果我是美国人，我应该会挺喜欢这个政策。 基于信用的社会体系美国的整个社会都构建在一套信用体系上，很多规则都没有人监督，全靠自觉。 比如坐火车买车票，整个火车乘车区域是开放式的，火车站台上有自动售票的机器，你自己选择从哪儿坐到哪儿，然后刷卡购票。车上没有检票的列车员，如果你不买票，根本就没有人管你。下图是我们坐火车（Caltrain）时，自觉购买的单程车票。 又比如停车交费，你需要自己购买停车时间，如果不买，基本上也是没有人查你的。各种游览景点的门票，买完票后你就可以自己进去参观了，同样没有检票和查票的人。公路上的十字路口，大多数也没有摄像头，你如果闯了红灯，其实也没有人管你。高速公路上的限速，实际上也是没有测速仪的，全靠自觉。 有些人可能会觉得是美国人道德水平很高，其实我觉得不是，我觉得美国能够构建起这样的信用体系主要原因是：美国通过提高违法成本，使得大家从经济角度认为，违法是不值得的。比如如果碰巧被发现逃票，那么这条不良信用记录将跟随你很多年。而美国的很多经济行为都是需要使用信用卡的，如果有不良的信用记录，那么信用卡的使用就会受限，会给自己的生活带来很大的麻烦。另外，高额的罚款也会让你觉得逃票不值得，比如逃一次票的罚款是逃票额的 1000 倍，你还敢逃吗？超速如果万一被警察看到，除了罚款，可能会直接坐牢。 当然，建立出上面的信用体系，也需要严格的执法。美国是一个法制国家，使得上面的规则最终在执行的时候不会有人走后门。 科技中心与创新文化行走在硅谷，还是能感受到满满的科技气息，Google 所在的山景城区域，时不时就能看到 Google 旗下的自动驾驶汽车。下图是我抓拍到的自动驾驶汽车，在我拍的时候，里面的工作人员还向我挥手致意。 同行的朋友也抓到了 Uber 的自动驾驶汽车： 参观硅谷的互联网公司，也能感觉到满满的鼓励创新的黑客文化。就拿街名来说，苹果的大楼前面的街名叫 Infinite Loop，嗯，这个程序员代码没写好的时候都会遇到：死循环。Facebook 前面的街名叫 1 Hacker Way。 Facebook 的厕所小便池前面，有一个黑客周报，会贴一些提高工作效率的小工具教程或小技巧。我那天去参观的时候，刚好介绍了一个提高 Code Review 提 Comment 的小工具，非常有用。 类似的细节还有挺多，能感觉到大家的想法是很开放的。我感觉这代表着一种黑客精神，就是不拘一格，以解决问题为导向，鼓励创新和开放的文化。 移民国家文化我在硅谷的几天游玩时间中，见到了各种地方的移民，特别是打 Uber 的时候，开 Uber 的很多人都是第一代或者第二代移民。大家其实母语都不是英语，所以在交流的时候，虽然我们的英语算不上特别流利，但是当地人无法由此判断我们是不是居民。他们甚至聊天的时候会问我们是在这里上学还是工作。 硅谷同样有华人比较密集的区域，在旧金山还有唐人街，我和 tinyfool 在唐人街尝试用中文交流，完全没有问题。我们甚至还跑到唐人街的银行，用中文询问办国外的银行帐号的各种问题，服务员可以用流利的中文回答我们。 比较搞笑的是，我们在唐人街还看到了有人转让铺面，转让信息上面赫然几个中文大字「旺铺转让」让我和 tinyfool 忍俊不禁（下图）。 华人工程师的就业硅谷科技公司里面的华人工程师非常高，说几个例子： 我在 Google 的食堂和一个朋友吃饭，座位旁边也坐了3个人，开始吃饭后，我惊奇地发现他们在用中文聊天。 朋友带我参观 Google 的办公室，走到他的座位附近时，刚好看到两个人正在用中文讨论技术细节。 在 Airbnb 吃饭时，Angela 给我们说，Airbnb 的华人员工有将近一半了，可见华人工程师之多。 在 Facebook 和朋友合影时，随便抓了一个旁边路过的员工帮忙照相，人家直接就说：“好啊，我也是中国人”。 所以有时候我想，同样华人给硅谷科技公司的贡献可能不亚于印度人，虽然印度人很多能做到很高的职位。 在和不少朋友沟通交流后，我觉得可以从两个角度来分享华人工程师的就业：融入度和升职空间。 在融入度上，我明显感受到在美国留学然后留在硅谷的同学，更加容易融入美国人民的生活，这可能是大学环境能够使得他们认识更多的外国朋友，从而形成比较好的社交圈子。而如果是工作之后移民到美国工作，由于社交圈子都集中在公司内部，加上美国人喜欢将工作和生活分得比较开，那么就很难交到足够多的、相互合得来的外国朋友了。通常工作之后的移民也会拖家带口，这会使得他们周末的时间更多是和家人度过，从而进一步减弱他们扩大社交圈的可能。不过刚刚提到，硅谷的华人非常多，所以即便你没有融入，你也可以拥有一个相当大的华人社交圈子，你也可以活得很自在。如果恰好和你工作搭档的是华人，如果你愿意的话，你可能一天都不怎么说英文。 在升职空间上，我能感觉到华人还是有比较明显的瓶颈。这可能都不是语言的原因，更可能是文化的原因。中国人的文化教育通常都比较偏向于让大家更加内敛，多替别人着想。而美国的文化可能更加强调自我，强调表达。华人工程师可以在一开始展示出非常扎实的技术实力，但是在更高的职位上，更多需要的是表达沟通。这方面融入度高的华人会获得更多的机会，而要完全适应美国人的文化，确实需要不少时间的努力。 物价、消费能力、房价硅谷的物价大概是：吃一顿早餐 10$，聚餐人均 35$，打车 10 公里左右的 10$ - 20$，太远的不太敢打。 硅谷的房价涨得很厉害，一个位置好一些的 Single Family 在 100 万美元以上。便宜的一些 Town House，也在 70 万美元左右。 加州税很重，算上交的养老金，到手只剩 55%。10 万美元的年薪，每月到手 4000 多（100000*0.55/12=4583）。租房一个房间就得 1000 - 2000 了，其实生活成本不低。 一个优秀的应届毕业生，刚毕业拿硅谷 10 万美元的年薪，如果他放弃来国内，应该可以拿到 BAT 30 万人民币左右的年薪。按照国内的个税，他到手每月应该有 17000 人民币，在北京租一个房间的话，大概是 2500 。 如果不考虑北京超过硅谷的房价的话，在北京还是比硅谷能存一些钱😂。 总结我很后悔自己没能早点去硅谷，见识一下这个全世界的科技中心。就像我 6 年前第一次用 Mac 时，很后悔自己没能早几年就接触这么优秀的操作系统，完美结合了 Unix 系的 Shell 和优秀的图形界面。 当然，如果你像我一样想省规划的时间，也可以报 Boolan 提供的这种硅谷游活动，可以帮你规划好很多细节， Boolan 的李建忠将这次活动办得尽心尽力，虽然多花了一些钱，但是我觉得还是挺值的。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"如何请教别人","slug":"how-to-get-help","date":"2017-03-04T16:54:28.000Z","updated":"2024-01-06T14:52:37.931Z","comments":true,"path":"2017/03/05/how-to-get-help/","permalink":"https://blog.devtang.com/2017/03/05/how-to-get-help/","excerpt":"","text":"我多多少少在 iOS 圈子里面有一点点知名度，所以在微博、微信、公众号上找我问问题的人不少。但是，大部分的程序员都不懂得如何请教别人，其实这件事情只需要学会「换位思考」就会好很多，但是还是有人做不好。 这篇文章主要是写给我自己用的，以后再遇到不会提问题的人，我就贴给他这篇文章就可以了。 如何请教别人呢，要做到以下几点。 合适的自我介绍上次有一个人在一个线下分享会后一直拉着我问问题，我一直忍着没有问他是谁，后来问了太多，我实在受不了了，我问他：你是谁呀，为什么好像和我很熟的样子？他说：哦，我是一个 iOS 开发，你没必要记住我的名字。 类似的情形出现过多次，还有一些人把名字故意取成很个性的，完全无法记住的 emoji 表情或者符号，也不做自我介绍，我完全无法记住这些人。 合适的自我介绍为什么重要呢？因为它代表着一种尊重和平等。我义务解答问题没有关系，但是我即使完全不求回报，也希望我到底帮助的是谁。这个提问者的名字，毕业学校，工作单位，以及他的问题，都会给我带来记忆。 这其实是基本的礼仪，看看那些著名演讲或者发布会的提问环节吧，提问者都会先自我介绍一番。 在吗？「在吗」，基本上以这种方式和我打招呼的提问者，通常都是令我感受非常差的。因为这意味着：我看到了必须回答在，我回答在了之后，还必须立即响应他后续的问题。 同学们，现在连 QQ 都取消在线状态了，有什么事情不能用留言的方式解决呢？说白了，还不是提问者自我为中心，他们希望偷懒，连在请教别人这件事情上，他们都希望不要浪费自己的打字 —- 如果对方不在，我就可以不用打字提问题了，免得提了别人不答。 但是，如果你这么不尊重对方的时间，又何来让对方免费的、在线互动地和你一问一答帮助你解决你的问题？ 凭什么？ 不会提问很多人都描述不清楚自己的问题，需要我来帮助他们一点点来弄清楚他到底想问什么。我举一个例子： 上次一个人在群里面问：有谁知道怎么更新 Mac 的 Numbers 吗？我以为他是一个 Mac 新手，于是我说：打开 Mac 的 App Store 应用，在 Updates 里面找到 Numbers，然后点 “update” 按钮。 结果他说：我知道，但是我为什么点了没有反应呢？我这个时候才发现，他其实是想问为什么 App Store 响应慢。于是我推荐他设置了一些加速下载的 DNS。 因为这个人我认识，所以我继续在帮助他。但是其实他给了我相当糟糕的体验。因为我在帮助他的时候，我在努力把解决方案说清楚，但是他懒得连问题都不想说清楚。或者，他认为只要他说「不会更新某个应用」，就表示的是 AppStore 卡顿，而不是别的意思。 提傻问题对于 iOS 开发者来说，向我提的最傻的两类问题是：审核问题和具体的 API 问题。 例如： 唐老师，麻烦看看：Your app uses public APIs in an unapproved manner, which does not comply with section 3.3.1 of the Apple Developer Program License Agreement. Specifically, your app was found to use “canOpenURL:” to scan for an arbitrarily large list of apps. Use of this method for generalized app detection is not appropriate. Since there is no accurate way of predicting how an API may be modified and what effects those modifications may have, Apple does not permit unapproved uses of public APIs in App Store apps. 审核的问题大部分情况下英文的审核意见已经说得非常清楚了，我实在没有什么动力做翻译。 另外如果是问 iOS 开发某个特定细节 API 的使用问题，其实是没有哪个人能够对苹果的所有 API 都了解得那么清楚的，与其问我，还不如用 Google 搜索或者查文档更好。 扔代码上来就扔一段代码，然后说：照着你的博客写的，为什么出问题了呢？好象我写了免费的博客，就有义务帮他找 Bug 一样。 当然，扔代码的还算好的，还有扔过来一个 GitHub 工程的，说：「麻烦帮忙看看」，这真的是要让我吐血。。。 情绪方面的问题巧哥，我 iOS 找不到工作怎么办？ 巧哥，我希望从 xx 方向换到 iOS 方向，你怎么看？ 巧哥，我的老大对我很差，你说我应不应该换一份工作？ 大部分这些问题，我其实也只能说：努力努力再努力，或者选择沉默。因为我确实也帮不上什么忙。如果需要找人安抚心情的话，找好朋友可能更适合。 不会感谢说句谢谢是最最基本的。 如果你的问题花费了别人大量的时间，例如几个小时或者一天，那么请别人吃个饭也是正常的。大家都是成年人，倒不是说要多功利，这仅是相互的尊重。 我现在如果有很困扰的问题要请教别人，简单几句能说清楚的，我会给别人微信留言说清楚，然后附一个 66 元的红包。简单几句说不清楚的，我会和别人约个时间当面请教，然后顺便请别人吃顿饭。外地的朋友，实在不知道如何感谢，我会说：希望以后如果需要我的时候，能够找我提供帮助。 我的困境最后分享一下我的困境。 我每天收到几十个求助的问题，但是我精力非常有限，对于我来说时间优先级肯定是：首先完成工作上的事情、然后完成家里的事情、然后是娱乐和学习、然后是和朋友聊天交流、然后是休息，如果上面这些做完了，偶尔有精力，正好遇上了会提问，提的问题又是经过深入思考，而恰好我又知道答案，答案又恰好不会花费特别多的时间，那么我才有可能回答。 当然，如果是朋友的问题，我会把这个看作我处理社交关系的一件事情，那我可能就会放弃一些休息或学习时间来帮助朋友，因为或许有一天我也会需要朋友的帮助，同时朋友的成功也会给我带来开心。 希望这篇文章能够教会大家这个简单的「换位思考」法则。 谢谢。","categories":[],"tags":[]},{"title":"《管理的实践》读书心得","slug":"the-practice-of-management-by-drucker","date":"2017-02-23T14:32:26.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2017/02/23/the-practice-of-management-by-drucker/","permalink":"https://blog.devtang.com/2017/02/23/the-practice-of-management-by-drucker/","excerpt":"","text":"引言最近读完了《管理的实践》，这是我读的德鲁克的第一本书，这是一本偏综述型的书，比较多的内容是偏笼统的，不过对我来说还是挺有帮助的。 刚刚说了，这是一本偏综述型的书，作者在别的书中，将本书的一些观点进行了细化讨论： 《成果管理》（Managing for Results, 1964）是第一本有关企业战略的书籍。 《卓有成效的管理者》（The Effective Executive, 1966）讨论组织中的管理者如何自我管理。 《管理：使命，责任，实务》（Management:Tasks, Responsibilities, Practices, 1973）则是为实际管理工作者所撰写的系统化手册，也是研读管理学的学生的系统化教科书，因此内容尽可能翔实完整，有别于本书容易理解、重启发性的特色。 《动荡时代的管理策略》（Managing in Turbulent Times, 1980）进一步探讨了本书提出的基本问题：我们的事业是什么？我们的事业将是什么？我们的事业究竟应该是什么？但同时也探讨了在动荡时代，企业如何兼顾创新与延续，化变动为契机。 第一部分：管理企业德鲁克从他的角度介绍了： 管理层的主要职责：管理企业、管理管理者、管理员工与工作。 企业的目的：创造顾客。我理解这表达的意思就是解决用户未被满足的需求或痛点。 企业的主要功能：营销和创新。 一些决策分析基础。基本要素分析试图探究未来的事件「为什么」会发生，趋势分析问的问题则是：「有多大的可能」和会「多快」发生。 这部分介绍的内容原则简单，实操则极难，算是一个引言章节，便于后面的部分做展开。 第二部分：管理管理者这部分先用福特公司的例子，来说明缺乏管理者是福特衰败的主因，老福特失败的根本原因在于，他在经营10亿美元的庞大事业时，有系统且刻意地排除管理者的角色。而福特二世采取了目标管理，将很多决策权下放，最终扭转了福特公司的衰败。 然后德鲁克用比较大的篇幅介绍了「目标管理与自我控制」。这一章非常有用。在这一章节中，德鲁克首先介绍了容易误导管理者的重要因素： 管理者的专业工作 管理的层级结构 愿景和工作上的差异，导致各级管理者之间产生隔阂 这里面，石匠的例子举得恰到好处： 本书中举的例子很有参考价值：在企业管理会议上，大家很喜欢谈的故事是：有人问三个石匠他们在做什么。第一个石匠回答：“我在养家糊口。”第二个石匠边敲边回答：“我在做全国最好的石匠活。”第三个石匠仰望天空，目光炯炯有神，说道：“我在建造一座大教堂。”当然，第三个石匠才是真正的“管理者”。第一个石匠知道他想从工作中得到什么，而且也设法达到目标。他或许能“以一天的劳力换取合理的报酬”，但他不是个管理者，也永远不会成为管理者。 麻烦的是第二个石匠。工作技艺很重要，没有技艺，任何工作都不可能获得生机。事实上，如果组织不要求成员展现他们最大的本领，员工必定士气低落，但太强调个人技艺，总是隐藏了一个危险。真正的工匠或真正的专业人士，常常自以为有成就，其实他们只不过在磨亮石头或帮忙打杂罢了。企业应该鼓励员工精益求精，但是专精的技艺必须和企业整体需求相关。 对于程序员来说，只关注于代码的优雅，而不关注于产品的按时上线，就是过于关注专业工作了。我身边有大量这样的例子存在，每个人都关注自己的专业性工作，这样从表面上看是对的，但是却丧失了企业的目标。 所以，确定目标对于管理者来说是非常重要的，因为管理者才能将这样的目标向下进行传达。书中提出了一种简单的方法：给上司写信。列明：自己的工作目标，自己应该达到哪些绩效，需要做哪些事情，这些事情的主要障碍，公司提供哪些东西会形成助力或阻力。最终，这个会用于指导管理者工作的重要章程。 过度地使用流程和规范会使得效果适得其反。如果管理者大部分精力都花在做 PPT，并且 PPT 的质量很大程度决定了他的绩效，那么就会形成坏风气。 每位管理者主要的任务：1、完成上级的目标。2、完成对企业的责任。3、协助下属的工作。 企业必须通过五方面的实践，才能确保正确的精神贯彻于整个管理组织中： 必须建立很高的绩效标准，不能宽容差的或平庸的表现，而且必须根据绩效，给予奖励。 每个管理职位本身必须有其价值，而不只是升迁的踏板。 必须建立合理而公平的升迁制度。 管理章程中必须清楚说明谁有权制定事关管理者命运的重要决定，管理者必须有向高层申诉的途径。 在任命管理者的时候，必须很清楚诚实正直的品格是对管理者的绝对要求，是管理者原本就需具备的特质，不能期待他升上管理职位后才开始培养这种特质。 评估必须基于绩效。最大的错误是试图根据缺点来做评估。 在培养管理者上，德鲁克认为不应该因人设事。 第三部分 管理的结构这一部分讨论了职能部门和业务部门如何组织更为合适。德鲁克还是非常希望建立以产品为中心的业务部门，在他的文章中，他把这个叫做“联邦分权制”的结构。他举了很多例子来说明按业务部门来划分组织结构的优越性，以下是一些摘要： 根据需要而形成的职能性组织把重心放在专业技能上，员工必须获得相关的知识和能力。然而职能性专家的愿景、技能和忠诚对象可能因此变得太过狭隘，以至于他们完全不适合担任总经理的职位。 如果员工认为会计部门的主管掌握了他能否升迁的大权，那么他就会重视自己在“专业会计工作”上的表现甚于对公司的贡献，把更多精力投注于会计部门的扩展上，而非努力促进公司成长。 换句话说，多样化的做法反而强化了一致的目标和信念，而这正是建立共同的公民意识所不可或缺的。只有当其他单位会直接受到影响时，才需要一致的做法。但是，却必须建立一致的原则，并且明确说明，严格遵守。 在互联网公司中，挺多大公司在这方面确实更喜欢采用职能部门的模式来做产品。他们有专门的PM部门，有专门的服务器开发部门，有专门的测试部门，有专门的设计部门。这些职能部门的人很容易产生只关注自己专业能力，而不关心产品（或公司利益）的行为。 第四部分 管理员工和工作在人员管理上，德鲁克认为应该给员工很高的绩效责任，并且根据绩效责任来建立相应的奖励。但是，企业不应该要求员工对企业绝对忠诚，就好像企业承诺对员工负起百分之百的责任一样，都是不对的。 在人事管理上，德鲁克整体上是反对成立专门的人事部门的。他的核心观点是：绩效这件事情应该交由主管来做，但是如果人事部门只是做一些辅助性工作的话，又太过于简单。德鲁克肯定了人事管理中的人际关系和科学管理理论。但是认为这些收益远远不足支撑起构建起整个人事管理部门。 德鲁克认为：机械式的工作是反人性的，每个人都需要在工作中找到成就感，即便是机械的工作，加入一些需要判断的事情，都会让人觉得有成就感得多。 我们无法用金钱买到责任感。金钱上的奖赏和诱因当然很重要，但大半只会带来反效果。对奖金不满会变成负面的工作诱因，削弱员工对绩效的责任感。 第五部分 当一名管理者意味着什么管理者的工作中包含了五项基本活动，这五项活动共同将所有资源整合成生气蓬勃、不断成长的组织。总结起来：设定目标，组织协调，激励员工，绩效评估，培养人才。 德鲁克强调对于管理者的通才教育，以培养他全面的能力。 在决策方面，德鲁克强调在不完整信息下做决策。他的原话是： 管理者永远都不可能获得所有应该掌握到的事实。大多数决策的基础都是不完整的知识──原因可能是无法获得所需信息，或要掌握完整信息需要花太多的时间和太高的成本。我们不需要掌握所有事实之后，才能有好的决策；但是我们必须了解还欠缺哪些信息，由此判断决策的风险有多大，以及当建议采取某个行动方案时，其严谨度和准确度有多高。 思维导图本书的观点涉及的话题很广，所以思维导图我整理得很复杂，放在这里供大家参考：《管理的实践》思维导图。 总结其实我在工作中的很多思考，都从德鲁克的这本书中都得到了一些启发。例如对于职能部门的思考一直困惑着我，在本书中，我看到了以业务部门为核心的联邦制架构的诸多优点，帮助我把这个道理想得更清楚了。又比如那个石匠的故事，用非常形象的方式让大家理解到什么样的工作方式更好。 还有一些小的道理，比如不能基于别人的缺点评估，比如因人设事，这些错误我都曾经犯过或见到别人犯过。一些实践，比如给上司写信，确实帮助我更好地理解了未来的工作目标。 这是一本好书，推荐给大家。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"独立思考的重要性","slug":"the-important-of-indepentent-thinking","date":"2017-02-19T14:43:30.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2017/02/19/the-important-of-indepentent-thinking/","permalink":"https://blog.devtang.com/2017/02/19/the-important-of-indepentent-thinking/","excerpt":"","text":"罗辑思维的「逻辑」问题我有一段时间很不喜欢罗辑思维，因为我发现他为了证明一个观点，会举一些非常不恰当的例子。而很多例子是可以从多方面来解读的，就像同样一本圣经，却可以成为多个宗教的教义一样。 昨天在微博上看到 @一乐 发了一篇微博： （产品设计）是一个擅长辩论的行业，而在那些雾里看花也没有直观感受的领域，怎么说都有道理，谁都别想说服谁。 一乐很恰当地说明了这种尴尬的现象。当我们作为程序员写代码的时候，一切都是确定的。但是在非编程领域，包括商业思考，产品设计，UI 设计，营销思路，竞争思路，很难有绝对的对错。 讲故事时必须有明确的观点刚刚说我不喜欢罗辑思维拿一些故事来生硬地证明他的观点。但是，我又还是继续在听罗辑思维。为什么呢？因为当我们在讲故事或者阐述观点的时候，我们必须给听众一个确定的内容，这个确定的内容就是一个明确的观点。 我还记得我发表过一篇 《成长为 iOS 大 V 的秘密》的文章。一位读者看完后回复得非常切中要害，他说我在文章中故意弱化了我的天赋，而强化了努力和坚持的效果。 我觉得他说得非常对。我在文章中说我毕业于一个计算机排名全国 100 名以外的学校，但是我也可以说我毕业于一个综合排名前 10 的 985 学校，并且我在这个学校的计算机专业成绩排名优秀并保送该校研究生。我可以说我自学 iOS 成才，但是也可以说我在网易时，可以下载有道词典和有道笔记的 iOS 代码资源学习，以及有大量优秀的同事可以帮助我解答自学中的疑问。 那么，我如果这么写文章，大家看了会怎么想呢？文章到底表达了什么观点呢？我其实觉得努力，机遇，天赋都很重要，但是如果要说到底什么是最重要的，我还是觉得是努力。所以我弱化了我的天赋和机遇，强化了努力的作用，以便传达出文章的核心思想。 罗辑思维也是这样，不管他讲什么例子，他都是在用故事试图证明他的观点。也许故事并不太恰当，但是观点本身其实就不是绝对正确的。所以只要把罗胖的观点放在地上思考这个观点的可取之处就可以了，危险的是那些把他的观点捧着举着的人。 这就是为什么张小龙会说「我说的都是错的」，小道消息的冯大辉也会说 「希望文章能给大家启发就好」。时代在变，我们不缺观点，缺的是一种辩证看问题，独立思考的态度。 如何独立思考要独立思考，首先要学会吸收不同的观点。在这方面，多读书是最好的方式。书读多了，你自然就会发现不同的书中的观点会有冲突，这就给了你思考的基础。有了这个，你再去思考两种观点最最基本的假设，检查逻辑推导的过程，这样就容易找到对的一方了。 一旦你多次进行独立思考，你就会有意识地「怀疑」一些观点，然后利用自己的已有知识或者进行适当地网上搜索学习，你就可以验证自己的怀疑是否正确，从进培养起自己独立思考的能力。 如果打个比方，那么独立思考就是把别人嚼碎的食物还原，自己嚼一遍，因为只有自己嚼一遍，才能知道口感是不是真的好。 例子我们选罗辑思维第 200 期《古典：超级个体》中的一个观点来挑战一下。这一期不是罗胖主持的，按理说应该挑罗胖自己讲的内容，但是我确实没有动机专门挑他的毛病，所以只能凭印象找最近的一期。这期节目中讲到，人以后的寿命变长，会使得婚姻很容易破裂。而他的理由是：夫妻之间婚姻的稳固，大多数是由于年轻的时候需要共同抚养孩子，年老之后不再好重新找伴侣只好将就过。 但是我正好看了《少有人走的路》这一本书，这里面提到了正确的婚姻价值观。所以，这一期节目中的这个例子，在很多家庭中应该是对的，但是这仅表示这些家庭成员缺少正确的对待婚姻的态度。有了这样的思考，我其实看待这个观点就更加成熟了。 我们生活中类似的需要独立思考的观点还有很多，大家都可以想一下，比如： 今日头条真的只是一个「新闻客户端」吗？ 为什么很多大公司继续使用 Objective-C，不用 Swift？ 这个时代人云亦云最可怕了，希望大家都能够有独立思考的能力。 与君共勉。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"2016 年个人总结","slug":"2016-summary","date":"2017-01-01T14:55:57.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2017/01/01/2016-summary/","permalink":"https://blog.devtang.com/2017/01/01/2016-summary/","excerpt":"","text":"关于创业今年年中，公司顺利拿到了腾讯的一笔 4000 万美元的投资。2016年，资本其实有些进入寒冬的感觉，好多公司都融不到资，我们能够进一步拿到融资，还是挺厉害的。 我们公司今年也借着融资的机会，向业界宣布改名成「猿辅导」，「猿辅导」是我们期望的商业化变现的途径，看起来虽然艰难，但是也还是能够有一些希望。这次从「猿题库」改名成「猿辅导」，其实是想更加重视这块核心业务。最终，我们在年底通过猿辅导的直播课做到了 1.2 亿 的营收。今年很多公司靠直播挣到了钱，陌陌更是靠直播打了一个翻身仗。 嗯，今年我还被几次搞错成猿辅导的创始人，实在有点哭笑不得，可能是很多时候我会对外说「我在创业」，说「我们公司」，但是这个其实仅仅表示我是把自己当作创业团队的一份子，让自己拥有创业的心态，努力希望整个团队创业成功。我在猿辅导公司的职务是小猿搜题产品技术负责人，这是一个很重要的职位，我自己的期权也不少，所以对外表现出在创业的状态不是很正常么？ 说到小猿搜题，今年最大的事情可能就是在年中的时候把猿辅导嵌入到小猿搜题中。内嵌另一个应用带来了大量的沟通和技术架构上的调整，不过最终这个改动还是值得的，让猿辅导得到了小猿搜题不少流量支持。 小猿搜题今年用户量很快就过亿了，我们内部吃了一个蛋糕庆祝了一下。不过用户量实在涨得有些快，我自己其实都没什么感觉。想想最激动的时候，竟然是去年庆祝用户量突破 1000 万的时候。这就像达成一个成就之后，就会有新的目标一样，小猿搜题在用户增长上已经很好了，大家的关注点就移到了别的问题上。 2015 年我的工作主要是组建和磨合团队，今年团队成员比较稳定了，我自己的工作主要是日常的项目跟进，重要成员沟通，产品把握。反思整个 2016 年团队的工作，我规划得还是不够系统，一些重要的功能没有优先做，另外一些优化工作做得很乱，不系统。希望 2017 年能够更加努力，让小猿搜题在竞争上有所突破。 写作和分享今年在写作上有些犹豫，一方面 iOS 开发不再是我的主要工作，要不要继续投入时间学习和分享 iOS 知识？另一方面，我又希望自己能够持续写作，有一些产出。最终我还是抽了不少时间写 iOS 方面的文章，开了几个新的主题来写，一个是 iOS 面试题，一个是 iOS 开发中的算法，但是都没有最终写完。Swift 烧脑系列倒是基本完结了，反响不错，以下是 Swift 烧脑系列的文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 由于自己的工作涉及产品管理，所以我也开始尝试写一些产品体验报告，主要希望通过这种方式来增加自己产品的感觉，今年写的体验报告有： 流利说「懂你英语」体验报告 快手体验报告 读书去年底定的一个月读一本书的目标基本完成了，读书笔记今年写了不少。有几本书特别难啃，所以最终离每月一篇读书笔记的目标还差一点。2016 年的读书笔记包括： 《如何阅读一本书》 《奇特的一生》 《领导梯队》 《启示录》 《把时间当做朋友》 《格鲁夫给经理人的第一课》 《独裁者手册》 《管理 3.0》 《技术人创业攻略》 《少有人走的路》 《软技能：代码之外的生存指南》 除了以上这些书之外，今年还读了《简约至上》，《点石成金》，GTD的入门书《搞定》，吴军老师的《硅谷之谜》，德鲁克的《管理的实践》，每月一期的《程序员》杂志（谢谢唐小引老师的赠阅），还有一些 iOS 方面的图书，不过这些都没整理出读书笔记。 分享分享方面，2016 年 3 月 27 日，我参加了 InfoQ 举办的技术社群大会，我分享的主题是关于 iOS 开发的个人成长问题，分享之后相关内容也被整理成了文字，放到了我的博客上：《成长为 iOS 大 V 的秘密》。 2016 年 4 月份，我在南京的软件技术大会（4 月 16～17 日）以及上海的 SwiftCon 大会（4 月 23～24 日）上做了关于 Monad 的分享。然后，当了三次 iOS 技术会议的吉祥物（其实就是帮忙邀请嘉宾或者客串主持）：一次是年初的 atSwift 大会，一次是年中的 MDCC 大会，还有一次是年末的 iDev 大会。 池建强做了一个 1024 元的付费群，我也报名参加了。听了之次分享后，我也去那里做了一次分享嘉宾。分享是在支付宝付费群里面通过语音的方式，感觉也是非常有意思。 年底尝试了一次在趣直播的分享，主要讲的是 iOS 的安全和 App Transport Security，那天正好是圣诞节，但是还是有 1500 多人报名参加，直播到最后还有 600 人在线，算是一个不错的尝试。直播的稀缺性和互动模式确实比公众号带来的收益更高，不过参与人数上还是比公众号文章少一些，我最终从这次分享中收入了 3000 块钱的报名费，但更多的体会是体验了一把做主播的感觉。 安全2016 年 3 月，由于被撞库攻击，我丢失了百度云的帐号，里面有我保存的许多家人的照片，幸好找到 sunnyxx 通过百度的同事担保，才强制重置了密码。这件事情之后，我把我的个人密码全部修改了一遍，并且除了最重要的密码外，其余密码全部通过 1password 来管理，重要帐号也开启了二步验证。改完之后，我写了一篇 《应该如何管理密码 - 我的密码管理心得》。 微信公众号和微博我的 「iOS开发」微信公众号订阅量达到了 4 万 6 千，不过感觉增长变得比较缓慢了，一方面可能是自己更新的频率有些降低，另一方面微信订阅号平台的红利感觉也已经结束了。由于公众号平台里面有一些与我重名的号，所以思考一段时间后，我把自己的公众号改名为「iOS开发by唐巧」,希望还是保证有一定的辨识度。今年我的微信公众号还是吸引了不少广告主投放，他们是 StuQ、稀土、极客学院、100offer，感谢各位金主。 我的微博粉丝缓慢增长，也达到了 4 万多，与微信公众号订阅量相当，不过微博的广告收入几乎为零。我依然保持基本只发 iOS 开发相关的微博，所以文章的转发量都还不错。 好奇心希望自己每年都对事物保持好奇心。今年我基于好奇心做的事情包括： 尝试了一把在老小区申请安装充电桩。今年初入了一个便宜的新能源车，然后就想试试能不能装个自用的充电桩。《独裁者手册》里面讲的社会原理在小区物业管理上表现得淋漓尽致，我尝试了各种沟通办法，在我快要放弃时最终搞定充电桩的安装。想想还是非常有意思的一次尝试，我甚至还去朝阳区信访办上访了一把，非常值得体验。从我花的时间和精力来看，这个充电桩安装得不值，但是从了解这个社会各种机构的运作机制来看，这还是一次性价比很高的学习过程。 出游了几次。其中普吉岛的那次公司集体出游，还是让我感受到了挺多不一样的文化。泰国人民那种安逸，满足的生活态度使得我们这群在互联网行业奋斗的人一下子感受到了很大的差别。整个北京都充满着奋斗，努力，成功的故事，而泰国给我带来的就是一个别样的幸福生活样版。 学习英语口语。今年我花了不少时间练习口语和听力，花一个月把流利说的「懂你英语」 Level 3 刷通关了。我之前没有刻意做英语的听说练习，由于早期 iOS 开发资料的匮乏，我听了不少 WWDC 的视频。但是我现在越来越发现，阅读和学习英语的资料是非常重要的，所以我希望能够将听力和口语都再提升一个档次，希望有一天可以流利地和国外的开发者相互交流，或者能够有机会去国外的技术会议上分享知识。中国的开发者在技术上从来是不差的，缺的就是交流的能力，所以如果能够走出国内的交流圈子，那么收获的将是和全球一流开发者交流的机会。 学会了自由泳。3 月份的时候，为了节省时间，花钱请了一个教练，然后坚持游了半年，到 7 月份的时候能够一次性 1000 米了，之后每天中午游 1000 米，当前最好成绩 26 分 10 秒，平均成绩大概在 28 分钟左右徘徊。公司搬到望京后荒废了两个月，希望继续坚持。 成绩今年的成绩如下： SwiftCon 最佳演讲 博文视点优秀作者 《iOS 开发进阶》第 6 次重印，总印数 19000 册 小猿搜题用户量破亿 未来的计划明年希望自己做好三方面的事情： 总结和学习团队管理知识，把团队的工作规划好。 通过学习和写作，保持自己在 iOS 开发方面的能力。 英语听说能力进一步发展，达到和国外同行交流能力。 个人 Milestone 小猿搜题用户量过亿。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"快手为什么成功？","slug":"kuaishou-summary","date":"2016-12-18T07:09:49.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2016/12/18/kuaishou-summary/","permalink":"https://blog.devtang.com/2016/12/18/kuaishou-summary/","excerpt":"","text":"前言这篇文章整理自我在几个月前和公司产品同事做内部分享的一个小作业。为什么要分析快手？因为快手是一个很有意思的产品，用户数突破得很快。并且我认为网上的很多分析文章并不恰当，特别是知乎里面的部分评价快手的内容。 快手的历史 2011.3 快手诞生。当时叫 GIF 快手，是一款用来制作、分享 GIF 图片的手机应用。 2012.11 GIF 快手转型。将制作的内容存储为视频，只有在分享到其他平台，如微博时，才转换成 GIF 图片 2013.10 确定短视频社交属性。强化社交能力。 2014.11 正式改名为「快手」。同年，快手在 App Store 连续 4 个月居前 50。 2015.6 快手总用户突破 1 亿。 完成 C 轮融资，估值 20 亿美金。 2016.10 快手总用户达 3 亿。 2017.3 快手获得腾讯 3.5 亿美金融资。 网上的一些观点产品简洁一种观点认为：快手成功的秘诀在于产品简洁和克制。这一点上快手确实做得非常特立独行。当你还没有注册登录时，打开快手，此里你能看到的就只有信息流，第一眼给人特别不精致的感觉，如下图所示： 但是，如果你仔细看快手在 App Store 上的更新说明的话，你就会发现快手近一年的更新说明只有两条： 问题修复以及性能提升 优化用户体验 这样的更新说明，不但从时间上超过了一年，而且还以周为频率在迭代。是的，快手的 iOS 很多版本更新时间接近一周，这基本上和苹果审核的速度一致了。也就是说，苹果才审完上一个版本，快手就已经准备好下一个更新版本了。下图是快手在 App Store 的更新记录： 但是，我并不认为快手的成功与产品简洁有什么必然关系，因为产品简洁从来都只是加分项，核心问题还是产品解决用户的需求。但是至少应该可以确定的是，快手当前的产品功能简洁并没有限制该产品的流行。 猎奇，自虐，审丑微信公众号「X 博士」的有一篇攻击快手的文章，把快手的成功解释成人们的猎奇，自虐，审丑等心理，这篇文章被进一步转载到了知乎上的一个讨论:如何看待「快手」这个 App，这个转载在讨论中排名第一，获得了 4300 多个赞同。这篇文章其实有很多漏洞，但是即便是知乎这样的平台，质疑这个观点的声音几乎没有。 但是我认为「X 博士」的观点是极不恰当的，后面我会详细解释我的观点。 信息流的两种属性很有意思的是，我从毕业开始，就一直在和信息流产品打交道。我毕业时进入网易，做的第一个产品就是网易微博，这是一个信息流产品。之后我作为员工加入猿辅导（之前叫猿题库）参与创业，做的第一个产品叫粉笔网，是一个教育类的微博，这也是一个信息流产品。 做久了之后，我发现信息流产品通常都有两种属性： 媒体（新闻）属性 社交属性 这两种属性在信息流上面通常会相互抑制，产品方案最终会偏向一种属性，抑制另一种属性。 比如拿新浪微博来说，它的信息流属性就是重媒体，轻社交的，因为： 大 V 可以在一瞬间将消息传播出去。 信息的转发设计使得传递成本非常低，容易形成刷屏效果。 关系链完全公开，评论完全公开。 你可以知道当天转发量最高的，最热的（新闻）事件。 微博的这种产品特点，会使得新闻事件以及大 V 的信息被更方便的传播，而在上面建立社交圈子则相对不太方便。注意：我这里不是说不能在上面建立社交，实际上微博上也会有一些基于兴趣的小圈子。我只是强调说这个产品设计更「适合」新闻的传播。 而与此相反，微信的朋友圈就是一个重社交，轻媒体的信息流，因为： 媒体性质的消息在朋友圈的传递被微信刻意抑制。 朋友圈的营销行为被严重监管。 关系链完全私密，评论严格保密，只能认识的人看见。 你不知道全中国当前看的最多的朋友圈文章是什么，但是能知道你的朋友当前在朋友圈转得最多的文章是什么。所以即便是传播，也是基于你的社交关系，产生的合乎你价值观的内容传播。 快手的信息流是什么属性的快手的信息流是什么属性的？在得出结论之前，我们先看看快手的产品设计： 限制传播：没有转发功能，没有榜单。 没有基于阅读量的推荐。「发现」推荐的内容并不关注阅读量，而是关注别的信息，比如实时性，距离等。 设置中有大量鼓励隐私行为的选项。 快手登录后底部有 3 个 tab：关注、发现、同城： 「关注」里面当然是自己关注的人发的内容，与大 V 无关。 「发现」一栏中显然不是给大 V 的，因为里面的内容更多的是一些比较及时性的内容，红心数也不太高。后来我们也会聊到，发现中的内容更多是基于推荐的，而不是基于热门的。 「同城」一栏也不是给大 V 的，我翻了很多同城的信息，作者的粉丝数基本上都是个位数，每个信息的红心数也非常少。 对于传播的鼓励，只有在快手侧边栏的「八卦」（如下图），能够有可能看到一些自己关注的人的行为。但是这个行为是聚合起来的，所以即使有一篇文章想传播，也比较难通过这个地方获得。 所以，你看出来了吗？在产品设计上，快手在抑制信息流的媒体属性。「同城」里面的内容全部都是基本地理位置推荐的内容，很多内容红心数都是个位数，所以不是什么热门内容，快手为什么推荐它们？ 我们再想想这些问题： 你能在快手上找到当天点赞数最多的视频吗？快手有热门视频榜吗？ – NO！ 你能在快手上转发你觉得很赞的视频给你的朋友吗？（我是指快手应用内，转发到微博和朋友圈的不算） – NO！ 由此我们看出，快手在刻意压制产品的媒体属性，强调社交属性，快手为什么要这么做，等我们看完快手的另一个特点再一起分析. 我们先接着说快手的另一个特点：个性化推荐。 个性化推荐经过我的试用，我很快发现快手的推荐算法是可以「调教」的，除了双击给红心以及加关注之外，快手在每个视频顶部的红心旁边，都可以弹出「减少类似作品」的选项，该选项和「取消关注」是放在一起的，所以算是一个非常显眼的位置了。 另外我关注了一个魔术的帐号之后，“发现” 里面明显有了更多「魔术」相关的视频出现了。 这个和「今日头条」对比起来，就能感受到差别非常大，我在今日头条上花了一个星期算法调教，他还是给我推荐没有营养的花边社会新闻。 快手的个性化推荐做得非常直接和迅速，基本上只需要几次调教，就可以使得 “发现” 里面都是你感兴趣的内容。 好了，这个时候我们可以反驳「X 博士」的观点了，其实「X 博士」看到的猎奇，自虐，审丑的视频，都是由于他一直在给这类视频点赞！如果你不相信的话，最好的办法就是下载快手试一试，看看你能不能找到猎奇，自虐，审丑的视频，我由于开始没有调教对方向，我现在连想找都找不出来。 快手是什么介绍了这么多，我们终于可以给快手下一个定义了： 它是一个基于视频的信息流。 - 它通过 “发现” 功能来推荐和学习你的个人喜好。 - 它通过 “同城” 鼓励社交行为。 - 它鼓励个人形成自己的圈子，而不是像微博那样，每个人都围绕在大 V 周围。 - 它鼓励个人私有圈子（类似朋友圈），它提供了 “私有用户”（关注前需要先经过同意），“禁止陌生人评论”，“禁止陌生人私信” 等设置。 好了，这样的快手会面临什么问题？冷启动！由于它的鼓励社交的产品形态，刚开始没人玩的时候，冷启动非常困难。需要运营人员想办法让大家都进来玩。而有意思的是，“发现” 功能刚好又可以弥补你刚来快手，没有建立社交关系的问题。 快手为什么成功所以说，知乎上的那篇攻击快手的文章，把快手的成功解释成人们的猎奇，自虐，审丑等心理，我认为是极不恰当的。 首先从功能设计上，鼓励传播的产品形态，更利于猎奇，自虐，审丑这类视频的传播，但是刚刚说了，快手在产品功能设计上，并没有这方面的设计。这么说吧，假如有一个和微博形态一样的 “快手”，那么由于有转发功能，那么这类视频传播起来会更快。但是在快手现在的产品设计中，只能通过 “发现” 功能来传播。而发现功能当前又被设计成学习你的个人喜好，那么很容易形成每个人各自不同的信息呈现。 快手真正成功的原因，我个人它满足了两类需求： 1、社交需求。它通过运营，让大家形成了一个个的社交圈子，大家在这个圈子里面相互玩，这些圈子里面的人，有你的同学，你的同事，你的朋友，他们即使是随便拍个天空，你都会点个赞，回复一句：天气真好，今天去哪儿玩的啊？也正是因为这样的运营工作太难，快手的发展速度才会这么慢。一个产品从 2011 年上线，经过好几年的运营，才火起来。(和同事聊天，他们另外也提到，2011 年智能手机还太早，微信都还没有流行，所以时间点不合适） 2、个性化内容获取需求。在社交圈子之外，快手通过 “发现” 的学习，来给你推荐一些基于你兴趣的内容。最终会使得你觉得信息流里面的大量内容都是你感兴趣的，根本停不下来。 这样，你的信息流最终会有两类信息： 你的朋友的信息 你觉得有趣的信息 显然，构建社交圈子这件事情是整个逻辑中最难实现的，因为有冷启动的问题，这也是为什么快手火得那么慢。但是同时这也是快手的极强的竞争壁垒，即使你发现它成功了，你也无法快速复制它。快手在抑制信息流的媒体属性，加强社交属性这件事情上做得非常克制，也非常果断。 最后，快手除了运营，还做了哪些有助于冷启动的事情呢？我自己的体会是里面段子视频特别多，可能是有一个运营团队在制作这些有趣的视频，放到发现中，以便于大家在没有建立社交关系时，有好玩的内容可看。 我身边的人几乎不用快手，所以我很难体验快手上的社交行为，不过试用几天后，我发现快手上的同城里面，有很多 Live 直播，在快手的直播频道里面，没有美女，只有一些打扮平常的女孩，很多直播点进去只有 3，5 个人在看，但是能感受到他们很熟悉，像聊天一样说着话，开着玩笑，我突然体会到了这就是快手构建的社交圈子，或许每天都有无数个这样的小圈子内的直播在进行着。这些直播间的平常女孩没有任何露骨的表演，但是因为大家认识，所以一切就具有了意义。 总结快手是一个兼具个性化推荐和社交属性的短视频信息流产品。通过个性化推荐来解决社交类应用的冷启动问题，同时用社交属性来强化自己 App 的竞争壁垒和内容优势。它的产品方案简洁和克制，解决了人们通过视频打发时间和社交的部分需求，是一款值得学习的 App。 2017.03.23 更新就在今天，快手获得了腾讯 3.5 亿美金的融资。本文的产生，使得我有幸和几位快手的朋友一起吃饭聊天，在和他们的聊天中，我得以修正了一些本文的观点： 快手的更新说明只说优化性能和修复bug，是一个他们的策略，他们希望让用户自己来发现更新的地方，这样的好处是给用户产生惊喜感。 他们的社交关系还是很弱，比我想的弱很多，大部分人还是围绕着网红。快手的发现功能使得它可以打造很多中等规模的小网红，而不是一些巨型网红，这样一定程度上使得平台的价值没有被削弱。他们提到一些网红转战别的平台，结果发现粉丝都没有跟过去，于是还得回来。 上面那条也解释了为什么快手敢和主播五五分成。 快手每周发布一个版本，其实是一种“发布快车”的模式。他们通常的版本迭代其实是两周，但是他们会每周都上一个版本，谁赶得上谁就上。如果没什么功能可以赶上的，他们也会修复一些bug，保持每周上线一次。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://blog.devtang.com/tags/PM/"}]},{"title":"搞 iOS 学算法有意义吗？","slug":"flying-big-phenomenon","date":"2016-12-17T14:27:46.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2016/12/17/flying-big-phenomenon/","permalink":"https://blog.devtang.com/2016/12/17/flying-big-phenomenon/","excerpt":"","text":"最近公众号写了两周的面试题，题目有少量涉及算法，有少量涉及底层原理。总有一些人在后台问：面试这个有意义吗？我不会还不是照样做 App。还有一些人说：这些题只适合问应届生。于是我今天就想聊聊这个话题：搞 iOS 开发，研究算法和底层有意义吗？ 雷军说：站在风口上，猪都能飞起来。 但是雷军没有说，风口上的风不是一直都吹的。 飞起来的猪，如果没有抓住机会到达彼岸，那么暂时飞一阵子之后，还是会重重地摔到地上。 而 iOS 行业，就是一个最好的例子。 2012 年-2014 年，整个移动开发大火，根本就招不到移动开发的人才，各个公司没有办法，只能让服务器端的同学转岗来学习 iOS 开发。那个时候真是幸福，很多非科班出身的同学，在培训机构经过短短 3 个月的培训，然后就可以拿到上万的薪水。 但是，市场最大的特点就是会自我调节，短短时间内，iOS 开发者就充斥在市场上了，这个市场竟然饱和了。能不饱和吗？有一个读者给我留言，说他以前是做厨师的，因为培训机构说做 iOS 开发收入高，就选择了做开发。 我觉得大家应该理性思考这件事情，如果，我是说如果，iOS 开发真的可以培训 3 个月达到要求，那为什么这个职位的薪资比别的行业远高很多？学当厨师，学修理汽车，学理发，哪一个是短短 3 个月就能够学好的？而厨师，汽车修理工，理发师凭什么工资要比你拿得少？或者这么说，这些厨师，汽车修理工，理发师都不干了，都花 3 个月来学习 iOS 开发，市场会怎么反应？ 所以说，你只能选择相信下面两种结论中的一个： iOS 开发不应该是一个高薪行业，因为随便一个人就可以三个月学会。 iOS 开发是一个高薪行业，他们选择招三个月培训出来的，只是暂时人才紧缺。 如果你是培训机构出来的，那么赶紧想想自己喜不喜欢这个行业，愿不愿意投入至少一年来积累学习，搞清楚数据结构，操作系统，计算机网络，设计模式，基础算法。计算机程序实际上是逻辑，花时间锻炼自己的逻辑能力，做一些基础的算法题目，这对于你面试也有帮助。 如果你觉得面试的时候考这些没有意义，那么你就再想想你是不是认同这个结论：如果随便一个人都能学会 iOS 开发，你为什么拿那么高薪水，别的公司为什么招你？ 如果你真要纠结意义，我可以说得更现实一点，这个行业这么多人想进来，就和每年上千万人想考公务员一样，面试还不是怎么难怎么来啊，而且你真的以为计算机基础真的就一定用不了吗？即便是只有 1% 的地方需要用到计算机基础帮助我们写出更好的 iOS 开发代码，那面试的公司也会问这些的，就像你可能完全不理解 Runloop 是什么也可以写 iOS 程序，但是面试的时候就会考 Runloop，因为就是有那么 1%，甚至 0.1% 的机会你工作中可能会用到它。 不止是 iOS 开发，你以为高考选拔在干嘛？高考考那么难的数学有意义吗？高考语文需要背那么多文章有意义吗？那不然怎么办？每年只有那么一点儿人可以进清华北大，不考难一些，大家分数都一样，怎么公平地选出谁上清华北大？反过来，高考考的那些，真的就完全没有意义吗？是不是还是相对公平地把聪明又努力的人挑出来了？ 大家真的别太较真，这个世界就是这么运作的，你觉得做 iOS 开发学算法没有意义，学底层原理没有意义，那你可以不学，但是世界就是这么选拔人才的。 最后，真的不要再问我意义了，我还在风口忙着减肥呢！是的，其实我也很水，我也是一只被风吹起来的猪。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"流利说「懂你英语」体验报告","slug":"liulishuo-dongni-english-summary","date":"2016-12-03T14:42:05.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2016/12/03/liulishuo-dongni-english-summary/","permalink":"https://blog.devtang.com/2016/12/03/liulishuo-dongni-english-summary/","excerpt":"","text":"序最近报了流利说的 99 元一个月的「懂你英语」，之后又续了一个月，简单写一下体验报告。事先申明，这不是一个软文。 什么是流利说的「懂你英语」「懂你英语」试图用最简单的、婴儿学语言的方式来学习英语，即：先盲听，即看不到什么单词，只有一张图片提示你说的内容。然后，你需要重复听和跟读，每次跟读时，可以判断跟读内容是否合格，如果合格，则会有 +1 的提示。 「懂你英语」是一种比较挣钱的商业模式，因为它完全依赖于机器来判分（而且是用户的手机），服务器只需要提供学习资源的下载服务即可，所以它的毛利率可以做到很高，我估计毛利率到 70% 是没问题的。 另外，「懂你英语」的产品设计是非常适合学习者的。因为它将学习任务进行了卡片式的任务拆解，所以你只需要关注于每天的任务完成就可以了。「懂你英语」要求每天练习口语 30 分钟，它在产品设计中通过每日学习统计，打卡，班主任督学，班级学习时长排名，学习效率分等各种细节来促使你坚持完成每天的学习任务。 这种任务式、关卡式的产品设计方案已经在很多产品设计中被采用，除了流利说外，像 Keep，洋葱数学也是这样。这样的设计使得大家能够专注于眼前的小任务，然后通过达成每一个小任务获得成熟感和激励，最终完成一个大的目标。 我现在认为，所有需要长久的学习任务，都应该拆分成小的阶段，以小任务的方式来完成。这就像我们工作的时候采用 Scrum，每个 Story 又拆分成一个个小的 Task 一样，让自己的工作即清晰，又可以在半天内完成。番茄钟的工作方式也是这样，将任务拆成若干个 45 分钟。产品的版本迭代也是这样，每个版本都有一个大的 Milestone，好的产品路线图既让人感觉目标清晰，又让人觉得目标可以达成。 「懂你英语」附加的「服务」「懂你英语」比较好地做到了「服务」感，我个人认为这个是当前在线教育比较缺少的地方，这方面「懂你英语」值得被学习。说说我的体验吧： 我报完名之后，App 会显示一个微信号，可以复制之后，关注公众号。 然后公众号进去之后，回复自己的帐号，可以获得班级群信息。 在班级群里面，班主任会主动和你沟通，帮你解答学习中的各种问题。 每天中午和晚上，班主任会发一条作业，很多时候是邀请大家一起来做，对于做了的同学，班主任会在群里解答。 每个周末，班主任会策划一个学习活动，有一些活动是小组活动，需要大家一起完成。 每天会有学习排行榜在群里，告诉大家哪些人学了，哪些人没学。 对于没有学习的人，班主任会在微信里面单独留言了解为什么没学。 班级快要结束的时候，班主任会一一私聊，问是否需要续费，并且介绍续费优惠活动。 我从这个学习当中获得了： 1、被老师服务的感觉 2、一起学习的感觉（集体） 3、竞争的感觉（排名） 4、感情（同学，老师） 这些都使得我觉得「懂你英语」不是一个冷冰冰的机器服务，值得花 99 元来报名。 「懂你英语」的问题夸完了「懂你英语」，再说说一些问题。这个课程依赖了两个很强的假设，但我认为这两者都还处于发展（或者不确定中）： 假设一：成人像婴儿那样学语言，是更好的方式么？「懂你英语」称这个研究来自国外的某个教授，我没有深入查证。但是就我个人体验来说，明明知道一句话说的什么，但是完全无法知道这个单词如何拼写还是非常难受的。最终，一些用户甚至拿另一个手机打开 Google 的听写功能，用于识别这些内容的拼写。按理说，学完检测应该是一个很好的判断自己是否提高的方式，但是「懂你英语」考试的内容其实就是练习的内容，所以你也无从判断是因为自己熟悉这些内容说得好，还是自己真正口语得到提高了。 假设二：机器能够很好地判断发音是否正确。现在深度学习如火如荼，流利说做到了完全在本地就可以用人工智能算法判断发音是否准确，但是就我个人的体验来说，机器对于较短的单词发音过于严格，例如：are, is, it, there, with 这些单词，常常会显示成黑色（读得不好），而一些长的单词，比如 comfortable, birthday, 即使读得自己都感到有些错了，但是机器有时会显示成绿色（读得好）。我问了一下我们公司（猿辅导）的首席科学家邓博，他说这些简单的单词因为标注数据多，所以做得比较精确，而那些长的单词，因为标注数据要做多的话工作量很大，所以只能降低召回率，以便保证召回数据的正确率。 但是这些问题其实都还好，因为口语练习最重要的就是说，即便你它判分不准，只要你天天坚持说 30 分钟，还是有效果的。 我之所以后来没有继续学，其实是因为「懂你英语」在通关的设计上，加了很多不合理地设计。比如到达 Level 4 之后，很多关卡的通关，依赖的是你背下前面的课程。我还记得 Level 4 的第二张卡片中的一个关卡，要求将文章的内容进行排序，除非你反复学习背下文章内容，否则是无法通关的。但是这其实并不能锻炼口语能力，只能练习记忆力。所以这让我感觉这个课程学习起来效率有些低下。类似的记忆考试挺多，有些考试直接就问：How long did he stay in China? When did he graduated? 这些都需要背。对于追求效率的我来说，我觉得背下课文通关没有意义，我需要的是练习口语，而不是熟悉并背下课文。即使要背下课文，我也希望是以高效地方式来背，而不是通过只听不看的方式来背诵。 最后，整个 App 的 Bug 还是挺多的，一些 Bug 让我甚至感觉到产品功能没有被仔细使用过，因为细心使用的话，明显就能体会到。不过相对于上面的产品问题，这些问题还不至于致命。 总结就我个人感觉，「懂你英语」是一个差一点就成功的产品，很多地方可圈可点，它让我看到了未来在线教育产品的雏形。 如果未来它能够改进关卡设计上再进行打磨，同时机器在判断读音准确性上能够有再进一步的提升，那么确实有可能成为一个不错的语言自学服务。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"PM","slug":"PM","permalink":"https://blog.devtang.com/tags/PM/"}]},{"title":"信息的迷失","slug":"talk-about-information-explosion","date":"2016-12-03T14:41:46.000Z","updated":"2024-01-06T14:52:37.930Z","comments":true,"path":"2016/12/03/talk-about-information-explosion/","permalink":"https://blog.devtang.com/2016/12/03/talk-about-information-explosion/","excerpt":"","text":"信息的爆炸还记得我读小学的时候，那个时候还没有互联网，所有人获取信息的渠道都来自传统的媒介：图书、报纸、广播、电视。那个时候，我无聊的时候可以把一本书反复翻，反复看，因为并没有什么别的书可以看。电视的普及应该是第一次将人们获取信息的能力进行了放大，电视除了让人们获取新闻之类的信息外，更多的是使得人们从中获得娱乐信息，即娱乐的方式从传统的纸媒和广播，变成了多媒体视频，进而产生了一个巨大的娱乐产业。 互联网的产生，除了让信息的获取成本变得极为容易外，同时也让信息经历了再一次的爆炸。由于信息实在太多了，所以有了搜索引擎，帮助我们检索需要的信息。另外，wikipedia、大学的 Mooc 视频，让大量优质的内容获得也变得极为容易。 信息的触手可得以前我们要接入互联网获得信息，我们通常需要打开电脑，这本身就是一个昂贵的成本。现在由于智能手机的普及，接入互联网变得极为容易，我们甚至不需要解锁输入密码或指纹，在手机的锁屏界面上就可以获得大量的信息。 移动互联网真正牛逼的地方就在于它改变了互联网的接入方式，它让每一个人都能做到随时在线，所以，10 年前的 QQ 有在线和离线的状态，而现在的微信则没有，所有人都始终是在线的。 信息的迷失可是问题是：没有人能够消费完这么多的信息。我们有一款初高中生的题库 App：猿题库，到现在为止我们收录了百万级的题目，没有人能够做得完这么多题目。所以我们提供了智能的推荐算法，帮助学生找到最适合他练习的题目。 信息检索和推荐算法，某种程度上解决了海量信息的获取问题，但是却解决不了注意力被分散的问题。 让我们看看这个场景：某一天你 6 点钟回到家，打算做一件事情，突然你手机收到一条 Push，其实是一条网易新闻的推送，新闻的标题很吸引人，于是你打开了。看完这条新闻，你不自觉地又看起来别的新闻。看完新闻后，你又不自觉地打开微信，翻朋友圈的消息，给好友点赞，点完一圈赞后，你又打开微信订阅号，查看订阅的一些文章。等你突然觉得困了，你才发现本来要做的事情完全忘记掉了！ 基本上，那些用于你打发碎片时间的应用，不但把你的碎片时间打发了，而且把你的主要时间也打发掉了。 是的，大部分在信息面前迷失掉了，我的母校北京师范大学心理学系曾经专门有人研究过人们在电脑和手机上注意力的转移，大部分人只要稍不加控制，大脑的注意力就轻易地被各种红点，通知提醒，QQ 消息或者浮窗广告吸引了。 信息的屏蔽总会有一天，大家都会意识到信息太多也是问题，然后会学会屏蔽信息。 我发现的最简单的屏蔽信息的办法是将自己当天的 Todo List 写在一张小小的便签纸上，然后贴在屏幕的一角，做完一件事情则划掉进行下一项。如果因为各种原因（电话，短信，别人的打扰）而中断，我就可以通过这张小小的纸片找回自己的目标。 当然，我们也可以用更复杂的办法，例如使用番茄工作法，或者 GTD 中提到的任务处理方式，来使得自己更加容易专注地处理信息和任务。 大家太依赖手机了，甚至离开手机太久都会不舒服。不知道大家有没有试过将手机关机一整天？我相信你会感受到你就像被世界屏蔽了，失去了和整个世界的连接。但是其实，人们总是需要一些长时间的思考的，或许是解决工作上的问题，或许是个人的一些规划，或许是思考未来，这些时候，断开和世界的连接反倒是好的。 乔布斯在他的自传中提到他年轻的时候很喜欢禅修，在我看来，这其实就是一种放空大脑，让自己专注于思考的一种体验。一旦人们体验到专注思考的好处，就不会那么依赖网络了。 自媒体的崛起和衰落在传统的年代，明星出名都是需要依赖传统媒体的，或许是报纸，或许是电视，而这些渠道有着极强的控制力，所以可以轻易对明星进行封杀或捧星。但是，互联网的出现，使得信息传播的渠道变得不但多样化而且免费，像新浪微博，微信公众号，知乎，一些论坛，都成为大 V 极好的成名渠道，而且这些大 V 的成名，基本上完全依赖于他们自己的本身的能力，靠本事吃饭，与渠道无关。 于是，这成为了自媒体人最好的年代，优质的内容可以在极短的时间内传播开来，帮助大 V 获得粉丝和影响力。 但是，人们的注意力终究是有限的，在早期的少量自媒体人享受到渠道开放的红利之后，由于信息的爆炸，更多的优秀内容反倒是被埋没在信息的汪洋之中。后期的自媒体人要获得足够的注意力，需要在内容质量上花费更多的心血。大部分无法创建出极度优秀的内容的自媒体人，在这样的年代完全没有了翻身的机会。 渠道的再次崛起信息的爆炸，自媒体的涌现，使得人们再一次需要一种内容筛选的服务，即便这种服务是付费的。于是我们看到，一些基于优质内容的付费服务再次得到人们地青睐，比如「得到」App，比如知乎Live，各种收费直播服务。这些付费服务的成功原因有很多：被服务感、直播的参与感与真实感，但不可否认，对于优质内容的价值认可，以及在海量信息中选择的无助，也是这些服务被认可的基础。 未来未来的信息消费是更趋于集中还是分散，我没有定论。不过未来相比信息本身的价格，人们的时间成本会变得更加重要，因为每一个人的时间都是稀缺资源，没有人愿意拿自己的生命来「试错」。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"什么是爱 - 读《少有人走的路》","slug":"what-is-love","date":"2016-09-16T15:04:36.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/09/16/what-is-love/","permalink":"https://blog.devtang.com/2016/09/16/what-is-love/","excerpt":"","text":"引言爱是什么？这或许是一个永恒的话题。我很少从学校的传统教育以及家庭教育中获得这方面的知识。 我小的时候对于爱的解释，印象中的故事竟然都是来自是电影：一部是 《泰坦尼克号》，另一部是 《真爱至上》。《泰坦尼克号》的男主 Jack 为了心爱的人，放弃自己生存的机会，让我以为爱是一种牺牲。而在大学时看的《真爱至上》，电影中的 10 个故事，讲了各种各样爱的故事，有小朋友之间的爱，有情侣之间的爱，更有同性之间的爱。电影最后的一句台词给爱下了一个更广泛的定义：「Love actually is everthing.」， 我现在 30 多岁了，结婚了，也有了小孩，有些时候我觉得爱就一种亲情，但是又说不清楚。因为家庭生活中其实会有各种琐事，各种争吵，有些时候也会困惑，不知该如何处理。 还是要感谢李笑来老师，他推荐的这本 《少有人走的路》，用更详尽的篇章，从一个学术的角度讨论了什么是爱。这本书的作者斯科特·派克是一个心理医生，在书中的第二部分，作者详尽分析了各种关于爱的行为，告诉我们什么样的行为是爱，什么样的行为不是爱。 爱的定义作者从他的角度，给爱下了如下的定义： 爱，是为了促进自我和他人心智成熟，而具有的一种自我完善的意愿。 这个定义非常有意思，完全不同于我们以前了解到的爱的描述，我们从中可以看到两个特征： 爱可以使双方都获得心智成熟。这就像是杨过和小龙女的「双修」一样，是一种共同进步的互利行为。 爱是一种自我完善的意愿。我们都希望通过它获得心智的成熟，人格的独立。 爱的误解弄清楚什么是爱是很难的，但是反过来，弄清楚什么不是爱相对来说容易一些，所以本书中分析了四种常见的错误的「爱」，分别是：坠入情网、依赖性、自我牺牲、（仅有）感觉。 坠入情网坠入情网不是爱。这可能是最常见的误区吧。年轻时的我们，由于荷尔蒙的分泌，对异性产生好感，进一步渴望和异性交往，然后坠入情网，最终啪啪啪以及结婚生子。作者认为坠入情网不是爱的核心理由是：坠入情网的 “爱” 不会持续太久，不管爱的对象是谁，早晚我们都会从情网的羁绊中 “爬出”。有一个词叫「七年之痒」，其实也是说这个道理。坠入情网这种爱更像是一种冲动和激情，随着时间会慢慢消退。 刚刚说到爱需要使双方心智变得成熟。但是坠入情网，惟一的好处就是消除寂寞。即便经由婚姻，使这一功用得以延长，也无助于心智的成熟。 悲观一点说，坠入情网其实是一种受人类本能控制的，来自我们 DNA 中繁衍需求的刺激。它的意义在于增加人类生殖机会，促进物种繁衍和生存。但是坠入情网其实是产生真正的爱的一个很好的媒介，后面我们再详细讨论。 依赖性依赖性不是爱。我们会见到各种依赖性的行为，比如小孩对父母的依赖，妻子对丈夫的依赖，甚至父母对小孩也有依赖。一些小孩长大之后离开家门，父母会特别难受，但都会调整接受。如果一个父母因为对小孩有依赖，阻止孩子去外地上学或者工作，那么这种依赖性就不是爱了，因为它其实对孩子的发展并不有利。 反过来，父母的这种行为对于自己也是不利的，因为这也体现出他们的人格并不独立。总有一天，孩子还是会追求自由与不受控制，到时候父母也容易产生心理问题。 所以，过度的依赖行为其实使孩子和父母都丧失了人格的独立性，是不利于心智发展的，所以不是爱。 自我牺牲自我牺牲不是爱。我们常常见到这样的行为：爷爷奶奶给孙子孙女买特别多的玩具，什么事情都惯着孩子，为了满足孩子的各种需求，甚至会牺牲一些自己的东西，例如金钱，健康，时间。这些牺牲如果是利于孩子身心发展的，那就是爱；如果最终使得孩子产生很坏的生活习惯和沟通方式，那么不但不是爱，还是一种伤害。 所以，自我牺牲的付出不一定是爱，还得看付出之后的效果是怎样的。 感觉爱，不是感觉。爱是一种行为，而不是一种感觉。如果你整天只是把爱挂在嘴上，但是并没有任何行为付出，那么其实这就不是爱。作者在书中指出，一些家庭的父母并不关心孩子的身心，只知道通过简单粗暴的方式来教育孩子，嘴上说是爱孩子，其实根本就没有付出真正上的行为。 作为父母，把孩子喂饱，提供教育相关的资金支持，仅仅是尽到了最基本的义务。而和孩子一起玩耍，交流，解决孩子的困难，纠正孩子的错误，关注和帮助孩子成长，才是更重要的行为。 如何爱那么，我们应该如何去爱呢？作者介绍了一些原则： 首先，爱与不爱最显著的区别之一，在于当事人的意识思维和潜意识思维的目标是否一致。 第二，爱是长期的和渐进的过程。爱是自我完善，意味着心智不断成熟。爱，能够帮助他人进步，也会使自我更加成熟。 第三，真正意义上的爱，既是爱自己，也是爱他人。爱，可以使自我和他人感觉到进步。不爱自己的人，绝不可能去爱他人。 第四，爱是自我完善，也是帮助他人完善。它意味着持续努力，超越自我界限。 在以上原则下，作者提供了一些实践的办法： 关注：爱最重要的体现形式，就是关注。体现关注，一种最常见、最重要的方式，就是 “倾听”。 自律：自律，是将爱转化为实际行动的过程。这里面涉及情绪的控制，我们既不能过于放纵情绪，也不能过于压抑情绪。 独立：爱的重要特征之一，在于爱者与被爱者都不是对方的附属品。付出真爱的人，应该永远把爱的对象视为独立的个体，永远尊重对方的独立和成长。 最终，如果我们这么做，就会产生精神贯注的现象： 真正的爱，是自我完善的特殊体验，跟自我界限有着密切关联。陶醉在爱的情感里，我们感觉灵魂无限延伸，奔向心爱的对象。我们渴望给对方滋养，我们希望对方成长。被自我界限之外的对象吸引，迫使我们产生冲动，想把激情乃至生命献给对方，心理学家把这样的激情状态，称为 “精神贯注”。我们贯注的对象，正是所爱的人或所爱的事物。 爱的风险即便我们做到了真正的爱，但是也会面临一些风险： 死亡的风险：精神贯注的代价之一，似乎是或早或晚你都要因为贯注对象的死亡或离去，让自己饱受痛苦的折磨。如果不想经受个中痛苦，就必须放弃生活中许多事物，包括子女、婚姻、性爱、晋升、友谊，但惟有这些事物，才能够使人生丰富多彩。 独立的风险：我们必须不再完全依赖任何人，成为一个人格独立的个体。 承诺的风险：我们需要具有责任感，承诺与爱相关的义务。 冲突的风险：我们需要面临与所爱的人的冲突，并且在冲突发生时，以帮助对方心智成熟作为出发点，来解决冲突。只有以爱为出发点，投入全部的情感，做出真挚的承诺，才能更好地滋养对方的心灵。例如，父母和孩子发生冲突时，首先应该自我检讨，认清自己的价值观，才能采取正确的方式，才能恰当地教育孩子。 关于死亡的风险我深有感触。我现在 30 岁了，整个身体都不像 20 多岁那样有活力了，加班太晚会感觉特别累。我相信有一天，我会发现自己真的老了，不光精力大不如从前，可能视力，听力都退化了，那个时候我需要放弃很多年轻时获得的成就，但是这就是人生，所有人都逃避不了死亡。 关于冲突，我也有一些体会。我有时候在家里会抱怨一些事情，后来我发现，这除了让我和家人产生矛盾以外，完全无助于解决任何问题。所以我开始反思我是否应该用更加有效的方式来和家人沟通，试过几次之后，我发现家人也这些事情也有自己的看法。在冲突发生时，用诚实和谦逊的态度先自我反省，再进一步沟通，最终大家会学会到更好的相处方式。这确实也让我的心智更加成熟了，对情绪的控制（自律能力）更强了。 总结《少有人走的路》 让我对爱有了更客观的认识，一句话总结：爱就是一种精神贯注的行为，它可以使自己和对方的心智都成长起来，从而获得健全的人格。 但是作者也坦诚地说，这样的定义还是无法解释很多爱的行为，不过对于我来说，已经学到很多了，推荐给大家。以下是本书第二部分的思维导图总结：","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"打开你的脑洞","slug":"open-your-brain","date":"2016-09-04T14:20:11.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/09/04/open-your-brain/","permalink":"https://blog.devtang.com/2016/09/04/open-your-brain/","excerpt":"","text":"职业病我的大学是在北京师范大学读的，当时读的一个叫做「励耘实验班」的专业（现在已经取消了），美其名曰第一年进行通识教育，第二年选专业。我最终选择了计算机专业，并且有幸和一群不同专业的室友一起生活了四年。 其中一个室友选了「数字媒体」专业，他在专业学习过程中，需要每天看各种电影，分析各种电影片段的拍摄手法。那个时候（03 年）网络还不发达，他有一个大书架，上面全是他买的各种电影光盘。有一次和他聊天，他说道：「我现在看电影已经无法融入剧情中了，因为我一看见电影，脑海里面想的就是当前的摄像机机位在哪里，用了什么拍摄手法，为什么导演要用这样的手法」。 有人把这种现场取一个名词，叫「职业病」，就像警察一样，不管有没有上班，都会下意识地观察有没有行为异常的路人。而我做为一个 iOS 开发者，每每试用一款新的 App，看到一些交互效果，第一想到的不是这个效果多酷，而是想这个效果是用什么技术方案做到的。 我以前觉得这就是「职业病」，但是突然有一天，我发现这还不是「职业病」这么简单的事情。 脑洞事情的转折发生在我开始转型，从一个 iOS 开发，转变为一个团队管理者。我开始参与产品和 UI 的讨论。这个时候，我发现我开始关注技术实现之外的东西，拿到一款 App，我不但会考虑它的技术实现，也会考虑产品经理这么设计的意图，也会考虑用户使用这个功能的场景，还会考虑视觉设计的特点。 于是，我觉得这不是职业病，而是打开了另一个思考问题角度的脑洞。 就像我的室友打开了「艺术创业」的脑洞一样，他可以从各种电影中吸取到电影拍摄的专业知识，而我却对此完全不会有感受。同样，我使用一个 App 可以带来技术实现上的思考和提升，而我的室友却完全不可能有这方面的感受。 每一个脑洞的打开，都代表着一种新的观察世界的视角，以及这个视角下的思考、学习和积累。iOS 开发者由于需要大量地接触到终端用户，产品原型以及 UI 设计，本来可以学习和积累出大量的产品设计、交互设计 和 UI 设计的知识，但大部分 iOS 开发者在面对产品稿的时候，却只知道思考这个功能应该如何实现。这些 iOS 开发者只打开了技术实现的脑洞，无论他们做多少个 App，他们也无法得到产品设计上的提升。 另外有一些 iOS 开发者，他们喜欢和产品经理聊天，了解产品稿背后的设计意图，他们还会反馈给 UI 设计师一些 iOS 下的视觉规范。在一些产品设计非常难以实现的时候，他们会站在产品经理的立场上，提出不损害产品意图，又有更容易实现的技术折中方案。这些 iOS 开发者，不但打开了技术实现的脑洞，也打开了产品设计，视觉设计的脑洞。每一次 App 的开发过程，他们除了能够提升开发能力，还能提升产品设计和视觉设计能力。 服务器端的同学在这一点上，会吃亏很多，因为服务器端的同学大多数不需要接触 UI 稿，产品稿方面，他们的工作因为不涉及交互细节，所以也很容易忽视产品实现的细节。相对来说，他们更难以打开产品设计，视觉设计的脑洞。 感受每一个脑洞都代表着一种新的思考问题的角度。我现在管理小猿搜题产品技术团队，我开始越来越关注大家的工作流程，沟通方式是否顺畅，希望让每一个人都能舒服地工作，高效地产出。这个时候，我打开了管理的脑洞，我开始注意到大家的协作方式，注意到非正式领导的组织过程，注意到跨组协作的效率问题，注意到细节问题的处理过程。我会观察和思考这些事情，甚至会尝试给组织加入一些规则或增加一些沟通来改善一些问题，这想在这个团队中，很少有人会像我一样关注这些问题，所以他们也很难像我一样积累出团队管理经验。 当你理解了这件事情之后，你就可以打开更多的脑洞了，因为很多经验的积累，并不真正需要你全职去做，而只要你仔细观察就可以了。比如你可以打开 CTO 的脑洞，看看公司的 CTO 是如何管理整个技术团队的，你还可以打开 CEO 的脑洞，看看 CEO 在哪些问题上会向员工沟通，前几天，《李大学：CTO，应该像 CEO 一样思考》 其实讲的也是这个道理。你甚至可以打开餐馆老板的脑洞，观察公司楼下的各种餐馆的经营模式，哪些最后死掉了，哪些最后成功了。 作为一个普通 iOS 开发者，我们更应该打开的是自己上司的脑洞，看看你的老大（他或许是一个 iOS 团队负责人）是如何负责一个团队的。这样，你也可以学习到他需要哪些信息，他会怎么决策，从而有效地和他进行沟通，让他对你的工作满意。 结语打开脑洞这个叫法是我自己发明出来的，你喜欢这个思考方式吗？ 一旦你被我打开了「打开脑洞」的脑洞，你就停不下来了，好好享受从新视角观察世界的乐趣吧！ 祝大家玩得开心！ 如果你感兴趣，这儿还有我的另一个脑洞：《软件开发中的上帝模式与农民模式》","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"人格化的公司","slug":"company-with-personality","date":"2016-09-04T13:19:39.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/09/04/company-with-personality/","permalink":"https://blog.devtang.com/2016/09/04/company-with-personality/","excerpt":"","text":"企业的品牌形象与管理者的品牌形象在过去，企业总是希望将企业品牌形象与企业的管理者的品牌形象区分开，因为一个长久的百年老店可能经历多次管理者的变更。IBM 就是一个例子，我们不记得 IBM 的 CEO，但是 IBM 在企业服务方面高质量的品牌形象还是深入人心的。 传统的企业这么做无可厚非，因为他们不希望企业的管理者由于健康或别的原因，给企业带来负面影响。在传统企业盈利模式和管理方式稳定的时期，聘用一个 “职业经理人” 一样的 CEO，对于企业来说风险也不大。 但是，现在的企业发展速度已经远远超过了过去。 年轻公司的快速崛起2005 年：全球市值最大的公司分别是通用电气，美孚石油，微软，花旗，沃尔玛，BP 能源，辉瑞，美洲银行，强生，汇丰银行。 到了 2015 年，全球市值前十公司：苹果，谷歌，微软，伯克希尔，美孚石油，亚马逊，Facebook，通用电气，强生，富国银行。从中我们可以看到像 Facebook 这类公司的快速崛起。 Facebook 2004 年成立，淘宝 2003 年成立，这些公司都花了不到 10 年的时间，就成为了估值上千亿美金的公司。飞速的发展速度，使得大家不再担心企业创始人的个人魅力与企业的品牌形象融合在一起。 而且，企业管理者的个人魅力和企业本身的品牌形象其实是有相互影响的叠加作用，当企业管理者在公众中具有光环效应时，对企业品牌本身也是一种无形的帮助。在现在的中国公司中，各种企业的创始人都会注意使用个人的魅力或人格，来给自己的公司产品宣传背书。 比如锤子手机的罗永浩，360 的周鸿祎，小米的雷军，乐视的贾跃亭。对于他们来说，企业的成功至关重要，能够有一个核心的 “代言人”，是更加利于产品宣传的。这个趋势也就是近年来才开始盛行，反观老牌的中国公司 BAT 以及门户网站网易搜狐新浪，他们的创始人都要低调得多。也就是说，创新型企业的快速发展，使得越来越多创业公司采用这样的策略。 情感化认知从用户认知方面，一个具象化的人格形象，是更加有利于消费者对于企业产生认知，并且生成情感联系的。大家对于罗永浩的认知是一个理想主义者，那么就可能会为 “情怀” 买单。很多消费者的消费都是 “非理性” 的，一款产品所传达出来的任何情感（例如环保，坚持不懈，创新精神，极客精神）都会吸引到消费者，让他们购买产品而表达和宣泄自己的情感。 人格化的企业形象，会更加利于情感联系的建立。传统企业会选择明星代言的方式来做这方面的事情，但是明星可能会过气或者有负面新闻，都会对企业带来影响。一家新成立的创业公司请明星代言需要付出巨大成本，从性价比来说，让公司创始人给公司 “代言” 会更加经济和有效。所以我们甚至看到了聚美优品的陈欧为自己产品 “代言” 的营销方案。 人格化的新公司在可以预见的未来，创业公司的创始人会更加注意使用社交媒体来树立个人品牌，然后利用个人品牌为自己的产品带来竞争力。今年正好是自媒体爆发的元年，我们看到了更多个人在垂直领域创业的故事，罗振宇，文怡，凯叔，崔玉涛，他们的公司都发展得很快。 所以我相信，在未来的企业中，创始人的个人品牌会被进一步强化，而那些拥有个人品牌的创业者，除了在竞争中占据巨大的品牌宣传优势外，也能在消费者的心智中建立起一个「人格化」的公司形象。 让我们拭目以待。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"我们身边的技术人生 -《技术人创业攻略》","slug":"dev-level-up-stories","date":"2016-09-01T14:02:34.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/09/01/dev-level-up-stories/","permalink":"https://blog.devtang.com/2016/09/01/dev-level-up-stories/","excerpt":"","text":"在这个信息爆炸的移动互联网时代，我们身边总会有一些技术圈的大牛出现，介绍他们的文章大多是以技术角度，描述他们的作品多么牛逼，而我们往往除了膜拜也无从知晓这些技术人的成长经历。 带着写一些「有趣」的技术人故事的初心，《技术人创业攻略》的作者张兰开始了她的乌托邦式的旅程。她从 2013 年开始，从 SegmentFault 的创始人高阳，开始了她的访谈之旅。当时张兰并没有工作，每篇访谈耗费她大量精力，最后都免费放到网上供大家阅读。 带着这样的初心，她一直坚持完成了 37 位不同年龄，不同技术领域，不同背景的技术人。在她的采访稿中，她以技术人的真实背景出发，试图揭示出这些人成功的原因。 这些被他采访的技术人里面，包括 SegmentFault 的创始人高阳，七牛云存储的创始人许式伟这些创业公司的 CEO，也包括擅长运营的前端领域的一姐田爱娜，也有深入开源社区，成为 Linux 内核核心贡献者的吴峰光，还有资本领域的天使投资人杨轩。我也有幸在一次阿里举办的技术沙龙上认识了她，继而成为了她笔下的一个技术成长故事。 因为张兰写的这些故事都很有趣，于是有出版社愿意将它出版成书，这就是《技术人创业攻略》。但是张兰的性格里面有着极强的「处女座」式的追求完美的情结。所以这本书整整花费了她将近一年的时间进行重新的内容梳理和再采访。 仅仅为了封面的设计，张兰就多次因为不满意而调整，最后还是找到了西乔设计封面（下图）才满意。此时西乔的公众号已经成为几十万粉丝的大号了，如果你还没有看过程序员的漫画，一定得关注一下：「神秘的程序员们」（coderstory）。 最终在上个月，《技术人创业攻略》终于出版了。不过在本书出版的时候，张兰已经和她老公旅居到了加拿大，开始了一段新的生活。而张兰此时开始学习上了 JavaScript，打算成为了一个前端工程师。她的第一个小作品，是用 DFS 生成的一个迷宫，我专门看了看她的代码：https://github.com/Graciazl/RandomMazeGame/blob/master/script.js，整体的代码风格和结构完全不像是一个初学者。我想这就是我认识的张兰最好的描述：做什么事情都那么认真。 最后我得到了张兰的授权，为大家附上《技术人创业攻略》书中节选的一篇内容。这是书中唯一一位受访的外国人：Dave Thomas，《程序员修炼之道》的作者，让我们看看在张兰笔下的大神是如何成长的。 Dave Thomas：生命不息，编程不止Dave Thomas，是一位从业近 40 年的大神级人物，他和 Andy Hunt 于 1999 年合著的《The Pragmatic Programmer》（中文译名《程序员修炼之道》），是历史上最畅销的开发指南书籍，曾获得 Jolt 大奖，影响深远。Dave 是敏捷宣言的 17 位发起人之一，Ruby 语言的支持者和传播者，正是他对 Ruby 语言的传播，使 Ruby 逐渐成为与 Perl，Python 齐名的语言。2003 年，他和 Andy Hunt 成立了 The Pragmatic Bookshelf 出版公司，致力于出版软件开发相关书籍，并用开发软件的方式实现了图书出版业的重大突破。 Dave Thoma 是一位令人尊敬的大师，更是一位伟大的程序员。在近 40 年的从业生涯中，他从未间断过编程，并时刻保持旺盛的好奇心和探索新技术的热情。在 Ruby Conf China 2013 大会上，Dave 接受了技术人攻略的访谈邀请，并在回信中 100% 地肯定了技术人攻略 “传递技术热情” 的理念： “I think your ideas about spreading passion are 100% correct. I would love to help spread this message.” 希望大师的访谈可以鼓励更多还在奋斗的程序员，技术人攻略也会继续把这种对技术的热爱传递给更多的人。 技术人攻略：您从什么时候开始接触编程？编程带给了您什么样的乐趣？在不断超越自我的过程中，是否遇到过什么困难，是否曾有过想放弃的时刻呢？ 我初次接触编程是在 1972 年，那时我还在英国上高中。有一部分人提前完成了考试，在学校没有别的事情可做。正巧校园对面的科技学院开设了编程课，于是我们申请了参加这个一周两次的课程。 我最初打算学数学专业，但当我开始编程，我慢慢爱上了它。 那时候我用 Basic 语言，将代码敲到纸带上，通过一台 110 波特的调解器将数据传到大型机上运行。虽然如此麻烦，但我发现编程十分符合我的大脑的运作方式——我喜欢这种创造性和精确性兼备的体验。 从那时开始，我从未间断过编程。我十分确定——除非是在度假的时候，我生命中的每一天都离不开写代码。 我也常常会有感到艰难的时候，但每次考验过去之后，你的技艺都将更上一层楼。所有值得做的事情都是困难的，但克服这些挑战不仅会让你更强大，还会让你变得更加投入。 技术人攻略：我们处在一个快速变化的时代，新的技术层出不穷，程序员应该如何保持和这个世界同步，持续提升自己的竞争力？ 想要跟上技术更新的速度越来越难。当我开始编程的时候，主要通过阅读书籍和杂志了解进展，但现在几乎每天都有新概念出现。 但事实上很多的新事物只是人们对旧东西的再发明。我们行业里的许多人，眼光只看向将来，对计算机的历史却知之甚少。这些人想要创造东西（当然是好的），但他们并不知道自己想做的东西在 20 或 30 年前已经实现了。 正因为如此，许多新生成的事物其实并没有那么新。对我来说，要跟上潮流就变得简单了，因为看到它们就会让我想起 “啊，这和 X 很像呢”。 但同时，也确实有一些不错的创新。我每个月总有那么一到两次，会遇到很有意思的东西，让我有兴趣去尝试一下。阅读技术内容是有趣的，但只有通过尝试才能认识得更加深入。 这很花时间，但对于程序员来说这种投入非常重要。如果不这么做，很快我们就会被淘汰。 技术人攻略：在大公司里，职位被划分得很细，例如前端、后端、运维、数据库等，程序员被固定在了公司设定的职位上，您认为程序员应如何提升技术的广度和深度？ 专业化分工属于昆虫世界。真正能够改变世界的人：他们具备更加广泛的能力，并能将不同的技术结合起来创造价值。 我认为很多公司并没有意识到这点，他们更乐于创造层级制度和把员工限制在某个职位上。 但是也有些不一样的公司，懂得通过制定目标和提供指导让程序员有最好的产出，而不是监督所有的细节。这些公司理解一个优秀的程序员可以同时胜任数据库设计、规划应用部署，也许还喜欢解决技术支持方面的问题。 我鼓励年轻程序员获取一些在不同的公司工作的经验，以寻找适合自己的工作方式。例如试试在大公司和在创业团队工作有什么不同，甚至尝试下独自工作。一旦你了解了自己适合的方式，就可以找到或者创造出合适的职位，让自己做得更好。 作为一名员工，很容易抱怨自己的公司，或者怀有这样的想法 “我就是一个普通人，没有能力改变什么”。但事实上，你有责任作出改变——让事情变得更好。这种责任不仅是对公司的，而且也是对自己的。看看你是否能让公司有所改变，如果无法改变现状，那么你应该换一个更适合自己的环境。 技术人攻略：《The Pragmatic Programmer》影响了非常多的人，如果这本书出修订版，您打算做哪些改变？今天，一个讲求实效的程序员正在做些什么？ 我和 Andy Hunt 常常会讨论这件事。实际情况是，虽然书上的案例看上去古老了一点，但背后的概念仍然很适用。无论你是做 C++ 还是 Javascript 编程，DRY（注：DRY 即 Don’t Repeat Yourself，不要重复自己）原则仍然适用:) 我个人认为可以修改或者去掉一些小的 tips，但没什么大问题。 如何做一个高效的程序员：do what works, and work at what to do。“do what works” 意味着你应该不断问自己 “我正在做的事情有什么样的价值？”，每天都尝试寻找提升所做事情价值的方法。“work at what to do” 意味着要时常回顾，从全局角度看问题，并且寻找改进工作的新方法。 技术人攻略：您是一名技术高手，又拥有自己的软件公司，您觉得程序员应该创业吗？程序员创业有哪些优势和劣势？ 这是一个很棒的问题，但我也还不知道答案。 我的一个弱点在于我喜欢让事情保持简单——我认为大多数程序员都喜欢这点。但现实世界——公司运作的世界，并不简单。我不得不克服把事情过度简单化的诱惑，因为我知道这样会让自己错失机会。 我认为程序员从事商业，最重要的强项在于我们懂得事物的关系如何。管理代码的原则，同样可以用在管理公司上，这也是 The Pragmatic Bookshelf 这家出版公司成功经营的原因之一。我们在一开始的时候，并不知道图书出版公司该如何运行，所以我们采用了管理软件公司的方式去产出图书，而不是产出代码。结果，我们将版本控制、持续系统构建，以及全自动化等方式运用在了商业运营的方方面面。其它出版商无法做到这些，我们对于出版行业的无知成为了最大的优势。 技术人攻略：在 Ruby 大会上听说您最近在关注一门新语言 Elixir，它为什么吸引您？您会像推广 Ruby 一样去推广这门语言吗？它是否代表了接下来的技术流行趋势？ 我非常确信未来的世界属于并行和分布式，五年之内，还要编写一个从头到尾顺序化执行的程序，这将是一个笑话。 但同时我们并没有拥有真正可以让我们创建分布式和并行系统的工具，用 Ruby 或 Java 写并行代码很容易出错，用 Javascript 也同样痛苦。 Erlang 诞生差不多 25 年了，这种语言的目的就是要进行分布式和并行编程，就是解决大规模和可靠性问题——在后者的环境中，要保持代码一直处于运行状态，即使代码在升级时也是如此。 Elixir 则没有这个问题，这种语言看上去跟 Ruby 很像，非常易于理解和编写。但是它运行在 Erlang 虚拟机上，这意味着它可以获得 Erlang 的一切好处。同时又可以胜任 Erlang 完成不了的任务，它有很强的元编程能力、宏和协议等方面也不错。 Elixir 会统治世界吗？可能不会。但我认为它代表了未来的方向。学习 Elixir 的过程可以让我理解未来的编码方式。五年后我可能不会用 Elixir，但我十分确信我会用一些类似的语言，我通过 Elixir 学到的东西仍然可以帮助我。 这听上去好像是我认为 Elixir 不会流行，但其实我不这么想。到目前为止，Elixir 是我们所拥有的最好的语言和运行时之一。当我没有为（由 Ruby 编写的）已有系统写代码的时候，我会用 Elixir 开发，我十分喜欢它。 我鼓励其他程序员试试 Elixir(或者其它类似的语言)，我总是鼓励程序员去学习更多的东西。 技术人攻略：在移动互联网时代，产品的开发模式和以前互联网时代相比，有哪些新特点？ 我认为程序员面对的世界和五年前相比有了显著的变化。浏览器基本上还和 IBM 将老式 3270 终端连到主机上的应用一样——你向它发送数据，用户输入一些东西，然后浏览器给出回应。还是以服务器为主。我知道：客户端在不断加入很多令人头痛的东西，比如 JavaScript 应用什么的，但是整体架构仍然一样。我认为浏览器技术基本上已经进入死胡同。我观察身边的人——他们在手机和平板上使用 App，只有在必须用到浏览器的时候才会用一下，移动世界是以用户为核心，而非以服务器为核心的。 在移动 App 上，客户端掌管一切，服务器仅仅作为资源提供方。这要求程序员掌握一些新的技能和技术支持这种结构。在客户端，我们需要通过编写复杂的，异步的应用，并且将这些应用运行在一系列不同的设备上（不仅是手机和平板）。在服务器端，我们需要从 Rail 风格的应用转向更灵活、更多以联合方式运行的架构。（这正是 Elixir 令人兴奋的原因之一。） 技术人攻略：去年的 Qcon China 上，您谈到了敏捷的腐化和到底什么是敏捷，有没有哪些软件项目领域，是敏捷开发模式不适用的？ 你的问题认为，“敏捷” 是一种东西。 真相是，“敏捷” 并不存在。它不是一种 “东西”，不是一个名词。人们是把它当成一个名词开始用起来的，但是他们并不理解背后的含义。 “敏捷” 不是一种东西，敏捷是一个形容词——它描述了一种东西。你可能有一个敏捷的团队，或者一种敏捷的过程，但你却从来不是 “敏捷”。 这是什么意思？这意味着那些向你硬推 “敏捷” 这个名词的人在撒谎，因为 “敏捷” 是买不来的。 相反，敏捷是因人而起的——它来自于那些希望把事情做得更好的个体。这些个体观察如何做事，并寻找改进事情的方法。Kent Beck 说这需要勇气，他说得没错。每当你尝试做出改进，你都在尝试改变现状，你将直面风险，你挑战了那些和你共事的人，他们也会用挑战来回敬你。 但是，我认为：在任何环境下，这些挑战和相关的讨论都是合适的。 技术人攻略：您接触过中国的程序员吗？您觉得他们和西方的程序员有哪些区别？ 我喜欢来中国的原因之一，就是可以和这里的程序员交流。 这次的中国之行，我们在一家创业孵化咖啡馆（注：车库咖啡）渡过了非常愉快的一段时光。大家的活力和热情让我和我的妻子非常震惊，她甚至还为此写了一一篇博客。 西方的程序员也拥有这样的热情，但我在中国遇到的程序员表现出更多东西。或许是因为中国程序员要在更困难的环境下工作，又或许是因为中国的市场正开始爆发。不管是因为什么，我总能从中国程序员身上感到更多能量。 中国同时还有另外一类程序员，我在和他们谈话的过程中注意到，他们把工作当成任务。或许在家庭的推动下进入这个可以获得一份 “好” 工作的行业，或许想在一个大型机构里寻求安全感。不管是出于什么原因，这类程序员身上都缺乏激情，缺少一份对他们所作事情的热爱。这令人伤心，因为写程序真的是一件非常有成就感，非常让人满足的事。我建议这些程序员们看看我妻子的那篇博客上的照片，问问自己是否也愿意加入其中，是否愿意向桌子对面的人分享自己的新想法？他们可以做到——任何人都可以做到。 采访时间：2013 年 11 月 7 日 附：Dave Thomas 妻子的博客文章——The Future晚餐过后，大会组织者将我们带到了一个创业孵化器——一家大型的互联网咖啡馆，年轻的中国技术创业者们在这里工作、和投资人会面、推销想法、编写代码——这些事情都同时进行。这一切简直是太赞了！星期天晚上的 11 点，我们走进了这个灯光昏暗、大堂几乎没有家具的路边办公室。穿过后门，上了楼梯，直接加入了充满创业热情的人群。我们比房间里的人年长得多，他们有着令人惊叹的能量，几乎所有的人都在参与创业项目。他们出来聊天，碰撞想法，并马上付诸实践。Dave 被包围了，起先，我以为他们是在寻求某种投资。但并不是——我彻底错了。我们听到，并不断听到，想投资他们的人比他们需要的多得多。他们想了解 Dave 对自己创业项目的看法，他的祝福和他的批评——他们十分投入，期待成功。他们想有所成就，而且他们每个人都有非常棒的，独特的事业。 在一个角落里有一台 3D 打印机——正在做一个脊椎。另一个大的角落作为演示区域，配置好了笔记本的投影。后面的墙上是一组技术书架（他们向我们保证，有许多 Pragmatic 出版的书）。这里的环境是随性而自然的——桌椅随意摆放，人们可以根据讨论需求随意组合。 这些年轻人了解各个层面的知识，不仅仅是技术上的。他们理解在开曼群岛上注册公司、天使投资以及 IPO，3D 打印机旁的电脑连着 Kickstarter。这些人聪明、热情，并且很努力，一点也看不到懒惰、傲慢以及理所当然的态度。还有来自香港和台湾的年轻人，他们认为中国大陆才是做事的地方。 我对此毫不怀疑——他们说得很对。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"谈谈程序员的软技能 - 读《软技能》有感","slug":"soft-skills","date":"2016-08-22T13:49:52.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/08/22/soft-skills/","permalink":"https://blog.devtang.com/2016/08/22/soft-skills/","excerpt":"","text":"最近读到一本有意思的书，叫：《软技能：代码之外的生存指南》，这是一本相当跨界的书，内容除了介绍了技术人的职业发展之外，还涉及了自我的营销、学习方法、生产力、健身、甚至还包括理财。应该说，每一个章节都是非常有意思的，值得每一个程序员学习的内容。 《软技能》一书的内容分为以上这些章节，我也按这些章节讲讲自己的感悟吧。 职业职业一章介绍了程序员的面试，晋升，离职，远程办公，自由职业，以及创业。不管做什么事情，专业性总是第一要点。就像书中写的那样，我们应该成为「专业人士」，这就要求我们对所做的工作始终精益求精。这其实与行业无关，职业精神在任何行业都应该俱备。 在程序员这个行业，我们的职业精神在于追求代码的美，这包括架构的可扩展，命名的规范，合理的注释，合理的设计模式。但其实，我们最最欠缺的职业精神是：按时发布产品。 我们总有无数的借口：未知的技术挑战，没有遇到过的 Bug，产品需求的变更，相关联调人员的问题，但是好的程序员，总是能够在各种风险发生时，通过自己的努力保持按时上线。 在这一点上，越是大公司的程序员，反倒由于大公司病的影响，职业精神就越差。 自我营销100 个程序员里面，有 99 个不会营销，这还是乐观的说法。而我就是那个稍微会点营销的人，我从中享受到的红利已经多得超过我实际的付出了，弄得我自己都不好意思。我常常给别人说，我不是大牛，我只是喜欢分享而已。不过话说回来，一般喜欢分享的人水平都差不到哪儿去，为什么呢？因为他如果分享的内容有问题，就会被人指出来，那么他就会很快得到纠正。他如果分享的内容没问题，就会被高手看到找上门来交流，那么他就多了一个高水平的相互学习讨论的人。所以对于分享者来说，分享行为总是好事。 在中国如何做自我营销呢？基本上做到两点就可以了： 写技术博客。 发技术微博。 写技术博客好难啊怎么办？可以从翻译国外博客开始。发技术微博好难啊怎么办？可以从转发技术微博开始。看看 JSPatch 的作者 bang，人家从 10 年前就写博客了，能写不好吗？ 切忌把时间花在混各种圈子，包括 QQ 群、微信群、各种技术论坛，这对自我营销效果基本没有，而且还很花费时间。 学习很多人问我：「唐巧，我参加完培训班找不到工作怎么办啊」，因为移动互联网的泡沫，今年 iOS 新人太多，我也不知道怎么办，但是学习肯定不是参加完培训班就结束了的。 程序员必须具备自我学习的能力，而自我学习的能力第一步，就是书中第 27 章讲的「学习如何学习」，我们把它叫做元学习吧。一个学习者，应该俱备一种通用能力，就是遇到一个新知识的时候，能够有一套方法，能够迅速地学习掌握这门新知识。 在这个快速变化的时代，编程语言以及开发生态都在不停迭代升级，像 iOS 开发更是经历着从 Objective-C 向 Swift 的巨大迁移。处于时代中心的我们，没有元学习能力，如何获得竞争力？难道你工作之后，还要给企业老板说：我要请三个月假报一个培训班，学习 Swift ？ 回到刚刚说到的问题，如果你参加完培训班找不到工作，只有更加努力地多积累 iOS 开发知识，尝试让自己的能力变得更强，可以尝试自己接个外包，或者自己写一些开源组件，或者找一份实习，都是一些可能的方法。iOS 新人的市场竞争非常激烈，除了自己比别人花更多时间和精力之外，没有什么捷径。 生产力作者介绍了许多办法提供自己的工作效率，里面也提到了我以前介绍过的 番茄工作法。 我自己对于生产力的理解在前两天的 《软件开发中的上帝模式与农民模式》 文章中也提到了，效率方面的生产力，其实都是提升自己的农民模式。 本书中提到的任务分解，计时，培养习惯都是不错的实践方法。 理财本章中我们看到了一个外国程序员对于买房和期权的理解。我个人感觉和中国的国情还是有一些差距。 在中国，我和小伙伴们在过去 5 年中很遗憾地发现，工资还没有房价涨得快。身边好几个朋友经历了自己买的房子暴涨几百万的情况，还是挺吓人的。 期权方面，国内的国情和国外也不一样，小道信息的作者 Fenng 最近似乎也在这方面遭遇了一些困惑，我其实之前也在这方面遇到一些问题。关于期权，稍后我也会另外撰文分享我的观点。 健身有人说程序员是最适合当老公的，因为社会关系简单，薪水高，死得早。。。。 健身这件事情被无数人挂在嘴边，却坚持不下来。其实这件事情还是看个人对于延迟满足感的控制，像我前段时间，就坚持了四个月健身，不但学会了自由泳，而且达到了一次游 1000 米。我现在 1000 米的成绩是 29 分钟，我打算继续坚持下去，每个月减少 1 分钟。 精神作者在本章中讲了一些积极的人生观，嗯，其实就是鸡汤。身子虚的同学可以补补。 最后（活动已结束）送书活动来啦，为了庆祝人民邮件出版社异步社区成立一周年，iOS 开发与异步社区联合发起评论赠书活动。 赠书规则如下：评论留下你关于软技能的想法，我将从评论的读者中选出 5 位读者赠送此书。 本次活动最终获奖的是：Thank立言、Julin、yeafel、OSong、破船。选择他们的理由包括：留言质量较高、经常与我互动留言（微信后台现在可以查到大家的互动次数）。奖品有限，希望没有获得的小伙伴别在意～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"小青和他的 RxSwift 课程","slug":"xiaoqing-and-rxswfit-course","date":"2016-08-13T03:31:11.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/08/13/xiaoqing-and-rxswfit-course/","permalink":"https://blog.devtang.com/2016/08/13/xiaoqing-and-rxswfit-course/","excerpt":"","text":"第一次认识小青（@靛青K），是在他与梁杰一起创办的 T 沙龙聚会上。当时小青邀请到了代码家，给大家介绍了函数式编程的一些内容。T 沙龙的模式很有意思，它强调纯线下的、小范围的、免费的交流。这与现在这个强调规模与经济的互联网时代格格不入，但是不可否认的是，小青和梁杰办得很成功。就在上一次分享会中，小青邀请到了 @txx 和 h4x 为大家分享逆向，特别是 txx 现象从头到尾演示一个 App 被逆向的过程让我对逆向的实践有了更多的了解。 沙龙的茶歇期间的闲聊，我才了解到小青还未大学毕业，但是他已经在 Enjoy 开始了他的第二份实习，而这份实习中，他将会用 RxSwift 重构 Enjoy 的众多模块。我私下问他为什么选择 Enjoy，他毫不犹豫地说：「因为可以用 RxSwift 呀！」。其实这也从一个侧面反映出，业界对于 RxSwift 以及比 RxSwift 更早的 ReactiveCocoa 都处于观望的心态，真正勇于尝试的并不多。 为了学习和推广 RxSwift，小青也花了大量的精力，比如他发布了大量 RxSwift 的教程在 SwiftGG网站 和他的博客 上。今年初，小青也成为了 GMTC 2016 全球移动技术大会 Swift 专场讲师，为大家分享了 RxSwift。另外他也在编写一本 RxSwift 的书，预计年底将会出版。 与此同时，小青也在 StuQ 开设了一门 RxSwift 在线直播小班课，这个课程当前处于报名阶段，预计 8 月下旬开课。这个在线直播课程限 60 人，感兴趣的同学可以查看这里的详细介绍，你可以说这是一个广告，也可以说这是一个推荐，反正我自己是报名了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"谈谈 T 型人才","slug":"talk-about-full-stack","date":"2016-08-13T03:10:25.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/08/13/talk-about-full-stack/","permalink":"https://blog.devtang.com/2016/08/13/talk-about-full-stack/","excerpt":"","text":"「全栈」工程师前一段时间，「全栈」工程师的概念很火，不过大多数时候，「全栈」工程师指的是一个人同时写 Web 前端和后端，顶多加上一些运维工作。通常情况下，我很少见到一个人能够同时写 Web 前端 + 后端 +iOS 端 +Android 端。 在猿题库（我们现在改名叫猿辅导了）创业初期，我曾经试图同时写 iOS 和服务器端，但是我很快就放弃了。因为当时服务器端的代码量还是很大，同时有好几个人在编写。有些时候我需要加逻辑时，会涉及到他们的代码修改，这个时候我就会需要花费额外的精力来看懂他们原来的逻辑。 当时正值创业初期，我们的 Code Review 并不严格，代码的相关设计文档也不多，我只能通过阅读源码来跟上另外几个服务器端开发同学的逻辑。很快我就放弃了，因为在创业阶段，效率是第一位的，同时做 iOS 和 服务器端，使得我在服务器端不够专注，效率变得低下。 从那之后，我就意识到，「全栈」工程师可能最适合的场景就是 Web 前端 + 后端的偏前端的逻辑。因为那个场景下，前端工程师可以省掉沟通接口的时间，也可以自己统一前后端的模版，甚至他可以尝试统一语言，同时用 JavaScript 写前后端（在后端使用 nodejs）。 而在别的职位上，是很不适合全栈的，因为这样工作产出会下降。 T 型人才那我为什么又想聊 T 型人才呢？是因为我觉得 T 型人才和全栈不一样。在我看来，T 型人才有一门自己擅长和精通的语言，同时又有足够宽的视野，使得他在合作的时候，能够更多地站在对方的立场上考虑问题。 打个比方，做过服务器端开发的同学，再转而做客户端开发，就会更加注意 Restful 接口的设计合理性。相互之间协商接口时，知道什么样的方式服务器端好实现，什么样的方式不好实现，然后定出来的接口就会让对方非常舒适。 与此同时，T 型人才对于自己理解和学习新东西，也是有很大帮助的。我之前做过 Java 语言的服务器端开发和 JavaScript 语言的前端开发，之后才转做 iOS 开发。各种语言和开发环境接触多了就发现：其实很多概念都是相通的。我想我之所以当时学 iOS 开发上手那么快，也是由于在别的语言上有积累。 其实对于移动开发来说，iOS 和 Android 也有很多相同的概念，比如 iOS 的 UIViewController 和 Android 的 Activity。当然，它们也有很多不同的技术细节，比如对界面排版设计，iOS 因为设备屏幕单一，所以刚开始选择了简单的绝对定位，后面选择了 size class 的方式。而 Android 因为屏幕分裂严重，所以选择了更加流式的排版设计。 iOS 因为追求界面的流畅和性能，选择了引用计数这种相对麻烦的内存管理方式，而 Android 因为需要借力 Java 语言本身的生态和苹果竞争，所以采用了垃圾回收这种会带来潜在卡顿风险的内存管理方式。每年的 Google IO 大会出现的新技术，并不比 WWDC 逊色。今年 iOS 10 的一些改进，也看到了不少 Android 的影子。 如何成为 T 型人才那么如何成为 T 型人才呢？我们老大郭常圳想了一个办法：轮岗。轮岗的意思是，当你成为某一方面的专家后，跳出自己的舒适区，转而到一个新的技术领域从头学起。 在我们公司，很多早期员工都经历过轮岗。比如我曾经从服务器端转到前端和 iOS 端，也是轮岗这个激励带动的。yangyz 从服务器端转到 Android，xuhf 从 Android 转到服务器端，zhangyc 从 Web 前端转到后端。每一个轮岗工作，都是对我们极大的挑战，但是让我们都成长为 T 型人才。 但是，轮岗的意思绝不是做一个技术方向「三心二意」，每一次转换技术方向，都应该是对前一个技术方向至少做到熟练掌握的程度才行，而我自己觉得，不经过一到两年的实践，很难称作熟练掌握。所以，轮岗的行为应该是低频的，而且是面向那些最优秀的开发者的。 这一点有点像大学的换专业，在我们学校，大一的学生可以在一学期后申请换专业，但是前提是这个同学在愿专业成绩达到前 10%。 换专业和换技术方向一样，机会只会给做得最好的人，公司不会因为一个人在 iOS 开发上做得不好，就把他轮换到别的开发岗位。 创业初期在创业初期，很多时候技术创始团队由于缺人，每个人都是多面手。上次一个朋友说，他自己完全了服务器和网站的开发，然后又自己开发了 iOS 和 Android 端，实现了真正的「全栈」。 对此，我完全不否认有这样的人存在，而且我认为创业初期这么做也是完全合理的。因为创业初期重要的是做出东西，而招不到人的情况下，自己动手干是最简单直接的方式。 我想我更想表达的是一个词：效率。举个例子，假如这个创业公司做大了，变成 20 人的技术团队时，你会让每个人都同时做服务器，iOS，Android 开发呢，还是每个人只做某一方面？我想从效率上讲，每个人只做某一个具体的平台，效率是最大化的。这其实就是我想表达的，「全栈」工程师在理想情况下，并不是高效运作的公司期望的，只有某些特别情况下，「全栈」才有它存在的理由。 但是反过来，T 型人才是每个公司都期望拥有的，因为这样的人才视野更广，学习能力更强，沟通时会从对方角度考虑技术方案，甚至在某些技术方向没落之后，也会迅速地成功转型，这才是互联网公司理想的人才。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"如何用 Git 将代码恢复到一个历史的版本","slug":"revert-to-target-commit-with-git","date":"2016-08-06T09:39:43.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/08/06/revert-to-target-commit-with-git/","permalink":"https://blog.devtang.com/2016/08/06/revert-to-target-commit-with-git/","excerpt":"","text":"需求有些时候，在一些特殊情况下，我们需要将代码恢复到一个历史的提交版本上。而这个历史提交版本，离最新的提交已经比较久远了。 比如，我希望将如下的仓库的提交，恢复到上上上上次提交。当然，我可以一次一次的 revert，但是有没有更快更简单的办法呢？ 暴力的方式如果你的仓库是自己在用（不影响别人），那么你可以使用 git reset --hard &lt;target_commit_id&gt; 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。 对于刚刚的例子，需要执行的命令就是： // 备份当前的分支到 backup_commitgit tag backup_commitgit push origin backup_commit// 重置 source 分支git reset --hard 23801b2// 强制 push 更新远程分支git push origin source -f 温和的方式如果你的仓库是多人在协作，那么你这么操作会使用别人本地的代码库混乱，所以只能建一个新的提交，这个新的提交中把想取消的提交都 revert 掉，那么具体应该如何做呢？方法如下： 首先，和刚刚一样，用 git reset --hard 23801b2 将代码切换到目标提交的 id。接下来，用 git reset --soft origin/source 命令，将当前代码切换回最新的提交。 执行完上面两步后，你的仓库还是最新的提交，但是工作区变成了历史的提交内容，这个时候用 git add 和 git commit 即可。最终完成的效果如下： 不过经过念茜的提醒，该方法需要保证 reset 的时候没有别人做新的提交，如果有的话，会一并把别人的提交也撤销了。所以还是挺危险的，慎用。 虽然用到的时候很少，但是理解它的原理有助于大家理解 Git 的工作区，暂存区和版本库的各种指针操作的意义，希望对大家有用。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"}]},{"title":"我为什么不喜欢 Core Data","slug":"i-do-not-like-core-data","date":"2016-08-04T14:47:06.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/08/04/i-do-not-like-core-data/","permalink":"https://blog.devtang.com/2016/08/04/i-do-not-like-core-data/","excerpt":"","text":"我一直不喜欢 Core Data，以前不太敢明目张胆地这么表达，现在收集到越来越多相关的信息，所以给大家分享一下，我为什么不喜欢 Core Data。 Core Data 太复杂在今年刚刚结束的 GMTC 大会上，来自澳洲的李剑做了题为《iOS 遗留系统上的架构重构》的演讲，其中就提到 Core Data 给他们 500 万用户带来了 300 万次崩溃。我想任何产品都是不能接受这样的崩溃率的。 这 300 万次崩溃是 Core Data 的问题吗？可能也不是。在现场我没有看到具体的代码细节，我更觉得这可能是 Core Data 在使用中的各种坑，需要大家注意避免的。但是 Core Data 的坑是如此之多，使得像李剑这样的资深 iOS 开发者也不得不考虑将其直接替换掉。一个好的技术框架应该是不容易出现使用错误的，所以从这个角度讲，Core Data 本身的设计就是不好的。 Core Data 学习成本高很多人觉得 Core Data 简单易学，我听了简直觉得自己的智商得到了 1 万点的伤害。反正我学习 Core Data 那阵子，Core Data 的各种概念着实让我郁闷了好久。在 OhMyStar 的作者 yu 的博客文章上，yu 这么写道： CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。 如果没有足够的时间和精力去接入 Core Data。 那选型的时候应当慎重考虑。 我想那些觉得 Core Data 很简单的人，可能更多时候是自己学了一点皮毛，就以为懂了全部吧。反正我是学不会 Core Data。 Core Data 的收益并不大如果一门技术方案学习成本高，那么我们有动力继续学习的它的唯一理由就是：它的收益也非常大。但是，Core Data 在各种性能测试中，表现出来的收益是相当差的。在这一点上，Realm 是最喜欢拿来说事的，拿查阅来说，Core Data 的性能是 FMDB 的六分之一不到，Realm 的十分之一不到。 Core Data 带来的另外的特性：例如可视化的编辑界面，关联关系的创建，数据库升级的支持，我个人觉得都不是非常大的收益。相对它带来的麻烦，这些收益微不足道。 Core Data 的这层抽象没必要其实 Core Data 是构建在 SQLite 之上，对数据存储层进行了进一步的抽象。而我个人认为，对于一个计算机专业的人员来说，掌握 SQL 就像掌握 BASIC 一样容易，关系型数据库实在太容易理解了，完全没有必要在这上面再做一层抽像，带来额外的理解成本。 所以我更喜欢用 FMDB，它只是将 SQLite 的一些方法进行了 Objective-C 语言更加友好的调用封装，除此之外，你就完全是在操作一个 SQLite 数据库。 总结使用复杂，学习复杂，坑多，收益小成本大，基本没有意义的抽象，我们还有什么理由继续学习和使用 Core Data ？ 哦，对了，我也不喜欢 Realm，有机会下次再说它。 对于我来说，FMDB 以及构建在 FMDB 上的简单的 Key-Value 存储就足够了。我之前在 GitHub 开源过一个简单的基于 FMDB 的 KeyValue 存储 YTKKeyValueStore，感兴趣的可以翻翻。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"理解 iOS 的内存管理","slug":"ios-memory-management","date":"2016-07-30T00:43:42.000Z","updated":"2024-01-06T14:52:37.929Z","comments":true,"path":"2016/07/30/ios-memory-management/","permalink":"https://blog.devtang.com/2016/07/30/ios-memory-management/","excerpt":"","text":"远古时代的故事那些经历过手工管理内存（MRC）时代的人们，一定对 iOS 开发中的内存管理记忆犹新。那个时候大约是 2010 年，国内 iOS 开发刚刚兴起，tinyfool 大叔的大名已经如雷贯耳，而我还是一个默默无闻的刚毕业的小子。那个时候的 iOS 开发过程是这样的： 我们先写好一段 iOS 的代码，然后屏住呼吸，开始运行它，不出所料，它崩溃了。在 MRC 时代，即使是最牛逼的 iOS 开发者，也不能保证一次性就写出完美的内存管理代码。于是，我们开始一步一步调试，试着打印出每个怀疑对象的引用计数（Retain Count），然后，我们小心翼翼地插入合理的 retain 和 release 代码。经过一次又一次的应用崩溃和调试，终于有一次，应用能够正常运行了！于是我们长舒一口气，露出久违的微笑。 是的，这就是那个年代的 iOS 开发者，通常情况下，我们在开发完一个功能后，需要再花好几个小时，才能把引用计数管理好。 苹果在 2011 年的时候，在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员。 在 ARC 刚刚出来的时候，业界对此黑科技充满了怀疑和观望，加上现有的 MRC 代码要做迁移本来也需要额外的成本，所以 ARC 并没有被很快接受。直到 2013 年左右，苹果认为 ARC 技术足够成熟，直接将 macOS（当时叫 OS X）上的垃圾回收机制废弃，从而使得 ARC 迅速被接受。 2014 年的 WWDC 大会上，苹果推出了 Swift 语言，而该语言仍然使用 ARC 技术，作为其内存管理方式。 为什么我要提这段历史呢？就是因为现在的 iOS 开发者实在太舒服了，大部分时候，他们根本都不用关心程序的内存管理行为。但是，虽然 ARC 帮我们解决了引用计数的大部分问题，一些年轻的 iOS 开发者仍然会做不好内存管理工作。他们甚至不能理解常见的循环引用问题，而这些问题会导致内存泄漏，最终使得应用运行缓慢或者被系统终止进程。 所以，我们每一个 iOS 开发者，需要理解引用计数这种内存管理方式，只有这样，才能处理好内存管理相关的问题。 什么是引用计数引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 Objective-C 和 Swift 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。 为了更形象一些，我们再来看一段 Objective-C 的代码。新建一个工程，因为现在默认的工程都开启了自动的引用计数 ARC（Automatic Reference Count)，我们先修改工程设置，给 AppDelegate.m 加上 -fno-objc-arc 的编译参数（如下图所示），这个参数可以启用手工管理引用计数的模式。 然后，我们在中输入如下代码，可以通过 Log 看到相应的引用计数的变化。 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSObject *object = [[NSObject alloc] init]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); NSObject *another = [object retain]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); [another release]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); [object release]; // 到这里时，object 的内存被释放了 return YES;&#125; 运行结果： Reference Count = 1Reference Count = 2Reference Count = 1 对 Linux 文件系统比较了解的同学可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于我们这里的 retain)，当删除一个文件时（相当于我们这里的 release)，系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。 我们为什么需要引用计数从上面那个简单的例子中，我们还看不出来引用计数真正的用处。因为该对象的生命期只是在一个函数内，所以在真实的应用场景下，我们在函数内使用一个临时的对象，通常是不需要修改它的引用计数的，只需要在函数返回前将该对象销毁即可。 引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。我们举一个具体的例子： 假如对象 A 生成了一个对象 M，需要调用对象 B 的某一个方法，将对象 M 作为参数传递过去。在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，那么对象 A 就需要在对象 B 不再需要对象 M 的时候，将对象 M 销毁。但对象 B 可能只是临时用一下对象 M，也可能觉得对象 M 很重要，将它设置成自己的一个成员变量，那这种情况下，什么时候销毁对象 M 就成了一个难题。 对于这种情况，有一个暴力的做法，就是对象 A 在调用完对象 B 之后，马上就销毁参数对象 M，然后对象 B 需要将参数另外复制一份，生成另一个对象 M2，然后自己管理对象 M2 的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。如下图所示： 我们另外还有一种办法，就是对象 A 在构造完对象 M 之后，始终不销毁对象 M，由对象 B 来完成对象 M 的销毁工作。如果对象 B 需要长时间使用对象 M，它就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好地解决了对象复制的问题，但是它强烈依赖于 AB 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象 M 的申请是在对象 A 中，释放在对象 B 中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象 B 需要再向对象 C 传递对象 M，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方式带来的复杂性更大，更不可取。 所以引用计数很好的解决了这个问题，在参数 M 的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加 1，使用完了之后再把引用计数减 1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 不要向已经释放的对象发送消息有些同学想测试当对象释放时，其 retainCount 是否变成了 0，他们的试验代码如下： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSObject *object = [[NSObject alloc] init]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); [object release]; NSLog(@&quot;Reference Count = %u&quot;, [object retainCount]); return YES;&#125; 但是，如果你真的这么实验，你得到的输出结果可能是以下这样： Reference Count = 1Reference Count = 1 我们注意到，最后一次输出，引用计数并没有变成 0。这是为什么呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。 那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？这是因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。 拿我们之前提到的 Linux 文件系统举列，Linux 文件系统下删除一个文件，也不是真正的将文件的磁盘区域进行抹除操作，而只是删除该文件的索引节点号。这也和引用计数的内存回收方式类似，即回收时只做标记，并不抹除相关的数据。 ARC 下的内存管理问题ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外还有 10% 内存管理，是需要开发者自己处理的，这主要就是与底层 Core Foundation 对象交互的那部分，底层的 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。 对于 ARC 盲目依赖的 iOS 新人们，由于不知道引用计数，他们的问题主要体现在： 过度使用 block 之后，无法解决循环引用问题。 遇到底层 Core Foundation 对象，需要自己手工管理它们的引用计数时，显得一筹莫展。 循环引用（Reference Cycle）问题引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 主动断开循环引用解决循环引用问题主要有两个办法，第一个办法是我明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。例如在我开源的 YTKNetwork 网络库中，网络请求的回调 block 是被持有的，但是如果这个 block 中又存在对于 View Controller 的引用，就很容易产生从循环引用，因为： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self，所以持有了 Controller 解决办法就是，在网络请求结束后，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。相关的代码见： // https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKBaseRequest.m// 第 147 行：- (void)clearCompletionBlock &#123; // 主动释放掉对于 block 的引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存（这通常与具体的业务逻辑相关），所以这种解决方法并不常用，更常见的办法是使用弱引用 (weak reference) 的办法。 使用弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。举个例子来说，两个 ViewController A 和 B，ViewController A 需要弹出 ViewController B，让用户输入一些内容，当用户输入完成后，ViewController B 需要将内容返回给 ViewController A。这个时候，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 相互引用对方造成循环引用问题，如下所示： 弱引用的实现原理弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： 我们在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见《再见，viewDidUnload方法》。 使用 Xcode 检测循环引用Xcode 的 Instruments 工具集可以很方便的检测循环引用。为了测试效果，我们在一个测试用的 ViewController 中填入以下代码，该代码中的 firstArray 和 secondArray 相互引用了对方，构成了循环引用。 - (void)viewDidLoad&#123; [super viewDidLoad]; NSMutableArray *firstArray = [NSMutableArray array]; NSMutableArray *secondArray = [NSMutableArray array]; [firstArray addObject:secondArray]; [secondArray addObject:firstArray];&#125; 在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。如下图 这个时候 iOS 模拟器会运行起来，我们在模拟器里进行一些界面的切换操作。稍等几秒钟，就可以看到 Instruments 检测到了我们的这次循环引用。Instruments 中会用一条红色的条来表示一次内存泄漏的产生。如下图所示： 我们可以切换到 Leaks 这栏，点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。这样我们就可以非常方便地找到循环引用的对象了。 Core Foundation 对象的内存管理下面我们就来简单介绍一下对底层 Core Foundation 对象的内存管理。底层的 Core Foundation 对象，在创建时大多以 XxxCreateWithXxx 这样的方式创建，例如： // 创建一个 CFStringRef 对象CFStringRef str= CFStringCreateWithCString(kCFAllocatorDefault, “hello world&quot;, kCFStringEncodingUTF8);// 创建一个 CTFontRef 对象CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL); 对于这些对象的引用计数的修改，要相应的使用 CFRetain 和 CFRelease 方法。如下所示： // 创建一个 CTFontRef 对象CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL);// 引用计数加 1CFRetain(fontRef);// 引用计数减 1CFRelease(fontRef); 对于 CFRetain 和 CFRelease 两个方法，读者可以直观地认为，这与 Objective-C 对象的 retain 和 release 方法等价。 所以对于底层 Core Foundation 对象，我们只需要延续以前手工管理引用计数的办法即可。 除此之外，还有另外一个问题需要解决。在 ARC 下，我们有时需要将一个 Core Foundation 对象转换成一个 Objective-C 对象，这个时候我们需要告诉编译器，转换过程中的引用计数需要做如何的调整。这就引入了bridge相关的关键字，以下是这些关键字的说明： __bridge: 只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 __bridge_retained：类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。 __bridge_transfer：类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不再需要调用 CFRelease 方法。 我们根据具体的业务逻辑，合理使用上面的 3 种转换关键字，就可以解决 Core Foundation 对象与 Objective-C 对象相对转换的问题了。 总结在 ARC 的帮助下，iOS 开发者的内存管理工作已经被大大减轻，但是我们仍然需要理解引用计数这种内存管理方式的优点和常见问题，特别要注意解决循环引用问题。对于循环引用问题有两种主要的解决办法，一是主动断开循环引用，二是使用弱引用的方式避免循环引用。对于 Core Foundation 对象，由于不在 ARC 管理之下，我们仍然需要延续以前手工管理引用计数的办法。 在调试内存问题时，Instruments 工具可以很好地对我们进行辅助，善用 Instruments 可以节省我们大量的调试时间。 愿每一个 iOS 开发者都可以掌握 iOS 的内存管理技能。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"六个维度的理论和故事 - 读《管理 3.0》","slug":"management-30-summary","date":"2016-07-24T13:00:46.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/24/management-30-summary/","permalink":"https://blog.devtang.com/2016/07/24/management-30-summary/","excerpt":"","text":"前言最近读完了段念推荐的《管理 3.0：培养和提升敏捷领导力》，本书是一本结构规整的书，全书将管理理论用六个维度来阐述，然后每个维度下，先讲理论，再讲实践中的故事。 在作者 Jurgen Appelo 的理解下，管理的六个维度是： 激励员工：保持员工的活力、创造力和积极性。 授权团队：如何进行自组织。 调合约束：如何保护人力资源以及如何共享资源。 培养能力：如何提高员工技能和提高竞争力。 壮大组织：如何实现组织的成长。 全面改进：如何进行改进。 本书对我来说，收获最大的是「壮大组织」（第 12，13 章）部分所介绍的实践。很多想法我自己本身有一些体会，看到书中的介绍就更加清楚了，以下是这部分的一些想法。 专业主义书中提到了专业人才，并且认为专业人才应该是优先被考虑的人才结构。这点我很认同，但是它和部分业界的观点不同。 比如，业界一直在追捧「全栈」工程师，但是其实大部分所谓的「全栈」工程师，是指同时写 Web 前端和后台逻辑。这里的后台逻辑通常也偏业务逻辑一些，不涉及太多的高并发问题。所以，「全栈」工程师更多时候是一种特定业务场景下的需求，在这些特定业务场景下，「全栈」的工程师可以省去沟通前后端接口约定的沟通工作，在出现问题后，也更加便于排查。在 Nodejs 流行后，由于前后端可以统一编程语言，进而可以统一渲染模版，前端工程师更加有动力参与到部分后端的工作中。 但是，「全栈」工程师也仅限于此，涉及到更专业的领域时，组织还是更倾向于使用专业人才。不信的话，你可以问问，很少有人同时做 iOS 和 Android 端的开发，也很少有人同时做客户端和服务器端的「全栈」开发。 但是，在一方面专精，同时对于其它方面又有广泛了解的人员会带来更多的沟通和协作上的效率提升，所以我们都强调培养 T 型人才。T 型人才指在某一方面专长，但是又有着不错的知识面的人。比如 iOS 开发者，如果同时能懂一些产品、交互、服务器端的知识，那么在合作上就会舒服得多。 扁平层级与非正式领导力过多的管理层级带来效率低下的沟通和决策过程，所以现在的互联网公司都提倡扁平化的层级。但是在扁平化的层级下同样需要合作和决策，这个时候非正式的领导力就变得更加重要了。 非正式领导力在我们公司并没有被明确提出来，但是它确实反复存在。非正式的领导力在跨部门合作的时候变得异常重要，而这里面也涉及大量的沟通技巧。 职能型团队 vs 跨职能型团队这是我又一次见到相关的讨论了，在格鲁夫的《给经理人的第一课》里面也提到了相同的问题。当时，格鲁夫的观点是采用「混合型组织」和「双重汇报」的方式来解决。而本书的作者提出了另外一个思考的角度：沟通的频繁程度。 本书的作者认为，按照复杂系统理论，达成一件事情需要的沟通总量是不变的，所以我们应该让组织的形式更加易于沟通。所以一个人的工作应该归属于职能型团队还是跨职能型团队，就看他和哪边的沟通工作更多。 在这种思考的角度下，作者认为以产品为单位的跨职能型团队是更加符合沟通需求的。因为在开发一款产品时，PM 与开发需要密切地沟通合作，客户端与服务器的开发也需要密切的沟通合作。所以我们应该把他们放在一个团队中，而不应该分开到不同的职能型团队中。 有意思的是，「跨职能型团队」与「决策由组织间自行沟通解决」就构成了敏捷开发中的 Scrum of Scrum 模式。 作者在本书中认为（并且他指明具有争议），项目管理、架构级模块、用户界面设计、硬件设计、测试是专业性很强的工作，并且沟通量并没有那么大，可以用职能型专家团队来完成。但是需要服务好项目团队，由项目团队判断职能团队的价值并且建立合适的沟通渠道。 适应作者强调企业的组织方式并不是一层不变的，我们可以不变调整适应，如果觉得不合适，就可以继续调整。比如我们发现需要构建出一些架构级的模块时，我们可以临时组建专家团队，当这方面的工作变少时，我们也可以选择将专家团队解散。 总结本书还有一些小的翻译问题，例如 P13 把授权团队翻译成赋能团队，P109 把凯文·凯利翻译成科里。 本书的理论部分太过散乱，并且没有重点。实践部分的各章节也不成系统。如果为了节省时间，可以直接看每一章最后的小结，从小结中就可以看出结论非常散。 就像本书最后说的那样，不同的管理理论有不同的模型，本书的六大模型并不一定是正确的，它更多是一种看问题的可选角度。所有模型都有错，但有一部分是有用处的就行了，为方法、框架、原则和实践争得死去活来真的没有必要。 本书对于我的价值，就是再一次思考了组织在壮大过程中的各种问题的解决方案，我们公司的团队正在经历人员增长，跨部门的合作也遇到了很多问题，本书有助于我理解这其中的原因。 最后是我整理出来的知识脉络思维导图，这份图带有我个人的主观色彩，一些我不认同的观点没有整理在里面。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"软件开发中的上帝模式与农民模式","slug":"programming-worlds-farmer-and-god","date":"2016-07-20T12:18:04.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/20/programming-worlds-farmer-and-god/","permalink":"https://blog.devtang.com/2016/07/20/programming-worlds-farmer-and-god/","excerpt":"","text":"我在做 iOS 开发的时候，发现自己在写程序的时候，常常处于两种状态的切换，我把这两种状态称为软件开发的上帝模式与农民模式。我先给大家介绍一下这两种模式的特点。 上帝模式处于上帝模式时，我需要构思整个应用的架构设计，如何进行类之间的组织和信息的传递。我有可能会在纸上画一些类图，把关键的几个类之间关系构思清楚。这就类似于建筑师画设计图纸一样。 在这个阶段，我的大脑是努力工作的，我会利用我学到的《设计模式》、《重构》、《代码大全》中的架构知识，先把类的关系组织好。然后我会深入到每一类的实现细节，构思好每个类大概怎么实现，这个过程又会利用了如何命名、DRY 原则、单一职责原则等编程知识。 而这一切的行为，都是在纸上完成的，我甚至会关掉电脑屏幕，因为电脑屏幕前有很多影响注意力的信息（例如 QQ、微信、邮件等）。 农民模式当一切构思基本完成，我就会打开 Xcode，开始我的农民模式工作。 在农民模式，我会专心于将我刚刚构思好的内容变成一行行真实的代码。由于已经想得比较清楚，这个过程通常更多是一种体力活，或者好听一点，是一个手艺人的体力活。对于农民模式的我来说，我需要知道 iOS 开发的各种基本知识，以及一些常见的提升效率的工作方式，以便我能够更快地完成编码工作。 在农民模式中，我会注意集中精力，因为虽然实现代码是偏体力活的事情，但是思路如果断掉，接上的话还是会花费不少时间。有一些同事会喜欢戴上耳机，以避免干扰，也是这个道理。 一个例子举一个具体的例子，下图是小猿搜题的发现页面，它明显是用一个 Group Style 的 UITableView 来实现的，每个 Cell 的样式也非常简单：左边有一张 UIImageView，接着是一个 UILabel，然后是靠右侧的 UILabel（可能内容为空）以及最右侧的一张右剪头的 UIImageView。 由于这个发现页面可以由服务器来定制，所以我在上帝模式的时候，先构思好我需要实现： 一个 View Controller 类（DiscoveryViewController），用于展示整个界面 一个 TableViewCell 类（DiscoveryTableViewCell），用于描述一个条目 一个 ViewModel 类（DiscoveryConfig），用于描述发现页的内容 一个网络请求类（GetDiscoveryApi），用于获得服务器的定制信息 在持久化层（StorageAgent）增加两个方法，用于获取上次缓存的定制内容（getDiscoveryConfig）以及保存最新的定制内容 (saveDiscoveryConfig） 一个负责更新的类（ConfigUpdateAgent），用于处理更新的时机选择（checkUpdate） 我还会把每个类大概的成员变量和成员方法名想好。构思完成之后，我脱下上帝的黄袍（别问我上帝为什么要穿黄袍，我也不知道），换上农民干活的麻布衣服，开始搬代码了。我先把这些类都建好，方法名命名好。接着我开始填一个一个的方法名的实现。 每一个类的实现过程都可以看作一个阶段性的成果，这个时候我会稍微休息一下，然后继续搬砖。 最终，我完成了所有代码，然后开始运行。咦，为什么运行效果不对？我赶紧打起精神，开始调试起代码来。这个时候，我一会儿切换成上帝模式，审视自己的架构是否有漏洞。一会儿切换成农民模式，看自己是不是不小心敲错了一些代码细节。 最终，代码被全部编写完成并且运行正常了。 一些技巧上帝模式的技巧上帝模式中，切忌不应该过于着急动手，把一切的细节都想清楚，看看有没有特殊情况没有考虑到。如果一开始设计得不好，那么真正实现到最后才发现，那么农民模式下写的代码就白白浪费了。 上帝模式的工作是可以脱离电脑来实施的，这意味着我们可以拉上同事，找个白板讨论。我们也可以在上下班的路上思考。 经过讨论的上帝模式的产出会更加靠谱，在我们公司，我们会在 Scrum 的计划会议的后半程，用出牌的方式估计每一个工作的 Story Point，而具体的估计方式，就是以上帝模式将整个工作细化，使得我们大家能够明确出农民模式下的编码工作量到底是多少。 软件开发能力的提高，上帝模式会比农民模式更难，在上帝模式下工作得出色的同学，会进一步成为架构师，成为更复杂架构的设计规划者。 在软件开发书籍中，涉及上帝模式的图书也有很多，例如《设计模式》和《重构》，但是好的架构都是无法脱离实际业务的，所以大多数程序员都无法通过简单地看书就提高自己的上帝模式的能力，更多的提高方式是工作一段时间，有一些实际体会之后再看书，就能够理解书中的道理。 农民模式的技巧农民模式中，效率是第一要素。所以，保证自己的专注力是非常重要的。在这方面，「番茄工作法」是一个不错的实践方式。 农民模式中，应该尽量采用「宽度优先搜索」的方式来完成任务，而不是「深度优先搜索」的方式。在上面的例子中，我先将各种类的类名和方法名填好，然后再完善细节就是一种「宽度优先搜索」的方式。这种方式下，我们不需要额外的「栈空间」来保存工作的上下文。 为了更容易理解，我来举一个「深度优先搜索」的工作方式，在上面的例子中，我先写界面的 Controller 类，写到一半发现需要 TableViewCell，于是就去写 TableViewCell。TableViewCell 写到一半发现需要先实现 ViewModel，然后就跑去实现 ViewModel，ViewModel 实现完发现需要缓存起来，于是就跑去写缓存逻辑。这种工作方式下，我就需要分别记住：Controller 的进度和 TableViewCell 的进度，以便我之后继续完善它们。这种方式其实就相当于一次「打断」，因为我把 Controller 的编写硬生生拆成了两次，这样就使得我需要更多时间回记上次的思路。 农民模式中，我们应该尽量提升自己的代码输入效率。比如将常用的代码片段保存在 Xcode 的 Snippets 中或者 Dash 中，在组织内规范好统一的命名约定和规则，熟悉 iOS 的各种调试技巧，都可以使自己更快把上帝模式下的蓝图转换成实际代码。 相对于上帝模式，大部分同学都会轻视农民模式下的效率。比如写一会儿代码聊一会儿 QQ。比如由于自己事先积累不够，很多基本的 iOS 开发知识还需要查资料和文档。农民模式下的效率低下，使得一个人看起来工作了很久，却没有什么产出。 在 iOS 领域，我个人的经验表明，我在一整天的农民模式中，最高可以产出 1000 行左右的代码。2012 年猿题库创业初期时，我在 4 个月的紧张工作中，平均每天的代码产出约为 500 行。 一些问题提升上帝模式能力很多 iOS 开发新手对于提升自己上帝模式的能力感觉到无从下手，建议这部分同学可以多分析一些优秀的开源软件的架构，同时阅读一些相关的书籍。另外，每一次恶心的重构都是一次难得的经验，说明之前的架构设计不够优雅，结合自身的业务特点，多思考多讨论，慢慢地就会培养出自己对于架构的一些心得了。 提升农民模式效率很多 iOS 开发新手对于农民模式不够重视。一个程序员大部分时间都应该是处于农民模式的，农民模式决定了我们产出的效率，而很多人只重视工作时间，不重视工作效率，使得自己的产出非常低下。 提升自己的农民模式能力，建议使用「番茄工作法」并且做一些时间记录，平时多学习一些最新的 iOS 开发知识，以便减少自己的知识盲区。专注于自己的精力是否集中，如果觉得太累，就活动一下或者适当休息，不应该强迫自己 Coding。 警惕混搭模式混搭模式，类似于练功人士的「走火入魔」，专指那些在上帝模式没有想清楚，就马上切入农民模式写代码，写到一半代码又切到上帝模式思考。边写边想的混搭模式使得自己想的时候不够清晰，写的时候又不够专注，两边都不讨好。通常刚刚入行的人都处于这种混搭的模式，不但写出来的代码容易有逻辑错误，而且速度很慢。 结语上帝模式与农民模式这个叫法是我自己发明出来的，你喜欢这个世界观设定吗？ 我们在程序的世界里，一会儿是高高在上的上帝，一会儿又是埋头干苦活的农民，想想也挺奇妙的。 愿大家在这个世界中玩得开心！ 如果你感兴趣，这儿还有我的另一个世界观设定：《打开你的脑洞》。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"成长为 iOS 大 V 的秘密","slug":"from-newbie-to-master","date":"2016-07-20T12:17:53.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/20/from-newbie-to-master/","permalink":"https://blog.devtang.com/2016/07/20/from-newbie-to-master/","excerpt":"","text":"前言毫不谦虚地说，我是国内 iOS 开发的大 V。我从 2011 年底开始自学 iOS 开发，经过 3 年时间，到 2014 年底，我不但写作了上百篇 iOS 相关的原创博客文章，完成《iOS 开发进阶》，同时还成功运营了「iOS 开发」这个国内最多 iOS 开发者订阅的微信公众号，另外我的微博（@唐巧_boy）粉丝超过 4 万。我是如何做到的呢？ 在武侠小说里面，武林高手通常生来就有慧根，是个学武奇才，就像周星驰《功夫》里面的星仔。另外，他们还通常会得到世外高人的指点，要么获得别人毕生修炼的真气（虚竹），要么获得绝世武功的秘笈（段誉）。 而我其实在这些方面都很弱。我在计算机编程方面并算不上聪明，我在北京师范大学读计算机专业，这是一个全国综合实力排在 100 名开外的院系，离清华北大差得不是一个级别。而我的语文高考成绩，刚刚及格。我的英语成绩也很一般。 更不凑巧的是，我当年学 iOS 的时候，国内资料很少，而且公司里面没人有时间指导我，我只能自学。很难想像，我这么差的背景的人，能够成为 iOS 大 V，能够写文章，甚至还出书。 那么，我成为 iOS 大 V 的秘密是什么呢？请听我慢慢道来。 大 V &#x3D; 大牛 ？首先我想讨论一个问题：「大 V &#x3D; 大牛」吗？其实很多时候，这两者并不能直接划等号。 我见过很多大牛，他们水平很高，但是他们或者不善于表达，或者不善于写作，或者表达和写作都没问题，但是他们并不喜欢在网上高谈阔论，更喜欢把时间花在研究技术问题上。这些大牛，就像《天龙八部》里面的扫地僧一样，不曾被外界知晓，但是技术实力一流。 我也见过一些大 V，技术实力一般，但是喜欢分享自己的心得，喜欢翻译国外的博文。他们有一些人甚至不善于写作，写文章喜欢大段大段地贴代码。但是，随着他在这方面不断地锻炼，他们慢慢地写作得越来越好，讲解技术越来越通俗易懂。因为频繁地交流，他们的技术实习也在不停地进步。虽然这些大 V 的真实水平可能比不过一些从不分享的大牛，但是他们的能力至少是达标的。 所以，我对这个问题的答案是：大 V 不等于 大牛。但是，要成为一个大 V，至少应该具备以下条件： 能力是达标的，不应该有明显的能力问题。 喜欢交流，认识很多业界同行。 喜欢表达，通过写作和线下分享来传播知识。 所以，我们不应该盲目崇拜大 V，他们只是喜欢分享而已。 那我算一个 iOS 的大牛吗？我不知道。有一些人认可我，也有一些人觉得我很一般。但是我的原创文章、我的书、我开源的代码、我做的每次分享都公开在网上。我仅仅用三年时间在 iOS 领域做到这些也是不容易的，所以希望大家继续看下去，看我是如何做到的。 奇材 + 秘笈？ 在武侠小说里面，武林高手通常生来就有慧根，是个学武奇才，就像周星驰《功夫》里面的星仔。另外，他们还通常会得到世外高人的指点，要么像虚竹那样，获得别人毕生修炼的真气；要么像段誉那样，获得绝世武功的秘笈。 我是一个奇材吗？我是一个奇材吗？显然不是。 我从小就喜欢计算机，从高中就开始接触计算机编程，我还记得那个时候学的是 PASCAL 语言，从那个时候起，我就展现出在计算机编程方面的愚钝。我还记得我和同班的小伙伴一起学习递归枚举，他大概只花了三天就看懂了相关的代码，而我花了整整一个月。 我的高考成绩其实也很一般，不过我运气比较好，当年全国试行自主招生，我靠着自主招生进入了北京师范大学，在北京师范大学读计算机专业。这是一个全国综合实力排在 100 名开外的院系，离清华北大差得不是一个级别。我靠着高中时积累的一点点编程知识混进了学校的 ACM 校队，之后一直比赛成绩一般，直到研一的时候才免强获得了亚洲区的区域赛金奖。 我的实习经历也非常不顺。我从大四就开始找实习，一直被拒，到研究生阶段还是找不到实习。最终还是靠刚刚说的区域赛金奖，获得了来自赞助商 IBM 的一次实习机会。 大 V 需要擅长写作，而我的高考语文成绩，92 分（满分 150），刚刚及格。我的英语成绩也很一般。 所以，我就是一个天资普通得不能再普通的一个人。 我有高人指点吗？那我有高人指点吗？很可惜，也没有。 我不但没有高人指点，而且我学习 iOS 开发的过程极其曲折。 没有资料我是在 2011 年底开始学习 iOS 开发的。当时我厌倦了服务器端的开发，感觉移动互联网很火，于是想做 iOS 开发。但是，当时移动开发刚刚兴起，国内外甚至都没有一本像样的 iOS 图书。当时除了一本入门的基础书，教你使用各种 UI 控件外，就只剩下一本满是代码的书，教你各种小技巧（比如如何读文件，如果发个网络请求之类）。 没有人带我当时在有道云笔记组，负责 iOS 开发的同学并不太擅长带人，所以我很遗憾基本上只能自己学习和研究 iOS 开发知识。 学习时间短我以为公司会给我一些时间让我学习 iOS 开发，但是真实的情况是，我只有两周的时间学习！两周之后，我就需要帮忙修复线上的 iOS 代码，以及参与功能开发了。 我不知道大家是花多久学完 iOS 开发的。有一些同学报 iOS 培训班，在有老师讲的情况下，一学就学三个月。而我，只有两周的时间。 背景知识为零我在学习 iOS 开发前，对客户端开发一无所知，我当时没有用过 Mac 机，没有 iPhone。一切东西对我来说都还非常神秘。 没有时间提高我从 2011 年底开始学 iOS 开发，到 2012 年 5 月份就离职创业了。那个时候因为创业刚开始，我们进入了长期的 6 天，每天 11 小时的高强度工作方式。我想提高自己的 iOS 水平，但是每天工作下来都很晚了，而且写了一整天代码精疲力尽，实在没有时间提高。 我的成就但是，在自身条件一般，环境恶劣的情况下，我还是做到了自我的快速成长，并且收获了很多成绩： 我从开始学习 iOS 开发半年后，就开始独立负责 iOS 端的开发工作。 我从 2013 年 1 月创建「iOS 开发」微信公众帐号，然后每周坚持更新，现在有超过 3 万 5 千的订阅量。 我从 2013 年底开始撰写《iOS 开发进阶》，2014 年底完成。另外我还写了一年多 「iOS 开发周报」。 我将公司的网络库，Key-Value 存储库开源，GitHub 上 Star 数上千。 我坚持写 iOS 技术博客，现在完成了超过 100 篇原创文章，很多发表在 InfoQ 和 《程序员》杂志上。 我是如何做到的那我是如何做到的呢？ 解决入门的问题学习 iOS 开发，没有相关硬件是不行的。但是苹果的硬件都很贵，很多人舍不得买，装黑苹果来解决，这种行为我简单尝试了一下就放弃了，因为黑苹果有着太多的兼容和性能问题，在这上面浪费时间非常不值得。于是，我还是自己掏钱买了 Mac 机和 iPad，为了省钱，我买的第一台 Macbook Pro 是从同学手中买的二手货，我买 iPad 而不是 iPhone，其实也是为了省钱，因为 iPad 不但相对来说更便宜，而且可以同时做 iPhone 和 iPad 的开发用。 国内没有学习资料怎么办呢？只有硬着头皮看国外的资料呗。其实当时国外的资料也不多。我是一个视觉型的学习者，所以我看的是斯坦福的iOS开发视频课程。前几节课看的是网易云课堂上的带中文字幕的版本，但是字幕只到第10课，后面的课程我就直接看的无字幕的原始视频。 两周的时间虽然比起外面的培训机构短很多。但是安排得好的话，每天还是可以学习很多。我大概一周就看完了视频课程，然后就是不停地写程序练习。虽然没有人带我，但是当时有道公司内部的所有 iOS 工程代码我其实也是可以用来学习的。所以我仔细阅读了有道词典和有道云笔记的代码。 于是，两周之后，我就开始参与工程Bug的修复工作了。差不多一个月左右，我就开始负责一部分开发工作了。 解决交流讨论的问题虽然我很快完成了iOS的入门学习，但是感觉交流很少，很多问题没有人讨论，这对于自己提高开发能力是一个很大的障碍。于是，我开始组织各种分享交流会。 刚开始我尝试在公司内部做这种交流工作，发现推进得非常困难，主要是喜欢分享的人还是比较少。有道的技术牛人其实是不少的，但是就像我刚刚说的那样，大牛不等于大V，大牛也不代表着乐于并且擅长分享。所以，经过了快两个月的推进，技术交流会还是非常少。大家都会说没有时间准备，而我又没有任何权力在强行要求同事做分享。 我苦恼了很久，最终到创业的时候，才发现我之前眼光太浅，世界那么大，我为什么要把交流的圈子定在公司内部呢？在创业的时候，我开始从全国范围内主动寻找和结识乐于分享的 iOS 开发者。我会从微博，博客，技术分享会，前同事等各种渠道去寻找这样的朋友。其实，对于乐于分享的人来说，你要做的事情就只是把他们聚到一起就行了，他们自己就会开始不停地交流、讨论、分享。 解决提高的问题大部分 iOS 开发者在入门一段时间后，就会苦于不知道如何提高。其实，提高的方式有很多，只要舍得花时间。我在提升个人技能方面，主要做了这些事情： 看 WWDC 的视频。因为由苹果官方提供，并且每年更新，所以 WWDC 是学习 iOS 开发新知识最好的渠道。我利用我每天上下班坐地铁的时间来学习，遇到一些关键的知识在地铁上不好做笔记，我会直接用截屏的方式把这些知识截下来，然后晚上在家里再把内容整理下来。下图是我在 Evernote 中记录的 WWDC 笔记，大家可以看到，一共有 70 多篇。 看 iOS 的博客。我用 RSS 聚合阅读器定阅了大量国外 iOS 的博客，然后利用碎片时间阅读。我的 Evernote 上收藏了上百篇的精选文章。我的碎片时间大多是上厕所和睡觉前。那个时候智能手机刚刚兴起，还没有微信，我感觉现在很难做到在手机上安静地做阅读了。 写作。对于我个人来说，我会坚持用写作的方式来学习。因为我觉得写作是知识理解的最高层次。美国教育心理学家 Bloom 将知识认知历程维度分为 6 个层次，分别为：记忆、理解、应用、分析、评鉴、创造。如下图所示，层次越高，表示对知识的掌握程度越深。我每次觉得我理解了一个知识后，就会用写作的方式把它写下来，通常情况下，在写作的过程中我都会发现自己的一些认知不足，从而通过二次学习来完善。 我的心得在这个过程中，我也发现了一些以前认识上的误区。 时间是最大的借口有一些朋友评价我：「迷之高产」，他们不理解我是如何有那么多时间搞定各种事情。 在我看来，当你做不好某一件事情时，时间通常是最大的借口。 时间是可以寻找的我学习 iOS 开发半年后，我就从网易离职参与创业了。当时我们需要工作 6 天，每天 11 个小时。但是，这仍然没有影响我学习、交流、甚至写作。其实你仔细记录自己的时间之后，就会发现有很多时间可以利用。 比如我在那段紧张的创业期间，就利用每天上下班的时间，在地铁上看 WWDC 视频。 我自认为最夸张的事情是利用陪老婆逛街的时候写博客文章。当时我老婆和岳母在商场里面逛，我就在手机上写文章。其实试过之后发现，在手机上写文章的速度也算不上慢。 现在，我有了小孩，周末常常要陪伴她。我就会特别珍惜晚上 8 点后她睡着后那段时间，我可以利用那段时间做一些学习和写作的事情。 时间是可以挤的如果我们提高工作的效率，那么做同样的事情，你就会比别人花费更少的时间。这样我们就可以挤出时间做别的事情。 程序员这个工作特点是需要集中精力，所以应该尽量避免被别人打断。推荐大家使用番茄工作法，让自己能够在短时间内集中精力做一件事情。久而久之，你就可以快速进入编程状态。 另外，写代码之前，先在纸上把逻辑写清楚，这样会使得自己 Coding 的过程非常顺利。有一些人喜欢边写边想，这样如果遇上一些没想清楚的情况，就可能白写一部分代码。在纸上把逻辑先写清楚后，Coding 的节奏会非常轻松，因为你的脑海里已经有整个架构的蓝图了，即使中间暂停休息一下，也不会有很大的影响。 平衡好时间和代码质量有一些人写代码，完全是堆功能，不考虑可维护性，你如果批评他，他就会义正言辞地说：时间不够！ 另外有一些人，追求代码质量，宁愿项目长时间延期，也不愿意写出看起来脏的代码。遇到需求变更，总是要进行大幅度的重构，以保证新的架构是最优雅的。 我有很长一段时间都是后者，但是我现在觉得，我们不应该走极端，我们应该平衡好时间花费和代码质量。 从商业上来说，按时交付产品比什么都重要，一家创业公司，如果不能按时交付产品，可能它就会面临资金不够的问题而倒闭，也可能被竞争对手抢先推出类似产品，在竞争上失去时间上的优势。 所以一个好的程序员，更应该有「大局观」，在保证代码质量的同时，也能明白，良好的代码质量其实是为了长期的可持续地按时响应需求变更、人员变更，以达到「按时交付产品」。 运用心智什么是心智关于什么是心智，我来讲一个故事吧。 我老婆是学幼儿教育的，她给我讲过一个故事，幼儿教育学家为了研究小孩的自控能力，会做一个叫做 延迟满足 的实验。这个实验（相关视频）是这样的： 在一个屋子里面，让小孩坐在一个书桌前，然后给小孩一个糖果，告诉他：「我 15 分钟后回来，如果你在我回来之前都不吃这个糖果，等我回来后就再奖励你一个糖果」。 通常情况下，很多小孩都无法抵抗糖果的诱惑而很快将它吃掉。而研究发现，那些坚持到最后的小孩，自控能力更强，在随后的跟踪研究发现，这些小孩能够在学校取得更好的学习成绩。 研究人员对这些表现出优秀控制力的小孩很好奇，想进一步分析出他们有什么特点。研究人员甚至用功能磁共振成像仪为他们的脑部进行扫描，希望通过对比扫描图，找出大脑对 “延迟满足” 能力起作用的特定区域。此外，研究人员还进行了不同的基因测试，以研究是否存在控制 “延迟满足” 能力的遗传因素。 最后，研究人员发现，这些小孩都会非常简单的一招：转移注意力。具体来说，他们会在特别想吃糖果的时候，选择做别的事情来让自己大脑暂时不那么关注糖果。比如他们可能会唱歌，在桌子上写字，将头转向窗外。 这个故事就是关于心智最好的解释，小朋友教会我们不要抵抗人性，要利用人性。他们知道自己喜欢吃糖果，但是他并不是强制让自己不喜欢吃糖果了，而是用别的办法来达到目的。 如果你合理利用人智，那么就会收获巨大的威力。 培养习惯培养习惯应该是最简单的心智利用手段。人们对做一件事情会有惰性，但是一旦培养成习惯之后，不做这件事情反倒不习惯了。所以那些值得做的事情，大家都应该在开始的一段时间内，强行让自己在固定时间点做这些事情，久而久之，就会形成习惯，让它成为你受益终身的习惯。 不止是个人，组织的协作也应该培养习惯。我们在用 Scrum 用项目推进时，会固定每天和每周的开会时间，以及产品的上线时间，这些都会让组织减小对于协作的管理成本。比如每周一晚上需要完成 App 的测试，大家就会自发地紧张起来，将遗留的 Bug 一一修复。 设立目标很多事情，当我们没有目标的时候，执行的动力就会差很多。所以，我在学习 iOS 开发的时候，会不断地给自己设立一些目标，通过不断强化这个目标，这样使得我在学习的时候意愿变得更强了。当目标达成之后，成就感和自信心就由此产生，从而激励我们更加努力，由此产生出良性的循环。 具体来说，我在学习初期不断要求自己将学习内容整理成博客文章，我要求自己每个月至少写一篇。我的第一篇 iOS 文章是从 2011 年 8 月开始写的，那个时候我才刚刚开始学习 iOS，当时看苹果的内存管理的官方文档，有一些心得，就写了下来。然后关于写博客这件事情我就一直没有间断，一直写到现在。 在文章积累到一定程度之后，我给自己设立的第二个目标是完成一本书。我希望借此机会，将自己没有系统整理的知识再梳理一次。这个目标对我其实挑战很大，最终我从中学会了将图书的撰写拆分成很多小的目标，然后一步一步达成。 把大目标拆分成小的阶段性目标这一点很重要，它使得整体的时间安排是适当的，不会刚开始过紧或过松。另一方面，很一次完成小任务的满足感，可以适当让我们的大脑产生喜悦，最终使得任务更容易被搞定。 寻找成就感人是需要激励的，《异类》一书中讲到，那些刚开始只有一点点天赋的人，因为不断被人夸奖，从而使得他们更加强化自己擅长的事情，从而获得成功。 所以，我们应该学会给自己做的事情寻找成就感。除了通过完成目标来获得成就感以外，我们还可以有更多的成就感来源。对于我来说： 我会从写文章分享知识这个过程中寻找成就感，因为这帮助了其他人学习 iOS 知识。 我会从给 InfoQ 和《程序员》杂志的投稿中寻找成就感，因为它让我感觉到了知识被认可。 我还会从粉丝的转发和评论中寻找成就感，它让我小小的内心充满了被认可的感觉。 我还会从文章的打赏中寻找成就感，毕竟金钱打赏是对文章质量最直接的肯定。 这些成就感，驱使着我，让我更加努力学习，停不下来。 适度坚持总会有一些事情，你不那么容易找到目标和成就感。 我在 2013 年开始做「iOS 开发」微信公众号的时候，就有这种感觉。每周都要坚持推送消息很辛苦，而且刚开始的时候，粉丝很少，没有人看。我有无数个理由停止做这件事情。但是，我有一个习惯，就是决定做一件事情之后，先做一段时间再说。 当时我给自己设立的目标是，先做半年再说。于是，我就继续更新。机会总是给有准备的人，做着做着，我发现关注数慢慢上升了，我就给自己打气说，慢慢会好起来，于是又继续坚持。终于坚持到 2015 年，我的关注数超过 2 万，也开始有了广告收入。 还是《异类》那本书里面提到了 10000 小时定理，这个观点其实给我很大的鼓舞，它让我们所有人意识到，不论你是否聪明，你都可以用简单地坚持，来成为某个领域的专家。我之前做 iOS 开发时就想，我平时上班一天 8 小时，一年 260 天工作，这样一年是 2000 小时，我大概需要 5 年才能成为 iOS 专家。但是如果我每天工作 10 小时，每周末多拿一天学习 iOS 开发知识，那么我一年可以花在 iOS 上的时间是 10（小时） * 310（天）&#x3D; 3100 小时，这样我只需要 3 年多一点，就可以成为 iOS 专家了。 我不但是这么 YY 的，我也是这么做的，是的，我就是希望我用三年的时间，达到别人五年的工作经验。事实上，我确实做到了，我相信所有其他人也都可以做到。 营销虽然和个人成长没关系，但是成为大 V 确实需要一些个人的营销。我在这方面其实做得不多，细数下来，我做过下面这些营销的事情： 「iOS 开发」公众号坚持三个月后，请冯大辉帮忙推荐过一次，请池建强推荐过一次。 我的微博坚持只发 iOS 开发的消息，刚开始的时候没有粉丝，我请池建强帮我转过几次文章。 图书出版后，和出版社合作搞过几次转发送书活动。 和荔枝软件搞过几次 Mac 正版软件特惠活动。 我在营销上其实做得不算好，我在成为大 V 这条路上真正的成功秘诀，还是不断坚持。 总结总结一下本文的观点： 大 V 不等于 大牛，不要盲目崇拜。 时间是最大的借口。 合理运用心智（培养习惯、设立目标、寻找成就感）。 适度坚持。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"写在创业四周年","slug":"startup-4th-year-summary","date":"2016-07-16T04:07:05.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/16/startup-4th-year-summary/","permalink":"https://blog.devtang.com/2016/07/16/startup-4th-year-summary/","excerpt":"","text":"序一转眼，创业四周年了。我从来没有想到过，我的职业生涯中，待得最久的是猿题库这家创业公司。2016 年 5 月 31 日，我们宣布了获得腾讯的 4000 万美元投资，这是腾讯在 K12 在线教育领域最大的一笔战略投资。拿 BAT 的钱更像是一种站队行为，腾讯拥有 QQ 和微信两大社交平台，如果要选的话，腾讯理应是最好的选择。趁着拿到融资的机会，我们顺便把公司名从「猿题库」改成了「猿辅导」，我们希望从「猿辅导」中，找到合适的商业化道路。 说说我个人吧，和两年前的创业总结 《写在创业两周年》 相比，我最大的变化是从一名纯 iOS 开发，转变为一个项目负责人。 时间流水2014 年 7 月小猿搜题立项，我开始负责这个项目。刚开始我一边负责 iOS 的开发工作，一边参与产品稿和 UI 稿的讨论。当时的我以非技术工作还很陌生，基本上不太敢提意见，不过产品稿都有郭常圳和产品委员会把关，因此并不会带来什么问题。 2014 年 9 月底小猿搜题第一版上线，我们当时评测显示和竞争对手算法差别不大，不过产品层面上，还有许多需要打磨的地方。 2015 年初，我们认为产品打磨得差不多了，于是开始了大规模的运营推广。我们很快在用户量和搜索量上，将某个竞争对手甩开了。 我在负责小猿搜题项目时，首先需要解决的是将 iOS 开发的事情交出去，如果我一直在 iOS 开发具体工作上耗费精力，我就无法关注别的事情了。但是招聘从来都不是一件容易的事情，相比 iOS 开发，我又觉得产品和项目管理的事情更重要，所以在 2014 年的最后两个月，有一些 iOS 端的开发工作被我延后了。 2015 年 1 月，我招到了一个 iOS 开发新手，于是开始带她，差不多带了 3 个月之后，我发现她基本可以独立工作了，所以就只做 code review 的事情。后来 6 月份的时候，我又招过来一个 iOS 开发新手，我指导他做了一些安全方面的工作之后，他们开始相互 review 代码，我参与过几次之后，我发现他们做得很好，所以就不再参与了。 安卓方面，刚开始从猿题库项目组调来一个应届生新人，同时猿题库的安卓负责人参与我们的 review 工作。也是等到这个新人熟悉工作后，他就开始独立开发了，之后补充了一个社招的安卓开发。 小猿搜题在 2015 上半年，相继补充了测试工程师，服务器开发，web 前端开发，产品实习生。到 2015 下半年，我们的团队基本成型了。 2016 年，我们的团队继续扩张，我有些管理不过来。我尝试将一些事情授权给别人，比如培养技术负责人和产品负责人。我们也明确了 iOS 和 Android 端的负责人，以便于更有效地沟通。 个人成长对于我来说，我开始像《领导梯队》那本书讲的那样，一开始经历了从管理自我到管理他人的阶段，而现在又开始经历从管理他人到管理经理人员的阶段。 从管理自我到管理他人从管理自我到管理他人，我学习到的技能点包括： 授权。在从管理自我到管理他人的阶段中，我学会了尽量放弃自己亲力亲为，特别是开发工作。因为开发工作需要长时间集中注意力，而我本身的工作性质导致沟通工作较多，容易被打断。足够的授权才能为自己争取到额外的时间，在授权的同时加以一些监督和检查，就又可以即保证新人得到锻炼，又保证这些工作的质量。 项目进展。管理他人另一个需要注意的就是关注于项目的进展，通常情况下都会有各种各样的问题需要介入讨论，保证进度。 沟通。管理他人中，沟通是一个很重要的环节，新人刚来的一个月是我特别花精力沟通的阶段。沟通的技能包括一对一沟通、绩效沟通、以及平常对于错误行为的及时纠正。其实保持友谊也很重要，不过人多了可能也确实比较难以做到。 流程。关注于规则是否有利于大家工作，是否需要改进。 从管理他人到管理经理人员从管理他人到管理经理人员阶段，我正在学习。 时间点。我发现在这一阶段，我无法细致到项目进展的每一方面，所以我对于项目进展的推动更多地依赖于别人了。而我只能强调时间点。具体的细节问题推进，我更多地依赖于别人。 沟通。由于人员变多，我只能和重要的负责人进行沟通了，不过和他们的沟通频率应该变得比以前更高，我通过和他们沟通，来获得更细致的项目进展问题和流程上的问题。 其它沟通。沟通不止是向下的，也包括向上的沟通和横向的跨组沟通。这部分工作也开始越来越占用时间了。 产品。我更多地思考产品方向，看一些产品数据或问题。 培训。我开始做一些培训，给相关负责人或者是新员工。给负责人的培训更多是通过聊天讨论的方式，因为这样一对一的讨论是更容易达成一致的。给新员工的培训更多是一对多分享的方式。 思考看起来管理他人的职位会涉及具体的业务细节的讨论和推进，属于在「一线」的管理人员，这些管理人员通常也具备不错的专业能力。 管理经理人员的职位会相对脱离「一线」，他的工作会有更多沟通的事情，和老大的向上沟通，和运营，研究，市场，HR 部门以及兄弟产品的横向沟通，和负责人的沟通，这些事情会占用他大量的时间。 但是这个职位也同样需要有一些「一线」的工作，例如看产品数据，试用产品功能，讨论产品稿，思考产品方向，了解开发的业务进展等。 总之我还没有很好地描述和定义清楚该职位的工作内容，很多时候我感觉自己插手的事情也相当多，当前的我还需要更多的学习和体会。 希望自己继续学习和总结。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"被中国黑客玩坏的苹果","slug":"hack-way-through-apple","date":"2016-07-16T01:25:21.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/16/hack-way-through-apple/","permalink":"https://blog.devtang.com/2016/07/16/hack-way-through-apple/","excerpt":"","text":"最近从几个做 iOS 开发的小伙伴那儿听说了几个发垃圾邮件的黑科技，利用的都是苹果的一些小「漏洞」，实在是让人觉得中国人的「创新」能力太强，分享给大家。 方法一 详细的办法在上面的这个截图中解释了，简单来说就是将自己的帐号名改成广告信息，然后不停修改自己的安全邮箱，于是这些含有自己的帐号名（其实就是广告）的邮件就通过苹果的服务器发送出来了。各大邮箱厂家确实是不敢贸然屏蔽苹果的邮件的，所以垃圾邮件被顺利发送出去。 我有一个小伙伴就收到了这样一封垃圾邮件： 苹果在发现这个漏洞被利用后，简单把用户昵称在邮件中不再显示了，不过可以看得出来改动非常匆忙： 方法二在方法一被苹果封堵后，前两天，梁杰发现了一个新的垃圾邮件发送行为。这次利用的是苹果的共享日历的功能。黑客利用将广告以日历日程的形式共享给大家，以便获得展示广告的能力。 背后的利益 由于对岛国大片的热爱， 我还真研究了一下这个垃圾邮件所描述的网址。这个网址打开后跳到一个看起来有各种诱人视频的播放列表中，然后弹出了如下 付款说明： 这个页面明显是一个骗人的假页面，因为上面描述的是：「付款之后刷新页面，尽享奇妙之旅」。我理解「奇妙之旅」应该就是可以播放视频吧。但是，这个付款的二维码是一个微信支付的二维码，所以，所有用户看到的二维码是一样的。 这就带来一个问题：假如有一个用户付款完，这个时候有两个用户同时按刷新，服务器端根本就无法知道是哪个用户付的款。所以，这根本就是一个诈骗的网站。 这个诈骗网站同时考虑了警察的心理，假如有人受骗报警，诈骗 18.8 元这种事情，对于警察叔叔来说，根本就达不到立案标准。如果警察叔叔要立案，他需要收集到上千个受害人的信息。另外，中国的办案还涉及管辖权，如果这个网站不在北京，那么北京的警察叔叔还需要找网站所在地的警察联合配合，这种事情想想都头大。于是，这个网站到现在还是能够正常打开（已经安全存在快一个月了）。 但是这如果不是一个诈骗网站，而是一个黄色网站，那么性质就完全不一样了。黄赌毒是警方重点的打击对象，警方跨辖区合作起来更有动力。相对诈骗网站来说，黄色网站的站长也会有更大的压力，而且就 18.8 这点钱，估计连站长的流量费都挣不回来。 木马的传播除以上面这种骗 18.8 的诈骗网站外，还有一种黑客行为是传播木马。通常的形式是要求你下载一款专用的视频播放器，用于看岛国大片。这类视频播放器通常都含有木马。 对于 Android 来说，视频播放器在安装时会要求大量系统级权限，然后在你不经意的时候，发一条扣费短信。注意，这种扣费短信通常只有 1 毛钱，对于这种报案，你可以想像一下警察叔叔的心理阴影面积了，他可能得收集上万个报案人的信息，才能达到立案的涉案金额，进而合并立案。在黑客界，这种扣费行为被称为最安全的挣钱方式，因为现有的法律使得警方的办案成本非常高。 对于 iOS 来说，视频播放器通常使用企业证书安装。有些小白用户或许觉得我的 iPhone 没有越狱，安装这类 App 没有风险，那么你就 too young too native 了。企业证书的安装的 App 不经苹果审核，黑客可以随意利用私有 API 进行各种信息的窃取。这里我就不教大家太多了，简单说一个过时的技巧吧：在 iOS 9 以前，企业证书的包可以覆盖同名的在 AppStore 上下载的 App。所以黑客可以利用一些小弹窗提示：「你的微信有新版本，是否更新」，从而把你的微信覆盖成它的修改后的版本。之后黑客可以做的事情就太多了。 写在最后安全的故事和事故每天都在上演，我们大家都得小心。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"技术主导型公司的困境","slug":"lead-by-tech-companys-trap","date":"2016-07-09T14:39:55.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/09/lead-by-tech-companys-trap/","permalink":"https://blog.devtang.com/2016/07/09/lead-by-tech-companys-trap/","excerpt":"","text":"Google 公司给了全世界的程序员一个理想公司的范例：招最聪明的人、工程师驱动项目、宽松的工作气氛、鼓励创新、20% 的自由时间⋯⋯我早年以为这样的公司一定会成功，但是工作到现在我却发现，那些模仿 Google 文化和工作方式的公司很多却活得很艰难。 豌豆荚的故事就在几天前，阿里巴巴宣布 收购豌豆荚，而交易价格并未对外公开。业界传言收购价为 2 亿美金，但是豌豆荚联合创始人王俊煜并未承认。不管是不是 2 亿美金，一个未公开的收购价很可能是为了避免让大家觉得尴尬，这种尴尬很可能是豌豆荚的收购价格并不乐观。 从前面几轮豌豆荚的融资信息来看，豌豆荚仅仅在 2014 年就获得了 1.2 亿美金的融资，当时估值为 10 亿美金，如果最终以 2 亿美金卖掉，那么真正归属给股东的回报应该寥寥无几，而众多员工的期权价值应该也就此成为一张废纸。 豌豆荚有类典型的技术主导型公司的气质。豌豆荚创始团队许多来自 Google，王俊煜从实习到毕业一直都在 Google，豌豆荚内部文化极其自由开放、透明及扁平化。 但是技术主导型公司通常还会有另一个特点，就是会「看不起」运营工作，在 《多面豌豆荚》 一文中，作者写道： 豌豆荚工程师文化非常强，在公司内部，产品设计师和工程师是项目主导，运营、市场、商务的地位都排在第二位。虽然豌豆荚把产品经理叫做 “产品设计师”，但豌豆荚的产品设计师是几乎不支持运营、市场或商务活动的，这类设计需求全部外包。外包一方面成本很高，另一方面周期比较长，因为设计师不在旁边，沟通成本要高许多。 作为最早的安卓应用市场，豌豆荚曾经是市场的老大，而它现在已经跌出了第一梯队。 豌豆荚在应用内搜索方面的尝试一直不太成功。作为一家技术人才聚集的公司，豌豆荚更喜欢用技术解决问题，应用内搜索看起来更像是一个技术难题，而不是用户需求。随着应用市场业务的萎靡以及新产品没有获得突破，豌豆荚不得已只能卖给阿里。 有道的故事网易有道是我第一份正式工作的东家，也是我认为文化非常贴近 Google 文化的公司。有道的创始人周枫是清华的年级第一，在清华读书时就是个风云人物。有道在成立之初，聚集了大量清华的同学。有道良好的技术氛围进而吸引了大量高质量的程序员，在我入职有道时，有道员工大部分都由清华北大的同学构成。有道员工里面不乏大量 ACM 世界总决赛获奖选手和 NOI 金牌获奖选手。公司内部重视代码 code review，重视 wiki，重视技术分享，甚至也有 20% 时间的个人项目。我还记得当时利用个人项目时间和黄东旭一起开发了 Mac 版的有道云笔记。 但是，技术上的优势并没有给有道带来商业上的成功。有道搜索在苦苦挣扎一段时间后，直接放弃了搜索业务。有道云笔记一直没能找到合适的用户增长点和盈利模式。有道惠惠做得非常早，但是仍然用户比较小众。现在看来，只有有道词典算是成功的一个产品，但收入应该远远没有达到支撑有道上市的程度。 有道在商业上的坎坷也造成了人员的动荡。早年的大量高质量工程师，待在有道是为了创业成功，以他们的实力很容易挑选新的公司。所以在有道发展下坡的时候，好多员工去了 Google、BAT 等其他一线互联网公司，而我也是在那个时候选择了加入猿题库创业。 豆瓣的故事豆瓣也是一个技术气氛浓厚的公司，阿北自己就是程序员出身，所以豆瓣的工程师氛围特别强，强到产品要做一个功能，技术会挑战他，会问为什么要做这个功能。但是豆瓣按自己节奏做事的风格，很快错过了移动互联网的机会。 技术主导型公司的短板豌豆荚、有道、豆瓣，为什么聚集了大量优秀的技术人才还是没能成功？其实从一个侧面说明一个创业项目的成功，技术只是各个条件中的一环而已。除开技术本身，我们还需要在产品，设计，运营，内容，市场推广等多方面努力，才可能在竞争中占据优势。 有道的运营推广在我看来一直是公司的短板，有道背靠网易，习惯于借助网易的大流量来获取用户，间接影响了有道自己在获得用户方面的尝试。 以前听别人说「技术驱动或技术主导」的公司，我会觉得很酷。现在我反倒觉得，一家公司技术太强势，可能就会压制产品或运营的声音，影响整体的竞争力。 看看周围成功的创业企业，也有大量的公司刚开始并没有牛逼的技术，但是毫不影响别人在创业路上的成长。比如滴滴，直到很晚才找到合适的技术合伙人。比如罗永浩，早期的 ROM 团队和硬件团队实力并不强。比如京东，早期用微软的 ASP 技术开发网站。比如现在很火的健身应用 Keep，一直没有很强的技术团队。 但是他们都成功了，现在的滴滴聚集了大量优秀的 iOS 开发者，还拿了苹果 10 亿美金的投资。罗永浩的软硬件团队早已脱胎换骨。京东已经不断地向业界输出着他们的技术积累。我相信 Keep 也会很好地解决掉他们的技术问题。 所以，除了少量像 Google 无人驾驶或者马斯克造火箭这类前沿技术创新项目外，技术在创业之路上，99% 的时候都不是关键因素，所以我们才会看着一家又一家顶着技术光环公司的陨落。 猿题库其实也算是一家顶着技术光环的公司，我们给高于大部分互联网公司的 offer，努力把以前在有道做的好的技术实践给传承下来。但是我们更明白，商业的成功才是最重要的，所以我们更看重按时交付产品，更关注用户数据。当产品上线时间和代码质量产生直接冲突时，我们会选择按时上线产品而做一些 dirty &amp; quick 的技术实现。更进一步地，我认为好的代码质量其实也是为按时上线服务的，我们写好的代码，只是为了以后在修改需求或者增加人手的时候，更节省时间，最终的结果还是减少了开发时间，保证了按时上线。 技术是一家互联网公司成功的基础，但是除了技术本身，产品方向、UI&amp;UE、市场推广、运营活动、内容建设同样重要。作为技术人员，我们不应该抱有技术改变一切的优越感，而应该是以一个谦卑的姿态，让技术更好地为产品服务，因为只有产品的成功才算是一家企业真正的成功。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"永远的致胜联盟 - 读《独裁者手册》","slug":"the-dictators-handbook-summary","date":"2016-07-07T14:24:17.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/07/07/the-dictators-handbook-summary/","permalink":"https://blog.devtang.com/2016/07/07/the-dictators-handbook-summary/","excerpt":"","text":"读书心得我们古代有句名言「水能载舟，亦能覆舟」，意思是一国之君应该尊重民意，执政为民，这样才能造就国家的富强。但是本书通过大量现代社会中的独裁国家的例子来告诉我们，其实独裁者的政治安全与人民的幸福生活并没有什么直接关系。这些独裁者的安危只与一个有关系：他是否能够构建好「致胜联盟」。 很有意思的是，本书中的大量例子来自「民主国家」美国。因为作者看来，独裁国家和民主国家的统治者在本质上都是一样的，都是追求服务于「致胜联盟」，所以我们在本书中看到了一个统一的关于政治生存的理论。 在我介绍本书的理论前，我们看看这个发生在美国的贝尔市的政治丑闻吧。 罗伯特·里佐是贝尔小城的前市政经理，该城人口大约为36600人，位于洛杉矶周边，是一座主要由西班牙裔和拉丁裔构成的贫困小城。年人均收入远低于加州和全美的平均水平。超过四分之一的劳动人口生活在贫困线以下。 罗伯特·里佐做了17年的市政经理。罗伯特·里佐在1993年被聘任时的年薪是72000美元，经过17年到他2010年夏天被迫下台时，他的年薪达到了令人震惊的78万美元。 罗伯特·里佐作为市政经理的薪酬与美国其他政府官员相比如何呢？美国总统的年薪是40万美元。加州州长的年薪是20多万美元。与贝尔市紧邻的洛杉矶市市长年薪刚过20万美元。 我们自然会认为罗伯特·里佐肯定一直在设法窃取钱财，2010年夏天贝尔市丑闻发生时，加州总检察长承诺将对罗伯特·里佐是否违法展开调查。他的举动含蓄表达了一个清楚的看法：没有人会每年付给一座小城的市政经理近80万美元。然而，事情的真相比预想的要复杂得多。 整件事其实是一种精明的政治操作，是由贝尔市的选民以及代表他们的市议员们间接批准的，再沾一点点盗窃的边。 罗伯特·里佐是如何做到这一点的呢？结论就是他构建了一个小的「致胜联盟」。他首先发起了一个投票，那场投票的目的是决定是否将贝尔市由“一般城市”转变为“宪章城市”，啥叫“宪章城市”呢？就是城市的政策由市议员决定，而不是由加州来决定。当然，罗伯特·里佐为此解释说：这可以给贝尔市更多的自治权，以摆脱遥远的州政府。 这样的投票其实很难被人理解其背后的影响，所以全市只吸引了400人来参与投票。于是，这个投票被通过后，罗伯特·里佐和市议员利用“宪章城市”的自治权，制定了很多政策，使得他们可以获得大量利益。于是，里佐和这些市议员合法地领取着高昂薪水。 最终，加州总检察长甚至无法对他们定罪，因为一切都是合法的。最终找的罪名竟然是他们拿了薪水，但是没有开相应的会议。所以，假如罗伯特·里佐每月再和这些议员「聚一聚」，那么真还拿他没办法了。 在本书的理论中，作者将政治分为三个维度和五个基本法则。 先介绍三个维度，对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。 名义选择人集团：包含了所有在选择领导人时至少具有某些法定发言权的人。在美国，指的就是所有合格选民，即所有年满18周岁的公民。 实际选择人集团：真正选择领导人的是这个集团。在沙特阿拉伯的君主政体下，指的就是皇室的高级成员；在英国则指的是支持多数党议员的选民。 致胜联盟：最重要的集团。它是实际选择人集团的一个子集，构成了一个致胜联盟。他们的支持对于一个领导人的政治生存至关重要。 领导人有五个基本法则可用于在任何体制下获得成功： 法则1：让你的致胜联盟越小越好。 法则2：让你的名义选择人集团越大越好。 法则3：掌控收入的分配。 法则4：支付给你的核心支持者刚好足够确保他们忠诚的钱。 法则5：不要从你的支持者的口袋里挪钱去改善人民的生活。 以下是一些解释： 法则1：越小的致胜联盟越好提供利益输送。 法则2：一个很大的选择人集团提供了充足的替代支持者，让不可或缺者时刻谨记必须保持忠诚、规规矩矩，不然就会被别人取代。 法则3：有钱才能给致胜联盟输送利益。在刚刚那个贝尔市的故事中，罗伯特·里佐将城市的房产税提高了50%。而巴基斯坦总统阿西夫·阿里·扎尔达里的财富估计高达40亿美元，尽管他统治着一个人均国民收入几乎全球垫底的国家。 法则4：钱少了不够收买忠诚，钱多了就浪费了，而且把支持者的胃口给调大了。 法则5：人民根本就不是威胁，致胜联盟才是真正的威胁。 在介绍完政治的三个维度和五个基本法则后，作者从多个角度来验证了他的理论。这些角度包括： 上台（第3章）：如果反叛者要成功，通常都是需要原有政府领导人无法构造忠诚的致胜联盟导致的。而这一点具体的原因，可能是财政危机或安全危机。 掌权（第4章）：本章比较了民选领导人和独裁者在维护核心支持者这件事情上的难度。最终指出，因为很难构建小的致胜联盟，所以民选领导人更容易下台。而独裁者开始的时候比较容易被人推翻，但是一旦独裁者构建成功致胜联盟，那么就很难下台了。本章还讨论了公司 CEO 在掌权上可以做的尝试，很多故事都可以在最近的万科事件中得到印证。 窃贫济富（第5章）：本章主要是讲的如何获得金钱。政治的5个基本法则中，第3条就是掌控收入的分配。如果无法获得足够的金钱，就无法构建致胜联盟，本章介绍了各种获取金钱的渠道。 获取与花费（第6章）：本章讨论可以把钱花在哪些地方，包括：教育、医疗、清洁的饮用水、基础设施建设、自由（出版自由、言论自由、集会自由等）。非常有意思的是，在独裁国家，领导人除了限制自由之外（这一点很好理解），也会限制教育、医疗或基础设施建设，因为这都有助于推翻独裁者的统治。 腐败使人有权（第7章）：对于独裁国家，腐败是一种提供私人报酬的方式，并且这种方式同时可以让动摇的联盟成员随时可能失去特权并被检控。对于民主国家，腐败的表现形式更加多样化，更多以扭曲的公共政策的形式出现，例如为富人的一些健康问题提供更多研究资金、为富人提供更为温和的税收政策等。 对外援助（第8章）：对于独裁国家的援助，很多时候都进了独裁者的口袋，而援助国很多时候对此是知情的，援助国对此睁一只眼闭一只眼的原因是：他在谋求某种政治交换。 反叛中的人民（第9章）：对于人民来说，反对独裁是非常正常的。但是作者指出，如果人民还能够发出反叛或抗议的声音，就说明政府还是相对温和的。真正的独裁者是不会让人有一丝抗议的声音。本章也详细解释了法则5，为什么人民无法构成有效的威胁。 战争、和平与世界秩序（第10章）：对于民主国家，战争和对外援助都是为了同一目的，只是一个更强势，另一个更温和。从另一个角度说明战争更多时候无关公平正义，只是政治行为。 最后，在第11章，作者讨论了一些办法来解决前面提到的独裁问题，最直接的办法就是扩大致胜联盟的规模，使得独裁者无法为海量的联盟成员提供私人报酬，所以只能提供面向所有人的公共服务地方式来获得选票。 书中引用了大量的事例，涉及美国，俄罗斯，还有一些独裁国家，也涉及一些上市公司的治理，很多故事从作者的角度看，又是另外一番景象。 最后，我个人认为，本书将政治生存作为论述基础是成立的，因为马斯洛的需求理论的最底层除了生理需求就是安全，如果一个人的政治生涯不能拥有安全感，那确实很难谈更高一层的理想。但是，我也不认为此理论就能将政治中所有人性的部分忽视，就像书中也把新加坡的李光耀作为一个特例来解读，这本身就说明本书的理论不是完美的。 这是一本非常有意思的书，推荐给大家，我也画了本书的思维导图（如下所示）。 读书笔记以下是更加详细的读书笔记。 第1章：统治的规则本章从美国一个小城市：贝尔市的政治丑闻说起，介绍贝尔市的市长：罗伯特·里佐 通过购建支持者小联盟，从而在这个城市大肆敛财的故事。 所以本书认为，独裁者的统治逻辑就是这样： 政治就是获得和维持政治权力。它与“我们，人民”的普遍幸福无关。 确保政治生存的最好方式是只依靠少数人来上位和在位。这意味着，那些拥有一批同伙可以依靠的独裁者—常常寿终正寝—比民主人士更容易长年掌权。 当这个同伙小集团明白外面还有大把人排队等着取而代之大吃公家饭，最高领导层就具有了如何花钱、如何征税的巨大自由裁量权。 依靠一个支持者小联盟，领导人可以放手大肆提高税率，正如贝尔市那样。 第2章：政治的法则 为了正确理解政治，我们必须修正一个特别的假设：我们必须停止认为领袖们能够独自领导。 所有独裁者都是需要一个核心的幕僚来帮助他做事情的，所以构建这个忠于自己的小联盟致关重要。 路易十四的故事本章中，作者把路易十四的故事作为例子，来看他是如何构建致胜联盟的。 他的父王路易十三死后，年仅四岁的路易十四登基。在早期，实际权力掌握在摄政的他母亲手中。她的亲信横征暴敛。到1661年路易十四23岁开始亲政时，法国已处于破产边缘。 国家破产的前景让初掌大权的路易十四身处险境，因为保守派贵族、包括军队将领看到他们的财富和特权在逐渐干涸。这一情况促使这些政治上重要但薄情寡义的朋友开始另找他人来确保他们的财富和特权。面对这样的危机，路易十四必须做出改变，否则将丧失统治权。 在以前，国家的高层是在贵族中产生的。但是路易十四做了一件事情：他改变了以前提拔人才的方式，通过从平民中提拔更多人才，特别是军队人才，路易十四成功地增强了致胜联盟的竞争，同时又使得这些平民对他更加忠诚。 通过提拔众多新人，路易建立了一个对他感恩的新阶层。在这一过程中，他更完整地集中了自己的权威，提升了对宫廷里不少老贵族年金的决定权。这样，他就建立起了一个“绝对”控制的体系，它的成功依赖于军队和新贵族的忠诚，也依赖于限制老贵族的权力，将他们的福祉直接转化为他的福祉。 这种改革确实非常有效。最终，路易十四在位 72 年，直到1715年寿终正寝。 政治的三个维度对领导人而言，政治情势可以被分解为三种人群：名义选择人集团、实际选择人集团和致胜联盟。 名义选择人集团：包含了所有在选择领导人时至少具有某些法定发言权的人。在美国，指的就是所有合格选民，即所有年满18周岁的公民。 实际选择人集团：真正选择领导人的是这个集团。在沙特阿拉伯的君主政体下，指的就是皇室的高级成员；在英国则指的是支持多数党议员的选民。 致胜联盟：最重要的集团。它是实际选择人集团的一个子集，构成了一个致胜联盟。他们的支持对于一个领导人的政治生存至关重要。 根本上讲，名义选择人就是领导人的潜在支持者；实际选择人则指那些其对领导人的支持确实有重要影响的人；而致胜联盟只包括那些领导人不可或缺的关键支持者。这三种人可简单概括为：可相互替代者、有影响者以及不可或缺者。 我们的出发点是意识到：任何一个有能力的领导人都希望掌握尽可能多的权力，并尽可能长久地掌握权力。设法利用可相互替代者、有影响者和不可或缺者来达到自己的目的，这就是统治的行为、艺术和科学。 政治的5个基本法则领导人有5个基本法则可用于在任何体制下获得成功： 法则1：让你的致胜联盟越小越好。 法则2：让你的名义选择人集团越大越好。一个很大的选择人集团提供了充足的替代支持者，让不可或缺者时刻谨记必须保持忠诚、规规矩矩，不然就会被别人取代。 法则3：掌控收入的分配。巴基斯坦总统阿西夫·阿里·扎尔达里的财富估计高达40亿美元，尽管他统治着一个人均国民收入几乎全球垫底的国家。 法则4：支付给你的核心支持者刚好足够确保他们忠诚的钱。 法则5：不要从你的支持者的口袋里挪钱去改善人民的生活。 第3章：上台本章从领导人上台的角度，来解释上一章提到的三个维度和五个基本法则。 本章讲了很多故事，基本上都是印证了：如果反叛要成功，通常都是需要原有政府领导人无法构造忠诚的致胜联盟导致的。而这一点具体的原因，可能是财政危机或安全危机。 财政危机领导人没有钱了。比如由于自然灾难，造成税收减少。比如俄国政府禁酒，造成税收减少1&#x2F;3。 饮用伏特加在俄国大众特别是军队中极为盛行。伏特加如此受欢迎且消费量巨大，它构成了俄国政府岁入的三分之一。一旦禁止伏特加买卖，沙皇的收入立刻锐减。而由于战争，他的开销却在持续增长。沙皇很快就没有能力继续收买忠诚。结果就是他的军队拒绝镇压罢工群众和示威者。 安全危机如果领导人因为身体原因快挂了，致胜联盟就会由于安全感缺失，需要寻找新的同盟者。 王朝式规则在民主国家司空见惯的原因与在独裁国家和君主制国家毫无二致。有谁比家族成员还能更好地保护家族财富和威望？民选官员花小钱赚大钱，享受权力，他们与奥古斯都皇帝或卡洛·甘比诺一样，渴望让自己的子孙享有一样的好处，保护他们的遗产。 书中还举了阿尔及利来的本·贝拉的愚蠢故事作为例子。 1965年6月12日，本·贝拉宣布一周之后将举行政治局会议，会上将讨论三个重大事项：（1）改组内阁；（2）撤换军队领导人；（3）清算军中反对派。他随后离开阿尔及尔前往奥兰。 这一宣示无疑等于告诉他的核心支持者，他将撤换掉他们中的一些人。由于他并没有透露打算具体清除谁，共同的危机感使所有人都起念要除掉他。 第4章：掌权 爬上高位所需的技能与维持大权所需的本领完全不同。 我们中国也有一句俗话，叫「打江山不易，守江山更难」。对于一个刚刚上台的新领导人，通常都需要调整致胜联盟，使其更加忠诚。韩信帮刘邦打下天下后，韩信本身的存在就成了一个威胁，因为他在军事上太有才能，并且掌握军队大权。范蠡在这一点上就非常聪明，懂得越王勾践「只可共患难不可共富贵」。 一名老谋深算的新领导人会迅速采取行动将他们当中的一些人清除掉，替换成那些所获利益更能确保其未来忠诚度的人之后，一名领导人的未来权位才有保障。 不光是国家领导人符合这种规律，企业的CEO也一样。同国家不同，企业的实际选择人集团很多时候就是公司的董事会成员，而董事会成员因为拥有多数公司股份，加上上市公司的限制，CEO 很难构建致胜联盟。不过，本书中的惠普公司 CEO 的故事中，我们看到了 CEO 菲奥莉娜 通过并购重建董事会成员，以提高致胜联盟的例子。 也许是为了获得留下来的几位原董事会成员的支持，或也许只是巧合，董事会成员们的报酬发生了显著变化。在菲奥莉娜成为惠普的首席执行官之前，董事会成员获得的报酬（也就是私人好处）在105700美元至110700美元之间。随着菲奥莉娜上台和董事会规模变小，这一数字略微缩减为100000美元至105000美元之间，并在2000年至2003年之间保持不变。但到了2004年，根据惠普公司委托声明书里公布的数据，董事会成员拿到的钱在200000美元至220000美元之间。同一时期，惠普的年化股息稳定在每股0.32美元，惠普的股票表现显著跑输主要股指。事实再清楚不过了：惠普的股价表现低劣、股息不变，而董事们的报酬却翻倍。 最近万科的事件当中，王石在投资中引入新的大股东，如果从构建致胜联盟来看，也是非常正确的。新引入的大股东和公司高管很容易处于蜜月期，从而在决策中达成一致。 一个联盟的最重要的三个特征是：（1）忠诚；（2）忠诚；（3）忠诚。成功的领导人让周围充满自己信赖的朋友和家人，而将任何有野心的支持者清除掉。 当然，有些时候拥有一些能干的顾问是必不可少的。拜占庭、莫卧儿、中国、伊斯兰王国以及许多其他国家的君主想出了一种很有创意的方法来防止这些顾问成为敌手：他们全都在不同时期仰赖宦官。 就算到了现代，选择无法登顶的亲密顾问这一原则仍然有效。萨达姆·侯赛因作为伊斯兰国家伊拉克的总统，却挑选了一名基督徒塔里克·阿齐兹作为二号人物，这不是偶然的。 作者也在本章比较了民选领导人和独裁者在维护核心支持者这件事情上的难度。最终指出，因为很难构建小的致胜联盟，所以民选领导人更容易下台。而独裁者开始的时候比较容易被人推翻，但是一旦独裁者构建成功致胜联盟，那么就很难下台了。 第5章：窃贫济富本章主要是讲的如何获得金钱。政治的5个基本法则中，第3条就是获得掌控收入的分配。如果无法获得足够的金钱，就无法构建致胜联盟。在这方面，书中提到了一些办法。 继承财富对于民选国家，财政可以从上一任领导班子中获得。但对于独裁者来说，通常这部分金钱是保密的，所以比较难找到。所以，「知道钱在哪里」在独裁国家尤其重要。利比里亚在多伊被推翻后，因为没有人有足够的资源控制全国，每个派别在小范围内收买支持者，所以全国陷入了内战。 征税征税面临三个限制： 第一，征税会削弱人们工作的热情。 第二，一些税收方面的负担不可避免地会落到领导人的关键支持者身上。 第三，收税需要专业知识和资源。收税的成本限制了领导人能够榨取什么并影响到征税方法的制定。 一般来讲，第一点限制了独裁国家的税收，第二点限制了民主国家的税收。 开采资源相比于征税，直接从自然资源中获得财富要容易得多。资源丰富的国家使独裁统治者有能力大规模地回报支持者并聚集起庞大的财富。但是，因为基本法则五，所以这些钱并不会用于改善人民的生活。 拥有丰富可开采自然资源的国家系统性地落后于资源稀缺的国家。资源丰富的国家经济增长较差，容易发生内战，比资源稀缺国家更具有独裁性。 为了确保人民无法协同造反、夺取国家控制权，领导人竭力让联盟以外的人保持贫困、无知和散漫状态。具有讽刺意味的是，原本可以用来解决各种社会问题的石油反倒给领导人提供了将这些问题故意变得更糟的政治动机。 在本书中，作者举了尼日利亚的例子，尼日利亚据称拥有世界第十大的石油储备。从1970年到2000年，尼日利亚累计获得3500亿美元的石油收入。但尽管拥有巨大的石油财富，但尼日利亚的人均年收入从1970年的1113美元降至2000年的1084美元，该国成为世界上最穷的国家之一。 借钱&amp;债务减免通过向别的国家借钱或债务减免来获得财富，这通常都伴随着一些政治条件的交换。 第6章：获取与花费本章讨论可以把钱花在哪些地方，包括：教育、医疗、清洁的饮用水、基础设施建设、自由（出版自由、言论自由、集会自由等）。 非常有意思的是，在独裁国家，领导人除了限制自由之外（这一点很好理解），也会限制教育、医疗或基础设施建设。因为这都有助于推翻独裁者的统治。 不论是独裁者还是民主领导人都面临相似的问题：什么范围的教育才是适量的？对于那些依赖极少数支持者的领导人来说，答案显而易见。教育机会不能太广泛，以至于普通人，也就是可相互替代者因受到教育而质疑政府的权威。 考察领导人对教育的兴趣，有一个更好的衡量办法，就是看顶尖大学在世界上的分布情况。除了几个特例之外，没有任何一个非民主国家拥有排名世界200强的大学。那些人口较少、依赖大量核心支持者的国家，比如以色列、芬兰、挪威、荷兰、比利时、加拿大，无一不拥有多所大学进入世界200强。 看到这里我顺便查了一下，中国的清华大学、北京大学排在全球第25名和第41名。 第7章：腐败使人有权对于独裁国家，腐败是一种提供私人报酬的方式，并且这种方式同时可以让动摇的联盟成员随时可能失去特权并被检控。 尽管私人报偿可以直接由政府财政拨给警察，补偿警察忠诚表现的最简单方式就是给予他们自由腐败的空间。工资这么少，他们必定会意识到腐败不仅可以接受也是必须的。然后他们会加倍效忠于政权：首先，他们会感谢政权给他们敛财的机会；其次，他们会明白，如果他们三心二意，将很可能失去特权并被检控。 对于民主国家，腐败的表现形式更加多样化，例如以扭曲的公共政策的形式出现。例如为富人的一些健康问题提供更多研究资金、为富人提供更为温和的税收政策等。 富裕人群和共和党候选人总的来说赞成政府对癌症、阿尔茨海默症以及其他老年病的医学研究提供支持，这些老人恰好构成了美国最富有的年龄层。 本文讨论了两个小致胜联盟的团体：国际足联和国际奥委会的丑闻，并且指出在这种小团体中，腐败几乎是无法避免的，唯一的办法是扩大致胜联盟的数量。 当独裁者通过腐败给予了致胜联盟合理的回报之后，剩下的钱就是他的自由裁量的资金了。他可以把这个钱存在自己秘密的银行帐号上，也可以用于改善人民的生活。不过文章也指出，很多时候改善人民的生活并不是那么容易的事情。 赫鲁晓夫计划实施一项农业改革。尽管出发点是善良的，赫鲁晓夫的农业计划和实施却是一场灾难。为了取悦赫鲁晓夫，并出于对达不到期望所带来的政治后果的可能担忧，地方官员们承诺尽力去完成他对于提高产量的要求。以苏联原始的农业技术来说，他们的承诺当然不可能实现。赫鲁晓夫的善意理念的结果就是，农民甚至不得不连种牛都杀掉以完成他们的肉类生产配额。 这一点和中国的大跃进时期遇到的问题如出一辙。 第8章：对外援助对于独裁国家的援助，很多时候都进了独裁者的口袋，而援助国很多时候对此是知情的，援助国对此睁一只眼闭一只眼的原因是：他在谋求某种政治交换。 很难相信援助机构会天真到不明白他们的资金遭误用。也许真相存在于美国国际开发署的另一个目标上—“增进美国外交政策的利益”。也许美国更感兴趣的是在对抗全球恐怖主义的战略中拥有一个可靠的盟友，以及在打击印度洋的索马里海盗方面获得帮助。 由于援助很多时候并没有改善人民的生活，所以援助国的形象甚至都是负面的。 2002年，皮尤研究中心在42个国家展开了一项民意调查。其中一个问题是问人们对美国的看法。在巴基斯坦，69%的受访者表示对美国极其厌恶。在埃及，这个数字是79%。在其他40个国家，平均只有11%的人对美国持有极端负面的评价。然而2002年巴基斯坦和埃及从美国平均获得了16亿美元的经济和军事援助，而其他40个国家平均只获得9700万美元的援助。这一模式被详细的统计分析所证实。获得大量美国援助的国家的人民看来很仇视美国。 第9章：反叛中的人民对于人民来说，反对独裁是非常正常的。但是作者指出，如果人民还能够发出反叛或抗议的声音，就说明政府还是相对温和的。真正的独裁者是不会让人有一丝抗议的声音。 谨慎老到的独裁者都将反叛扼杀在萌芽状态。这就是为什么我们一再重申，只有那些愿意做真正肮脏勾当的人才适合盘算成为独裁者。心慈手软的人一眨眼工夫就会被人搞掉。 如果军队不对人民的抗议采取措施，通常都表明，独裁者的致胜联盟出现了动摇。「安全部队拿不准是否能保住长期的特权，拒绝镇压群众，两面下注。」这种做法使得安全部队最终是站在胜者的一边的，这是一种更为自保的行为。 近代以来不少重大政治历史事件，从法国大革命到苏联及其卫星国的崩溃，都缘于政权的核心支持者不愿在关键时刻镇压人民。近年来的所谓“颜色革命”（格鲁吉亚2003年的玫瑰革命、乌克兰2004—2005年的橙色革命以及2005年吉尔吉斯斯坦的郁金香革命），突尼斯的茉莉花革命以及埃及革命，都展现了同一现象。 第10章：战争、和平与世界秩序对于民主国家，战争和对外援助都是为了同一目的，只是一个更强势，另一个更温和。 对民主领导人而言，战争不过是达到对外援助想要达到的目标的另一种方式。对外援助收买受援国的政策让步，战争则强加政策让步。 对于美国来说，中东政策的核心就是能源政策，为的是给美国经济运转带来稳定的能源供给。 如果说能源政策不是美国中东政策的一个主要决定因素甚至是最主要决定因素，那就太天真了，但这并不意味着是拿士兵的生命去换石油财富。美国的目标是保护石油的供应，因为石油为世界经济机器的运转提供了能源。联盟的目标是经济稳定而不是私人回报。 由于战争的胜负决定着民主国家领导人的政治安全，所以民主国家更喜欢打肯定赢的战争。 民主国家专挑软柿子捏毫不稀奇。回顾过去近200年，民主国家赢得了93%由它们挑起的战争。相比之下，非民主国家只赢下60%由它们发起的战争。 第11章：怎么办本章讨论了一些办法来解决前面提到的独裁问题，最直接的办法就是扩大致胜联盟的规模，使得独裁者无法为海量的联盟成员提供私人报酬，所以只能提供面向所有人的公共服务地方式来获得选票。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"美团到底为什么从 AppStore 下架","slug":"why-meituan-is-removed-from-appstore","date":"2016-06-26T15:08:39.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/06/26/why-meituan-is-removed-from-appstore/","permalink":"https://blog.devtang.com/2016/06/26/why-meituan-is-removed-from-appstore/","excerpt":"","text":"故事背景6 月 23 日（上周四）晚上，美团公司旗下的所有 App（包括美团团购、美团外卖、猫眼电影等 13 款）被苹果下架。一时间谣言四起，网上传得最多的原因是美团没有支付牌照，被实名举报，所以被下架了。而美团对外称是由于技术原因下架，正在和苹果沟通。 6 月 24 日上午，美团公司的全线产品重新上架成功。而美团和苹果公司均没有对外详细透露此次下架原因。 但是，此次事件里面反映出很多有意思的细节，值得和大家分析一下。 分析忘记续费首先我们来分析一下美团是否是因为忘记续费而被下架。做 iOS 开发的应该都知道，当我们的开发者帐号快要到期时，iTunesConnect 后台的顶部会出现黄色的警告提示，另外开发者的邮箱也会收到相应的邮件提醒。 美团旗下有 13 款应用，按照应用发版的频率，肯定会有工程师看到 iTunesConnect 后台的警告。因此，忘记续费这种事情实在是不太可能发生的。 牌照问题我们再来看看网上传得最多的理由：牌照问题。美团确确实实没有支付牌照，但是，如果真的是因为这个理由被全线下架，那么为什么仅仅过了一天又全线上架了？ 美团到现在也没有获得支付牌照，它旗下的 13 款应用在恢复上架后也没有做明显的功能改动。所以如果它因为这个理由被下架，那么理应在获得牌照，或者关闭相应功能后才能重新上架。 我查了一下，在恢复上架后，美团的应用最后更新时间是 6 月 20 日，美团外卖的最后更新时间是 6 月 2 日。这就说明这些 App 并没有做任何功能改动就重新上架了。 因此，牌照问题这个理由也是站不住脚的。 下架理由猜测那么，还有什么可能的下架理由吗？我突然想起来我以前在网易有道听到过的一个故事。 有一家公司的 App 有个小问题，苹果的审核人员想让他们做一个修改，但是，苹果发现这家公司留的 Agent 帐号里的电话号码打不通（或者没人接），于是苹果就霸气地把人家的 App 直接下架了。这家公司当然慌了，赶紧联系苹果，于是这个小修改迅速被执行了，App 被重新上架。 美团有可能遇上了类似的遭遇吗？我感觉是很有可能的。因为苹果在应用市场一贯强势的态度，让各大互联网公司都不敢怠慢。 而这种理由，也是最最可能不被苹果和美团公开的。因为对于苹果来说，因为联系不上就把人家全线 App 下架明显做法不太厚道。而对于美团来说，因为不敢得罪苹果，加上自己失误在先，也会选择不公开原因。 于是，技术原因就成了对外的公关说辞了。 我见过的下架事件在我的 iOS 开发经历中，除了上面讲的那个沟通不畅带来的下架外，我还知道两次下架事件。 一次下架事件是关于抄袭的。2012 年 9 月，大众点评向苹果举报食神摇摇抄袭大众点评内容，于是食神摇摇被苹果 App Store 下架。这次算是公司维护知识产权的一次正常博弈。 另一次下架事件是关于人人网的。2013 年，人人网旗下的游戏因为在 AppStore 恶劣地刷榜行为，被苹果全线下架。AppStore 的刷榜行为其实到现在也没有停息过，而且做得更加隐蔽，我们公司也深受其害，而且我们向苹果举报也不管用，我本周会另外撰文介绍那些不为人知的刷榜手段。 写在最后这个事情还有一点比较奇怪的是，我私下认识一些美团的 iOS 开发，连他们都不知道这件事情的背后原因，让这件事情更加神秘了。 另外，我了解到像微信这种海量用户的 App，会被苹果的审核团队特别照顾。除了能够获得快速的审核外，审核员也会和微信团队有更加密切的交流，以便微信能够快速响应审核意见。 我个人认为，除了微信以外，像美团这种在中国区 AppStore 总榜前十的应用，也理应受到这样的审核照顾。这种野蛮的下架，对于中国区的 iPhone 用户来说，也是一种伤害。 就在发稿前，美团在 AppStore 排名总榜第五（下图）。 苹果现在更加重视中国市场了，而应用审核时更加良好的沟通，就是对于中国市场和开发者最大的激励，期望 AppStore 中国区越来越好。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"我与 InfoQ 的故事","slug":"my-story-about-infoq","date":"2016-06-26T13:28:29.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/06/26/my-story-about-infoq/","permalink":"https://blog.devtang.com/2016/06/26/my-story-about-infoq/","excerpt":"","text":"如果你也喜欢写作，这个真实的故事或许能够帮助你继续坚持下去。 我最早听说 InfoQ ，是因为在上面发现了很多关于敏捷开发的文章。可以说，InfoQ 是最早推广敏捷软件开发的社区。之后 InfoQ 的内容范围开始扩展，除了敏捷外，服务器开发，移动开发的内容也都有了。 在我心目中，InfoQ 网站上的文章一直是「高大上」的，直到有一天，我的老大常圳看到我常常写博客，推荐我向 InfoQ 投稿时，我才发现，或许我可以把「向 InfoQ 投稿」作为一个长远的目标。 我最早的投稿文章都是偏 iOS 开发工具类的，那个时候网上的 iOS 文章很少，有一些好用的工具并不是那么普及，于是我就将我熟悉的 Charles, Reveal, Crashlytics 等工具整理成文章发表到了 InfoQ 上。很感谢 InfoQ 的水哥和杨赛两位编辑，他们对于我这个新手非常 Nice，对于文章内容也提了很多有价值的意见。这些文章在 InfoQ 上的发表给了我最初的信心。 于是我开始写一些更难的 iOS 技术文章，包括分析 Tagged Pointer 实现的：《深入理解Tagged Pointer》、block 的实现原理等。 最终，我发现这些文章已经足够汇集成一本书了，于是我就出版了《iOS 开发进阶》。所以，如果没有 InfoQ 最初的鼓励，应该就没有这本书的出版。 也正是因为我在 iOS 领域的文章得到了 InfoQ 和读者的认可，也才使得我更加大胆地表达意见。包括推广 ReactiveCocoa 的文章：《ReactiveCocoa - iOS开发的新框架》，以及警示大家避免过于崇拜 MVVM 和函数式编程的文章：《被误解的MVC和被神化的MVVM》，以及关于 Swift 的一些思考。 现在的我更加自信，我可以明确地表达出自己的技术观点，包括对于 Core Data 的厌恶，对于 Realm 的警慎，对于 React Native 的悲观，对于 Xib 的漠视，对于自动化测试的遗憾。这些观点在新人口中说出很可能会被认为无知，而我有信心坚持自己的观点。 我在快速成长，InfoQ 也是。现在的 InfoQ ，已经成长为极客邦，旗下除了 InfoQ，还包括 GIT，EGO 和 StuQ。而 InfoQ 主办的 QCon 、ArchSummit 已经成为全中国最有名的技术会议。在今年，InfoQ 开始涉足垂直领域，上周刚刚结束的全球移动技术大会（GMTC） 就是一次成功的移动端会议。 现在，InfoQ 不但有网站了，也有微信公众号，里面的推送内容有相当一部分都是移动开发相关的，例如： 携程移动 App 架构优化之旅（编号 21） 全栈工程师谈微博 iOS 客户端架构与优化之路（编号 22） 京东无线服务端架构演进历程（编号 23） 滴滴 iOS 客户端的架构演变之路（编号 24） 偷师饿了么：怎样用 HTTP&#x2F;2 优化 iOS APP 网络层次架构？（编号 25） 被误解的 MVC 和被神化的 MVVM（我的投稿，编号 28） 这些文章都是非常有阅读价值的，长按上面的二维码，关注 InfoQ 后，在 InfoQ 的微信公众号回复相应编号，就可以看到相关文章。 感谢 InfoQ 一直以来对我的帮助，如果你也希望像我一样成为技术作者，那么可以从尝试给 InfoQ 投稿做起，相信你一定会收获很多。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://blog.devtang.com/tags/writing/"}]},{"title":"为什么提交 AppStore 总有事故发生","slug":"appstore-accident","date":"2016-06-19T12:23:24.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/06/19/appstore-accident/","permalink":"https://blog.devtang.com/2016/06/19/appstore-accident/","excerpt":"","text":"6 月 18 日上午，百度云 iOS 版出现了线上事故，他们在提交 AppStore 审核的时候，把名字给弄错了。用户更新 App 之后，看到的 App 名字是 netdisk_iPhone，如下图所示。此后，百度在当天紧急提交了一个加急版本，修复了该问题。 百度云在 AppStore 总榜中排名 50 名左右，这次事故虽然不太影响用户使用，但是确实会给用户感觉到一些困扰。比如因为它的名字实际上不存在，所以当它想获取 PUSH 消息权限时，弹出来的对话框是如下图这样。用户很可能会觉得奇怪，从而点击 “不允许”。 在大厂里面，不止百度犯过错误，大约在一年前，新浪微博的客户端不小心把调试选项给加包到了正式功能中。于是大家都乐坏了，各种给自己加 VIP 效果，当然，服务器端的验证逻辑还是存在的，所以倒也并没有产生非常大的事故。下图是当时新浪微博事故 App 的截图。 也不能光说别人，其实我们公司前段时间也出现了一个线上事故。猿辅导 App 不小心把测试版给提交到 AppStore 上了，但是由于测试服务器地址不是对外网公开的，于是更新了的同学就无法正常使用 App 了。这个事故大概影响了我们将近一天时间，线上服务完全连不上，算是比较严重的了。 我见过的最最严重的事故，大概是两年前，某个上市公司出的金融类应用，在打包的时候，不小心把源代码打进了 IPA 里面。这个行为恰好被喜欢解 IPA 随意翻翻的 BeeFramework 的老郭看到了，于是大家一起围观了一下它的代码。好在大家都是圈内人，没什么恶意，所以也没有公开此事。不然，用这个代码随意做一些社交机器人或者抓取机器人还是挺容易的。 好了，关键来了。如何防止这类事故发生呢？我觉得做到以下几点应该就可以了： 不需要到线上的调试代码，需要用 DEBUG 宏在代码里面明确禁掉。 将整个工程的配置，用 shared scheme 的方式，放在版本管理之下，所有的配置改动，都需要进行 review。 使用自动打包的脚本，不依赖人工进行打包操作。 在正式上线前，用苹果的 TestFlight 进行测试。TestFlight 的测试包可以做到和线上的包完全一致，所以像以上提到的所有问题，都可以在这一个环节发现。 百度云的这次事故，很可能的原因是被开发误删除了配置中的 App Name，如果采用上面的步骤，那么在第二步和第四步中，将会发现这个问题。 大家有什么更好的办法吗？欢迎回复讨论。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"WWDC 2016 随想","slug":"wwdc-2016-notes","date":"2016-06-14T14:32:50.000Z","updated":"2024-01-06T14:52:37.928Z","comments":true,"path":"2016/06/14/wwdc-2016-notes/","permalink":"https://blog.devtang.com/2016/06/14/wwdc-2016-notes/","excerpt":"","text":"今天凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。 花絮我为了半夜起来看 WWDC，特意提前 10 点钟就睡觉了。我睡觉前特意带上 Apple watch，并且设置好震动闹钟，免得到时候闹钟吵到家人。结果这傻 watch 在我睡着后先是提醒我看每周运动摘要，然后过半小时又震动提醒我已经静止太久应该活动一下，你妹啊！ 不准笑！说你呢！！ 时光因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：&lt;wwdc.apple.com&gt; 。 我还记得我刚毕业那阵子，也是熬夜看 WWDC，那个时候我还和老婆租的房子住，并且和校友一起合租的一个两居室。想想也就过去几年，现在自己有了更大的房子住，而整个移动互联网也成就了大量的百亿市值的公司。Tim Cook 在直播中提到，AppStore 是 8 年前出现的，再次感叹到移动互联网真的是好年轻啊。 内容这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。 watchOSwatchOS 推出了 watchOS 3，据说启动速度更快了，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享《Architecting for Performance on watchOS 3》，感兴趣的朋友可以关注。 增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。 别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。 tvOS这部分直接跳过吧，原因你懂的。 macOSOS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 ! 剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。 optimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。 apple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。 siri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。 增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。 iOS介绍了 10 个特性，我选一些有意思的介绍吧。 Siri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。 系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。 homekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。 电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了。另外，phone extension 似乎可以做更多的事情。 iMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。 中国元素这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。 Developer这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒，下面是这个应用的界面，大家感受一下。 不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：https://developer.apple.com/swift/ 。 所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。 还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字： 这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：《Using and Extending the Xcode Source Editor》 结语最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。 哦，我整理了一个后续值得观注的 session 列表，分享给大家： Improving Existing Apps with Modern Best Practiceshttps://developer.apple.com/videos/play/wwdc2016/213/ What’s New in Cocoa Touchhttps://developer.apple.com/videos/play/wwdc2016/205/ What’s New in Foundation for Swifthttps://developer.apple.com/videos/play/wwdc2016/207/ What’s New in UICollectionView in iOS 10https://developer.apple.com/videos/play/wwdc2016/219/ Typography and Fontshttps://developer.apple.com/videos/play/wwdc2016/803/ Advanced Testing and Continuous Integrationhttps://developer.apple.com/videos/play/wwdc2016/409/ Debugging Tips and Trickshttps://developer.apple.com/videos/play/wwdc2016/417/ Getting Started with Swift ( 有最新 Swift 3 的内容）https://developer.apple.com/videos/play/wwdc2016/404/ Going Server-side with Swift Open Sourcehttps://developer.apple.com/videos/play/wwdc2016/415/ Introduction to Xcode ( 看看 Xcode 8 的新功能有啥）https://developer.apple.com/videos/play/wwdc2016/413/ Swift API Design Guidelineshttps://developer.apple.com/videos/play/wwdc2016/403/ Understanding Swift Performancehttps://developer.apple.com/videos/play/wwdc2016/416/ Using and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）https://developer.apple.com/videos/play/wwdc2016/414/ What’s New in LLVMhttps://developer.apple.com/videos/play/wwdc2016/405/ What’s New in Swifthttps://developer.apple.com/videos/play/wwdc2016/402/ What’s New in Xcode App Signinghttps://developer.apple.com/videos/play/wwdc2016/401/ Concurrent Programming With GCD in Swift 3https://developer.apple.com/videos/play/wwdc2016/720/ NSURLSession: New Features and Best Practiceshttps://developer.apple.com/videos/play/wwdc2016/711/","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"写给程序员的管理入门课程 -《格鲁夫给经理人的第一课》","slug":"high-output-management-summary","date":"2016-06-06T15:50:00.000Z","updated":"2025-06-22T14:33:07.188Z","comments":true,"path":"2016/06/06/high-output-management-summary/","permalink":"https://blog.devtang.com/2016/06/06/high-output-management-summary/","excerpt":"","text":"序 《格鲁夫给经理人的第一课》 最早出版于 2007 年，书原名为《High Output Management》。本书的作者格鲁夫是 Intel 的前 CEO，领导了 Intel 从一家濒临倒闭的存储器公司，转型为微处理器公司，并且在个人 PC 开始流行时，成功和微软缔结 Wintel 联盟，主宰了整个 PC 电脑时代。 格鲁夫是一个技术出身的管理者，在本书中，我们甚至看到他多次用编译器来举例，所以这本书也非常适合有技术背景的读者。 本书主要分为四大部分： 第一部分「早餐店的生产线」：用早餐店的经营故事，来类比企业的经营管理，介绍了一些数据分析、产品预测、产品检验的办法，提出了管理杠杆率以及关注于产出的管理原则。 第二部分「打好团体战」：展开论述管理杠杆率，并且讨论了开会、决策和规划。 第三部分「推动组织的巧手」：从企业组织架构入手，谈混合型组织，双重报告，CUA 模型，以及文化价值观。 第四部分「谋事在人」：讲人员管理。涉及激励、工作成熟度、绩效评估、招人与留人、报酬与培训。 第一部分：早餐店的生产线本部分用早餐店的经营故事，来类比企业的经营管理。介绍了一些数据分析、产品预测、产品检验的办法。 第一章：“生产” 包含什么？格鲁夫认为，一个早餐店的生产线，就包含了一个现代软件开发管理中的各种问题。一个合格的早餐店的生产线，可以在预定的时间内，用最低的成本，做出顾客需要的产品。而现代软件的开发流程，也是希望在一个预定的时间内，用最低的成本，开发出符合产品经理定义的、合格的应用或服务。 这个过程，涉及一些最基本的项目管理工作：找出限制步骤，然后优化流程，形成一个最佳的策略。 在经营早餐店的故事中，限制步骤可能是人员数量、一些机器的产能、或者库存量。通过分析这些限制步骤的成本和收益，你就可以找出一个最价收益的方案。 软件开发中的项目管理也是这样，你的限制步骤可能是人员数量、开发时间、产品功能点、测试时间、或者技术实现方案。找到限制步骤后，通过优化限制步骤就可以优化整个流程。 第二章：从早餐店的库存谈起格鲁夫认为，我们应该确定和监控早餐店的核心指标，对于一个早餐店来说，核心指标包括：销售预测、原料库存、设备状况、人员情况、品牌评价（用户反馈），并且每天检视这些指标。 另外，作者提到，指标应该有相互的限制，这样避免过度反应。就像软件开发中的软件质量与开发时间一样，不能只追求质量而不管开发时间，也不能只追求时间还不管质量。 其实作者在这章强调的就是数据分析的重要性，在数据分析上，作者介绍了一些方法，包括： 先行指标，用于揭示未来信息的指标，例如 NPS，机器故障记录。 线性指标，用于分析进度的指标。 趋势指标，用于分析变化趋势的指标。 重复印证表，用于修正预测行为，提高预测准备性的指标。 作者接着提到了计划生产。这个事情是预期未来的销售额而提前生产（放到库存）的一种行为。这里面合理地预测未来是核心，否则要么就会造成没有商品可卖，要么就会造成库存过高。刚刚提到的「重复印证表」可以比较好地帮助我们做预测的调整。 作者接着提到了检验质量。检验质量应该在生产的每个环节都做，但是越早的环节，检验的成本越低。就像我们修复程序的 Bug 这件事情一样，如果我们刚刚写完代码就收到相应的 Bug 报告，那么修复的成本会小很多。但如果我们写完过了一周才收到 Bug 报告，那么我们就需要花精力先回顾当时的逻辑，才能进一步找到有问题的代码。 作者提到了一些检验质量的办法，用于节省检验本身的精力成本。 第一种检验办法是：海关与监视器。海关简单来说就是所有的东西都必须检查，监视器简单来说就是抽样检查。根据具体产品出问题的概率，以及出问题的危害程度，我们可以结合海关的检验方法和监视器的检验方法。 第二种检验办法是：随机检验。随机检验的量应该随着检验结果的好坏有所调整，使得检验有针对性。 本章的最后，作者提出了管理杠杆率的概念，并且用下面的漫画来做了解释。作者认为，通过定义管理的「产出」，我们可以专注于那些提高产出的管理活动，那些高投入产出比的管理活动被作者称作「管理杠杆率」高，进而应该被优先安排和执行。 第二部分：打好团体战本部分介绍了管理的一些经验技巧，涉及管理杠杆率、开会、决策和规划。 第三章：管理杠杆率作者首先在本章定义了经理人的产出： 经理人的产出 &#x3D; 他直接管辖部门的产出 + 他间接影响所及部门的产出 格鲁夫介绍了他一天的工作，能够看出来工作内容非常杂乱，也非常多，而且做不完。他说： 我的一天通常结束在我觉得累而决定回家休息的时候，而不是事情做完了。 像家庭主妇一样，经理人永远有忙不完的事情。 因为事情永远做不完，所以我们更需要关注于工作的产出，把最高优先级的事情找出来优先安排和执行。 管理工作的分类我们从格鲁夫一天工作的介绍中，能看出来他的工作分为几类： 信息收集类。看邮件、看报告、开会、和同事聊天、看用户反馈、看产品数据、试用公司产品等。 传递信息。培训或者分享观点。 决策。通过、制定或者否决一些方案。 给予提示。传递一些观点。 为人表率。提供行为示范。 在信息收集方面，作者鼓励在使用传统的邮件和口头直接沟通外，多增加一些非正式的沟通机会。比如多随意在公司里走走，找不同的人聊聊天等等。 在决策方面。作者认为决策分为两类：「未雨绸缪型」和「亡羊补牢型」，前者是在规划未来，后者是在补救当前问题。 关于给予提示，作者认为他与决策的差别在于，给予提示很多时候并没有明确的方案，他是希望让对方通过提示来做一些调整，而调整的具体的细节需要对方自己思考。 除了以上四类（信息收集、信息传递、决策、给予提示）工作，作者也提到，管理者的所有行为，同时也在以「榜样」的作用被员工效仿。例如管理者随意迟到，员工就会随意迟到。管理者做事情认真，员工也会有认真工作的压力。 管理杠杆率在介绍完管理工作的分类后，格鲁夫给大家介绍了他的管理杠杆率公式： 经理人的产出&#x3D; 组织产出的总和&#x3D; 杠杆率 A * 管理活动 A + 杠杆率 B * 管理活动 B …… 与管理杠杆率相关的因素有很多，包括时效：一个员工有离职情绪时，及时沟通的时效就很重要。一个重要会议要开时，提前准备内容的时效就很重要。 另外，格鲁夫指出，也有很多管理活动的杠杆率是负的，例如：经理人情绪低下，影响员工士气。经理人越权干涉别人的工作，影响别人积极主动性。经理人做出错误决策，浪费人力物力。 格鲁夫指出，高杠杆率的事情包括： 当一个经理人可以同时影响多个人的事情 当经理人一个简单动作或简短谈话，会对别人产生长远影响的时候 当经理人的技术、知识或信息，对一群人造成影响的时候 作者也列出了一些具体的高杠杆率的事情： 关注用户的反馈，特别是抱怨。 绩效评估。 传授知识、技能或价值观给部署。 授权。 授权关于授权，作者做了展开的介绍： 没有完备监督计划的授权等于渎职。你绝对不能完全地抽身，即使你已经授权，你还是得负成败责任。全程监督整个被授权的案子是确保结果尽如人意的唯一方法。监督不是干涉，而是通过不时的检查，来确定活动的进行一如预期。因为监督你熟悉的工作比较容易，所以如果有机会，你应该把自己熟悉的工作授权给他人。但切记先前举的例子—理智叫你松手，但情感上你可能老大不愿意。 监督的办法可以用上一部分提到的检验产品质量的原则：越早检验成本越小。例如对开发工作不熟悉的员工，让他们在写代码前就先给你讲讲他打算如何规划，就比让他写完你再检查要好得多。 监督的另外一个技巧也是检验产品质量的原则提到的：注意检验的频率。对于新人，要增加频率。对于信任的人，可以降低频率。另外，监督的方法要具有多样性，对不同的人采用不同的方法。 监督并不是说经理人一定需要替员工考虑好事情的方方面面，因为这毕竟需要付出大量的精力。对于某些事情，经理人只需要提出一些细节问题来测试员工的思考是否全面，则可以一定程度上评估出事情的靠谱程度。对于经理人不熟悉的领域，也可以用此办法。 关于这方面的知识，我在指导 iOS 开发新人的时候体会很深。通常指导新人的常用办法，就是将自己熟悉的工作交给新人完成。因为这些工作非常好通过监督（Code Review + 定期讨论）来保证质量，所以风险可控，而我自己也会从中学习到指导别人的各种技巧和经验。 最重要地，我需要打破我的舒适区，因为我需要放弃自己非常熟悉的工作内容，转而做一些新的陌生的事情。而新人的代码质量和编写速度往往是比我自己直接写要慢得多的，我需要有耐心地等待他们犯错，然后通过 Code Review 和讨论来让他们学习到相应的编程知识。 学会指导新人通常是一个有经验的程序员转向更高职位的第一个挑战，不管是他是转向偏管理的岗位还是继续在技术岗位上深挖，都需要先将手中的工作交出去，才能够承担更重要，更有挑战的事情。 提高效率作者提出了一些提高效率的办法： 找出限制步骤：重要的、紧急的事情优先安排。这样的情况下有空余，再安排别的事情。 类似的工作放在一起做。例如将邮件处理，QQ 信息回复的事情稍做积累再统一回复。 安排好日程表。对一些事情说不，对日程表的事情留上 Buffer。 建立指标。尽量估计自己在每件事情上的花费，尽管这件事情很难，也可能不太准，但是总是会有所帮助，而且有经验了之后，估计时间会越来越准。 存货法。留一些重要不紧急的事情，使自己不太忙的时候，可以做这些事。比如对于我来说，学习产品知识，试用各种 App 的功能，分析各种 UI 设计就是一个「存货」。 标准化。对一些经常做的事情，制定标准化的流程就可以提高效率。这就类似我们制定的产品评审流程，上线流程一样。标准化了之后，就不用每次想应该怎么做了，按步就班地开展即可。 老被人打断怎么办？作者认为「躲起来让人找不出」或者「叫别人不要在某些时段打扰」的办法都不太好，他介绍了很多有用的办法，包括： 标准化。把一些常见的问题归类总结。如果一类问题有归类总结了，也就意味着它能够被授权给员工来处理了，也很容易被进一步用于员工指导别人。 类似的工作放在一起做。每天固定时间处理员工的问题，或者固定在一对一沟通中处理相关问题。 运用指标。有指标就可以改进流程。看看自己花费在解决临时问题上的时间以及常见问题，然后就可以看看能够优化这些时间。 第四章：管理必经之路：开会格鲁夫将会议分为两类：过程导向会议和任务导向会议。 过程导向会议：关于知识技能和信息交流，通常是例行的。 任务导向会议：会产生决策的，通常不是例行的。 过程导向会议过程导向会议又可分为以下三类：一对一会议、部门会议，以及运营总结会议。过程导向会议要尽量规律化。 关于一对一会议，我之前专门写过文章：《浅析一对一沟通》 关于部门会议，作者的经验是经理人要注意大家讨论的主题和效率，事先讨论的主题需要明确，最好大家在开会前能做好准备。经理人要尽量让讨论是自由的，避免成为自己主宰的「一言堂」。部门会议的议题应该尽量让部属来负责，经理人的责任只是保证讨论不要偏题即可。 运营总结会议是让那些通常没有机会开部门会议的同事提供互动的机会，让他们有机会彼此学习及分享经验。 任务导向会议过程导向的会议一般有固定的开会时间和频率，其效果也多是交流信息为主。而任务导向会议一般没有固定的开会时间和频率，会议结束后一般也需要产出一份会议的讨论结果用于后续执行。 这种需要决策的会议通常需要控制人数，如果超过 8 个人，很可能比较难以推动达成意见的一致。 互联网公司实际的情况就我的感受，互联网公司其实为了追求效率，还是希望尽量少开会，我参与的会议主要分几类： Scrum 相关的会议：包括计划会议、每日站会、评审会议和回顾会议。我们的技术和产品工作都用 Scrum 的方式来管理。 过稿会议：产品的过稿会议，UI 稿的过稿会议。 一些临时性的，需要讨论的会议，类似格鲁夫提到的任务导向会议。 如果把一对一沟通算作会议，那么这也是我常参与的。但是因为一对一沟通的场地经常是在非办公室的区域，所以我其实不觉得这是一种会议。 第五章 不挥舞权杖的决策由于在互联网公司，科技类知识更新速度非常快，而相对于一线的技术人员，管理者并不能拥有更多决策所需要的专业知识，因此我们需要将具体的决策，下放到一线的员工手中。 格鲁夫在书中描述了一种理想的决策方式： 先是充分地讨论和表达意见 然后是在意见充分被表达之后的决策 最后是一旦最后决策产生，那些少数不同意的同事，都应该在之后执行过程中全力支持。 第六章 规划是为了明天 在你规划行动方案之前，一定记得先问自己：有什么事情我如果 “今天” 做了，可以让 “明天” 更好，或者至少让 “明天” 不会更糟。 在本章，格鲁夫首先介绍了 Intel 在流程规划上的一些方法，但是个人感觉比较偏制造业，因为讲的都是处理原材料，库存与订单之单的矛盾。 接着，格鲁夫介绍了目标管理，包括需要做到：1、有明确的目标。2、有向目标前进的具体方案。 当你将计划落实为白纸黑字时，看起来最抽象笼统的总结即为你的战略，而你用来实行战略的行动即为战术。 对于这章，我自己倒是有一些总结。就我在互联网公司的经验来说，我们做规划和目标管理主要是分为以下几类：产品规划、开发规划、运营规划、人员规划。 产品的规划我们通常需要计划出未来至少 3 个版本的产品迭代计划。然后，对于这些产品计划，安排相应的产品 PRD 稿的撰写和评审、UI 稿的制作和评审、技术评审、开发测试及最后的上线。 开发的规划开发的规划主要是通过 Scrum，将产品和美术稿已经 Ready 的待做事项以 backlogs 的方式放在 Scrum 的管理中。然后在每一个迭代冲刺（Sprint）中，我们从 backlog 里面选取部分工作到当个 Sprint 中。 每一个 Sprint 是包括完整的开发和测试工作，服务器端通常在 Sprint 快结束时，就需要完成上线操作。客户端由于版本发布过于频繁对于用户也有一些打扰，所以我们通常两周对外发布一次版本。 运营的规划大型的运营活动如果需要产品和开发的介入，就也需要相应的规划。通常情况下，我们认为提前一个半月开始是相对充裕的方式。运营花大概两周做活动的策划，剩下的一个月用于技术的排期。 人员的规划作为团队管理者，我们还需要在人员上做相应的规划。这包括： 人员的招聘。预估未来业务增长对于人力的需求，以便提前做好相应的招聘工作。 人员的培养。新人的培养、重要岗位人员的培养。 人员的激励或开除。对一些表现优秀的人员，给予更多的关注和沟通。对一些表现不佳的人员，除了需要明确地指出他们的问题外，也需要根据改进情况选择后续的处理方案。 第三部分：推动组织的巧手本部分介绍一些实践经验，作者从早餐店的发展作为故事，引出企业管理中涉及的混合型组织架构，从这种架构带来的问题出发，提出了双重报告这种解决方案，由从双重报告需要的企业文化出发，介绍了影响人们行为的 CUA 模型，最后得出高 CUA 因素的工作，需要员工用文化价值观来指导行为。 比较可惜的是，对于如何增强大家的文化价值观，格鲁夫并没有展开讨论，只是说领导应该以身作则。 第七章 当早餐店开始繁衍 在实务中，这种有关管理上集权及分权的分歧到处可见，几已成为今日管理上最重要的课题之一。 本章只讲了一个故事，当早餐店做得越来越好时，分店越来越多，带来的管理上的复杂度也越来越大。不管是采购，还是人事，还是资产，我们都需要专门雇佣人员来负责。 但是除了这个故事外，本章并没有涉及任何解决方案的内容。 第八章 混血型组织 斯隆总结他在通用汽车数十年的经验时说：好的经营管理，是中央集权和地方分权间的折中产品。 本章讨论了两种组织形式：「任务导向组织」和「功能导向组织」。 任务导向组织是以具体的完成某件事情为目标而形成的组织。功能导向组织是以完成某个细分功能而形成的组织。这两种组织各有优缺点，很多时候需要以混合的形式存在于一家公司，而具体如何混合，在不同的公司差异相当大。 拿互联网公司来举例，我所在的猿题库是更偏向「任务导向组织」的公司，我们公司旗下有三款产品：猿辅导、猿题库、小猿搜题。这三个产品下面，各种有着完整并且独立的运营、产品、开发、测试、UI 团队。而我之前工作的网易有道，就是一家更偏向「功能导向组织」的互联网公司，因为在网易有道，有着全公司统一的测试团队、UI 团队。还有一些公司，他们甚至将全公司的移动端开发都集中成一个移动开发团队。 两种组织方式各有优缺点，我们来看看作者格鲁夫的分析。 功能导向组织「功能导向组织」的部门更像是内部的分包商，相比外部的外包商，内部的分包商因为同属于一家公司，所以提供的服务会更好，而且还有： 规模经济。以运维为例，全公司统一的运维部门，有利于在公司内部建一统一的运维规范和运维系统，节省运维成本。 根据需求，转移或分配企业资源。以测试为例，全公司统一的测试团队，在某些产品有更多临时测试需求时，更好地调配人员。 共享知识。全公司统一的测试团队、UI 团队有利于他们更加方便地交流相关的专业技术，测试团队可能在测试流程上更加优化，UI 团队可能在全公司范围内统一 UI 设计规范和准则。 但是，「功能导向组织」的缺点也很明显，包括： 不同部门之间会争抢「功能导向组织」的资源。比如测试团队如果是公共的话，每个部门都会为自己的产品争取尽量多的测试资源，但是谁能够证明自己的优先级肯定比别人的高呢？所以这其中会产生更多的沟通和决策成本。 责任心减弱。这一条并不是格鲁夫总结的，而是我自己感受到的。拿移动开发团队举例，如果移动开发团队是「功能导向组织」，那么某个移动开发者对于一个临时的开发工作很可能并不能做到付出 100% 的全力，因为他很可能只在这个项目做两个月。那么他很可能着眼于「把当前的工作做完」，而不是「整个产品本身的利益」来考虑问题。 举一个具体的例子，当一个产品设计对一种特殊情况考虑不完整时，一个「功能导向组织」的开发者很可能基于按时「把当前的工作做完」这个目标，而选择忽视这些未定义的产品细节，按照「怎么方便就怎么开发」的方式来做，因为产品没定义清楚本来是产品的责任，与他无关。如果他找产品讨论这些细节，很可能使得实现方案变得更加复杂，对于他「把当前的工作做完」这个目标产生冲突。 但是，如果是一个「任务导向组织」的开发者，因为他会长久地负责这个项目的开发，这个项目的好坏最终会决定大家的绩效，他当前没有处理好这个产品细节，以后很可能也会是他来再次重构相应的代码。那么他就有更大的可能去和产品沟通和协调，确定这些未定义的产品细节。 任务导向组织「任务导向组织」的优点是什么呢？优点是需求更加明确，决策更加灵活，人员也更加有凝聚力。 「任务导向组织」也有缺点，主要是这种方式会使得大家在共享专业知识上更加困难。对此，我们公司增加了很多全公司范围内的技术分享会，通过这些分享活动，我们希望增加大家在技术上的交流。 那么，猿题库公司的具体混合型组织是什么样的呢？我们的「功能导向组织」仅包括：运维团队、算法研究团队、数据分析团队、财务和行政团队。而我们将产品、运营、测试、客户端开发、Web 前端开发、UI 设计人员都分拆放到了「任务导向组织」中，而我们按产品将「任务导向组织」分为了三个：猿辅导团队、猿题库团队、小猿搜题团队。 第九章 双重报告格鲁夫在本章中，推荐用双重报告来解决混合型组织的管理问题。混合型组织中，一个人如果在一个「任务导向组织」，那么他很可能在专业技能上无法得到 Leader 的指导，格鲁夫希望通过让这个人在专业技能上报告给一个专业技能上的 Leader，使得这个人在专业技能上有所成长。 但是，格鲁夫也提到，这种双重报告很多时候是模糊不清的，「含混是解决问题之道」。所谓的含混，就是指专业技能的 Leader 在实际上并没有明确的权力。有些时候，双重报告的存在形式是一些「同级群体」或「同级委员会」，这些群体可能由于一些专业问题自发地形成，但是自主地决策解决一些 Leader 无法解决的问题。 我自己就亲自经过多次「同级群体」决策。例如，苹果规定 2016 年 6 月 1 日之后的应用必须支持 IPv6，这意味着我们可能需要升级全公司共用的网络库，于是我就在群里面发起了这个问题的讨论，一些人（主要是相关产品的 iOS 负责人）自发地参与了这个讨论，然后大家讨论出了一些方案和结论。 这种「同级群体」决策的成功，更大程度上不是某个规则的作用，因为我们很难明确出哪些事情需要跨部门讨论，也很难明确出这些讨论的负责人。所以，我们只能用一些企业文化或者做事方式影响大家。 所以，我感觉格鲁夫在本章其实并不是强调双重报告，而是强调在「任务导向组织」中，还应该有一只看不见的手，让大家在织织之间，产生协同、讨论和决策。 格鲁夫在本章中没有描述清楚这只看不见的手，他只把它称作「企业文化」，而这正是他在下一章将要展开阐述的内容。 第十章 每个人都听命于三个 “长官”格鲁夫通过一个故事（故事中涉及买轮胎、遵守交通规则、主动帮助车祸的人）来说明一个人的行为，受三方面的影响： 自由市场因素：大家简单地以自己的利益作为行为指导，例如挑选商品时大多只会考虑价格和质量。 契约义务：通过事先达成的一致，然后履行契约义务。例如我们上班，就是和公司的一种契约义务。 文化价值观：一种为了组织利益，牺牲自我短期利益的行为，通常这种行为长远来看对个人也是有利的。 格鲁夫引入了 CUA 指标来帮助我们选择用以上哪方面的因素来指导人们的行为。CUA 分别指：工作环境的复杂性（Complexity）、不确定性（Uncertainty）、指令的模糊度（Ambiguity）。 程序员的工作就充满了复杂性，因为程序员需要不断地学习新知识，代码的逻辑和架构也可能很复杂。而市场的工作充满了不确定性，很多时候上司也无法帮你想出有新意的市场推广方案。 格鲁夫认为，如果一个工作的 CUA 因素高，而个人关注的是团体利益，那么就只能用文化价值观来作为行为的指导。但是如果个人关注的是自身利益，那么就会如下图显示的那样，情况变得「一筹莫展」。 格鲁夫举了一个例子，当海滩上发生灾难时，每个人都只顾及保全自己的性命，而救援工作需要极高的 CUA 因素，所以现场只会是一片混乱。 按这个理论思考，我们就能理解为什么要做火灾演习了，多次火灾演习可以极大地减少火灾发生的 CUA 因素，因为大家在演习中对于火灾已经有着明确的处理方案了，需要做的只是按之前演习中的契约行动就行了。 格鲁夫认为该理论对于指导新人也有意义： 让我们把这套理论套用在某个刚进公司的新人身上。由于初来乍到，他无疑比较关心自身的利益。因此，你应该给他明确的工作架构，降低复杂性及不确定性。 另外，该理论对于空降的高管也有意义： 对于空降的高管来说，就像起用任何新人一样，一开始他还是比较关心自身利益。但身为高级经理，他难免会被指派管理一个有问题的部门—毕竟这是我们从外面找人的原因。此时对这个经理人而言，他面临的不仅是烫手山芋，还有环境里很高的 CUA；同时，他也尚未建立起属于这个企业的价值观与行事准则。在此状况下，大家只能求老天保佑他能赶紧忘却私利，以大我为前提，并设法降低 CUA。如果他做不到这些，恐怕很快就会被撤掉。 文化价值观也不是银弹，在 CUA 因素低的时候，选择用自由市场因素或契约义务，都比文化价值观来得有效。所以，根据具体工作的 CUA 值，选择具体的控制模式，是经理人需要关注的。 不过话说回来，我仔细想了想互联网企业里面的各种职位，不管是产品、技术、还是运营，似乎都是高 CUA 因素的职位，所以文化价值观应该是互联网公司管理员工的基本方式。 很可惜，格鲁夫在本章中并没有详细介绍如何增强大家的文化价值观，他只是认为，管理者自己的行为示范，比把文化价值观挂在口头上有效。但是本书的第四部分，详细讨论了企业管理中人的问题。 第四部分：谋事在人本部分涉及激励、工作成熟度、绩效评估、招人与留人、报酬与培训。 第十一章 激励部属参加比赛格鲁夫将员工的问题分为不能和不为两类： 不能：能力不够。 不为：能力够，但是不够努力。 针对这两类问题，他提出了培训和激励两种解决方案。在本章作者并没有讲培训，主要详细讨论了激励相关的问题。 作者认为，激励应该和马斯洛的需求金字塔理论相符。 在「归属感与认同感」这一层，我们应该让同事们都喜欢当前的工作环境和同事关系，认同当前公司做的事情。同事之间的合作应该是愉快和融洽的，同事中还会有自己欣赏的牛人，有自己的好朋友可以一起吃饭、聊天。 只有产生了归属感与认同感，员工才会追求更高一层的「地位与尊重」。我们给那些表现优秀的员工更重要的事情，更高的职位，使得他能够在这一层上产生明确的目标。很多公司都会做职业发展的内部评级，其实就是给大家一个明确的地位与尊重的目标，让大家为此努力。 但是，「地位与尊重」的目标一旦达到，人们工作的动力又会下降。一些更牛的人，就会追求马斯洛需坟金字塔的顶端：「自我实现」。「自我实现」这一层的需求的差异性在于： 一旦某个人受激励的来源是自我实现，他工作的动力将不再受局限。这是自我实现有别于其他激励模式最重要的特点。其它的激励来源一旦在需求满足之后便不再生效，但是自我实现将不断激励个体向上突破。 有两种自我实现的动力可以促使个体将能力发挥到极致：精益求精型和成就导向型。 精益求精型的例子是音乐家、运动员，也包括程序员。拿程序员来说，一个程序员如果不断追求写出更牛逼的代码，那么他可以像阿里的多隆那样，成为合伙人级别的重要人物。 成就导向型的人常常怀有达成任务的决心，对于困难，他们喜欢挑战自我。其实做很多事情，刚开始都是需要面对失败的。成就导向型可以坦然地面对失败，然后再次挑战目标。 对于较高需求层次的人，失败的恐惧大多数是来自于内心而不是外界，如果不能克服自我内心的恐惧，那么这个人就会从自我实现的层次往下降。 一般而言，在较高的需求层次时，恐惧通常源自内在而非外在的威胁。人们经常因为过不了自己那一关而导致行动上的退却。但如果老是如此，这个人很快就会从自我实现的层次往下降落。 在具体实施激励时，格鲁夫认为，一个好的激励应该是目标明确的，并且这个目标应该是比较难以达到的，这样大家才会全力以付，发挥出尽量大的潜力。 如果我们想要让员工都能提升自我实现需求的层次，便必须先创造出一个讲求产出的环境。 另外，可以合理使用一些竞赛，让大家把竞技场上的争胜的心态应用到工作中。 工作的概念天生就不如竞技，我们干脆将运动场上的竞争精神融入工作。最好的方法便是先制定游戏规则，并让员工有衡量他们表现的尺度。 关于竞赛，我自己也有一些真实的感悟。我们公司很多人中午都会去游泳，之前大家都自己随便游，后来有一个同事说，我们分成两组，搞接力赛吧。虽然这是一个没有任何奖励的比赛，但是大家因为比赛，就会不自觉得更加努力游泳，连续多日下来，大家的体力都上升了很多。 关于激励，格鲁夫最后总结道： 经理人的角色在此便极为明显：他应当是个教练，身为教练，首先必须不居功，团队的成功来自于队员对教练指导的信赖；其次，他的训练必须严格。通过当一个铁面教头，他努力激发出队员的潜能，并刺激团队做出最佳表现。一个教练应该曾经是个好选手，因此他了解竞赛的规则以及选手在练习及比赛时可能面临的问题。 第十二章 工作成熟度 令人惊讶的是，即使较早建立起的管理理论多半靠直觉，后来的实证科学也并没有办法将它们推翻，或是证实某种管理风格确实较其他的更胜一筹。研究学者似乎必须下没有所谓最佳管理风格的定论。 格鲁夫首先通过英特尔在轮换经理人上的故事，引出了用「工作成熟度」（Task Relevant Maturity，TRM）来评估个人或部门。 根据工作成熟度的不同，格鲁夫建议用不同的办法来指导： 工作成熟度低时，指导应该是明确和具体的。包括做什么事情，何时完成，如何着手等。 工作成熟度中时，指导应该从具体的事情，转移到沟通、情绪上的支持与鼓励。 工作成熟度高时，指导只需要关注努力方向是否正确上。 格鲁夫说，我们在指导小孩的时候，也是符合这套理论的。刚孩子还小的时候，我们只会说做什么，不做什么；等他们长大一些之后，我们变成一些叮嘱和指导；等他们成人之后，我们基本上不再管教他们了。 指导的时候，我们应该注意建立共同的价值观。我们在猿题库也在这方面做了很多具体的尝试，比如我们强调：按时发布产品、代码质量、信息尽量共享、指导新人比日常开发工作更重要。这些都是在努力建立共同的价值观。 一旦员工了解了组织的营运价值观，又具有较高的工作成熟度时，主管便可以开始分权，进而提高自身的管理杠杆率。 格鲁夫在本章中也讨论了一个非常有意思的话题，管理者是否应该与员工建立友谊。他对此有两个观点： 我们不应该把友谊相关的社交活动与工作上的指导混为一谈。因为社交活动并不能直接在工作上产生帮助，当然，友谊对工作是有一些间接帮助的，因为它使得你们之间在沟通的时候会更加有效一些。 命令朋友其实是一件不愉快的事情。当你需要批评或直接命令朋友时，友谊可能会是一个阻碍。格鲁夫举了一个例子：当你需要给你的朋友打很低的绩效时，你是否感觉到非常难受？ 对此我个人的感受是，适当的友谊还是非常有必要的，对于一些同事，经过一段时间的合作，我们其实是能够比较清楚地判断出来他们的潜力。如果我们认为他们的潜力是足够大的，在建立友谊的同时，在工作上也给予更多的指导，应该是一个更好的做法。 另外，建立共同的「就事论事」的价值观也是非常有必要的。大家是朋友，但是工作上应该批评就批评，如果大家有着对事不对人的共同价值观，批评就不是那么不可接受了。 第十三章 再难也得做：绩效评估格鲁夫认为绩效评估是一个高杠杆率的工作，可以使得优秀的员工得到激励，从而更加努力。但是绩效评估又是一个非常难的事情，因为很容易产生冲突和争议。 绩效评估大致可以分成两部分：评估部属的绩效，以及将评估的结果告诉部属。作者认为，一个有效的评估报告应该包括：优点（需要有实例证明），缺点（需要有实例证明），如果在未来提高绩效。其实对于很多公司来说，绩效评估都是含混过去的。我现在所在的公司也没有详细到格鲁夫描述的那样的绩效评估报告。 不过，格鲁夫介绍了如何向一个完全不合格的员工传达绩效评估，我感觉很有价值。格鲁夫用解决问题的阶段来描述不合格员工的状态。 这些阶段具体解释如下： 忽视：表现不佳的员工最初会忽视问题。所以你需要找到具体的证据，让他无法抵赖。 否认：当员工开始否认问题时，事情其实已经有进展了，因为至少问题被提出来了。 责怪别人：责怪别人是一种很有效的防卫机制，因为员工可以以此为理由拒绝承担责任。所以这一步是关键，如果让他意识到不是别人的问题，那么就很容易进入到担起责任阶段。责怪别人到担起责任涉及的是克服心理障碍的问题，而从担起责任到寻找解决方案是能力问题，后者要简单得多。 担起责任：承认问题。 找出对策：双方一起找出问题的解决方案，并且实施。 格鲁夫把阶段分得很多，其实我倒觉得关键的阶段就是从否认责任到承担责任的过程，这个过程中，经理人需要收集到足够多的证据，尽量客观地沟通，另外强调就事论事的工作态度，才可能帮助员工克服心理障碍。 另外，即使到了最后的「找出对策」阶段，大家也可能无法达成一致，这个时候，格鲁夫建议不必在这阶段强求一致，只要员工承诺按经理的方案实施即可。我们不应该强求说服别人，因为这更多是一种心理上的需求。 你当然希望看到部属心悦诚服地同意你的看法，但如果他不是完全同意，只要他愿意采取改进行动，你就不该再在这上面伤脑筋。不要混淆了情绪问题和工作的需要。为了完成任务，你最需要的是部属愿意施行你决定的行动方案，至于他是否与你抱持同样的想法则是其次。期望别人凡事都和你想得一样其实并不是件好事，在工作上我们主要追求的是绩效，而并不是心里舒不舒服 我们在做绩效评估时，也应该把重点放在那些重要的员工身上，他们已经非常优秀了，所以找出他们的问题将会相对困难，但是他们在未来很可能承担更重要的工作，所以把心思花在他们身上是值得的。 格鲁夫在本章的最后建议，应该提前把评估报告发给员工阅读，之后再组织讨论，这样会使得员工对评价有所思考，之后的讨论更加有效率。 第十四章 招人与留人关于招人，格鲁夫提到，仅仅靠一小时的面试，根本就不足以客观地评价面试者的水平。对此我是非常同意的。但是企业的成本有限，确实也没办法花费更多时间来考查面试者了，所以这是一件非常难，但是又不得不做的事情。 关于如何招人，其实无非就是建立一套方法论，然后希望以「较大概率」招到满意的员工。我听过很多别的公司的方法论，大家的面试方法都差别很大，但是我觉得都是做到了刚刚说的原则。我自己长久以来针对程序员、产品经理、产品实习生面试分别都有总结，在此就不展开介绍书中的办法了。 关于留人，书中提到最麻烦的就是重要的优秀员工想离开。对待想离职的优秀员工，第一步需要做到的是足够的倾听。 你应该马上放下手上的事情，请他到办公室坐下来谈，问他为什么要辞职。让他畅所欲言，千万不要和他起任何争执。相信我，你的爱将已经在不止一个失眠的夜里将这套词儿演练过千百遍。等到他讲完所有他要辞职的理由（没有一个会是好理由），你再多问他一些问题。先让他说个够，因为当他讲完了事先准备好的那一套词儿后，真正的理由也许才会显现。千万不要争辩，不要说教，也不要动气。 倾听之后，找到离职真正的原因，只能站在对方立场上考虑，如果是薪水问题，看看是否合理，该调整的话就调整。如果是工作内容，看看能否做一些公司内部的工作变动来帮助他找到更喜欢的工作。如果是当前公司的一些具体的问题，看看能不能做一些改进。但是，这些做法的前提都是：这是一个优秀的、重要的员工。如果是一个表现普通的员工提出的不合理要求，那么倾听之后可能也只能做一些形式上的挽留了，因为我们不能破坏公司的薪酬体系来挽留他。 第十五章 报酬的诱惑大部分人的薪资都是结合他的工作表现+工作年限的综合评价，这其实是建立员工稳定期望和公平的一个方案。在我们公司，有一些优秀的应届生能够比一些老员工贡献更多的产出，但是我们确实无法一下子就给他老员工那样的薪水，大部分的时候，我们会给他超出同样工作年限的人的薪水。 以工作年限作为薪资的重要衡量手段，算不上特别公平，但是确实也没有特别好的办法。不过，当前互联网公司已经有一些创业公司开始打破这样的规则，他们给那些工作一两年的优秀员工非常高的薪水，因为事实上，这些员工的产出和那些工作五六年的员工差别不大，但是从性价比上讲，他们比那些工作五六年的员工要价少得多，所以多给一些也没关系。 在互联网公司抢人的时候，这种策略被大量的采用了。这造成了互联网人才薪资水平的差异被进一步缩小，大部分人的年薪都集中在某一个很小的范围区间。而那些工作多年的人，如果不能进一步提升自己的能力，就会陷入薪资基本停止不前的怪圈。 在本章，作者也提到，一般职务的提升都会面临工作内容的巨大变化，很多人处理不好，反倒会表现得很差劲，这便是著名的 彼得原理。 一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，导致无所作为。对一个组织而言，一旦相当部分人员被推到其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。 但是，对此我们又有什么办法呢？我们不提拔优秀的员工，难道提拔糟糕的员工吗？所以除了对提拔的员工悉心培养之外，也没什么好办法。 如果一个员工实在对新工作不感兴趣，作者建议还是让他回到以前表现优秀的岗位上。虽然刚开始有一些难堪，但总比他主动离职要好得多。 第十六章 别等火烧眉毛才培训作者认为经理人应该是培训的责任人，不应该把培训交给外面的公司负责。因为经理人本身在公司内部具有权威性和可信度，他的培训内容更容易被理解，另外，每个公司的做事方式和文化都不太一样，自己参与培训才能够把正确的做事方式传递给大家。 设计培训课程花费的精力相当大，我当前就在设计产品实习生的培训课程，还好我之前有一些总结，否则第一次课可能都会耗费我大量时间。就算这样，我也不知道培训能否一直按计划进行下去。不管怎么样，只要开始了，总归是有产出的，而且我相信多做几次之后，我就可以建立起优秀的、系统的培训课程。 最后的问题列表作者在最后留了一些很棒的问题，值得大家回答一翻。 如果你能从下列各项检验中拿到100分以上，以这本书的标准，你算是个杰出的经理人了。★ 试着将你工作中的操作分为编制流程、组装及测试三个步骤。【10分】★ 针对你手头开展的方案，找出限制步骤，并依此设计你的工作流程。【10分】★ 找出你工作中最适合进行验货、线上检验与最终检验的地方。决定这些检验应该采用“海关”还是“监视器”的方式。然后考虑在什么时机下，你可以升格至“随机检验”。【10分】★ 找出至少6项以上的新产出指标。这些指标应该要能衡量产出的质与量。【10分】★ 将这些新的指标变成工作上的例行事项，并在部门会议中定期审视。【20分】★ 你现在正寻找的最重要的战略（行动计划）是什么？描述你面临的环境需求以及计划进度。如果计划能成功地执行，是否能将你或你的公司带到理想中的境界？【20分】★ 简化你最烦琐、最耗时的工作。至少让原有的步骤减少30%。【10分】★ 找出什么是你真正的产出？你所管理的部门及影响力所及的部门的产出元素为何？按重要顺序排列。【10分】★ 实际在公司中走动走动。然后，列出这次“出巡”中和你有关的事项。【10分】★ 找一些借口让你一个月可以在公司内巡视一次。【10分】★ 描述下一次你授权给部属时会如何督导。你将以什么为标准？怎么做？督导的频率是怎样的？【10分】★ 列出你可以利用零碎时间进行的项目。【10分】★ 列出和每一个部属“一对一会议”的时间表。（在会议之前向他们解释会议的目的，并要求他们作准备。）【20分】★ 找出你上星期的日程表，将做的活动分为高、中、低杠杆率三类。设法多做一些高杠杆率的活动。（有哪些活动该减少或干脆不做？）【10分】★ 预测下周有哪些事要瓜分你的时间。有多少时间要花在开会上？其中有多少是过程导向会议？多少是任务导向会议？如果后者占去的时间超过25%，你该如何设法删减？【10分】★ 列出你的组织在未来三个月中最重要的三个目标，并一路验收成果。【20分】★ 在与部属充分讨论过以上目标后，要他们也“依葫芦画瓢”—制定他们的目标并一路验收。【20分】★ 写出“悬而未决”需作决策的事项。找出其中三项，试着运用决策制定过程的架构以及“六点问题”的方法。【10分】★ 依据马斯洛的需求理论评估你自己的需求层次。并为部属找出他们所属的层次。【10分】★ 给部属勾画他们的跑道，并找出每一个人的绩效指标。【20分】★ 列出你给部属各种形式的工作所给予的相关回馈。他们是否能借着这些回馈来测量自己的进度？【10分】★ 将你部属的工作成熟度分为低、中、高三类。并针对个人选出最适当的管理风格。并在你的管理风格及最适当的管理风格之间作比较。【10分】★ 评估你上一次收到的或你对部属所作的绩效报告。这些报告对提高绩效有多大的影响？在上司告诉你报告内容或你告诉部属时，你们的沟通形式是怎样的？【20分】★ 如果有哪一份报告不够理想，重做。【10分】 写在最后我整理这份笔记花费了好几周，我从本书中收获巨大，希望你能从这篇总结中也有所收获，祝大家玩得开心～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"技术演讲中最容易被忽视的问题","slug":"tech-talk-notes","date":"2016-06-05T08:08:35.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/06/05/tech-talk-notes/","permalink":"https://blog.devtang.com/2016/06/05/tech-talk-notes/","excerpt":"","text":"我在国内的大大小小技术会议（比如 QCon, ArchSummit，MDCC，SwiftCon 等）中做过不少演讲，也听过很多别人的演讲。作为一个一路走过来的技术演讲者，我见过很多优秀的演讲者，也见过很多干货满满的分享因为嘉宾的演讲水平问题而搞砸。关于演讲的技巧的文章很多，我想找一个侧面，分享一下技术演讲中最容易被忽视的三个问题。 超时一个演讲，刚开始准备的时候，通常都会感觉要准备 45 分钟好难，于是就会紧张起来，紧张会使得我们准备过度。而大部分演讲者都不会在正式演讲前完整地模似真实的现场演练一遍。加上演讲现场通常都会因为场下黑压压的人群，以及耀眼的灯光而产生兴奋，兴奋有可能产生两种极端，一种是以非常快地语速把 PPT 讲完，但是大部分认真准备的演讲嘉宾都会由于过度兴奋而深入到演讲的细节中忘记了时间，从而把本来就准备过多的 PPT 更加充分阐述。于是，超时随之而来。 一般像 QCon 这种专业的技术会议，对付超时也是相当专业的，台下的工作人员会在演讲只剩 5 分钟的时候，在台下举牌子让你注意到时间。但是这个时候，你会发现一切都晚了，PPT 只讲了一半，而时间只剩下 5 分钟，除了蒙逼还能干嘛？我见到过一次在 QCon 的超时就是这样，一位来自某一线互联网公司的技术人员，用 5 分钟的时间，把他准备的另外几十页 PPT 翻完了，大家甚至都来不及读完他在 PPT 上的写的所有文字，而基本上他除了翻完，也没有什么办法了。 对付超时怎么办？ 第一步：控制 PPT 页数。通常情况下，一页 PPT 演讲时间花费大概是一分钟，一个 45 分钟的演讲一般也要留 10 分钟提问，所以准备 30 - 35 分钟的分享就够了，这样对应的页数大概是 30 - 40 页。当然，如果你的 PPT 中还有大量非摘要的、可以快速翻过的动效内容，页数可以适当增加（比如我在 SwiftCon 中演讲的 PPT 就有 60 页，但其实很多都是动画效果）。 第二步：提前试讲。其实这是最简单的办法，在公司内部直接把自己的演讲主题讲一遍，这样就能够精确地知道会花费多少时间了。如果不方便在公司的分享会上讲，也可以拉几个同事给他们私下分享。如果拉不到同事，自己找个小黑屋，开个计时器，完整地给自己讲一遍，也都是准确了解时间花费的办法。我在 SwiftCon 中的演讲，事先就试讲了 6 次，当然后面很多次是为了打磨内容，而不是了解时间花费。 干货太多有人问：干货太多是问题吗？我想说：是的，问题很大！ 我还记得有一次 InfoQ 给演讲嘉宾做培训，当时的演讲培训师给大家提了一个问题：如果让你的演讲在趣味性和技术性中做选择，你会选择哪个？现场有一半选择了前者，另一半选择了后者。我当时选择的是后者，因为我觉得，一个技术演讲，讲得没意思没关系，只要有干货就行。但是，培训师却告诉我，应该选择趣味性。 培训师的理由是这样的：大部分 45 分钟的演讲，都不足以完整地阐述大量的知识，获取大量的知识有更多方便的途径，比如看书。一个好的演讲者，不是应该让观众在现场接受多少内容的知识，而是让观众在现场产生对演讲内容大体框架的理解，进而在演讲结束后，观众可以进一步通过别的途径获得更多相关的知识。 所以，如果你的演讲原本要讲 10 个干货，那还不如把其中的最重要的 5 个整理得更加生动，形象，有趣。让观众现场能够对你演讲的主题产生兴趣，而另外那 5 个干货，你完全可以附在最后一页 PPT 上，作为延伸学习的推荐话题。如果你的演讲能让观众产生兴趣，在会后学习几个小时，那么听众在知识性上的获取效果绝对比你「填鸭」式的干货分享要好。 所以，适度收敛，少即是多。 缺乏练习在这个世界上，有很多技巧都不是学来的，而是练出来的。比如我最近在学自由泳，无论我如何熟记姿势的各种要领，我也无法短时间内让自己的身体产生记忆，我能做的只是不停地练习，纠正错误，产生肌肉记忆。演讲也是一样。 你看到的大部分优秀的演讲者，在台上口若悬河，侃侃而谈，其实都是因为他们在之前做了大量的练习。 而大部分技术人员通常都是没有兴趣一遍一遍讲同样的内容，所以，缺乏练习使得他们在台上过度紧张，有些人因为紧张，只能对着讲稿把演讲内容一个字一个字读出来，这样和观众的互动就差太多了。 在这一点上，解决办法除了练习别无它法。我个人会有意识地每个月都做一些分享，很多时候是公司内部的或小范围的分享，这样可以不断提高自己的演讲能力。另外培训师也提到一个办法，就是自己对着摄像机做演讲，然后通过回放录像，来审视自己的表现。我试过一次，确实发现了自己很多问题，感兴趣的同学也可一试。 总结超时、干货太多、缺乏练习，这就是技术演讲中我看到的最大的 3 个问题。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"如何指导新人 - Mentor 指导手册","slug":"mentor-guide","date":"2016-05-26T14:22:21.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/05/26/mentor-guide/","permalink":"https://blog.devtang.com/2016/05/26/mentor-guide/","excerpt":"","text":"概述本文希望帮助 Mentor 在指导实习生和新员工时，建立一些基本的共识和准则。本文主要讨论的是技术类的岗位。 我们为什么要招实习生和应届生？猿题库在招实习生上，向来是非常大方的。那么，我们为什么要花大价钱，招那些可能都没有任何实习经验和工程经验的学生？我们是为了让他们做一些简单低级的事情，还是想培养有潜力的学生？相信大家都能明白是后者。 那么，我们为什么想培养有潜力的学生？因为，找到一个靠谱的同事不容易，我们希望帮助这些有潜力的学生成长，在他们在成长的同时，最终能够喜欢上这里，最后能够成为正式员工。所以，为了吸引最优秀的实习生，我们开出来非常高的实习工资和有挑战的工作内容。 对待应届生也是一样，我们非常看重他的学校，成绩，数据结构和算法知识，兴趣，这也是为潜力买单。 但是，我们做的这些，得到的只是有潜力的实习生和应届生。他们离一个优秀的员工还有很大的差距，所以 Mentor 对他们的指导非常重要。如果把他们比做一个好树苗的话，Mentor 就是帮助他们最终成长成参天大树的人。相信大家都能明白，培养人其实比招人难得多。 那么，作为 Mentor，我们应该如何指导这些新人呢？ 建立友谊好的老师和学生的关系有些时候更像朋友。大家不但会交流技术，也会一起吃饭聊天，扯淡八卦。互联网公司推崇平等，朋友式的关系更适合讨论技术。 如何建立友谊呢？作为 Mentor，应该在新同事刚刚入职时，带他熟悉公司环境和同事，陪他一起吃饭。平常休息的时候，聊聊工作之外的话题。有些时候，大方一点，请他吃吃饭。 良好的私人友谊，对于新人融入团队是非常重要的，遇到困难时，他会更加主动地向你寻求帮助。等他成长起来后，你们会成为很好的同事。即使以后你和他不在一个项目组，甚至不在一家公司了，但是你们的友谊会使得你们相互尊重并欣赏，谁知道你们以后不会再次合作呢？ 努力培养新人如果说建立友谊算是铺垫的话，那么努力培养新人才算是正题。 虽然大家都懂道理，但是就我观察，很多人都没有意识到培养新人的重要性，当项目太忙，自己精力不够时，就忽略了这方面的工作。而这方面的工作又没有实际明确的标准，就很容易做得不好。 所以，我想了一个评判培养新人重要程度的标准：培养新人的重要程度应该高于所有线上的功能开发，仅仅低于线上的紧急 Bug 修复。如果你手头有重要的开发工作，同时有重要的新人需要培养，那么你应该优先把培养新人的事情做了，再做重要的开发工作。 为什么这么说呢？因为，培养新人是「一次性」的投资，假如一个新人成长起来所需要的指导时间是 20 个小时，那么你尽早的完成这 20 个小时的指导，新人就可以尽早地产出有质量的工作。而如果你因为项目紧张而忽略了这件事情，那么新人可能会养成一些不好的编程习惯或做事方式，之后，你可能需要更多的时间来纠正他。 具体来说，努力培养新人要做好的事情包括： 定期主动和新人讨论他遇到的问题。 开始的几周 Code Review，非常详细地审核，保证代码风格达成一致，一些不好的编程习惯得到立即纠正。 教会新人一些正确的学习方式，例如 Google，Github，Stackoverflow。 推荐一些深入的学习资料给新人。并且发现他在某方面没有提高时，持续 PUSH 他看相关的书籍。 定期主动和新人讨论他遇到的问题建议新人在入职的头一两周可以使用这个办法。比如每天晚上 6 点半，在吃饭前用半小时，让新人把当天学习积累的问题和你讨论。 固定时间做固定的事情，一来使得你被他打断地次数减少，二来也使得他有机会把任何疑问都提出来。 Code Review基本上刚入职的新人都会有 Code Style 的问题，刚开始的几次 Code Review，我们要首先解决 Code Style 问题。如果新人犯错，可以提供相关的 wiki 或代码风格资料给他，甚至和他进行代码风格的一些讨论，分享一些故事，让他对代码风格产生重视。一个合格的 Mentor 应该让新人在最多三次 Code Review 之后，就能够改正掉几乎所有的代码风格问题。 如果新人对代码风格有不同意见，可以组织一些学习讨论会，也可以在吃饭的时候叫上几个资深一些的同事一起分享这方面的经验。切忌不能只是用强力纠正，而没有让新人产生真正重视代码风格的意识。 在 Code Style 保证的同时，我们还需要让新人了解我们的各种编码约定，例如接口如何定义，目录如何安排，注释的原则，Commit Log 的约定等等。这方面也需要有 wiki 供新人学习。 Code Review 的最难部分，我们需要审核新人的架构和逻辑是否有问题，这方面花费的精力将非常多。对于有问题的架构，和新人的讨论也将花费大量时间。但是这就是新人成长的过程，对于他来说是非常重要的经历。 另外，让新人同时 Review 自己的代码，是一个非常好的学习方式，新人可以模仿和学习到一些好的架构和代码风格习惯。 正确的学习方式部分新人可能对于使用英文查找资料，使用 Google 存在一些障碍。我们应该需要纠正他们不使用百度，不使用中文来进行资料查找，否则对他们知识获取将会有很大的影响。 我们还应该分享一些自己常常学习和提高的方式，推荐一些博客、论坛和社区给新人，让新人学会我们的学习方式。 推荐学习资料在培养一段时间后，你可能就会发现新人在某一些方面的知识有所欠缺，但是显示我们把这些知识系统地讲一遍是不太现实的。我们应该推荐一些相关的书籍给他们，鼓励他们用闲暇的时间来阅读。时不时问问他们学习的进度，或者让他们分享一些学习的体会，都是不错的 PUSH 他们提高的技巧。 授权当你发现新人已经成长起来后，可以尝试将自己熟悉的，同时重要的功能交给他来完成，而你自己做一些其它工作（根据实际情况，可以是更简单的工作，或者是更难的工作）。 这样做的好处是： 新人可以借此得到更大的锻炼。 你因为对相关功能很熟悉，所以也能有效地进行指导和监督，控制代码质量和风险。 将自己熟悉并且重要的工作交给别人，通常是比较难受的，因为一般人都希望保证效率，而自己因为熟悉，所以效率肯定是最高的。但是长远来看，对于 Mentor 来说，自己也需要成长，将自己擅长的事情交给别人，可以让自己跳出舒适区，尝试更难的事情。这么来看，对 Mentor 自己也是非常有利的。 回顾不管如何用心，刚开始指导新人的时候，总还是会有一些做得不尽人意的地方。Mentor 应该对自己的指导过程有一些总结和回顾，然后总结一些心得，这样在指导下一个新同事的时候，就会做得更加出色。 总结在和新人建立良好友谊的基础上，我们需要努力培养他们，并且把这件事情当作最高优先级的事情。具体要做的事情包括： 定期主动和新人讨论他遇到的问题 Code Review 教会他正确的学习方式 推荐学习资料 授权给他有挑战的，并且自己熟悉的工作 带完一个新人后，回顾一下自己的工作，看看有哪些值得改进的地方","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"猿题库从 Objective-C 到 Swift 的迁移","slug":"migrate-from-oc-to-swift","date":"2016-05-24T14:15:31.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/05/24/migrate-from-oc-to-swift/","permalink":"https://blog.devtang.com/2016/05/24/migrate-from-oc-to-swift/","excerpt":"","text":"引言相信没有人会怀疑，Swift 是 iOS 开发未来的主流语言，但是由于 Swift 语言的不断变化以及庞大的迁移成本，真正把项目迁移到 Swift 语言的公司并不多。而猿题库 iOS 客户端是一个超过 3 年的项目，积累了超过 15 万行的 Objective-C 代码，我相信它在迁移过程中的经验对很多人有所帮助。 蓝晨钰（@晨钰Lancy）是猿题库 iOS 客户端的负责人，他主导了猿题库 iOS 客户端从 Objective-C 到 Swift 的迁移工作。同时他在实践 Swift 的过程中，总结了不少心得，这次他将会在 GMTC 大会上分享这方面的话题，以下是我对他的采访，希望对大家有帮助。 提问 问题：向读者简单介绍一下自己吧。 我叫蓝晨钰，iOS 开发者，11 年开始接触 iOS 开发，13 年加入猿题库负责 iOS 客户端开发工作，和猿题库一起经历了从无到拥有数千万用户的成长，和我的团队一起完成了数十个版本的迭代。 我从 14 年底 Apple 发布 Swift 语言开始一直关注和学习其知识理念，并在 15 年初在公司推广和实践 Swift 项目，至今在生产环境实践 Swift 已经超过一年，算是有比较丰富的移动客户端开发经验和 Swift 编程经验吧。个人对 Swift 语言的持乐观态度，在公司内积极推进 Swift 语言的实践，也非常享受 Swift 的编程体验。 问题：听说你这次打算在 GMTC 上分享的话题是：《当泛型遇上协议 —— Generic Programming with Protcol in Swift》，能简单介绍一下为什么选这个主题吗？ 泛型编程和面向协议编程都是 Objective-C 语言所没有的特性，作为一个老 iOS 开发者来说，当我第一次接触它们时，我的内心是激动的，我迫不及待的想知道，这些个新特性新技术，会给我们的程序和开发带来怎么样的变化。而经过我们团队的不断学习和实践，我们也的确在这当中找到了很多乐趣，积累了不少经验，我希望能通过这次分享讲它们分享给更多人。 问题：你怎么看待泛型编程和面向协议编程在客户端编程的未来？ 泛型编程是许多现代语言所有的特性，在其他语言的实践经验告诉我们，泛型是一个强大的工具，经常能有效的提高编程效率和提高代码的复用程度。面向协议编程则是由 Swift 提出的编程范式，强大的表达力和抽象能力，毫无疑问会变成一项重要工具。而这两者的结合则是一种全新的体验，这也是我这次分享的一个重要部分。 同时，由于 Swift 语言缺乏类似 objc runtime 的机制，我认为泛型编程和面向协议编程作为实现之前 runtime 所实现功能的替代，将越来越成为 iOS 开发者需要掌握的重要技能。 问题：猿题库当前对 Swift 的使用到什么程度？已经完全迁移到 Swift 了吗？ 猿题库有两个客户端项目，分别是老师端和学生端，他们都是 Swift 和 Objective-C 混编的项目，并没有完全迁移到 Swift。其中猿题库老师端是在 Swift 发布之后不久启动的项目，我们在这个项目中开始推行 Swift 语言，所以这个项目是一个 Swift 语言为主的项目，Objective-C 部分主要为复用旧代码。 而猿题库学生端是我们的主项目，这个项目从 iOS 5 时代开始，一直使用 Objective-C 编写，直到近期 Swift 升到 2.x 之后，我们认为 Swift 已经足够成熟，并且我们在老师端中积累了足够的经验后才开始向 Swift 迁移的。目前学生端的项目中，大部分还是 Objective-C 语言实现，但新实现的页面和功能基本都使用 Swift 语言来编写。 问题：你认为猿题库大概还需要多长时间能够完全迁移到 Swift? 事实上，在生产环境中，几乎没有人愿意在收益甚微的情况下把 Objective-C 代码重写一次，因为重写意味着大量的研发资源和测试资源的消耗，而这基本不会产生实际意义上的产品收益。另外 Apple 在 Swift 和 Objective-C 的桥接上做了相当多的努力，大部分情况下，我们都可以不太费力的在 Swift 中复用 Objective-C 代码。 所以大部分公司的策略都会是新功能用 Swift 语言实现，旧功能先维持现状，等到产品变动或是架构变动的时候再使用 Swift 语言实现，这也是猿题库所采用的策略。所以我想短时间内不太可能完全迁移到 Swift 吧。如果非要说一个时间的话，我推测大约一年之后大部分业务应该会迁移到 Swift，而整个项目彻底迁移恐怕就需要两到三年以上了。 问题：你认为 Swift 什么时候能够达到 ABI 稳定？ 老实说，我也不知道。Swift 的发展很快，我这次主题要讲的泛型相关的实践，在 Swift 1.x 的时候就没法实现。Swift 项目组的 Chris Lattner 也公开表示 Swfit 3.0 不会达到 ABI 稳定并且会缺少一些重要的泛型功能。我们只能期待在 Swift 3.x 或 Swift 4 的时候会有惊喜吧。 问题：对比 Swift 和 Objective-C，你觉得 Swift 最大的优势是什么？ Swift 的优势有很多，我比较喜欢的有几点：更安全的类型，代表更少的 Bug 和更低的崩溃率；更简洁的语法，代表更少的代码和更快的编程速度；强大的函数式、泛型、协议等特性，代表更能发挥程序员的想象力。选一个的话，我选最后一个，强大的特性给了我很大的编程愉悦感。 问题：对于从 Objective-C 迁移到 Swift，你有遇到什么值得分享的坑吗？ 从 Objective-C 迁移到 Swift 代表着在很长一段时间内都是处于混编的状态，这里我认为最重要的经验是一定要有一个迁移的规范和指南来约束开发团队哪些部分需要迁移 Swift 而哪些部分不要，接口应该如何设计才能兼顾混编调用。举个例子，由于 Swift 调用 Objective-C 是方便的可靠的，反之则有许多的限制，所以设计接口的时候，需要考虑这个模块会不会被 Objective-C 调用，如果是的话，应该避免使用 Swift 语言的特性，又或是制定一套规则，来 Swift 语言的接口如何转成 Objective-C 兼容的接口。 问题：对于学习 Swift，你有什么推荐的方法或资料吗？ iBooks 上有 Apple 推出的 Swift Programming 系列书籍是所有 iOS 开发者的必读和参考书目。iTunes U 上有 Stanford 的 Developing iOS Apps with Swift，讲师是 Apple 工程师 Paul Hegarty，推荐新入门的 iOS 开发者学习。 Objc.io 上的 Advanced Swift 是我最近在读的书，内容绝对对得起 Advanced 这个词，推荐有一定基础 Swift 开发者阅读。此外 Github 上有大量的 Swift 开源项目，可以阅读源码来学习。 最后，也是最重要的，多写，多想，实践是最好的学习方式。 问题：你对今年 WWDC 有什么期待吗？ 最大的期望是能去一次 WWDC（笑），可惜我们公司每年到 6 月高考的时候就是最忙的时候，所以这个愿望只能等以后了。对 WWDC 本身的话，期望 Apple 能弄出一些新东西，比如我很看好的虚拟现实相关的产品和技术。 另外希望 Apple 能加快 Swift 的推进，比如发布与 Google 合作推进 Swift 语言在 Android 客户端的应用之类。 全文完。 广告由 InfoQ主办的GMTC全球移动技术大会将于6月24日在北京召开。来自BAT、携程、滴滴和社区的技术专家联袂分享，主题包括应用架构、性能优化、动态化、插件化、Swift、React Native、Weex等。本周移动大会8折最后一周，我的粉丝本周前20人报名享受6折1080的优惠呦，手慢无！手慢无！优惠码：GMTC-TangQiao 购票链接：http://www.bagevent.com/event/27886?bag_track=tangqiao","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://blog.devtang.com/tags/Interview/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"Swift 烧脑体操（六）- 类型推断","slug":"swift-gym-6-type-infer","date":"2016-05-22T05:46:26.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/05/22/swift-gym-6-type-infer/","permalink":"https://blog.devtang.com/2016/05/22/swift-gym-6-type-infer/","excerpt":"","text":"索引Swift 烧脑系列文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 正文前几天，一个朋友在微博上通过私信问了我一个问题，如下的代码，为什么变量 crr 没能把值为 nil 的元素过滤掉？ let arr:[Int?] = [1, 2, 3, nil, 4, 5]let brr = arr.flatMap &#123; $0 &#125;brr// brr = [1, 2, 3, 4, 5]let crr:[Int?] = arr.flatMap &#123; $0 &#125;crr// crr = [&#123;Some 1&#125;, &#123;Some 2&#125;, &#123;Some 3&#125;, nil, &#123;Some 4&#125;, &#123;Some 5&#125;] 简单来看，同样是使用 flatMap 函数，brr 变量成功过滤掉了值为 nil 的元素，变量 crr 过滤失败。而 brr 和 crr 的区别就是它们的类型不一样，brr 的类型是 [Int] ，而 crr 的类型是 [Int?]，想必其中原因与此有关，那到底是为什么呢？ 在和一些朋友讨论之后，我大概想明白了，这和类型推断有关系。在 crr 相关的代码中，因为 crr 的类型已经被程序员指定为 [Int?]，所以为了编译通过，编译器需要推断出 flatMap 中的闭包的输入和输出变量类型。我们回顾一下 flatMap 在数据中的定义： extension SequenceType &#123; public func flatMap&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T?) rethrows -&gt; [T]&#125; 可以看出，flatMap 返回的结果是 [T]，而闭包 transform 返回的结果是 T?。而在 crr 这个例子中，T 被推断出是 Int? , 因此 tranform 中 T? 就被代入，变成了 (Int?)? 。所以，如果完善一下上面例子的代码，编译器推断出来的类型是这样的： let crr:[Int?] = arr.flatMap &#123; (element: Int?) -&gt; (Int?)? in return element&#125; 注意这里，返回的变量 element 其实类型并不是 (Int?)?，但是 Optional 是有 conversion 的方法，允许将一个类型的 S 的变量，自动转成 S?，所以转换被自动做了，并没有编译错误发生。 怎么改这个代码呢？ 有人说把闭包的类型手工指定成 Int?，我试了一下，确实能够正常了，不过我感觉这更像是一个编译器的 Bug，我们再看看这个接口： extension SequenceType &#123; public func flatMap&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T?) rethrows -&gt; [T]&#125; 按照 flatMap 的接口定义，如果闭包返回的是 Int?，那么按照这个定义，最终 flatMap 的结果就必须是 [Int]，而我们要强制要求结果是 [Int?]，除非这里有自动的转换，否则就应该编译失败。而我自己的试验代码失败，确认出并没有从 [Int] 到 [Int?] 的自动转换。所以我暂时认为这么改能正常工作是一个编译器的 Bug（如有错误，欢迎指出）。 error: cannot convert value of type &#x27;[Int]&#x27; to specified type &#x27;[Int?]&#x27; 另外，也有朋友说，在这种场景下并不应该使用 flatMap 函数。确实是这样，flatMap 函数本来就有着 flat 的作用在里面，在数组的 flatMap 实现中，有两个重载： 一个重载版本是为了打平嵌套的多维数据。 另一个重载版本，就是我们刚刚讨论的版本，flat 是为了去掉 Optional 的封包，同时把 nil 元素去掉。 而这个示例代码调用了 flatMap 函数，却希望仍然得到 Optional 的数组，实在是不应该使用 flatMap 来做这个事情。如果只是为了去掉 Optional 中的 nil 元素，使用 filter 方法可能更为合适一些： let arr:[Int?] = [1, 2, 3, nil, 4, 5]let drr:[Int?] = arr.filter &#123; if let _ = $0 &#123; return true &#125; else &#123; return false &#125;&#125;drr// drr = [&#123;Some 1&#125;, &#123;Some 2&#125;, &#123;Some 3&#125;, &#123;Some 4&#125;, &#123;Some 5&#125;] 其实函数式编程的方法不止 map, flatMap, filter 这些，在一个名为 reactiveX 的网站上，列举了 Reactive 编程实践下的一些 常见的函数，里面的很多方法都挺有意思，这些方法也被实现在了 RxSwift 中，感兴趣的同学可以看看。 祝玩得开心！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"济州岛旅游见闻","slug":"jeju-island-tour","date":"2016-05-08T13:44:12.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/05/08/jeju-island-tour/","permalink":"https://blog.devtang.com/2016/05/08/jeju-island-tour/","excerpt":"","text":"前言公司五一节给大家放了九天假，于是和家人去了一趟济州岛，记录一些见闻。 乱打秀 在观看乱打秀之前，我以为乱打秀就是一种利用各种厨房炊具进行音乐打击演奏的表演。看完之后，我才发现乱打秀其实是一种混合了多种表演形式的艺术混合体。 乱打秀的核心内容是音乐，在表演中，演员会利用各种厨房乐器来进行各种有节奏感的打击。但是如果只是听打击乐声的话，演出难免单调，所以乱打秀在打击音乐的同时，又混入了很多别的表演元素。 首先混入的是不少杂技的表演内容。例如：在奔跑中翻跟头、相互之间非常快速地扔盘子、背对篮筐投篮、耍双截棍以及打斗等等。这些杂技类的元素对于演员的身体素质和协调性要求非常高，现场能够看出女演员的腹肌和手臂肌肉非常结实。乱打秀的故事场景是在厨房，所以还有一些关于刀功的杂技元素，其中一个环节大家比拼切菜的功力，整个表演演员用锋利的菜刀切出各种效果，看得让人心惊动魄。 然后混入的是魔术元素。包括一个把酒瓶变没的魔术，以及一个丝巾变棍子的魔术，现场还利用灯效配合演员做出蜡烛灭掉和点亮的魔术。魔术元素虽然不多，但是因为观众事先并没有预期，所以看到时还挺意外的，有一点惊喜。 接着混入的是小品的元素。整个乱打秀融入在一个紧张的烹饪任务的故事情节中，随着剧情地发展，观众会不自觉地融入到那种紧张的故事剧情中。 乱打秀还融入了大量与观众的互动，这些互动有一些非常深入，已经本身成为了演出的一部分。其中有一个环节是邀请几个观众上台参与包饺子，然后突然演员们都快闪离场了，留下几个观众尴尬地不知所措，现场观众笑翻天了。另外还有一个环节是演员邀请观众和他一起打拍子，演员故意用生气地表演来表示对观众的配合不满意，然后学大家各种搞笑的动作，非常有意思。 电动汽车济州岛的景点离得都比较远，所以一般自由行都需要包车。这次包车的时候，我发现我们乘坐的竟然是一辆新能源电动汽车，进一步了解到，济州岛政府都在推广电动汽车。 我们乘坐的电动汽车是三星旗下的（如上图），在国内完全搜索不到。与国内不同的是，三星的这款电动汽车快充和慢充是共用一个充电口。另外听司机说，快充充满电只需要 20 分钟，满电可以开 100 多公里，听起来还是非常夸张的。可惜在网上搜不到这款车的中文资料。 物价济州岛的物价整体还是比北京还是要高一些，吃一碗当地的猪肉面，最少是 7000 韩元，折换成人民币大概 40 多块钱。如果不吃面，人均 80 元左右吧。出租车的话，起价 2800 韩元（约 17 元人民币）。当地的特产橘子，长得有点像国内的丑橘，但是便宜的也要 2000 韩元一个（约 10 元人民币）。 济州岛的海产品非常丰富，按理说海产应该比较便宜对吧？但是也不是，一个当地产的带鱼，好一点的要 6 万韩元一公斤（约 180 元人民币一斤）。 饮食济州岛在古代其实是流放之地，物资比较匮乏。所以济州岛上其实没有什么特别好吃的东西。当地有名的食物，无非就是：猪肉面，参鸡汤，烤黑猪肉，海鲜锅，炸鸡。 从这些食物上可以感受到当地蔬菜匮乏，我个人对参鸡汤的评价还可以，烤肉的话，其实北京的味道一点也不比当地的差。 免税购物济州岛为了吸引外国人（其实主要就是中国人）前来旅游，专门有大型的免税店：新罗免税店和乐天免税店。在相关购买流程上，政府做了很多优化的工作。比如在新罗免税店，我们可以直接刷支付宝、微信支付以及银联卡。 我还记得大概 5 年前来济州岛购物的时候，每件商品都还需要填一个退税申请，然后跑到机场相应的窗口办理退税。但是这一次，我们在一家叫 eMart 的可退税超市，超市的收银机可以直接刷护照，然后将税金当场免去，购物体验相当棒。 免税购物和免签证应该是济州岛吸引中国游客的大杀器，基本上到处都是中国人，各种商店也都有中文导购。 天气济州岛有三多：石多、风多、女人多。我们去的第二天就赶上了接近 9 级的大风。基本上大风夹着一些雨水，使得室外的旅游完全无法进行了，还好有很多室内的观光景点可以游玩，不然还是挺遗憾的。济州岛最佳的旅游时间其实是秋季，我们上次来旅游就是那个时节，完全没有大风。 未来济州岛近年来因为旅游火爆，整体物价和房价都涨了很多，不知道这对当地居民来说是祸是福。 这次了解到有很多租车公司提供济州岛自驾服务，车子上还专门有中文的导航，只需要有国际护照即可，希望如果下次带来，能够试一试。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"SwiftCon 期间的面基和八卦","slug":"swiftcon-2016-chat-notes","date":"2016-05-06T16:01:37.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/05/07/swiftcon-2016-chat-notes/","permalink":"https://blog.devtang.com/2016/05/07/swiftcon-2016-chat-notes/","excerpt":"","text":"4 月 23 - 24 日，我参加了上海的 SwiftCon 大会。有一些人说参加会议主要就是混圈子，也有一些人说参加会议主要是了为听干货，还有一些人在微博上投票，到底我们应该听干货还是去混圈子。好吧，不能都做吗？一次会议演讲嘉宾的质量固然重要，但是一次会议天然地把一群相同趣味的人聚集到了一起，不乘机好好认识一下扯扯蛋聊聊天，多可惜呀。 我这次去上海参会，不但听了很多有意思的分享，私下也见了特别多朋友。和这些朋友面基聊天，很是开心，一些讨论也很有感触，一并记录一下。 本文主要记录聊天扯蛋方面的感受，如果要看技术方面的总结，可以移步到 《SwiftCon 2016 参会感想》。 tinyfool &amp; 碎月成星tinyfool 是我面基的第一个人。那天是大会正式开始前一天的下午，我们约在一家咖啡馆聊天。一同来的还有大会的组织者锅巴，触控科技的廖宇雷，tiny 公司的 CTO 碎月成星（陈勇辉）。 第一感受就是，tiny 是一个非常健谈的人。我们几个人在那儿聊天，基本上将近一半的表达时间都被 tiny 霸占了。不过我是那种特别容易冷场的人，所以有一个人不停地叨叨，反倒感觉特别舒服，我只需要听着就可以了。 tiny 的思路转换得特别快，基本上给他一个话题，他就可以一直发散下去，各种观点听起来也挺有意思。我们聊在线教育，聊招人，聊 Remote 的工作方式，聊雾霾，聊创业，聊学习和成长，还有各种八卦。也许是聊得太多吧，好多观点也没能记住。tiny 说他创业做不下去了，打算把公司关了找工作，这一点在第二天的大会演讲中他也提到了。 还记得的就是各种 tiny 和碎月成星的趣事，这两个人的性格就像冰与火一样处在两个极端，碎月成星是那种极度内向的人，但是他们却能够一起合作经营公司。我也私下八卦了一下 tiny 的小女朋友的故事，就不给大家说了，哈哈，祝他们早日成婚。 聊天时，碎月成星讲了一个非常有意思的笑话，现场听他讲完，感觉他也是那种人混熟之后，话也能讲很多的人。 锅巴 &amp; 扳子锅巴在忙完大会的一些琐事后，赶过来加入了我和 tiny 的聊天。从锅巴那儿，我了解到这次大会基本上由他和扳子两个人完成，他们都有固定的工作，这种会议是完全民间的行为。锅巴说，之前办 PHP 相关的大会很成功，现在 Swift 语言刚刚兴起，没有人办过，所以就决定办一场。 相比今年年初在北京的 atSwift 大会，锅巴的这次 SwiftCon 大会是两天的时间，时间更长（atSwift 大会是一天），场地租金更贵（atSwift 大会是租的学校的会场），而且锅巴考虑到有很多是外地的嘉宾和参会者，所以选择的会场离机场特别近，这也一定程度上增加了办会的成本。 锅巴私下和我聊的时候说到，他们之前甚至打算亏本办这场大会，不过聊天中我问他卖票情况，他说还比较理想，我估计应该是没有亏本的。办会不亏本应该是非常好的事情，这样才能使得大家有动力持续改进会议质量。锅巴还是一个特别大度的人，他们这次还邀请了算是「竞争对手」的梁杰的 atSwift 大会组委会成员，并且为他们提供了免费的展台。 当然，聊天少不了八卦，锅巴提到关于股票的高频交易一些趣事，很有意思，涉及一些敏感信息就不给大家说了，哈哈。 吴柯瑶吴柯瑶是一个性格外向活泼的美女，从非技术工作转而做 iOS 开发，没有参加培训班，自己一点一点成长起来。她在找工作的时候，因为是女生，遭遇了更多的挑战。本来她找 tinyfool 想让他帮忙推荐，tinyfool 做了一个非常明智的决定，tinyfool 说：「你先找，自己试试看，不行再说」。结果，瑶瑶最后凭自己的能力找到了 iOS 开发的工作，这件事情 tiny 做得太赞了，因为它让瑶瑶获得了相当大的自信心。 这次大会吴柯瑶是主持人，在大会中午休息的时候，瑶瑶分享了一段自己成长的经历，不知道有多少人认真听了，我感觉她的成长过程对于大家的启发或许更多。 和瑶瑶聊天八卦的主要是她以前当模特的故事，嗯，详细的也不给大家说了，哈哈。 傅若愚 &amp; 方志刚大会第一天结束后，我和 ThoughtWorks 的几个朋友（傅若愚、方志刚、小灰灰）一起去撸串。他们给我介绍了很多关于这家公司的趣事。小灰灰其实是前 ThoughtWorks 员工，现在在 SegmentFault 做市场运营相关的工作。 ThoughtWorks 以前在我眼中总是很神秘，这次和他们聊天，更进一步从各种故事中了解了这家公司。和别的偏咨询的业务不太一样，ThoughtWorks 在移动开发领域，整体上业务还是侧重「外包」开发的工作较多。 在和他们聊天的过程中，我才发现 ThoughtWorks 是在 iOS 开发中，也实践成功了 TDD 的公司。而这一点，其实做到的互联网公司非常少。在我之前的认知中，因为移动开发的单元测试能够覆盖的代码极其有限，加上移动开发中的功能模块（特别是上层的界面和交互逻辑）在快速迭代中反复更改，我认为 TDD 并不适合在移动开发领域。ThoughtWorks 的故事让我再次对自己的观点产生了动摇。 进一步了解到，ThoughtWorks 的一个 App 的业务逻辑，可能由超过 10 个人来完成，另外 ThoughtWorks 的员工也可能分布在不同的城市，他们需要更解耦地工作和协调，而这个时候，TDD 成为一个很简单有效的方式。ThoughtWorks 接的 App 开发的单子，本身也不太可能像移动互联网公司那样，两周发一个版本来快速迭代。综合起来，在移动开发中引入 TDD，或许适合这样的场景： App 开发人员超过 10 人，并且大家代码相互依赖 App 开发人员异地协同工作 App 的迭代周期不算特别频繁 App 的质量非常重要 小灰灰还提到，ThoughtWorks 这家公司还有一个比较独特的地方，就是创始人不完全以赢利为目的来经营公司，比如他们会接一些明显亏本的、但是公益性的项目，比如在一些第三世界国家，帮助当地的政府开发一些信息系统。整体 ThoughtWorks 中国区还是很挣钱的，但是补贴给了不少国外的亏本项目。 ThoughtWorks 另外一个文化，就是大量招聘新人，大部分员工都是工作 1-3 年的，使用新人的首要原因其实是因为便宜，ThoughtWorks 在整体互联网行业中给付的薪水并不高，所以使用新人可以使得他们能够控制住成本。同时，ThoughtWorks 还是比较有技术追求的，他们公司内部有一些行业资深的大牛可以指导这些新人，于是那些有潜力的新人，能够得到快速地项目锻炼和恰当的指导，于是快速成长。小灰灰说，有一些新人，刚进公司，就要去给那些年纪比他大十几岁的客户做敏捷咨询，那种压力是巨大的，相对来说成长也是巨大的。 但是，终究 ThoughtWorks 这种模式下，能够到达金字塔顶端的人是少数，所以大部分员工在工作几年之后，能力成长起来了，就会选择跳槽。拿小灰灰的话说：「薪资 double 是至少的，能力强的能够 triple」。 其实对于 ThoughtWorks 来说，这其实是「双赢」的。为什么人离职了还是「双赢」呢？因为 ThoughtWorks 还是留住了少量最最精英的人到达金字塔的顶端，同时 ThoughtWorks 以非常小的人力成本，保证了它能够完成项目，公司能够正常经营。那些离开 ThoughtWorks 的人，在公司经历了历练和成长，何尝不会感恩公司，他们在别的公司做得好，反倒会正面宣传 ThoughtWorks 的技术影响力。 我有一次听到一个类似的故事，四大会计事务也是大量招募新人，很多重要的项目，用老人带新人的方式开展工作，那些新人拿着非常低的薪水，但是工作压力特别大，但是通常三年之后，这些新人成长起来，离职都能够找到非常好的新工作。而少量留下来的四大老员工，又继续着这种老人带新人的模式。 某种程度上，这就是一种商业模式，这些公司选择用低薪 + 成长空间，来吸引应届毕业生，同时获得商业收益，虽然人员不停流动，但是公司依然能够经营得很好。 陈乘方因为陈乘方所在的公司雇佣了图拉鼎，以 Remote 的方式为 ENJOY 工作过。所以我找他聊天时，首先请教了一下在以 Remote 的方式合作时，有哪些注意事项。陈乘方提到最好 Remote 的工作内容还是比较确定，不太会变的产品方案，因为远程修改产品细节将涉及大量的沟通工作，这样效率会非常低下。 陈乘方也介绍了一些远程工作的实践，比如在微信群里面，用微信语音来开每天早上的站会，方便大家沟通上一天的进度和当天的安排。我相信这里面的实践技巧还有很多，因为时间关系，我也没有详细了解。 LYcHEE这次去上海，我还专门见了荔枝软件的 LYcHEE。LYcHEE 一直在努力推广正版的 Mac 软件，他经营的 小店 虽然没挣多少钱，但是也够他日常的生活开销。我之前和他合作推广过 Charles 和 Reveal，都非常愉快。 LYcHEE 的 淘宝小店 的模式是，和国外的正版软件谈合作，然后一次性地下单购买几百个 License，然后再销售。通常为了保证软件是正版的，这些 License 都是正版软件官方网站购买的兑换码，这样可以保证购买人的注册信息都是兑换时生效的。LYcHEE 的风险其实也来源于这种模式，因为这些 License 都是批量采购，一旦没有卖到一定数量，他就会面临亏本。 和 LYcHEE 聊天，我发现他是一个非常自律的人，因为他自己开淘宝店，所以每天上班的地方就在家里。他会每天早上固定的时间起床，然后健身，然后工作，中午和晚上也会有固定时间休息。我特别佩服这种自律性强的人，LYcHEE 个子很高，整个人看起来非常精神，由于长期健身，身体有明显的肌肉线条，非常帅。 他的淘宝店的客服，也全部都是远程办公的方式在协作。这种 Remote 的方式和图拉鼎的 Remote 有很大的差别，因为客服的 PKI 很好制定，也非常有效（比如回答量，响应时间等），所以 LYcHEE 只需要定好 PKI，就可以很好地管理这些客服的工作了。而淘宝的卖家平台也很方便地提供了这些 PKI 指标。 如果你长期使用 Mac 电脑，以后买正版软件之前，建议都可以去 LYcHEE 的 淘宝小店 先搜一下，基本上如果有正版的话，都是网上能够买到的最低价了。 另外，LYcHEE 私下告诉我，他在卖正版的 Mac 软件之余，计划再做一些更大的事情，期待着他的新产品发布。 嗯，顺便还见到了 LYcHEE 的女朋友，祝早日成婚～ 汤圣罡汤哥一直是我眼中的全才，运维、开发、设计通吃，这次终于有机会见到了他真人。汤哥性格非常内向，另外感觉有一些固执，对事情有着自己的看法，不太容易说服他，哈哈。 汤哥一直强调会场的凳子坐着屁股疼，到大会第二天中午，马上轮到我分享前，汤哥说屁股实在坐不住了，要走了。吓得我赶紧抽中午的时间，把下午的分享提前给他讲了一遍。但是，结果到大会分享结束前，汤哥都没有走！汤哥不但又听了一遍我的分享，还把傅若愚的分享也听完了才走。我对此表示，以后再也不相信汤哥的屁股会疼了。 关于汤哥的八卦，嗯，汤哥给我讲了讲他们家那边的做相亲 O2O 的大妈，实在是非常有趣，如果你见到了他，一定得让他讲一讲。 结束语每次参加各种技术大会，我都会挑几个感兴趣的主题，认真听演讲嘉宾的分享，然后别的时间，我就会到处找朋友聊天八卦。我想这才是参加技术大会正确的姿势，没人说你一定需要坐在凳子上一直听到「屁股疼」，对吧？ 希望明年的 SwiftCon 大会，能够见更多的新朋友，听更多的八卦和趣闻。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"SwiftCon 2016 参会感想","slug":"swiftcon-2016-notes","date":"2016-04-24T16:10:53.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/04/25/swiftcon-2016-notes/","permalink":"https://blog.devtang.com/2016/04/25/swiftcon-2016-notes/","excerpt":"","text":"4 月 23 - 24 日，我参加了由 Think 技术社区举办的 SwiftCon 大会。这次大会见到了很多新老朋友，也从嘉宾的分享中学习了很多，微博上对于此次大会也有一些争议，一并写个参会感想，分享一下我的观点。 分享笔记首先分享一下我两天听分享的收获。 一个 Swift 项目的网络层变迁——陈乘方陈乘方负责开发 ENJOY 这个 App，ENJOY 是一个比美团和点评更「上档次」的美食推荐和团购应用。而 ENJOY 是一个由纯 Swift 语言开发出来的 App。陈乘方的这次分享中，我感受到了大家 ENJOY 这个项目对于 Swift 新特性的接受和演进过程。 大家刚开始写 Swift 项目的时候，都是把 Objective-C 翻译成 Swift，那个时候，虽然我们用的语言是 Swift，但是我们的思维方式还是 Objective-C 的，所以，陈乘方首先介绍了在项目演进过程中，大家对于 Swift 新特性的引入，从而带来编码方式的变革过程。 他们使用枚举、范型、以及 protocol extension 作为第一个演进版本，使得自己的项目更加 Swift 化。 接着第二个演进版本，他们将 AFNetworking 进行了替换，改成了 Alamofire。比较关键的一点，他们把成功和失败的双回调，合并成 completion 单回调，所以就产生了 APIResult 对象： enum APIResult&lt;T&gt; &#123; case Success(T) case Failure(NSError, AnyObject?)&#125; 这种改进是更加 Swift 化的尝试，因为 APIResult 这种保存网络结果的方式，是一种对数据的封装，可以更加方便地使用 map 和 flatMap 进行链式调用。 最后一个演进版本，他们： 用 ObjectMapper 代替了 Mantle 去掉命名前缀 用 Struct 类型的 Model 尽可能减少 optional 的 Model 属性 为 APIResult 增加了 map 和 flatMap 方法 整个演进过程中，我能感受到他们对于 Swift 的最佳实践也是一步一步摸索得更加清晰。除了总结性的介绍外，陈乘方在演讲的后半部分，还以一个具体的 API 请求为例，展示代码的整个生成过程，让我更加清晰地理解了他们的应用架构方式。 这个主题分享非常适合那些刚刚迁移到 Swift 语言的新项目，他们可以从中吸取到宝贵的实践经验。 最后恭喜 ENJOY 获得了 3000 万美元的新一轮融资，以及陈乘方本人抽中了今年 WWDC 的门票，ENJOY 公司会报销陈乘方参加 WWDC 的全部费用，真是良心公司，大家投简历去吧，哈哈。 Objective-C 和 Swift 的跨平台开发——Tinyfooltinyfool 的这个分享我很早以前听过，当时应该是在网上看的他参加博览网的分享，分享地址 在这里，当时他分享的主题是《如何把 iOS 代码编译为 Android 应用》。这次分享的题目虽然不一样，但实质内容是一样的。 这其实是一个非常有技术含量的事情，tinyfool 基本上把他们要做的事情讲了，但是并没有深入到细节讲怎么做。这其实是完全能够理解的，因为这些细节讲起来会非常碎，在场的人也很难有谁有这方面的需求做同样的事情。所以基本上，这件事情大家了解他是如何着手计划和实施的，就可以了。 不过这场分享，很多人表达出不满意。我想 tiny 如果抛出两个技术细节，让大家玩味一下会更有意思一些。 逆向工程：从 Objective-C 到 Swift——包涵卿这个分享非常对我的味口，因为我一直对 iOS 安全非常关心。 包涵卿在演讲中，介绍了他使用 Hopper Disassembler， IDA Pro， otool, class-dump 逆向分析 Objective-C 和 Swift 的编译后代码。其中涉及的技术细节都非常有意思。 例如 Non Fragile Layout，这种编译方案，使得父类增加成量变量，不会影响子类的二进制代码运行。这样，苹果就可以在新的 iOS 操作系统中，默默地升级 NSObject，UIView 和 UIViewController 这些大家都会继承的父类的成员变量，而不会影响原有的代码运行。这个技术细节感觉国内并没有多少人是真正理解清楚的。 关于这个，我记得王晓磊给我的公众号投稿过一篇名为 Objective-C 类成员变量深度剖析 的文章，也对这个特性做了详细的分析。 包涵卿还介绍了 Swift-String 的内部实现，通过介绍它的大小是是 24 字节，一步步分析，最后还原出原来是它有一个 _core 的变量，类型是一个 _StringCore 结构。这个结构里面有三个变量：_baseAddress, _countAndFlags, _owner。 包涵卿接着介绍了 Swift-Demangle 的细节，一个 Swift Protocol 的指针大小是 40 字节的逆向分析。 包涵卿介绍了一个超有用的分析命令ima lookup -a &lt;address&gt; ，可以查对应地址可能是什么对象，有这个命令之后，在分析对象组成的时候，就方便很多了。 最后，我了解到 protocol witness，它是一个类似 C++ 的虚方法表的实现，这让我理解了 Swift 对 Protocol 的实现方式。 拥抱 Swift 3.0 与未来展望——图拉鼎图拉鼎是奇点和 Manico 的作者，也以 Remote 的方式为 ENJOY 工作过。 图拉鼎的这次分享，首先介绍了 Swift 3.0 的目标： ABI 稳定 跨平台 Package Manager 接着，他分享了 Swift 2.2 在语言演进上的变化，包括：selector、keyPath、去 Objective-C 化、标准化命名、参数化命名、废除 IUO 。 这些语言变化对我都很有帮助，特别是标准化命名这一点，方法名加 ed 结尾统一表示返回新的对象，例如：sort 是在原数组排序，sorted 是返回的是新数组。类似的还有 reversed, enumerated 等。这种命名方式设计是非常舒服的，而我之前并没有注意到这一点。 废除 IUO（Implicityly Unwrapped Optional） 这一点对我启发也很大，我们了解到苹果对于语言的演进过程，其实就能理解哪些是好的设计，哪些是不好的设计。 最后，图拉鼎介绍了 Swift 未来的 演进方向： SE-0025: Scoped Access Level SE-0038: Package Manager C Language Target Support SE-0048: Generic type alias 对此，我最大的收获是知道了原来可以 从这里 看苹果对于 Swift 语言未来的规划，相信我以后会常常到这里翻翻，看看苹果是如何做计划的。 图拉鼎还介绍了一个好的学习平台，IBM 的 Swift sandbox: https://swiftlang.ng.bluemix.net，听他说这个平台更新非常及时，可以方便我们实验 Swift 的新特性。 Redux in Swift——新一代的 iOS 应用架构——方志刚方志刚自己在 playground 上做了一个用于演讲的程序，可以播放 PPT + 看代码，而且你知道吗？这是他在第一天演讲的现场撸出来的。真是后生可畏啊！ 在这个分享中，方志刚分享了一个小众的、新颖的架构方案：Redux。在介绍完架构后，方志刚直接上代码，带着我们一步一步演示如果用 Redux 开发出一个 TODO 的应用。Redux 优点：好测，简单，可缓存，时光倒退模式这些都让人感觉耳目一新。 但是，我最大的收获倒不是这个框架本身。我相信一个新的框架肯定也会有各种各样的问题，我最大的收获是方志刚在介绍如何把这个框架改造成支持异步的时候，提出了一个 Inverse Of Control 的方案：把 dispatch 反转控制，交给异步的线程来回调。 我不知道未来我是否会有类似的设计架构的需求，如果我以后也有改造现有框架，让它支持异步的方案时，我应该会仔细评估方志刚的这种设计方式，还是挺有意思的。 How to parse float numbers - the really hard way——傅若愚每次听傅若愚的分享，我都有智商被碾压的感觉，不过每次回头再仔细学习他的 keynote，我总是会收获很多。其实我的 Swift 烧脑系列文章，有几篇都是在傅若愚的演讲中得到的启发。 这次我听到他一下子定义了大量操作，将 Monad, Application 和 Functor 都实现并且应用在浮点数转换中时，我又知道我得会后再下功夫了。 其实傅若愚也明白这一点，他将所有的讲稿和代码都放到了 GitHub 上，大家可以自行学习。 读 Swift 源码，理解 Monad——唐巧我自己的分享，主办方把我放在中午饭之后，让我压力山大，为了让大家不睡着，我带大家一起伸了懒腰，是的，我们大会所有人一起举起双手伸了一个大懒腰。然后，我结合《引爆点》这本书，给大家讲了一个段子：「如何成为 iOS 大 V」。 热场大概花了 10 分钟吧，然后就进入正题讲 Monad。整体语速还是有点稍快，现场没有提词器，我不得不时不时回头，对观众还是挺不友好的。最后演讲完，我让听懂的同学举手，现场大概有一半的同学举手表示懂了。 我自己学习 Monad 大概断断续续花了一年时间，能够在 40 分钟内让现场有一半的同学听懂，我认为值了。这场演讲是我准备得最多次数的演讲，在正式演讲前，我一共讲了五次（一次给 Lancy，一次公司内部分享，一次给 T 线下沙龙，一次给南京软件技术大会，一次给汤圣罡），也是我认为最有挑战的演讲内容吧，整体来说，我给自己打 90 分。 没听懂的同学，对不住了，我已经尽力了。如果你没听懂，建议再学习一下相关的资料：http://t.cn/Rq4fwJk、http://t.cn/Rqp3GiW、http://t.cn/RL5pYwM 其它以上几个分享，是我认真听了，并且觉得非常值得总结的。除此之外，由于我和会场的朋友聊天，错过了「从数学函数角度理解函数式编程——丁峰」，「Swift 语言的设计取舍及跨语言调用——董一凡」，「Asynchronous Programming in Swift，Swift 异步编程——刘冠杉」这三个分享，所以无法总结。 「Swift 设计模式——老镇 (曾伟) 」这个分享我听了，我觉得稍微有一些问题，因为老镇只是把这些设计模式一一介绍，其实这样并不是很有效。作为分享，还不如选一两个点，结合 Swift 的源码来理解，可能更好一些。不过老镇对这次分享准备得非常认真，写了一万多字的讲稿，举了大量武侠的例子，没能深入也蛮可惜的。我感觉还是他经验太少，在内容组织上没有经验，期待他以后会演讲得更好。 关于对会议的讨论从昨天开始，twitter 和 微博上就有人开始喷这次 SwiftCon 会议，我感觉实在犯不着，因为这次大会有相当多的内容都是精心准备的，如果有一两场不合你的胃口，也不用攻击整场会议。这次 SwiftCon 会议的分享内容，在我以上总结到的分享，都是高质量的，而这些总结，已经覆盖了超过半数的分享议题了。如果你仅仅拿一两场的分享说事，明显犯了以点盖面的错误。如果有谁觉得不对，建议也能够详细指出每一场分享到底水在哪里，让讨论能够更加客观和公正。 另外，微博上发泄或者互喷是相当浪费时间的，有这个时间还是看看技术文章，看看开源代码吧。整个互联网圈子已经够乱了，我还是希望我们 iOS 圈子能够少一些偏激，多一些心平气和的讨论。 最后，我要说，这次会议其实是非赢利的，首先所有讲师都没有报酬的。我从锅巴和板子那里了解到，所有的大会志愿者，也是没有任何劳务报酬的，大会的主持吴柯瑶（其实她是一个 iOS 开发者）也是没有任何报酬的。那为什么要收门票呢？因为分享的场地设备得花钱，外地讲师的路费和住宿费得花钱，所以这些钱需要通过门票来补贴。 如果你能理解这是一个完全民间的团体，组织的一次非赢利性的大会，他们都是本着做事和分享的态度来做这个会议，那么我相信你的心态会更加宽容一些。这是上海有史以来的第一次 Swift 大会，所有人都希望它办成功，这个过程中有什么不如意的，我们改进就行了，没有那么不可原谅的。 愿大家开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"聊聊 WWDC 的八卦","slug":"talk-about-wwdc-2016","date":"2016-04-19T13:34:22.000Z","updated":"2024-01-06T14:52:37.927Z","comments":true,"path":"2016/04/19/talk-about-wwdc-2016/","permalink":"https://blog.devtang.com/2016/04/19/talk-about-wwdc-2016/","excerpt":"","text":"就在今天，苹果对外公布了 WWDC 2016 即将举办的消息，具体的举办时间是 6 月 13 日 - 17 日。我虽然从来没有去过 WWDC，但是我的个人提高和 WWDC 是密切相关的。 了解我的朋友都知道，我曾经说过，我是一个视觉型的学习者，所以我在刚刚初学 iOS 的时候，选择了斯坦福的视频课程。而我在入门之后，理所当然地选择了看 WWDC 视频作为我的进一步提高的方法。 由于 iOS 开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是 WWDC 的视频。通常情况下，一个 iOS 开发的新知识首先会在 WWDC 上被苹果公开，然后 3 个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过 WWDC 的视频。 在 2014 年以前，这些视频只能在会议之后获得，但是从 2014 年开始，视频开始随着 WWDC 大会的进程，在会议过程中逐步放出，而且重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的 iOS 开发知识，还可以提高英文听力水平。 很多朋友说他英语听力不好，相信我，其实技术的文档和会议中使用的英语语法和单词都相当简单，你缺少的只是一个坚持一段时间的信心。我当时也是受制于国内资料太少，被逼无赖看的，但是「通过英文资料学习」这个能力一旦获得，你就停不下来了。 WWDC 在早年其实是通过抢票的方式来购买的，所以历年 WWDC 门票售卖期间，各个开发者都如临大敌，为了抢得一张近一万人民币的票，想尽各种办法。这种情型在 2013 年达到了巅峰，那个时候，门票开售仅仅 2 分钟，就销售一空（见下图）。 这种情况至到 2014 年改成「摇号」的方式，才得到改变。苹果也意识到 WWDC 对开发者的吸引力太大，于是将视频尽量早地放出。 最近，苹果甚至给去年的 WWDC 视频都补上了中文字幕，不过说回来，字幕里面把 「Tim Cook」 翻译成 「提姆厨师」真的不是开玩笑吗？反正看了一眼这个字幕，我心中升起了「比更大还大」(Biger than biger）的无奈，乖乖切回了英文字幕。 我没有去过 WWDC，作为一个 iOS 开发者，我一直希望有一天能够去那个圣地学习一番。不过门票和来回的机票和住宿还是让我的钱包压力山大。所以我一直很羡慕那些公司能够报销参加 WWDC 大会的开发者。如果你在这样的公司，欢迎留言告诉我，我会把留言精选出来，让大家围观羡慕的。我也希望猿题库公司成长到一定阶段之后，也能给优秀的员工这样的福利。 今年的 WWDC 能有什么期待呢？除了例行的 iOS 升级大版本之外，我猜估计就是 Swift 3.0 的推出吧，不过也可能苹果留了一手给我们再次带来惊喜。 或许期待本身，就是一件美妙的事情吧，让我们拭目以待。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"《把时间当做朋友》：一本关于心智的启蒙书","slug":"control-yourself","date":"2016-04-19T00:28:17.000Z","updated":"2024-01-06T14:52:37.926Z","comments":true,"path":"2016/04/19/control-yourself/","permalink":"https://blog.devtang.com/2016/04/19/control-yourself/","excerpt":"","text":"引言很早以前就看了李笑来老师的《把时间当做朋友》，最近终于整理完成了学习笔记。《把时间当做朋友》是一本老书，最初写于 2008 年，现在依然在售卖中。李笑来也将本书的 电子版 公开到了网上，免费供读者下载。 本书的作者李笑来以前是新东方的英语老师，在比特币火爆之前，花 100 万买了比特币，我猜他现在应该是财务自由了。李笑来老师在投资比特币之余，展现出了强大的自学能力，自己学习了编程、设计并且作品都还不错，现在，他在学习社群的运营，并且创建了「学习学习再学习」微信公众号以及多个付费社群。 我看完《把时间当做朋友》之后，最大的感受是：这是一本关于心智的启蒙书。 关于心智的定义，我觉得李笑来在书中的定义稍显复杂。在我看来，所谓心智就是一种高层次的大脑控制技巧。这种高层次的大脑控制技巧主要包括两个部分： 内在控制：控制自己的情绪。 外在控制：控制自己的行为。 接下来，我会按照上面的理解，来将书本的内容重新梳理和介绍。 真的存在高层次的大脑控制吗？理解心智，首先就得理解高层次的大脑控制的存在。那么，真的存在高层次的大脑控制吗？关于这个，作者在书中举了很多例子，我也给大家举几个我自己想到的例子。 注意力转移你是否有遇到过这种情况？你在看书，遇到一个不认识的单词，想查一下词典，于是你打开手机。刚刚解锁手机，你发现你的微信上有两个红点，于是你点进去，发现是你的死党发过来的搞笑视频。看了视频把你乐坏了，回了死党一段信息后。你发现微信朋友圈上有红点，于是你就点进去看朋友圈。等你把朋友圈刷完，你早已忘记了你本来在看书这件事情。 在上面这件事情中，你到底是被你的大脑控制，还是被各种外界信号刺激所控制呢？ 情绪失控 在电影 《七宗罪》 里（上图），有一个情节是连环杀人案凶手最后利用警员米尔斯的愤怒，让他无法控制自己的情绪，最终当着所有人的面，把凶手杀死。当然，最后等待米尔斯的是被押上警车以及职业生涯的断送。 在这件事情中，米尔斯不是被他的大脑控制，而是被愤怒的情绪所控制。《七宗罪》里面涉及的暴食、贪婪、懒惰、愤怒、骄傲、淫欲和嫉妒，这些情绪都会在某些场景下影响我们，使得我们的行为丧失理智。 内在控制：控制自己的情绪个性是由情绪和经历塑造的情绪是我们生命重要的组成部分，很多时候，我们的性格和做事方式都是情绪在各种经历下的产物。我接触到的对此最好的阐述，就是电影 《头脑特工队》 了。顺便说一下，该片由皮克斯与迪士尼合作制作，在 2016 年 2 月，获得了第 88 届奥斯卡最佳动画长片奖。 在电影《头脑特工队》（上图）中，主人公莱利的行为由五种情绪构成，这五种情绪是 “欢乐”、“恐惧”、“厌恶”、“悲伤”、“愤怒”。在这五种情绪相互影响下，莱利在小时候是一个有着外向，活泼，调皮性格的小女孩，但是随着她搬到新家，没有了朋友，她慢慢变得焦虑，厌恶身边的人，以前的性格被重新塑造。最终，她将自己的痛苦述说出来，使自己的压力得到释放，她的个性中的快乐成份融入了眼泪，使得她更加懂得珍惜。 控制情绪我们说控制自己的情绪，并不是指我们需要压抑所有的不好情绪，在《头脑特工队》中，主人公莱利就是因为过度压抑悲伤，使得自己无处释放压力，最终反倒被自己的愤怒情绪所控制。 所以，当我们说控制自己的情绪的时候，我们其实在说，我们应该为了获得长久的好情绪，而控制自己短期的坏情绪。 我老婆是学幼儿教育的，她给我讲过一个故事，幼儿教育学家为了研究小孩的自控能力，会做一个叫做 延迟满足 的实验。这个实验（相关视频）是这样的： 在一个屋子里面，让小孩坐在一个书桌前，然后给小孩一个糖果，告诉他：「我 15 分钟后回来，如果你在我回来之前都不吃这个糖果，等我回来后就再奖励你一个糖果」。 通常情况下，很多小孩都无法抵抗糖果的诱惑而很快将它吃掉。而研究发现，那些坚持到最后的小孩，自控能力更强，在随后的跟踪研究发现，这些小孩能够在学校取得更好的学习成绩。 最后，研究人员发现，这些小孩都会非常简单的一招：转移注意力。具体来说，他们会在特别想吃糖果的时候，选择做别的事情来让自己大脑暂时不那么关注糖果。比如他们可能会唱歌，在桌子上写字，将头转向窗外。 所以，在这个故事中，小孩为了获得「得到两个糖果的奖励」这种喜悦的情绪，通过转移注意力的方式，暂时压抑了自己短期「想吃这个糖果」的欲望。 我们在生活中，也在不断地重复着这种事情。当我们工资不高的时候，看到一个想买的东西，我们会理性地压抑自己的购物欲望，为的是这个月不至于交不起房租或者饿肚子。当我们在高三时，我们每天都学习得很辛苦，但是我们会控制自己的压力，为的是高考时能够考出更好的成绩。当我们和别人起冲突时，我们会控制自己想打人的冲动，为的是自己不至于在警察局待上几天。 中国有句古训：「忍一时风平浪静，退一步海阔天空」。其实意思就是我们应该为长久的好情绪，控制自己短期的坏情绪。而这种推迟满足感的能力，就是一种高层次的大脑控制技巧。 控制情绪的技巧下面是我总结出来的控制情绪的具体技巧。（注：我将这些技巧在《把时间当做朋友》书中的对应章节，以章名 + 小节名的方式附在每个技巧标题后面，例如 3.2 节表示：第 3 章第 2 节。） 转移注意力（第 2.4 节）刚刚上面小孩抵抗糖果的诱惑的实验其实已经提到了这种技巧，这种技巧的核心在于，对于一些坏情绪或者痛苦的体验，我们不去想它，那么它的影响就会大大降低。小孩通过简单的把头转向窗外想别的事情，就可以让糖果的诱惑力对大脑的影响大大降低。 类似的场景还包括，当你特别不高兴的时候，找一些你平时喜欢做的事情，甚至简单地让自己做一些事情（比如运动）都可以极大的转移掉你对于糟糕情绪的关注。 推迟满足感（第 2.5 节）人总是倾向于立刻获得满足，如果完成一件事情的满足感来自未来的某一个时间，那么这就需要大脑的控制了。推迟满足感与转移注意力的差别在于，推迟满足感明明知道当前的行为让自己有些难受，但是仍然控制大脑做这件事情。 我最近在学习两个新技能，一个是学自由泳，一个是学骑独轮的思维车。这两个技能的获得过程都是痛苦的。我在学自由泳的时候，由于身体还没有对动作产生记忆，所以身体非常不协调，稍微不小心就呛水了。但是我会明白这是学会游泳的必经过程，所以坚持学下去，以便我在未来的某个时间，可以获得「学会自由泳」带来的喜悦和成就感。 学自由泳是一个很容易达到推迟满足感的例子。真实生活中，有着更多更难做到的事情，需要我们控制好情绪。 在《把时间当做朋友》的书中，作者就举了一个很难的事情：背下 GRE 要求的 2 万个单词。因为 2 万个单词实在太多，所以这件事情必须经过一个相当长的时间才能完成，即使一天背 100 个单词，也需要连续 200 天才能完成，而坚持做这件事情 200 天的难度非常大。 虽然所有人都能理解这个道理，但是真正能坚持做下来的人少之又少，后面我会分享坚持的一些技巧。 外在控制：控制自己的行为我们对情绪的控制，最终反映出来的结果就对自己行为的控制。外在的行为控制表现出来有各种实践技巧，在本书中，用了大量篇幅进行了介绍。下面我们来一一看看这些技巧包括哪些。 精确感知时间（第 2.3 节）控制行为的第一步是感知时间，这也是书名《把时间当做朋友》的由来。书中也提到《奇特的一生》，我对此书也刚好写过读书笔记。时间是完成所有事情的基础资源，精确感知时间使得我们能够对时间资源的利用率显著提升。 用纸笔来记录时间，以及具体的执行技巧（第 3.2-3.5 节）这部分的内容偏执行，详细讲解了如何用纸笔来记录时间，记录执行时间的技巧和总结方法。虽然李笑来老师在书中没有推荐「番茄工作法」，但是我觉得这部分的实践技巧和「番茄工作法」是能够相互配合使用的。关于「番茄工作法」，我也写过一篇读书笔记。 合理的、适度的计划（第 3.6 节）避免过度看重计划的重要性，在打算做一些事情时，没有计划或者简单计划后的快速启动，比花费大量时间计划后再做要更好。比如说健身，与其说研究哪种健身运动更合适，倒不如今天开始就动起来。当然，笑来老师也提到，改变的事情需要快做决策，投资的事情需要慢做决策。 阅读（第 4.1 节）阅读是持续获得新知识的技巧。不过我们更应该看重图书的阅读，同时应该压抑自己在社交网络（微博、微信朋友圈）上碎片时间的阅读。因为后者知识不但很碎片化，而且也不成系统，另外同时有很多毫无营养价值的鸡汤 &#x2F; 假新闻存在。 关于阅读，我之前写过《如何阅读一本书》的读书笔记，也推荐给大家。 学会如何学习（第 4.2-4.4 节）「学会如何学习」就是要掌握正确的获取新知识的方法。很多人问我 iOS 开发如何入门，如何提高，好象这些问题就应该通过问别人才能获得答案。但是我觉得，一个学习能力强的人，面对一个新领域的知识，他自己就会找到学习新知识的方法和提高技巧。 这其实就是一种自学能力。书中对于自学能力的解读（第 4.3 节）包括： 阅读理解能力 检索能力 写作能力 实践能力 保持开放的心态 了解学习的进程 在书中，笑来老师还提到的学习技巧包括：警惕自己的经验造成的「思维误区」，当我们面对不同观点时，常常自省一下，可能才有机会调整自己的认识。我们不光需要自省，同时也要不盲目信服权威和老师（第 4.4 节）。 另外，在判断知识正确的时候，掌握「正确的科学方法论」也非常重要。这一点在《如何阅读一本书》中也有涉及。我们在判断一个理论是否正确时，要考虑它的论点，论据以及推导过程。任何论据不对、论据不充分或者推导过程不严谨的观点，我们都应该加以小心。 在这方面，最应该小心的就是成功学鸡汤了(第 5.1 节），成功学鸡汤常常会犯论据不对或者推导过程不严谨的错误。 罗辑思维有一期节目批判中医，其中就指出了中医粉在为中医辩护中的各种逻辑上的错误，感兴趣的朋友可以翻来听听。 另外我最近和朋友讨论，也颠覆了我的一些观点，其中一个观点是：电动车一定是未来吗？我一直觉得是未来，但是我的这个朋友的观点让我发现了，我的论据还是有一些不充分的地方。 书中同时提到了《少有人走的路》，我还没阅读，稍后应该会补上阅读笔记。 改变态度（第 4.5 节）「改变态度」其实改变的是：思考问题的角度，从而让自己更舒服。 比如我本来 iOS 开发做得很成功，但是转而做管理之后，iOS 方面的技能基本上只能在业余时间提高了。对于此，我可以这么想：这么多年辛辛苦苦学习积累的 iOS 技能不能够派上用场上，慢慢还会忘掉，真是郁闷。但是，换一个角度，我还可以这么想：我在 iOS 方面已经很难提高了，但是我在管理方面还是一个菜鸟，人的一生能够同时经历程序员和管理者两个职业角度来学习，最终我如果能够在新的领域成长起来，何尝不是一件精彩的事情！ 我们面对失败，面对困难，面对学习的态度，都可以通过换一个角度，找到更加积极的应对方式。如果你实在找不到角度，我给你出一个办法，你想象一下这个场景：你不是出身在中国，而是出生在非洲的一个平民窟里，你吃不饱，无法受到良好的教育，周围医疗环境糟糕，甚至连喝干净的水都是奢望。你再想想你现在的生活，是不是真的有那么糟糕。 小心「成功学」（第 5 章）书中提到的技巧包括： 拒绝鸡汤 拒绝简单地强调坚持 拒绝不合理的论证 过于强调自己的独一无二 过于强调人脉和圈子 理解和提高学习效率（第 6.1-6.7 节）学会：分割任务，坚持执行，保持合理节奏，不迟到。 不要浪费时间证明自己（第 6.8 节）活在别人的世界里是很悲惨的，因为大多数时候，除了你特别好的朋友和亲人之外，别的人并不关心你是否过得开心。那些看不起你的人，那些批评你的人，只要不是友善的态度，大可不必回应，更不用证明自己。 我还记得，有一个人在我的公众号留言：「你 iOS 技术文章写得还行，但是非技术的东西写得很烂，麻烦以后别写了，浪费我的时间」。我看了之后，默默地把他拉入了黑名单。 你永远不可能让所有人喜欢你，你也永远无法和那些试图伤害你的人解释，总有一些人喜欢看你的笑话，看你出丑，对于这些人，无视他们的存在是最好的生活方式。实际上，他们的存在对于你确实一点价值也没有。 不后悔，而是总结（第 6.9 节）这也是一种看问题的角度，当我们失败的时候，专注于总结而不是后悔才有可能让我们进步。 耐心（第 7.3 节）耐心其实就是「推迟满足感」的外在表现，但是这件事情其实说起容易做起来难。笑来老师在本节中也没有说应该如何获得耐心。面对一个花费时间较长的工作，我知道的产生耐心的技巧包括： 拆解任务，为自己的任务设立阶段性目标。以便从心理上感受到目标容易达成，同时可以更好地追踪进度。 每天用「番茄工作法」来安排当前的工作，使得自己能够聚焦当前的工作。 暗示自己工作时产生焦虑是正常的，所以尽力不去想工作量的事情。 当工作快要完成的时候，暗示自己快要成功了。 一开始就做好充分的估计和准备，不要盲目乐观，避免进度延后之后心理的落差。 通过固定时间和固定频率的工作，培养习惯让身体对任务的执行产生条件反射。 利用 10000 小时定理来鼓励自己。 其它书中还提到的技巧包括：培养记忆力（第 4.6 节）、不自卑（第 6.10 节）、不要简单地把时间都转换成金钱（第 6.11 节）、专注于当前的工作（第 6.12 节）、提前准备（第 7.1-2 节） 另外，我自己也有一些书中没有提到的一些心得。包括： 自省：定期回顾与总结。形式可以是以年度总结、月度总结的方式，审视自己的行为是否有值得改进的地方。 培养好奇心。鼓励自己学习和探索新的事物。 培养习惯。刚刚也说到，习惯让自己对一些事情的坚持变得更加容易。 适度坚持。面对一些不确定收益的事情，不应该随意放弃。 心智与情商的关系如果说心智这个概念听起来如果比较新的话，那么 情商 就是一个历史悠久的概念了。我好奇地翻了一下情商的定义，包括五个部分：自我意识、控制情绪、自我激励、认知他人情绪和处理相互关系。 看完这个定义，我突然觉得，其实心智就是一部分的情商，包括：自我意识、控制情绪、自我激励。这部分主要是偏向于自我的控制。而情商的剩下部分：认知他人情绪和处理相互关系，主要偏向于社会交往能力。 所以说，看起来李笑来老师似乎搞了一个新概念，但是其实是把以前的情商理论，抽取出了一部分偏自我控制的部分，进行了归纳和总结。 小结李笑来老师的《把时间当做朋友》是一本关于心智的启蒙书，对于我们控制情绪和行为都具有不错的实践指导意义，本书的 电子版 可以免费下载，推荐各位朋友阅读，早日开始自己的心智。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"「番茄工作法」- 简单的时间管理方法","slug":"tomato-time-management","date":"2016-04-12T13:20:55.000Z","updated":"2024-01-06T14:52:37.926Z","comments":true,"path":"2016/04/12/tomato-time-management/","permalink":"https://blog.devtang.com/2016/04/12/tomato-time-management/","excerpt":"","text":"简介「番茄工作法」是一个简单、轻松的提高工作效率的办法。一直在小众圈子里面流行，但是没有被普及。写下此文，希望番茄工作法能够被更多人了解和接受。 「番茄工作法」这个名字的来历是这样：番茄是指番茄外形的定时器（下图）的意思。专门的定时器常常用于烹饪的计时，时间到了之后闹钟就会响起来。 番茄工作法的思想是：将日常工作分割成若干个计时器单元，每个单元大概 30 分钟左右。在番茄单元之间，进行合理地休息放松。在番茄单元进行时，保证自己精力全部集中在工作的事情上，不接受被打断和分神。 这种思想看起来非常简单，但是我在实际工作中，发现它确实能够非常高效地帮助我集中注意力。程序员在编程时通常需要较长的时间来整理思路和编码，「番茄工作法」使得我们更加容易集中注意力，从而将时间利用率提升。 使用方法「番茄工作法」的使用主流程如下： 每天早上到公司后，首先拿一张纸（或者是本子中的一页），用笔写下当天应该要做完的事情。 将这些事情按优先级排序，然后进行大致的估算后，拆分成若干个「番茄钟」，每个「番茄钟」是 25 分钟。 设置「番茄钟」倒计时，同时开始第一件事情的第一个「番茄钟」。 在「番茄钟」倒计时期间，集中精力只做事先安排好的事情。 在「番茄钟」结束后，休息 5 分钟，走动放松一下，然后继续下一个「番茄钟」，直到完成自己的任务。 每完成 4 个「番茄钟」（即 2 小时），休息 15-30 分钟。 一些意外情况： 如果你被电话、交谈打断，这个「番茄钟」即宣告失败，可以简单休息 5 分钟，然后重启「番茄钟」。 如果你突然想到一件重要的事情，除非当前非做不可，否则应该在纸上将此事快速记录下来，然后继续你的「番茄钟」。 一些技巧和心得 在进行「番茄钟」时，我们应该尽量想办法避开一些容易分神的信息源。例如：将手机的消息推送静音，关闭 QQ 和微信。相信我，你大多数时候并不需要立即响应聊天软件中的信息。使用「番茄钟」后，你的消息回复时间最坏情况下也就是晚 25 分钟。如果真的有人有急事，他会直接到你的办公桌来找你，或者直接给你打电话的。对于程序员来说，也可以带个笔记本，找一个相对安静的地方编程。 随着你的注意力控制越来越容易，你可以适当延长「番茄钟」的时间。就我的经验，延长到 45 - 50 分钟是完全没有问题的。其实你如果明白了「番茄钟」的原理，你甚至可以在心中假想一个「番茄钟」，然后让自己快速进入精力集中状态。 一天下来，回顾自己当天的「番茄钟」完成情况，看看主要的问题在于自己的精力无法集中，还是老是被别人打断。针对具体的问题可以做一些调整的尝试。比如，如果是精力无法集中，则看看是否是干扰源过多，尽量减少干扰。如果是老被打断，则可以和同事商量一些工作方式，比如让同事尽量用邮件和 QQ 找你，而不是当面打扰你。 「番茄工作法」是一种简单轻松的工作法，我们应该尽量简单地使用它来辅助自己的工作，而不应该让任务计划和管理本身成为一件麻烦。所以，建议不要使用复杂的 App 来记录你的番茄钟完成情况，一张 A4 纸和一支笔就够了。另外，记录档案和思考如何提高不应该超过一个番茄时间，我们不应该让「番茄工作法」成为一种负担。 我们应该认识到，工作被打断是在所难免的，总会有一些临时的沟通工作无法被计划，并且是有价值的。所以，「番茄钟」失败后，不应该有过多的情绪，尽快重启一个「番茄钟」，你的工作应该很快就会进入状态。 各位做 iOS 开发的同学有多少买了 Apple Watch？我发现 Apple Watch 就是最好的「番茄钟」，我将 Apple Watch 的计时器放到了表盘上，抬手就可以开始一个番茄时间，非常方便（下图）。时间到了就会震动，也不会影响到旁边的同事。 推荐读物 《番茄工作法图解：简单易行的时间管理方法》：一本 10 几块钱的、薄薄的充满图案的小册子，让你轻松理解番茄工作法。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"应该如何管理密码 - 我的密码管理心得","slug":"my-password-management-way","date":"2016-04-07T15:59:37.000Z","updated":"2024-01-06T14:52:37.926Z","comments":true,"path":"2016/04/07/my-password-management-way/","permalink":"https://blog.devtang.com/2016/04/07/my-password-management-way/","excerpt":"","text":"我的密码升级之路我最早接触密码这个概念是在高中的时候，那个时候我第一次申请 QQ 号，需要想一个超过 6 位数的密码。于是，我填上了我爸爸的手机号。老实说，手机号作为密码还不算最糟糕的。比起生日来说，手机号更长一些，可能的组合也更多一些。 我很快就了解了撞库这种攻击方式，你的密码如果在任何平台都用一样的话，如果有一个平台不靠谱，明文存储了密码（在那个年代其实并不少见，CSDN 都曾经存的是明文），那么黑客就可以用这个账号密码尝试登录其它平台。 于是，我把自己的密码分成了几套，简单的一套用于注册一些不太重要的服务，复杂的一套用于一些比较重要的服务，支付相关的还有一套。 对于每一套密码，我在密码后面加上了平台的名字。比如 QQ 的密码就是基础密码后面加 qq，网易邮箱的密码就是基础密码后面加 mail。 用了一段时间之后，我又增加了一些变化，我希望我尾部增加的与平台相关的名字不那么明显，于是，我把平台的首字母简单的取其字典序的下一个字母，然后插入到一个中间的位置。比如 qq 的密码，就是去 q 的下一个字母 r，然后把 r 插入到密码中间位置。因为我的基础密码本来就是一段随机的数字字母（真是随机的，只不过我背下来了），所以要看出规律可能需要爆出两个库才行。 但是，这么管理密码还是很累。而且，现在不断出现的安全事故让我觉得爆出两个网站被拖库也不算什么让人意外的事情。 1password终于，我尝试购买了 1password，开始用 1password 来管理密码。1password 常常有 5 折的优惠活动，今年春节趁他家 APP 优惠，我开始了我的密码迁移之旅。 1password 完全采用随机的方式来生成每一个网站的密码，通常推荐的是 12 位的字母数字组合。我花了好几天，才把所有自己在用的账号密码做了更新。 1password 支持各种方式（iCloud 或 Dropbox）在云端同步你的密码。这样你也不用担心换了电脑找不到密码了。对于云端数据安全，1password 使用的是加密的方式来保存。即使黑客获得了你们密码文件，也需要一个解密的密码来解开它。而这个密码，就是你需要牢牢记住的那最后一个密码。 使用 1password 之后，每次在 chrome 中需要输入密码时，直接使用 1password 的插件进行自动的填充即可。习惯 Safari 的朋友，1password 也有 safari 的插件。值得一提的是，1password 还支持在 iOS 系统的 Safari 中填充密码，如下所示： 除去浏览器后，主要需要输入密码的地方就是 Mac 的原生应用和手机 APP 了。对于原生应用和手机 APP，1password 都支持把密码用复制的方式，粘贴到应用的密码输入界面。对了，买了 Mac 版的 1password，手机版的 1password 高级功能也自动解锁了。 1password 唯一搞不定的是那些不允许粘贴密码的应用，比如支付宝。对于这些应用，我另外有一套密码独立管理，没有放在 1password 管理中。 有了 1password 之后，一些软件的 License 也可以集中管理了，这还是一件挺爽的事情。1password 可以自动识别出软件的图标，如下所示。 反思过来，密码确实是一个非常反人类的事情，因为人们天然怕麻烦，所以大多数人都只有一套密码，并且密码规则非常弱。 现在我们也慢慢看到越来越多的应用开始抛弃密码，用手机随机短信验证码来登录。还有一次公司，尝试用指纹（比如 iPhone)、声音 (比如微信的声音锁）、头像视频（比如借贷宝的认证）等来作为安全认证的替代品，都是不错的兼顾用户体验和安全的尝试。 密码被盗悲剧的是，就在我刚刚改完各种密码之后，我的百度云账号被盗，而且我通过正常渠道申诉失败。后来发现原因是我百度云账号绑定的网易邮箱被盗了，而那个邮箱我很久没有使用，都忘记了，所以也没有用 1password 改过密码。盗号者盗完我的网易邮箱后，从里面看到了我的注册百度云的确认邮件，于是申请了百度云找回密码，从而重置了我的百度云密码。重置之后，我的绑定邮箱被解绑，于是我就没有方法找回百度云密码了。 最终多亏在百度的朋友帮忙和担保，我才得以用非正常的渠道申诉成功。看到家里的所有照片失而复得，我第一次感觉到安全问题离自己这么近。 最后推荐 Mac 的各位朋友都使用 1password 来管理密码，并且对于一些非常重要的账号，用独立的非 1password 密码来管理。 安全问题，真的就在我们身边，大家还是小心一点。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"Swift 烧脑体操（五）- Monad","slug":"swift-gym-5-monad","date":"2016-04-05T14:56:07.000Z","updated":"2024-01-16T01:43:49.847Z","comments":true,"path":"2016/04/05/swift-gym-5-monad/","permalink":"https://blog.devtang.com/2016/04/05/swift-gym-5-monad/","excerpt":"","text":"索引Swift 烧脑系列文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 前言Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。 Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。 这是本体操的第五节，练习前请做好准备运动，保持头脑清醒。 Why Monad?因为 Monad 的定义有点复杂，我们先说为什么要理解和学习它。业界对于 Monad 的用处有着各种争论，特别是学术派喜欢用 Haskell 来解释它，因为「Haskell 是纯函数式编程语言」。但这往往让问题更加复杂了—-我为了理解一个概念，还需要先学习一门新语言。 所以我希望就 Swift 这门语言，分享一下理解 Monad 有什么用。实际上，即使在 Wikipedia 上，Monad 也没有被强行用 Haskell 来解释。所以我相信基于 Swift 语言，还是可以把 Monad 的概念讲清楚。 在我看来，之所以有 Monad 这种结构，实际上是为了链式调用服务的。什么是链式调用呢？我们来看看下面一段代码： let tq: Int? = 1tq.flatMap &#123; $0 * 100&#125;.flatMap &#123; &quot;image&quot; + String($0)&#125;.flatMap &#123; UIImage(named: $0)&#125; 所以，如果一句话解释 Monad，那就是：Monad 是一种设计模式，使得业务逻辑可以用链式调用的方式来书写。 在某些情况下，链式调用的方式组织代码会特别有效，比如当你的调用步骤是异步的时候，很容易写成多层嵌套的 dispatch_async，使用 Monad 可以使得多层嵌套被展开成链式调用，逻辑更加清楚。除了异步调用之外，编程中涉及输入输出、异常处理、并发处理等情况，使用 Monad 也可以使得代码逻辑更清晰。 基础知识封装过的值（wrapped value)这个中文词是我自己想出来的，有一些人把它叫做「上下文中的值」（value with a context），有一些人把它叫做「容器中的值」（value in a container)，意思是一样的。 什么叫做「封装过的值」呢？即把裸露的数据放到另一个结构中。例如： 数组就是对值的一种封装，因为数组把裸露的元素放到了一个线性表结构中。 Optional 也是对值的一种封装，因为 Optional 把值和空放到了一个枚举（enum）类型中。 如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum (如下所示）。 enum Result&lt;T&gt; &#123; case Success(T) case Failure(ErrorType)&#125; 判断一个数据类型是不是「封装过的值」，有一个简单的办法：就是看这个数据类型能不能「被打开」，拿出里面的裸露的元素。 数组可以被打开，拿出里面的数组元素。 Optional 可以被打开，拿出里面的值或者 .None。 一个 Int 类型的值，无法「被打开」，所以它不是「封装过的值」。 一个字符串是不是「封装过的值」呢？前提是你如何定义它「被打开」，如果你把它的打开定义成获得字符串里面的每个字符，那么字符串也可以是一个「封装过的值」。 flatMap在上一篇烧脑文章中我们也提到过，要识别一个类型是不是 Monad，主要就是看它是否实现了 flatMap 方法。但是，如果你像下面这么实现 flatMap，那也不能叫 Monad： class TangQiao &#123; func flatMap() &#123; print(&quot;Hello world&quot;) &#125;&#125; Monad 对于 flatMap 函数有着严格的定义，在 Haskell 语言中，这个函数名叫 bind，但是定义是一样的，这个函数应该： 作用在一个「封装过的值」M 上。 它的参数应该是另一个闭包 F，这个闭包 F：接受一个解包后的值，返回一个「封装过的值」。 具体在执行的时候，flatMap 会对 M 进行解包得到 C，然后调用闭包 F，传入解包后的 C，获得新的「封装过的值」。 我们来看看 Optional 的 flatMap 实现，验证一下刚刚说的逻辑。源码地址是：https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift。 public func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U?) rethrows -&gt; U? &#123; switch self &#123; case .Some(let y): return try f(y) case .None: return .None &#125;&#125; Optional 的 flatMap： 作用在一个「封装过的值」：self 身上。 接受一个闭包参数 f，这个 f 的定义是：接受解包后的值，返回一个「封装过的值」: U? 。 在执行时，flatMap 先对 self 进行解包，代码是 case .Some(let y)。 如果解包成功，则调用函数 f，得到一个新的「封装过的值」，代码是 try f(y)。 如果解包出来是 .None，则返回 .None。 设计背后的追问flatMap 接受的这个闭包参数，直观看起来很奇怪。接受的是解包的值，返回的又是封装过的值，一点都没有对称的美！ 为什么要这么设计？不这么设计就不能完成链式调用吗？我想了半天，答案就是一个字：懒！ 为什么这么说呢？因为「封装过的值」大多数时候不能直接计算，所以要计算的时候都要先解包，如果我们为了追求「对称的美」，使得函数接受的参数和返回的值都是「封装过的值」，当然是可以的。不过如果这么设计的话，你就会写大量雷同的解包代码。程序设计的时候追求「Don’t Repeat Yourself」原则，这么做当然是不被接受的。 Functor刚刚我们说，在设计上为了复用代码，我们必须保证闭包的参数是解包后的值。 那么，同样的道理，每次返回之前都封包一下，不一样很重复么？我们返回的值能不能是解包后的原始值，然后自动封装它？ 答案是可以的，但是这就不是 Monad 了，这成了 Functor 了。我们上一讲提到过，Functor 中实现的 map 方法，就是一个接受解包后的值，返回结果仍然是解包后的值。为了保证链式调用，map 会自动把结果再封包一次。 我们再来回顾一下 map 的源码吧： public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) rethrows -&gt; U? &#123; switch self &#123; case .Some(let y): return .Some(try f(y)) case .None: return .None &#125;&#125; 在该源码中，函数 f 在被执行完后，结果会被封包成 Optional 类型，相关代码是：.Some(try f(y))。 所以，Optional 的 map 和 flatMap 差别真的非常非常小，就看你的闭包想不想自己返回封装后的值了。 在具体业务中，我们也有一些实际的需求，需要我们自己控制返回封装后的值。比如 Optional 在操作的时候，如果要返回 .None，则需要使用 flatMap，错误的使用了 map 函数的话，就会带来多重嵌套 nil 的问题。比如下面这个代码，变量 b 因为是一个两层嵌套的 nil，所以 if let 失效了。 let tq: Int? = 1let b = tq.map &#123; (a: Int) -&gt; Int? in if a % 2 == 0 &#123; return a &#125; else &#123; return nil &#125;&#125;if let _ = b &#123; print(&quot;not nil&quot;)&#125; 归根结底，你在编程时使用 Monad 还是 Functor，取决于你的具体业务需求： 如果你在处理「封装过的值」时，不会（或不需要）返回异常数据，则可以使用 Functor，让数据的封装过程交给 map 函数来处理。 如果你在处理「封装过的值」时，需要在闭包函数里返回类似 nil（或 ErrorType）一类的数据，则可以使用 Monad，自己返回新的「封装过的值」。 ApplicativeSwift 语言中并没有原生的 Applicative，但是 Applicative 和 Functor、Monad 算是三个形影不离的三兄弟，另外它们三者的差异都很小，所以干脆一并介绍了。 刚刚我们讨论 Functor 与 Monad 时，都是说把值放在一个容器里面。但是我们别忘了，Swift 是函数式语言，函数是一等公民，所以，函数本身也是一种值，它也可以放到一个容器里面，而我们要讨论的 Applicative，就是一种关于「封装过的函数」的规则。 Applicative 的定义是：使用「封装过的函数」处理「封装过的值」。这个「封装过的函数」解包之后的参数类型和 Functor 的要求是一样的。 按照这个定义，我们可以自己改造数组和 Optional，使它们成为 Applicative，以下代码就是一个示例，来自 这里。 extension Optional &#123; func apply&lt;U&gt;(f: (T -&gt; U)?) -&gt; U? &#123; switch f &#123; case .Some(let someF): return self.map(someF) case .None: return .None &#125; &#125;&#125;extension Array &#123; func apply&lt;U&gt;(fs: [Element -&gt; U]) -&gt; [U] &#123; var result = [U]() for f in fs &#123; for element in self.map(f) &#123; result.append(element) &#125; &#125; return result &#125;&#125; 我们为数组和 Optional 增加了一个 apply 方法，而这个方法符合 Applicative 的定义。如果和 map 方法对比，它们的唯一差别就是闭包函数是封装过后的了： 对于 Optional 来说，apply 的闭包函数也变成 Optinoal 的了。 对于数组来说，apply 的闭包函数也是一个数组（我们之前介绍过，数组也是对数据的一种封装）。 Monad 的应用理论都离不开应用，否则就是「然并卵」了，讲完了概念，我们来看看除了 Swift 语言中的数组和 Optional，业界还有哪些对于 Monad 的应用。 PromisePromiseKit 是一个同时支持 Objective-C 和 Swift 的异步库。它用 Promise 来表示一个未来将要执行的操作，使用它可以简化我们的异步操作。因为篇幅有限，本文并不打算展开详细介绍 Promise，我们就看一个实际的使用示例吧。 假设我们有一个业务场景，需要用户先登录，然后登录成功后发API获取数据，获取数据后更新 UITableView 的内容，整个过程如果有错误，显示相应的错误信息。 传统情况下，我们需要把每个操作都封装起来，然后我们可以选择： 方法一：用多层嵌套的 dispatch_async 把逻辑写到一起，但是这样嵌套代码，可读性和可维护性很差。 方法二：每一步有一个 delegate 回调函数，把业务逻辑分散到各个回调函数中。但是这样不但逻辑分散了，而且关键的函数调用的依赖关系被我们隐藏起来了。 另外，以上两种方法处理错误逻辑都可能会有多处，虽然我们可以把报错也封装成一个函数，但是在多个地方调用也不太舒服。使用 PromiseKit 之后，刚刚提到的业务场景可以用如下的示意代码来完成： login().then &#123; return API.fetchKittens()&#125;.then &#123; fetchedKittens in self.kittens = fetchedKittens self.tableView.reloadData()&#125;.catch &#123; error in UIAlertView(…).show()&#125; 另外，如果你的逻辑涉及并发，PromiseKit 也可以很好地处理，例如，你希望发两个网络请求，当两个网络请求都结束时，做相应的处理。那就可以让 PromiseKit 的 when 方法与 then 结合工作： let search1 = MKLocalSearch(request: rq1).promise()let search2 = MKLocalSearch(request: rq2).promise()when(search1, search2).then &#123; response1, response2 in //…&#125;.catch &#123; error in // called if either search fails&#125; 在 PromiseKit 的设计中，then 方法接受的闭包的类型和 flatMap 是一样的，所以它本质上就是 flatMap。Promise 其实就是一种 Monad。 ReactiveCocoa比起 PromiseKit，ReactiveCocoa 的名气要大得多。最新的 ReactiveCocoa 4.0 同时支持 Objective-C 和 Swift，我们在源码中发现了 RAC 的 SignalType 就是一个 Monad： extension SignalType &#123; public func flatMap&lt;U&gt;(strategy: FlattenStrategy, transform: Value -&gt; SignalProducer&lt;U, Error&gt;) -&gt; Signal&lt;U, Error&gt; &#123; return map(transform).flatten(strategy) &#125; public func flatMap&lt;U&gt;(strategy: FlattenStrategy, transform: Value -&gt; Signal&lt;U, Error&gt;) -&gt; Signal&lt;U, Error&gt; &#123; return map(transform).flatten(strategy) &#125;&#125; 总结我们再次总结一下 Monad、Functor、Applicative： Monad：对一种封装过的值，使用 flatMap 函数。 Functor：对一种封装过的值，使用 map 函数。 Applicative：对一种封装过的值，使用 apply 函数。 我们再对比一下flatMap、map 和 apply： flatMap：对自己解包，然后应用到一个闭包上，这个闭包：接受一个「未封装的值」，返回一个「封装后的值」。 map：对自己解包，然后应用到一个闭包上，这个闭包：接受一个「未封装的值」，返回一个「未封装的值」。 apply：对自己解包，然后对闭包解包，解包后的闭包：接受一个「未封装的值」，返回一个「未封装的值」。 参考链接 Swift Functors, Applicatives, and Monads in Pictures Functor、Applicative 和 Monad Promises are the monad of asynchronous programming","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"如何实现自己没实现过的需求之文本动画","slug":"text-animation-guide","date":"2016-03-20T13:34:23.000Z","updated":"2024-01-06T14:52:37.926Z","comments":true,"path":"2016/03/20/text-animation-guide/","permalink":"https://blog.devtang.com/2016/03/20/text-animation-guide/","excerpt":"","text":"吕伟（@我在罪恶坑的日子）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。感谢投稿，原文链接。 大家好，我是非知名程序员，想跟大家说一段传统相声节目，额，对不起，说错了。想跟大家分享一点关于文本和动画的东西。这不是一篇纯血统，高、精、尖的技术文章，但依然希望有人能像喜欢混血美女一样喜欢。 前言记得以前看到过一个很赞的文字效果的动画，类似于这样： 当时被惊艳到了，最近偶然间又再次见到，依然还是那么喜欢。假设我们现在需要实现这样的需求。一般碰到需求我们都会去 GitHub 上看看，俗称找轮子（GitHub 基本上只有你想不到的，就没有它没有的）。大多数情况下，没有问题。或者说有点小问题：轮子太多，无从下嘴。 选择 选轮子就像选姑娘，你不知道后面等着你的是什么 —–罪恶坑小程如是说 程序员江湖，每位大侠的武功和套路不尽一样，少林，武当，昆仑各门各派，百花争艳。实现轮子的思路自然也不一样。有的轮子高深晦涩难懂，功能强大，有的清晰明了，功能简单。不过有一点相同是，选错了就会被坑，只是坑大坑小问题。选轮子自然需要无比谨慎，既要匹配需求同时也要能在掉坑里的时候填上（废话，出 bug 了，你不填，谁填），要能 hold 住。然而填坑哪能那么简单呢，首先轮子实现思路，代码的结构，运行时序你要搞清楚吧，提供了哪些功能，没提供哪些功能，你要了解吧。基本上一个复杂点的轮子，研究下来就要好些时间了。这还不包括你开会，沟通，解 bug，喝茶，倒水，上厕所，抽烟，骂娘，吐槽产品需求的时间。所以，妹子们，不要问我们今天加不加班，要问今天能不能在你睡前下班。（项目快上线了，小程不加班谁加班。嗯哼。） 创造 如果能用代码扮演上帝话，苍老师的量产不是问题，就看产品经理定的需求是拟物还是扁平。—-罪恶坑小程如是说 既然选轮子的时间成本也不低，那有时候我们可以自己造一个轮子。其实写一个的好处也多，有成就感，写好了可以吹牛逼，写坏了填坑速度快。但问题是，以前没写过怎么办？没把握怎么办？比如我们现在需要实现上面的文字效果，但是又不知道怎么写，怎么办？ 没关系，上帝创造世间也分了七步走，跟着这位带头大哥后面学，总不会错的。 开始 罗马不是一天建成的，毛片不是一次性拍完的 —-罪恶坑小程如是说 咦，好像扯得有点多了。对不起，现在开始正式拍（苍老师准备下，小程也准备下，Action）： 1. ** 分解任务 **通过简单观察我们可以马上知道，上面那个动画效果是通过对每个字符做动画完成的。而在 iOS 里，文本显示控件最常见和常用的是 UILabel。而 iOS 的 Explicit Animation 有 Properties Animation 和 keyframe Animation 两种。 但是 UILabel 控件没有提供对其 Text 中每个字符的控制的功能，我们需要改造下。既然要对每个字符做动画，那少不了需要frame，bounds，position，transform，这些属性。这样看来我们需要两个武器：一个做排版功能的 framework，不用说，肯定是 TextKit。而另一个是能显示单个字符也拥有frame，bounds，position，transform等属性的类，很自然，我们想到CATextLayer。 2. ** 先解决文本布局 **TextKit 里主要是三个类 NSTextStorage，NSLayoutManager，NSContainer。它们一起帮组我们解决文字布局，排版的工作。 NSTextStorage：NSMutableAttributedString的子类，持有文字内容，当字符发生改变时，通知NSLayoutManager对象 NSLayoutManager: 我们的男主角，从NSTextStorage里获取文字内容后，转换成对应的 glyph，根据NSTextContainer的 visible Region 显示 glyph。 NSContainer: 确定一个 region 来放置 text。这个 region 被NSLayoutManager用来决定哪里可以 break lines 不过可惜 UILabel 没有这三个类作为自己的属性对象，我们需要自己解决： class TextAnimationLabel: UILabel,NSLayoutManagerDelegate &#123; let textStorage:NSTextStorage = NSTextStorage(string: &quot;&quot;) let textLayoutManager:NSLayoutManager = NSLayoutManager() let textContainer:NSTextContainer = NSTextContainer()&#125; 除此以外我们还需要两个 Array 用来保存文本变换前的旧字符和变换后的新字符: var oldCharacterTextLayers:[CATextLayer] = [] var newCharacterTextLayers:[CATextLayer] = [] 因为我们需要用我们自己的 textStorage 对象，所以我们需要覆盖 text 和 attributedText 等属性。 override var text:String!&#123; get &#123; return super.text &#125; set &#123; super.text = text let attributedText = NSMutableAttributedString(string: newValue) let textRange = NSMakeRange(0,newValue.characters.count) attributedText.setAttributes([NSForegroundColorAttributeName:self.textColor], range: textRange) attributedText.setAttributes([NSFontAttributeName:self.font], range: textRange) let paragraphyStyle = NSMutableParagraphStyle() paragraphyStyle.alignment = self.textAlignment attributedText.addAttributes([NSParagraphStyleAttributeName:paragraphyStyle], range: textRange) self.attributedText = attributedText &#125; &#125; override var attributedText:NSAttributedString!&#123; get &#123; return self.textStorage as NSAttributedString &#125; set&#123; cleanOutOldCharacterTextLayers() oldCharacterTextLayers = Array(newCharacterTextLayers) textStorage.setAttributedString(newValue) self.startAnimation &#123; () -&gt; () in &#125; self.endAnimation(nil) &#125;&#125; 当 TextStorage 的文本内容改变时，会触发一个通知 send textLayoutManager 以便重新布局排版。显然我们可以在排版布局完成后来为每个字符创建设置一个 CATextLayer，并设置相应的 frame 以便正确的显示内容。我们可以有个函数来完成计算。并且 layout finish 完成时调用。 //Mark:NSLayoutMangerDelegatefunc layoutManager(layoutManager: NSLayoutManager, didCompleteLayoutForTextContainer textContainer: NSTextContainer?, atEnd layoutFinishedFlag: Bool) &#123; calculateTextLayers() print(&quot;\\(textStorage.string)&quot;)&#125; //MARK:CalculateTextLayerfunc calculateTextLayers()&#123;&#125; 接下来我们的主要想法，是找到 text 里每个 character 以及对应的 glyph rect. 然后用 character 和 glyph rect 创建 CATextLayer 首先我们要有一个空数组用来存放新的 CATextLayer。并且获取 textStorage 的 attributedText。 func calculateTextLayers()&#123; newCharacterTextLayers.removeAll(keepCapacity:false) let attributedText = textStorage.string&#125; 接下来我们要通过 LayoutManger 找到 TextContainer 的 used Rect，这样方便我们可以让文本垂直居中，就像普通的 Label 那样。 func calculateTextLayers()&#123; newCharacterTextLayers.removeAll(keepCapacity:false) let attributedText = textStorage.string let wordRange = NSMakeRange(0, attributedText.characters.count) let attributedString = self.internalAttributedText(); let layoutRect = textLayoutManager.usedRectForTextContainer(textContainer) var index = wordRange.location let totalLength = NSMaxRange(wordRange) while index &lt; totalLength &#123; ... &#125;&#125; 现在我们开始迭代处理文本里的每个字符，创建一个 glyphRange 并且用这个 glyphRange 找到对应的 character，然后我们将 glyph index 丢给 LayoutManager 得到 textContainer，再用 container 和 glyphRange 取得 glyphRect(这里需要注意下 kerning 的问题)。 let glyphRange = NSMakeRange(index, 1)let characterRange = textLayoutManager.characterRangeForGlyphRange(glyphRange, actualGlyphRange: nil)let textContainer = textLayoutManager.textContainerForGlyphAtIndex(index, effectiveRange: nil)var glyphRect = textLayoutManager.boundingRectForGlyphRange(glyphRange, inTextContainer: textContainer!) 最终我们还需要注意的就是 glyph 的 kerning，如果 kerningRange.location == index，我们需要将前一个 textLayer 取出来调整其 Rect 的宽度至新的 glyphRect 的最右边，保证 glyph 不会被裁切掉（可以对比下面两张图片） let kerningRange = textLayoutManager.rangeOfNominallySpacedGlyphsContainingIndex(index)if kerningRange.location == index &amp;&amp; kerningRange.length &gt; 1 &#123; if newCharacterTextLayers.count &gt; 0 &#123; // 如果前一个 textlayer 的 frame.size.width 不变大的话， // 当前的 textLayer 会遮挡住字体的一部分，比如 “Yes” 的 Y 右上角会被切掉一部分 let previousLayer = newCharacterTextLayers[newCharacterTextLayers.endIndex - 1] var frame = previousLayer.frame frame.size.width += CGRectGetMaxX(glyphRect) - CGRectGetMaxX(frame) previousLayer.frame = frame &#125;&#125; 这里关于 kerning 和 glyph 要多说一点。先来说下 glyph，简单来说 glyph 是表示一个 character 的具体样式 , 但他们却不是一一对应的关系，比如一个字母 “A” 可以有不同的写法来表示例如： 除此以外，还有这种情况： 上面是的 “ff” 虽然是两个 character，但是 glyph 却是一个。不过不用担心，强大 LayoutManager 提供了两个方法帮助我们通过一个找到对应另外那个。 func characterIndexForGlyphAtIndex(_ glyphIndex: Int) -&gt; Intfunc glyphIndexForCharacterAtIndex(_ charIndex: Int) -&gt; Int 现在我们说下 kerning。通常，在水平排布的文本中，glyph 都是一个挨着一个放置的，但是在某些时候为了让文本的可读性更好，看上去更加优雅美观，一个字形和另外一个字形之间可能会稍微的错位下，比如下面这种情况： 这也是上面为什么”Y“会出现显示不全的原因了。 接下来就比较简单了，创建 Textlayer, 设置垂直居中，添加到数组当中，index += characterRange.length，开始下次循环 glyphRect.origin.y += (self.bounds.size.height/2)-(layoutRect.size.height/2)let textLayer = CATextLayer(frame: glyphRect, string: attributedString.attributedSubstringFromRange(characterRange));layer.addSublayer(textLayer);newCharacterTextLayers.append(textLayer);index += characterRange.length 3. ** 动画实现 **上面我们解决了字符排版的问题，接下来动画的实现就相对的容易了，仔细观察那个动画，很容易得出主要是对 opacity 和 transform 两个属性做属性动画，opacity 让每个字体逐渐显示和逐渐消失，而 transform则做了两种变形，一种是往下移动，另外一种是旋转。用 CABasicAnimation 可以解决单个属性动画，而 CAAnimationGroup 则帮我们解决多个动画叠加的复合效果。 func groupAnimationWithLayerChanges(old olderLayer:CALayer, new newLayer:CALayer) -&gt; CAAnimationGroup? &#123; var animationGroup:CAAnimationGroup? var animations:[CABasicAnimation] = [CABasicAnimation]() if !CATransform3DEqualToTransform(olderLayer.transform, newLayer.transform) &#123; let basicAnimation = CABasicAnimation(keyPath: &quot;transform&quot;) basicAnimation.fromValue = NSValue(CATransform3D: olderLayer.transform) basicAnimation.toValue = NSValue(CATransform3D: newLayer.transform) animations.append(basicAnimation) &#125; if olderLayer.opacity != newLayer.opacity &#123; let basicAnimation = CABasicAnimation(keyPath: &quot;opacity&quot;) basicAnimation.fromValue = olderLayer.opacity basicAnimation.toValue = newLayer.opacity animations.append(basicAnimation) &#125; if animations.count &gt; 0 &#123; animationGroup = CAAnimationGroup() animationGroup!.animations = animations &#125;&#125; 这里需要注意一个问题，就是隐式动画的问题，Core Animation 基于一个假说，就是屏幕上的任何东西都可以 (或者可能) 做动画，我们平时在写代码时应该有这种印象就是你只是 layer 设置了一个值，没有添加动画，但是你会看到一个平滑过渡的显示效果而不是非常突兀的变化。这就是隐式动画。当我们改变一个属性时，Core Animation 帮我们做了一个动画，动画时间取决于当前 NSTransaction 的设置，而动画类型取决于图层行为。 这里有个有趣的东西，多说一点，就是当我们对 UIView 关联的图层做动画而不是一个单独的图层做动画，比如 func changeColor()&#123; CATransaction.begin(); CATransaction.setAnimationDuration(1.0) CGFloat red = CGFloat(arc4random() / (CGFloat)INT_MAX); CGFloat green = CGFloat(arc4random() / (CGFloat)INT_MAX); CGFloat blue = CGFloat(arc4random() / (CGFloat)INT_MAX); self.layerView.layer.backgroundColor = UIColor.(colorWithRed:red green:green blue:blue alpha:1.0).CGColor; CATransaction.commit();&#125; 图层的颜色瞬间切换到新的值，而不是之前的平滑过渡，隐式动画似乎给关闭了。我们知道 UIView 和 CALayer 最重要的关系就是 UIView 是 CALayer 的 delegate，当我们改变 CALayer 的属性时，它会调用 func actionForKey(_ event: String) -&gt; CAAction? 这个方法，接下来发生的事情在官方文档里都有写，实际上是如下几步: If the layer has a delegate that implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following: Return the action object for the given key. Return the NSNull object if it does not handle the action. The layer looks in the layer’s actions dictionary for a matching key&#x2F;action pair. The layer looks in the style dictionary for an actions dictionary for a matching key&#x2F;action pair. The layer calls the defaultActionForKey: class method to look for any class-defined actions. UIView 作为它关联图层的 Delegate，实现了 actionForLayer(_ layer: CALayer, forKey event: String) -&gt; CAAction? ，当不在一个动画块中，UIView 返回 nil，而在动画块中则返回一个非空值 print(&quot;OutSide:\\(self.view.actionForLayer(self.view.layer, forKey: &quot;backgroundColor&quot;))&quot;)UIView.beginAnimations(nil, context: nil)print(&quot;InSide:\\(self.view.actionForLayer(self.view.layer,forKey: &quot;backgroundColor&quot;))&quot;)UIView.commitAnimations() 显示结果如下 OutSide:Optional(&lt;null&gt;)InSide:Optional(&lt;CABasicAnimation: 0x7f7f93ff81b0&gt;) 当然返回 nil 并不是禁用隐式动画的唯一方法，下面这样也行 CATransaction.setDisableActions(true) 那为什么说这个问题呢？因为我们在对每个字符做动画的时候需要先将隐式动画关闭，否者将会做两次动画，比如下面这样: 那么，我们先生成一份 oldlayer, 然后改变相应的属性，生产新的 newLayer。然后创建相应的动画组，添加显式动画。 let olderLayer = animationObjc.animatableLayerCopy(layer)CATransaction.begin()CATransaction.setDisableActions(true)newLayer = effectAnimationClosure(layer: layer)CATransaction.commit()var animationGroup:CAAnimationGroup?animationGroup = groupAnimationWithLayerChanges(old: olderLayer, new: newLayer!)layer.addAnimation(textAniamtionGroup, forKey: textAnimationGroupKey) 收工好了，当上面所有的工作完成之后，就是我们最开始看到的那个效果，代码已经上传 GitHub，你可以从 这里 下载。其实这个 demo 里实现的 label 还有很大优化的空间。比如支持多种类型的动画效果，动画效果可配置等等。这是我接下来打算做的事情。本人才疏学浅，错漏难免，欢迎大家批评指正。如果你发现 bug，可以提个 pull request。如果你有更好地思路也请告诉我，让我进步，我请你喝咖啡 ：）。 这是我的微信号（未完结，请往下看）： 最后不知不觉工作许多年了，这几年萝莉变成了姑娘，姑娘变成了孩子妈。大家从 QQ 空间杀到朋友圈。从晒女朋友，到晒结婚照继而到晒娃。这几年鸣人同志都不负众望当上了火影 (丫也不请吃饭)。大家都在发生变化。 学会开始写点东西分享可能是我想要的一个变化。 本来作为非知名程序员，平时都是自己上 GitHub 玩，自认为比起一干牛人既没本领可以提振民心士气，又没有独门绝技可以分享。直到我收到了一封来自组织的信。 最近我加入了一个公会，里面云集了各类高手，轻功，内力，暗器，大家各有所长，时不时分享下自己的看家本领。还是那句老话，不看不知道，一看吓一跳。世界还是外面的大，姑娘还是城里的靓。在群里，大家都很积极活跃，学习氛围异常的好。其实自打做起程序员起，这么多年来，虽然生性慵懒，但是自学却未敢放下，毕竟逆水行舟，不进则退。不可否认的是一个人的学习是很苦闷无聊的，但一群人陪着你一起苦闷无聊也是很欣慰的。 最后我想引用那封邮件里面的话来表达下我对公会的看法: 这个社群的意义证明了，在互联网时代，依然有这么多人愿意为知识的积累和个人的成长付费，知识本身的价值得到重新的认知，人们以一种去中心化的方式连接起来，P2P 的创作和分享，可能会让知识和技能的积累、传播达到了一种新的高度、深度和广度 我想一贯懒散的我为何突然想写这么个 blog 可能也是因为这个，毕竟知识的受益者永远是那些积极参与学习并持续思考的人。 额，最后想说的是，是的，那段引用的文字你没看错，这是个需要付费的群，免费时代的付费群，它叫 攻城狮之路。 知识是很昂贵的，我一直这么认为。另外，其实这是篇硬广。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"},{"name":"投稿","slug":"投稿","permalink":"https://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"}]},{"title":"iOS 视图控制器转场详解","slug":"iOS-transition-guide","date":"2016-03-13T08:15:47.000Z","updated":"2024-01-06T14:52:37.926Z","comments":true,"path":"2016/03/13/iOS-transition-guide/","permalink":"https://blog.devtang.com/2016/03/13/iOS-transition-guide/","excerpt":"","text":"作者：seedante，神秘人士，他的 GitHub。感谢投稿，原文链接。 前言屏幕左边缘右滑返回，TabBar 滑动切换，你是否喜欢并十分依赖这两个操作，甚至觉得 App 不支持这类操作的话简直反人类？这两个操作在大屏时代极大提升了操作效率，其背后的技术便是今天的主题：视图控制器转换(View Controller Transition)。 视图控制器中的视图显示在屏幕上有两种方式：最主要的方式是内嵌在容器控制器中，比如 UINavigationController，UITabBarController, UISplitController；由另外一个视图控制器显示它，这种方式通常被称为模态(Modal)显示。View Controller Transition 是什么？在 NavigationController 里 push 或 pop 一个 View Controller，在 TabBarController 中切换到其他 View Controller，以 Modal 方式显示另外一个 View Controller，这些都是 View Controller Transition。在 storyboard 里，每个 View Controller 是一个 Scene，View Controller Transition 便是从一个 Scene 转换到另外一个 Scene；为方便，以下对 View Controller Transition 的中文称呼采用 Objccn.io 中的翻译「转场」。 在 iOS 7 之前，我们只能使用系统提供的转场效果，大部分时候够用，但仅仅是够用而已，总归会有各种不如意的小地方，但我们却无力改变；iOS 7 开放了相关 API 允许我们对转场效果进行全面定制，这太棒了，自定义转场动画以及对交互手段的支持带来了无限可能。 本文并非华丽的转场动画教程，相反，文中的转场动画效果都十分简单，但本文的内容并不简单，我将带你探索转场背后的机制，缺陷以及实现过程中的技巧与陷阱。阅读本文需要读者至少要对 ViewController 和 View 的结构以及协议有基本的了解，最好自己亲手实现过一两种转场动画。如果你对此感觉没有信心，推荐观看官方文档：View Controller Programming Guide for iOS，学习此文档将会让你更容易理解本文的内容。对你想学习的小节，我希望你自己亲手写下这些代码，一步步地看着效果是如何实现的，至少对我而言，看各种相关资料时只有字面意义上的理解，正是一步步的试验才能让我理解每一个步骤。本文涉及的内容较多，为了避免篇幅过长，我只给出关键代码而不是从新建工程开始教你每一个步骤。本文基于 Xcode 7 以及 Swift 2，Demo 合集地址：iOS-ViewController-Transition-Demo。 Transition 解释 前言里从行为上解释了转场，那在转场时发生了什么？下图是从 WWDC 2013 Session 218 整理的，解释了转场时视图控制器和其对应的视图在结构上的变化： 转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现，基于此进行动画，动画的方式非常多，所以限制最终呈现的效果就只有你的想象力了。图中的 Parent VC 可替换为 UIViewController, UITabbarController 或 UINavigationController 中的任何一种。 目前为止，官方支持以下几种方式的自定义转场： 在 UINavigationController 中 push 和 pop; 在 UITabBarController 中切换 Tab; Modal 转场：presentation 和 dismissal，俗称视图控制器的模态显示和消失，仅限于modalPresentationStyle属性为 UIModalPresentationFullScreen 或 UIModalPresentationCustom 这两种模式; UICollectionViewController 的布局转场：UICollectionViewController 与 UINavigationController 结合的转场方式，实现很简单。 官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。 iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画： 1.转场代理(Transition Delegate)： 自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。有如下三种转场代理，对应上面三种类型的转场： &lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。 &lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。 &lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。 这里除了&lt;UIViewControllerTransitioningDelegate&gt;是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。 转场发生时，UIKit 将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。 2.动画控制器(Animation Controller)： 最重要的部分，负责添加视图以及执行动画；遵守&lt;UIViewControllerAnimatedTransitioning&gt;协议；由我们实现。 3.交互控制器(Interaction Controller)： 通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守&lt;UIViewControllerInteractiveTransitioning&gt;协议；系统已经打包好现成的类供我们使用。 4.转场环境(Transition Context): 提供转场中需要的数据；遵守&lt;UIViewControllerContextTransitioning&gt;协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。 5.转场协调器(Transition Coordinator)： 可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守&lt;UIViewControllerTransitionCoordinator&gt;协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。 总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。 阶段一：非交互转场 这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分，代理部分非常简单，我们先搞定动画控制器吧。 动画控制器协议 动画控制器负责添加视图以及执行动画，遵守UIViewControllerAnimatedTransitioning协议，该协议要求实现以下方法： //执行动画的地方，最核心的方法。 (Required)func animateTransition(_ transitionContext: UIViewControllerContextTransitioning) //返回动画时间，&quot;return 0.5&quot; 已足够，非常简单，出于篇幅考虑不贴出这个方法的代码实现。 (Required)func transitionDuration(_ transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval //如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。 (Optional)func animationEnded(_ transitionCompleted: Bool) 最重要的是第一个方法，该方法接受一个遵守&lt;UIViewControllerContextTransitioning&gt;协议的转场环境对象，上一节的 API 解释里提到这个协议，它提供了转场所需要的重要数据：参与转场的视图控制器和转场过程的状态信息。 UIKit 在转场开始前生成遵守转场环境协议&lt;UIViewControllerContextTransitioning&gt;的对象 transitionContext，它有以下几个方法来提供动画控制器需要的信息： //返回容器视图，转场动画发生的地方。 func containerView() -&gt; UIView? //获取参与转场的视图控制器，有 UITransitionContextFromViewControllerKey 和 UITransitionContextToViewControllerKey 两个 Key。 func viewControllerForKey(_ key: String) -&gt; UIViewController? //iOS 8新增 API 用于方便获取参与参与转场的视图，有 UITransitionContextFromViewKey 和 UITransitionContextToViewKey 两个 Key。 func viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0) 通过viewForKey:获取的视图是viewControllerForKey:返回的控制器的根视图，或者 nil。viewForKey:方法返回 nil 只有一种情况： UIModalPresentationCustom 模式下的 Modal 转场 ，通过此方法获取 presentingView 时得到的将是 nil，在后面的 Modal 转场里会详细解释。 前面提到转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为 fromView，对应的视图控制器为 fromVC，即将出现的视图为 toView，对应的视图控制器称之为 toVC。几种转场方式的转场操作都是可逆的，一种操作里的 fromView 和 toView 在逆向操作里的角色互换成对方，fromVC 和 toVC 也是如此。在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力。这也是动画控制器在封装后可以被第三方使用的重要原因。 在 iOS 8 中可通过以下方法来获取参与转场的三个重要视图，在 iOS 7 中则需要通过对应的视图控制器来获取，为避免 API 差异导致代码过长，示例代码中直接使用下面的视图变量： let containerView = transitionContext.containerView() let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey) let toView = transitionContext.viewForKey(UITransitionContextToViewKey) 动画控制器实现 转场 API 是协议的好处是不限制具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同，但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。 三种转场方式都有一对可逆的转场操作，你可以为了每一种操作实现单独的动画控制器，也可以实现通用的动画控制器。处于篇幅的考虑，本文示范一个比较简单的 Slide 动画控制器：Slide left and right，而且该动画控制器在三种转场方式中是通用的，不必修改就可以直接在工程中使用。效果示意图： 在交互式转场章节里我们将在这个基础上实现文章开头提到的两种效果：NavigationController 右滑返回 和 TabBarController 滑动切换。尽管对动画控制器来说，转场方式并不重要，可以对 fromView 和 toView 进行任何动画，但上面的动画和 Modal 转场风格上有点不配，主要动画的方向不对，不过我在这个 Slide 动画控制器里为 Modal 转场适配了和系统的风格类似的竖直移动动画效果；另外 Modal 转场并没有比较合乎操作直觉的交互手段，而且和前面两种容器控制器的转场在机制上有些不同，所以我将为 Modal 转场示范另外一个动画。 在转场中操作是可逆的，返回操作时的动画应该也是逆向的。对此，Slide 动画控制器需要针对转场的操作类型对动画的方向进行调整。Swift 中 enum 的关联值可以视作有限数据类型的集合体，在这种场景下极其合适。设定转场类型： enum SDETransitionType&#123; //UINavigationControllerOperation 是枚举类型，有 None, Push, Pop 三种值。 case NavigationTransition(UINavigationControllerOperation) case TabTransition(TabOperationDirection) case ModalTransition(ModalOperation) &#125; enum TabOperationDirection&#123; case Left, Right &#125; enum ModalOperation&#123; case Presentation, Dismissal &#125; 使用示例：在 TabBarController 中切换到左边的页面。 let transitionType = SDETransitionType.TabTransition(.Left) Slide 动画控制器的核心代码： class SlideAnimationController: NSObject, UIViewControllerAnimatedTransitioning &#123; init(type: SDETransitionType) &#123;...&#125; func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123; ... //1 containerView.addSubview(toView) //计算位移 transform，NavigationVC 和 TabBarVC 在水平方向进行动画，Modal 转场在竖直方向进行动画。 var toViewTransform = ... var fromViewTransform = ... toView.transform = toViewTransform //根据协议中的方法获取动画的时间。 let duration = self.transitionDuration(transitionContext) UIView.animateWithDuration(duration, animations: &#123; fromView.transform = fromViewTransform toView.transform = CGAffineTransformIdentity &#125;, completion: &#123; _ in //考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。 fromView.transform = CGAffineTransformIdentity toView.transform = CGAffineTransformIdentity //2 let isCancelled = transitionContext.transitionWasCancelled() transitionContext.completeTransition(!isCancelled) &#125;) &#125; &#125; 注意上面的代码有2处标记，是动画控制器必须完成的： 将 toView 添加到容器视图中，使得 toView 在屏幕上显示( Modal 转场中此点稍有不同，下一节细述)； 正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过transitionWasCancelled()方法来获取转场的状态，使用completeTransition:来完成或取消转场。 实际上，这里示范的简单的转场动画和那些很复杂的转场动画在转场的部分要做的事情都是上面提到的这两点，它们的区别主要在于动画的部分。 转场结束后，fromView 会从视图结构中移除，UIKit 自动替我们做了这事，你也可以手动处理提前将 fromView 移除，这完全取决于你。UIView的类方法transitionFromView:toView:duration:options:completion:也能做同样的事，使用下面的代码替换上面的代码，甚至不需要获取 containerView 以及手动添加 toView 就能实现一个类似的转场动画： UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in let isCancelled = transitionContext.transitionWasCancelled() transitionContext.completeTransition(!isCancelled) &#125;) 特殊的 Modal 转场 Modal 转场的差异 Modal 转场中需要做的事情和两种容器 VC 的转场一样，但在细节上有些差异。 UINavigationController 和 UITabBarController 这两个容器 VC 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的子 VC 中的视图，转场是从子 VC 的视图转换到另外一个子 VC 的视图，其根视图并未参与转场；而 Modal 转场，以 presentation 为例，是从 presentingView 转换到 presentedView，根视图 presentingView 也就是 fromView 参与了转场。而且 NavigationController 和 TabBarController 转场中的 containerView 也并非这两者的根视图。 Modal 转场与两种容器 VC 的转场的另外一个不同是：Modal 转场结束后 presentingView 可能依然可见，UIModalPresentationPageSheet 模式就是这样。这种不同导致了 Modal 转场和容器 VC 的转场对 fromView 的处理差异：容器 VC 的转场结束后 fromView 会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而 Modal 转场中，presentation 结束后 presentingView(fromView) 并未主动被从视图结构中移除。准确来说，是 UIModalPresentationCustom 这种模式下的 Modal 转场结束时 fromView 并未从视图结构中移除；UIModalPresentationFullScreen 模式的 Modal 转场结束后 fromView 依然主动被从视图结构中移除了。这种差异导致在处理 dismissal 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。下面来看看 dismissal 转场时的场景。 ContainerView 在转场期间作为 fromView 和 toView 的父视图。三种转场过程中的 containerView 是 UIView 的私有子类，不过我们并不需要关心 containerView 具体是什么。在 dismissal 转场中： UIModalPresentationFullScreen 模式：presentation 后，presentingView 被主动移出视图结构，在 dismissal 中 presentingView 是 toView 的角色，其将会重新加入 containerView 中，实际上，我们不主动将其加入，UIKit 也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。 UIModalPresentationCustom 模式：转场时 containerView 并不担任 presentingView 的父视图，后者由 UIKit 另行管理。在 presentation 后，fromView(presentingView) 未被移出视图结构，在 dismissal 中，注意不要像其他转场中那样将 toView(presentingView) 加入 containerView 中，否则本来可见的 presentingView 将会被移除出自身所处的视图结构消失不见。如果你在使用 Custom 模式时没有注意到这点，就很容易掉进这个陷阱而很难察觉问题所在，这个问题曾困扰了我一天。 对于 Custom 模式，我们可以参照其他转场里的处理规则来打理：presentation 转场结束后主动将 fromView(presentingView) 移出它的视图结构，并用一个变量来维护 presentingView 的父视图，以便在 dismissal 转场中恢复；在 dismissal 转场中，presentingView 的角色由原来的 fromView 切换成了 toView，我们再将其重新恢复它原来的视图结构中。测试表明这样做是可行的。但是这样一来，在实现上，需要在转场代理中维护一个动画控制器并且这个动画控制器要维护 presentingView 的父视图，第三方的动画控制器必须为此改造。显然，这样的代价是无法接受的。 小结：经过上面的尝试，建议是，不要干涉官方对 Modal 转场的处理，我们去适应它。在 Custom 模式下，由于 presentingView 不受 containerView 管理，在 dismissal 转场中不要像其他的转场那样将 toView(presentingView) 加入 containerView，否则 presentingView 将消失不见，而应用则也很可能假死；而在 presentation 转场中，切记不要手动将 fromView(presentingView) 移出其父视图。 iOS 8 为&lt;UIViewControllerContextTransitioning&gt;协议添加了viewForKey:方法以方便获取 fromView 和 toView，但是在 Modal 转场里要注意，从上面可以知道，Custom 模式下，presentingView 并不受 containerView 管理，这时通过viewForKey:方法来获取 presentingView 得到的是 nil，必须通过viewControllerForKey:得到 presentingVC 后来获取。因此在 Modal 转场中，较稳妥的方法是从 fromVC 和 toVC 中获取 fromView 和 toView。 顺带一提，前面提到的UIView的类方法transitionFromView:toView:duration:options:completion:能在 Custom 模式下工作，却与 FullScreen 模式有点不兼容。 Modal 转场实践 UIKit 已经为 Modal 转场实现了多种效果，当 UIViewController 的modalPresentationStyle属性为.Custom 或.FullScreen时，我们就有机会定制转场效果，此时modalTransitionStyle指定的转场动画将会被忽略。 Modal 转场开放自定义功能后最令人感兴趣的是定制 presentedView 的尺寸，下面来我们来实现一个带暗色调背景的小窗口效果。Demo 地址：CustomModalTransition。 由于需要保持 presentingView 可见，这里的 Modal 转场应该采用 UIModalPresentationCustom 模式，此时 presentedVC 的modalPresentationStyle属性值应设置为.Custom。而且与容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC 提供。动画控制器的核心代码： class OverlayAnimationController: NSobject, UIViewControllerAnimatedTransitioning&#123; ... func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123; ... //不像容器 VC 转场里需要额外的变量来标记操作类型，UIViewController 自身就有方法跟踪 Modal 状态。 //处理 Presentation 转场： if toVC.isBeingPresented()&#123; //1 containerView.addSubview(toView) //在 presentedView 后面添加暗背景视图 dimmingView，注意两者在 containerView 中的位置。 let dimmingView = UIView() containerView.insertSubview(dimmingView, belowSubview: toView) //设置 presentedView 和 暗背景视图 dimmingView 的初始位置和尺寸。 let toViewWidth = containerView.frame.width * 2 / 3 let toViewHeight = containerView.frame.height * 2 / 3 toView.center = containerView.center toView.bounds = CGRect(x: 0, y: 0, width: 1, height: toViewHeight) dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5) dimmingView.center = containerView.center dimmingView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight) //实现出现时的尺寸变化的动画： UIView.animateWithDuration(duration, delay: 0, options: .CurveEaseInOut, animations: &#123; toView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight) dimmingView.bounds = containerView.bounds &#125;, completion: &#123;_ in //2 let isCancelled = transitionContext.transitionWasCancelled() transitionContext.completeTransition(!isCancelled) &#125;) &#125; //处理 Dismissal 转场，按照上一小节的结论，.Custom 模式下不要将 toView 添加到 containerView，省去了上面标记1处的操作。 if fromVC.isBeingDismissed()&#123; let fromViewHeight = fromView.frame.height UIView.animateWithDuration(duration, animations: &#123; fromView.bounds = CGRect(x: 0, y: 0, width: 1, height: fromViewHeight) &#125;, completion: &#123; _ in //2 let isCancelled = transitionContext.transitionWasCancelled() transitionContext.completeTransition(!isCancelled) &#125;) &#125; &#125; &#125; iOS 8的改进：UIPresentationController iOS 8 针对分辨率日益分裂的 iOS 设备带来了新的适应性布局方案，以往有些专为在 iPad 上设计的控制器也能在 iPhone 上使用了，一个大变化是在视图控制器的(模态)显示过程，包括转场过程，引入了UIPresentationController类，该类接管了 UIViewController 的显示过程，为其提供转场和视图管理支持。当 UIViewController 的 modalPresentationStyle属性为.Custom时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供UIPresentationController的子类对 Modal 转场进行进一步的定制。官方对该类参与转场的流程和使用方法有非常详细的说明：Creating Custom Presentations。 UIPresentationController类主要给 Modal 转场带来了以下几点变化： 定制 presentedView 的外观：设定 presentedView 的尺寸以及在 containerView 中添加自定义视图并为这些视图添加动画； 可以选择是否移除 presentingView； 可以在不需要动画控制器的情况下单独工作； iOS 8 中的适应性布局。 以上变化中第1点 iOS 7 中也能做到，3和4是 iOS 8 带来的新特性，只有第2点才真正解决了 iOS 7 中的痛点。在 iOS 7 中定制外观时，动画控制器需要负责管理额外添加的的视图，UIPresentationController类将该功能剥离了出来独立负责，其提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的animateTransition:的关系： func presentationTransitionWillBegin() func presentationTransitionDidEnd(_ completed: Bool) func dismissalTransitionWillBegin() func dismissalTransitionDidEnd(_ completed: Bool) 除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色： //指定初始化方法。 init(presentedViewController presentedViewController: UIViewController, presentingViewController presentingViewController: UIViewController) var presentingViewController: UIViewController &#123; get &#125; var presentedViewController: UIViewController &#123; get &#125; var containerView: UIView? &#123; get &#125; //提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。 func presentedView() -&gt; UIView? 没有 presentingView 是因为 Custom 模式下 presentingView 不受 containerView 管理，UIPresentationController类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过viewForKey:方便获取转场的视图，而该方法在 Modal 转场中获取的是presentedView()返回的视图。因此我们可以在子类中将 presentedView 包装在其他视图后重写该方法返回包装后的视图当做 presentedView 在动画控制器中使用。 接下来，我用UIPresentationController子类实现上一节「Modal 转场实践」里的效果，presentingView 和 presentedView 的动画由动画控制器负责，剩下的事情可以交给我们实现的子类来完成。 参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 UIViewController 的transitionCoordinator()方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 nil。 转场协调器遵守&lt;UIViewControllerTransitionCoordinator&gt;协议，它含有以下几个方法： //与动画控制器中的转场动画同步，执行其他动画 animateAlongsideTransition:completion: //与动画控制器中的转场动画同步，在指定的视图内执行动画 animateAlongsideTransitionInView:animation:completion: 由于转场协调器的这种特性，动画的同步问题解决了。 class OverlayPresentationController: UIPresentationController &#123; let dimmingView = UIView() //Presentation 转场开始前该方法被调用。 override func presentationTransitionWillBegin() &#123; self.containerView?.addSubview(dimmingView) let initialWidth = containerView!.frame.width*2/3, initialHeight = containerView!.frame.height*2/3 self.dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5) self.dimmingView.center = containerView!.center self.dimmingView.bounds = CGRect(x: 0, y: 0, width: initialWidth , height: initialHeight) //使用 transitionCoordinator 与转场动画并行执行 dimmingView 的动画。 presentedViewController.transitionCoordinator()?.animateAlongsideTransition(&#123; _ in self.dimmingView.bounds = self.containerView!.bounds &#125;, completion: nil) &#125; //Dismissal 转场开始前该方法被调用。添加了 dimmingView 消失的动画，在上一节中并没有添加这个动画， //实际上由于 presentedView 的形变动画，这个动画根本不会被注意到，此处只为示范。 override func dismissalTransitionWillBegin() &#123; presentedViewController.transitionCoordinator()?.animateAlongsideTransition(&#123; _ in self.dimmingView.alpha = 0.0 &#125;, completion: nil) &#125; &#125; OverlayPresentationController类接手了 dimmingView 的工作后，需要回到上一节OverlayAnimationController里把涉及 dimmingView 的部分删除，然后在 presentedVC 的转场代理属性transitioningDelegate中提供该类实例就可以实现和上一节同样的效果。 func presentationControllerForPresentedViewController(_ presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController) -&gt; UIPresentationController?&#123; return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting) &#125; 在 iOS 7 中，Custom 模式的 Modal 转场里，presentingView 不会被移除，如果我们要移除它并妥善恢复会破坏动画控制器的独立性使得第三方动画控制器无法直接使用；在 iOS 8 中，UIPresentationController解决了这点，给予了我们选择的权力，通过重写下面的方法来决定 presentingView 是否在 presentation 转场结束后被移除： func shouldRemovePresentersView() -&gt; Bool 返回 true 时，presentation 结束后 presentingView 被移除，在 dimissal 结束后 UIKit 会自动将 presentingView 恢复到原来的视图结构中。通过UIPresentationController的参与，Custom 模式完全实现了 FullScreen 模式下的全部特性。 你可能会疑惑，除了解决了 iOS 7中无法干涉 presentingView 这个痛点外，还有什么理由值得我们使用UIPresentationController类？除了能与动画控制器配合，UIPresentationController类也能脱离动画控制器独立工作，在转场代理里我们仅仅提供后者也能对 presentedView 的外观进行定制，缺点是无法控制 presentedView 的转场动画，因为这是动画控制器的职责，这种情况下，presentedView 的转场动画采用的是默认的动画效果，转场协调器实现的动画则是采用默认的动画时间。 iOS 8 带来了适应性布局，&lt;UIContentContainer&gt;协议用于响应视图尺寸变化和屏幕旋转事件，之前用于处理屏幕旋转的方法都被废弃了。UIViewController 和 UIPresentationController 类都遵守该协议，在 Modal 转场中如果提供了后者，则由后者负责前者的尺寸变化和屏幕旋转，最终的布局机会也在后者里。在OverlayPresentationController中重写以下方法来调整视图布局以及应对屏幕旋转： override func containerViewWillLayoutSubviews() &#123; self.dimmingView.center = self.containerView!.center self.dimmingView.bounds = self.containerView!.bounds let width = self.containerView!.frame.width * 2 / 3, height = self.containerView!.frame.height * 2 / 3 self.presentedView()?.center = self.containerView!.center self.presentedView()?.bounds = CGRect(x: 0, y: 0, width: width, height: height) &#125; 转场代理 完成动画控制器后，只需要在转场前设置好转场代理便能实现动画控制器中提供的效果。转场代理的实现很简单，但是在设置代理时有不少陷阱，需要注意。 UINavigationControllerDelegate 定制 UINavigationController 这种容器控制器的转场时，很适合实现一个子类，自身集转场代理，动画控制器于一身，也方便使用，不过这样做有时候又限制了它的使用范围，别人也实现了自己的子类时便不能方便使用你的效果，这里采取的是将转场代理封装成一个类。 class SDENavigationControllerDelegate: NSObject, UINavigationControllerDelegate &#123; //在&lt;UINavigationControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则使用系统默认的效果。 func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; //使用上一节实现的 Slide 动画控制器，需要提供操作类型信息。 let transitionType = SDETransitionType.NavigationTransition(operation) return SlideAnimationController(type: transitionType) &#125; &#125; 如果你在代码里为你的控制器里这样设置代理： //错误的做法，delegate 是弱引用，在离开这行代码所处的方法范围后，delegate 将重新变为 nil，然后什么都不会发生。 self.navigationController?.delegate = SDENavigationControllerDelegate() 可以使用强引用的变量来引用新实例，且不能使用本地变量，在控制器中新增一个变量来维持新实例就可以了。 self.navigationController?.delegate = strongReferenceDelegate 解决了弱引用的问题，这行代码应该放在哪里执行呢？很多人喜欢在viewDidLoad()做一些配置工作，但在这里设置无法保证是有效的，因为这时候控制器可能尚未进入 NavigationController 的控制器栈，self.navigationController返回的可能是 nil；如果是通过代码 push 其他控制器，在 push 前设置即可；prepareForSegue:sender:方法是转场前更改设置的最后一次机会，可以在这里设置；保险点，使用UINavigationController子类，自己作为代理，省去到处设置的麻烦。 不过，通过代码设置终究显得很繁琐且不安全，在 storyboard 里设置一劳永逸：在控件库里拖拽一个 NSObject 对象到相关的 UINavigationControler 上，在控制面板里将其类别设置为SDENavigationControllerDelegate，然后拖拽鼠标将其设置为代理。 最后一步，像往常一样触发转场： self.navigationController?.pushViewController(toVC, animated: true)//or self.navigationController?.popViewControllerAnimated(true) 在 storyboard 中通过设置 segue 时开启动画也将看到同样的 Slide 动画。Demo 地址：NavigationControllerTransition。 UITabBarControllerDelegate 同样作为容器控制器，UITabBarController 的转场代理和 UINavigationController 类似，通过类似的方法提供动画控制器，不过&lt;UINavigationControllerDelegate&gt;的代理方法里提供了操作类型，但&lt;UITabBarControllerDelegate&gt;的代理方法没有提供滑动的方向信息，需要我们来获取滑动的方向。 class SDETabBarControllerDelegate: NSObject, UITabBarControllerDelegate &#123; //在&lt;UITabBarControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则没有动画效果。 func tabBarController(tabBarController: UITabBarController, animationControllerForTransitionFromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123; let fromIndex = tabBarController.viewControllers!.indexOf(fromVC)! let toIndex = tabBarController.viewControllers!.indexOf(toVC)! let tabChangeDirection: TabOperationDirection = toIndex &lt; fromIndex ? .Left : .Right let transitionType = SDETransitionType.TabTransition(tabChangeDirection) let slideAnimationController = SlideAnimationController(type: transitionType) return slideAnimationController &#125; &#125; 为 UITabBarController 设置代理的方法和陷阱与上面的 UINavigationController 类似，注意delegate属性的弱引用问题。点击 TabBar 的相邻页面进行切换时，将会看到 Slide 动画；通过以下代码触发转场时也将看到同样的效果： tabBarVC.selectedIndex = ...//or tabBarVC.selectedViewController = ... Demo 地址：ScrollTabBarController。 UIViewControllerTransitioningDelegate Modal 转场的代理协议&lt;UIViewControllerTransitioningDelegate&gt;是 iOS 7 新增的，其为 presentation 和 dismissal 转场分别提供了动画控制器。在「特殊的 Modal 转场」里实现的OverlayAnimationController类可同时处理 presentation 和 dismissal 转场。UIPresentationController只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。 class SDEModalTransitionDelegate: NSObject, UIViewControllerTransitioningDelegate &#123; func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return OverlayAnimationController() &#125; func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return OverlayAnimationController() &#125; @available(iOS 8.0, *) func presentationControllerForPresentedViewController(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController) -&gt; UIPresentationController? &#123; return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting) &#125; &#125; Modal 转场的代理由 presentedVC 的transitioningDelegate属性来提供，这与前两种容器控制器的转场不一样，不过该属性作为代理同样是弱引用，记得和前面一样需要有强引用的变量来维护该代理，而 Modal 转场需要 presentedVC 来提供转场代理的特性使得 presentedVC 自身非常适合作为自己的转场代理。另外，需要将 presentedVC 的modalPresentationStyle属性设置为.Custom或.FullScreen，只有这两种模式下才支持自定义转场，该属性默认值为.FullScreen。自定义转场时，决定转场动画效果的modalTransitionStyle属性将被忽略。 开启转场动画的方式依然是两种：在 storyboard 里设置 segue 并开启动画，但这里并不支持.Custom模式，不过还有机会挽救，转场前的最后一个环节prepareForSegue:sender:方法里可以动态修改modalPresentationStyle属性；或者全部在代码里设置，示例如下： let presentedVC = ... presentedVC.transitioningDelegate = strongReferenceSDEModalTransitionDelegate //当与 UIPresentationController 配合时该属性必须为.Custom。 presentedVC.modalPresentationStyle = .Custom/.FullScreen presentingVC.presentViewController(presentedVC, animated: true, completion: nil) Demo 地址：CustomModalTransition。 阶段二：交互式转场 激动人心的部分来了，好消息是交互转场的实现难度比你想象的要低。 实现交互化 在非交互转场的基础上将之交互化需要两个条件： 由转场代理提供交互控制器，这是一个遵守&lt;UIViewControllerInteractiveTransitioning&gt;协议的对象，不过系统已经打包好了现成的类UIPercentDrivenInteractiveTransition供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。 交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。 满足以上两个条件很简单，但是很容易犯错误。 正确地提供交互控制器： 如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 TabBarController 的代理里提供交互控制器存在同样的问题，点击 TabBar 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。 以为 NavigationController 提供交互控制器为例： class SDENavigationDelegate: NSObject, UINavigationControllerDelegate &#123; var interactive = false let interactionController = UIPercentDrivenInteractiveTransition() ... func navigationController(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123; return interactive ? self.interactionController : nil &#125; &#125; TabBarController 的实现类似，Modal 转场代理分别为 presentation 和 dismissal 提供了各自的交互控制器，也需要注意上面的问题。 问题的根源是交互控制的工作机制导致的，交互过程实际上是由转场环境对象&lt;UIViewControllerContextTransitioning&gt;来管理的，它提供了如下几个方法来控制转场的进度： func updateInteractiveTransition(_ percentComplete: CGFloat)//更新转场进度，进度数值范围为0.0~1.0。 func cancelInteractiveTransition()//取消转场，转场动画从当前状态返回至转场发生前的状态。 func finishInteractiveTransition()//完成转场，转场动画从当前状态继续直至结束。 交互控制协议&lt;UIViewControllerInteractiveTransitioning&gt;只有一个必须实现的方法： func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) 在转场代理里提供了交互控制器后，转场开始时，该方法自动被 UIKit 调用对转场环境进行配置。 系统打包好的UIPercentDrivenInteractiveTransition中的控制转场进度的方法与转场环境对象提供的三个方法同名，实际上只是前者调用了后者的方法而已。系统以一种解耦的方式使得动画控制器，交互控制器，转场环境对象互相协作，我们只需要使用UIPercentDrivenInteractiveTransition的三个同名方法来控制进度就够了。如果你要实现自己的交互控制器，而不是UIPercentDrivenInteractiveTransition的子类，就需要调用转场环境的三个方法来控制进度，压轴环节我们将示范如何做。 交互控制器控制转场的过程就像将动画控制器实现的动画制作成一部视频，我们使用手势或是其他方法来控制转场动画的播放，可以前进，后退，继续或者停止。finishInteractiveTransition()方法被调用后，转场动画从当前的状态将继续进行直到动画结束，转场完成；cancelInteractiveTransition()被调用后，转场动画从当前的状态回拨到初始状态，转场取消。 在 NavigationController 中点击 NavigationBar 的 backBarButtomItem 执行 pop 操作时，由于我们无法介入 backBarButtomItem 的内部流程，就失去控制进度的手段，于是转场过程只有一个开始，永远不会结束。其实我们只需要有能够执行上述几个方法的手段就可以对转场动画进行控制，用户与屏幕的交互手段里，手势是实现这个控制过程的天然手段，我猜这是其被称为交互控制器的原因。 交互手段的配合： 下面使用演示如何利用屏幕边缘滑动手势UIScreenEdgePanGestureRecognizer在 NavigationController 中控制 Slide 动画控制器提供的动画来实现右滑返回的效果，该手势绑定的动作方法如下： func handleEdgePanGesture(gesture: UIScreenEdgePanGestureRecognizer)&#123; //根据移动距离计算交互过程的进度。 let percent = ... switch gesture.state&#123; case .Began: //转场开始前获取代理，一旦转场开始，VC 将脱离控制器栈，此后 self.navigationController 返回的是 nil。 self.navigationDelegate = self.navigationController?.delegate as? SDENavigationDelegate //更新交互状态 self.navigationDelegate?.interactive = true //1.交互控制器没有 start 之类的方法，当下面这行代码执行后，转场开始； //如果转场代理提供了交互控制器，它将从这时候开始接管转场过程。 self.navigationController?.popViewControllerAnimated(true) case .Changed: //2.更新进度： self.navigationDelegate?.interactionController.updateInteractiveTransition(percent) case .Cancelled, .Ended: //3.结束转场： if percent &gt; 0.5&#123; //完成转场。 self.navigationDelegate?.interactionController.finishInteractiveTransition() &#125;else&#123; //或者，取消转场。 self.navigationDelegate?.interactionController.cancelInteractiveTransition() &#125; //无论转场的结果如何，恢复为非交互状态。 self.navigationDelegate?.interactive = false default: self.navigationDelegate?.interactive = false &#125; &#125; 交互转场的流程就是三处数字标记的代码。不管是什么交互方式，使用什么转场方式，都是在使用这三个方法控制转场的进度。对于交互式转场，交互手段只是表现形式，本质是驱动转场进程。很希望能够看到更新颖的交互手法，比如通过点击页面不同区域来控制一套复杂的流程动画。TabBarController 的 Demo 中也实现了滑动切换 Tab 页面，代码是类似的，就不占篇幅了；示范的 Modal 转场我没有为之实现交互控制，原因也提到过了，没有比较合乎操作直觉的交互手段，不过真要为其添加交互控制，代码和上面是类似的。 转场交互化后结果有两种：完成和取消。取消后动画将会原路返回到初始状态，但已经变化了的数据怎么恢复？ 一种情况是，控制器的系统属性，比如，在 TabBarController 里使用上面的方法实现滑动切换 Tab 页面，中途取消的话，已经变化的selectedIndex属性该怎么恢复为原值；上面的代码里，取消转场的代码执行后，self.navigationController返回的依然还是是 nil，怎么让控制器回到 NavigationController 的控制器栈顶。对于这种情况，UIKit 自动替我们恢复了，不需要我们操心(可能你都没有意识到这回事)； 另外一种就是，转场发生的过程中，你可能想实现某些效果，一般是在下面的事件中执行，转场中途取消的话可能需要取消这些效果。 func viewWillAppear(_ animated: Bool) func viewDidAppear(_ animated: Bool) func viewWillDisappear(_ animated: Bool) func viewDidDisappear(_ animated: Bool) 交互转场介入后，视图在这些状态间的转换变得复杂，WWDC 上苹果的工程师还表示转场过程中 view 的Will系方法和Did系方法的执行顺序并不能得到保证，虽然几率很小，但如果你依赖于这些方法执行的顺序的话就可能需要注意这点。而且，Did系方法调用时并不意味着转场过程真的结束了。另外，fromView 和 toView 之间的这几种方法的相对顺序更加混乱，具体的案例可以参考这里：The Inconsistent Order of View Transition Events。 如何在转场过程中的任意阶段中断时取消不需要的效果？这时候该转场协调器(Transition Coordinator)再次出场了。 Transition Coordinator 转场协调器(Transition Coordinator)的出场机会不多，但却是关键先生。Modal转场中，UIPresentationController类只能通过转场协调器来与动画控制器同步，并行执行其他动画；这里它可以在交互式转场结束时执行一个闭包： func notifyWhenInteractionEndsUsingBlock(_ handler: (UIViewControllerTransitionCoordinatorContext) -&gt; Void) 当转场由交互状态转变为非交互状态(在手势交互过程中则为手势结束时)，无论转场的结果是完成还是被取消，该方法都会被调用；得益于闭包，转场协调器可以在转场过程中的任意阶段搜集动作并在交互中止后执行。闭包中的参数是一个遵守&lt;UIViewControllerTransitionCoordinatorContext&gt;协议的对象，该对象由 UIKit 提供，和前面的转场环境对象&lt;UIViewControllerContextTransitioning&gt;作用类似，它提供了交互转场的状态信息。 override func viewWillAppear(animated: Bool) &#123; super.viewWillDisappear(animated) self.doSomeSideEffectsAssumingViewDidAppearIsGoingToBeCalled() //只在处于交互转场过程中才可能取消效果。 if let coordinator = self.transitionCoordinator() where coordinator.initiallyInteractive() == true&#123; coordinator.notifyWhenInteractionEndsUsingBlock(&#123; interactionContext in if interactionContext.isCancelled()&#123; self.undoSideEffects() &#125; &#125;) &#125; &#125; 不过交互状态结束时并非转场过程的终点(此后动画控制器提供的转场动画根据交互结束时的状态继续或是返回到初始状态)，而是由动画控制器来结束这一切： optional func animationEnded(_ transitionCompleted: Bool) 如果实现了该方法，将在转场动画结束后调用。 UIViewController 可以通过transitionCoordinator()获取转场协调器，该方法的文档中说只有在 Modal 转场过程中，该方法才返回一个与当前转场相关的有效对象。实际上，NavigationController 的转场中 fromVC 和 toVC 也能返回一个有效对象，TabBarController 有点特殊，fromVC 和 toVC 在转场中返回的是 nil，但是作为容器的 TabBarController 可以使用该方法返回一个有效对象。 转场协调器除了上面的两种关键作用外，也在 iOS 8 中的适应性布局中担任重要角色，可以查看&lt;UIContentContainer&gt;协议中的方法，其中响应尺寸和屏幕旋转事件的方法都包含一个转场协调器对象，视图的这种变化也被系统视为广义上的 transition，参数中的转场协调器也由 UIKit 提供。这个话题有点超出本文的范围，就不深入了，有需要的话可以查看文档和相关 session。 封装交互控制器 UIPercentDrivenInteractiveTransition类是一个系统提供的交互控制器，在转场代理的相关方法里提供一个该类实例就够了，还有其他需求的话可以实现其子类来完成，那这里的封装是指什么？系统把交互控制器打包好了，但是交互控制器工作还需要其他的配置。程序员向来很懒，能够自动完成的事绝不肯写一行代码，写一行代码就能搞定的事绝不写第二行，所谓少写一行是一行。能不能顺便把交互控制器的配置也打包好省得写代码啊？当然可以。 热门转场动画库 VCTransitionsLibrary 封装好了多种动画效果，并且自动支持 pop, dismissal 和 tab change 等操作的手势交互，其手法是在转场代理里为 toVC 添加手势并绑定相应的处理方法。 为何没有支持 push 和 presentation 这两种转场？因为 push 和 presentation 这两种转场需要提供 toVC，而库并没有 toVC 的信息，这需要作为使用者的开发者来提供；对于逆操作的 pop 和 dismiss，toVC 的信息已经存在了，所以能够实现自动支持。而 TabBarController 则是个例外，它是在已知的子 VC 之间切换，不存在这个问题。需要注意的是，库这样封装了交互控制器后，那么你将无法再让同一种手势支持 push 或 presentation，要么只支持单向的转场，要么你自己实现双向的转场。当然，如果知道 toVC 是什么类的话，你可以改写这个库让 push 和 present 得到支持。不过，对于在初始化时需要配置额外信息的类，这种简单的封装可能不起作用。VCTransitionsLibrary 库还支持添加自定义的简化版的动画控制器和交互控制器，在封装和灵活之间的平衡控制得很好，代码非常值得学习。 只要愿意，我们还可以变得更懒，不，是效率更高。FDFullscreenPopGesture 通过 category 的方法让所有的 UINavigationController 都支持右滑返回，而且，一行代码都不用写，这是配套的博客：一个丝滑的全屏滑动返回手势。那么也可以实现一个类似的 FullScreenTabScrollGesture 让所有的 UITabBarController 都支持滑动切换，不过，UITabBar 上的 icon 渐变动画有点麻烦，因为其中的 UITabBarItem 并非 UIView 子类，无法进行动画。WXTabBarController 这个项目完整地实现了微信界面的滑动交互以及 TabBar 的渐变动画。不过，它的滑动交互并不是使用转场的方式完成的，而是使用 UIScrollView，好处是兼容性更好。兼容性这方面国内的环境比较差，iOS 9 都出来了，可能还需要兼容 iOS 6，而自定义转场需要至少 iOS 7 的系统。该项目实现的 TabBar 渐变动画是基于 TabBar 的内部结构实时更新相关视图的 alpha 值来实现的(不是UIView 动画），这点非常难得，而且使用 UIScrollView 还可以实现自动控制 TabBar 渐变动画，相比之下，使用转场的方式来实现这个效果会麻烦一点。 一个较好的转场方式需要顾及更多方面的细节，NavigationController 的 NavigationBar 和 TabBarController 的 TabBar 这两者在先天上有着诸多不足需要花费更多的精力去完善，本文就不在这方面深入了，上面提及的几个开源项目都做得比较好，推荐学习。 交互转场的限制 如果希望转场中的动画能完美地被交互控制，必须满足2个隐性条件： 使用 UIView 动画的 API。你当然也可以使用 Core Animation 来实现动画，甚至，这种动画可以被交互控制，但是当交互中止时，会出现一些意外情况：如果你正确地用 Core Animation 的方式复现了 UIView 动画的效果(不仅仅是动画，还包括动画结束后的处理)，那么手势结束后，动画将直接跳转到最终状态；而更多的一种状况是，你并没有正确地复现 UIView 动画的效果，手势结束后动画会停留在手势中止时的状态，界面失去响应。所以，如果你需要完美的交互转场动画，必须使用 UIView 动画。 在动画控制器的animateTransition:中提交动画。问题和第1点类似，在viewWillDisappear:这样的方法中提交的动画也能被交互控制，但交互停止时，立即跳转到最终状态。 如果你希望制作多阶段动画，在某个动画结束后再执行另外一段动画，可以通过 UIView Block Animation 的 completion 闭包来实现动画链，或者是通过设定动画执行的延迟时间使得不同动画错分开来，但是交互转场不支持这两种形式。UIView 的 keyFrame Animation API 可以帮助你，通过在动画过程的不同时间节点添加关键帧动画就可以实现多阶段动画。我实现过一个这样的多阶段转场动画，Demo 在此：CollectionViewAlbumTransition。 插曲：UICollectionViewController 布局转场 前面一直没有提到这种转场方式，与三大主流转场不同，布局转场只针对 CollectionViewController 搭配 NavigationController 的组合，且是作用于布局，而非视图。采用这种布局转场时，NavigationController 将会用布局变化的动画来替代 push 和 pop 的默认动画。苹果自家的照片应用中的「照片」Tab 页面使用了这个技术：在「年度-精选-时刻」几个时间模式间切换时，CollectionViewController 在 push 或 pop 时尽力维持在同一个元素的位置同时进行布局转换。 布局转场的实现比三大主流转场要简单得多，只需要满足四个条件：NavigationController + CollectionViewController, 且要求后者都拥有相同数据源， 并且开启useLayoutToLayoutNavigationTransitions属性为真。 let cvc0 = UICollectionViewController(collectionViewLayout: layout0) //作为 root VC 的 cvc0 的该属性必须为 false，该属性默认为 false。 cvc0.useLayoutToLayoutNavigationTransitions = false let nav = UINavigationController(rootViewController: cvc0) //cvc0, cvc1, cvc2 必须具有相同的数据，如果在某个时刻修改了其中的一个数据源，其他的数据源必须同步，不然会出错。 let cvc1 = UICollectionViewController(collectionViewLayout: layout1) cvc1.useLayoutToLayoutNavigationTransitions = true nav.pushViewController(cvc1, animated: true) let cvc2 = UICollectionViewController(collectionViewLayout: layout2) cvc2.useLayoutToLayoutNavigationTransitions = true nav.pushViewController(cvc2, animated: true) nav.popViewControllerAnimated(true) nav.popViewControllerAnimated(true) Push 进入控制器栈后，不能更改useLayoutToLayoutNavigationTransitions的值，否则应用会崩溃。当 CollectionView 的数据源(section 和 cell 的数量)不完全一致时，push 和 pop 时依然会有布局转场动画，但是当 pop 回到 rootVC 时，应用会崩溃。可否共享数据源保持同步来克服这个缺点？测试表明，这样做可能会造成画面上的残缺，以及不稳定，建议不要这么做。 此外，iOS 7 支持 UICollectionView 布局的交互转换(Layout Interactive Transition)，过程与控制器的交互转场(ViewController Interactive Transition)类似，这个功能和布局转场(CollectionViewController Layout Transition)容易混淆，前者是在自身布局转换的基础上实现了交互控制，后者是 CollectionViewController 与 NavigationController 结合后在转场的同时进行布局转换。感兴趣的话可以看这个功能的文档。 布局转场不支持交互控制。Demo 地址：CollectionViewControllerLayoutTransition。 进阶 是否觉得本文中实现的例子的动画效果太过简单？的确很简单，与 VCTransitionsLibrary 这样的转场动画库提供的十种动画效果相比是很简单的，不过就动画而言，与本文示例的本质是一样的，它们都是针对 fromView 和 toView 的整体进行的动画，但在效果上更加复杂。我在本文中多次强调转场动画的本质是是对即将消失的当前视图和即将出现的下一屏幕的内容进行动画，「在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力」，当然，还有你的实现能力。 本文前面的目的是帮助你熟悉转场的整个过程，你也看到了，转场动画里转场部分的实现其实很简单，大部分复杂的转场动画与本文范例里简单的转场动画相比，复杂的部分在动画部分，转场的部分都是一样的。因此，学习了前面的内容后并不能帮助你立马就能够实现 Github 上那些热门的转场动画，它们成为热门的原因在于动画本身，与转场本身关系不大，但它们与转场结合后就有了神奇的力量。那学习了作为进阶的本章能立马实现那些热门的转场效果吗？有可能，有些效果其实很简单，一点就透，还有一些效果涉及的技术属于本文主题之外的内容，我会给出相关的提示就不深入了。 本章的进阶分为两个部分： 案例分析：动画的方式非常多，有些并不常见，有些只是简单到令人惊讶的组合，只是你不曾了解过所以不知道如何实现，一旦了解了就不再是难事。尽管这些动画本身并不属于转场技术这个主题，但与转场动画组合后往往有着惊艳的视觉效果，这部分将提供一些实现此类转场动画的思路，技巧和工具来扩展视野。有很多动画类型我也没有尝试过，可能的话我会继续更新一些有意思的案例。 自定义容器转场：官方支持四种方式的转场，而且这些也足以应付绝大多数需求了，但依然有些地方无法顾及。本文一直通过探索转场的边界的方式来总结使用方法以及陷阱，在本文的压轴部分，我们将挣脱系统的束缚来实现自定义容器控制器的转场效果。 案例分析 动画的持续时间一般不超过0.5秒，稍纵即逝，有时候看到一个复杂的转场动画也不容易知道实现的方式，我一般是通过逐帧解析的手法来分析实现的手段：开源的就运行一下，使用系统自带的 QuickPlayer 对 iOS 设备进行录屏，再使用 QuickPlayer 打开视频，按下 cmd+T 打开剪辑功能，这时候就能查看每一帧了；Gif 等格式的原型动画的动图就直接使用系统自带的 Preview 打开看中间帧。 子元素动画 当转场动画涉及视图中的子视图时，往往无法依赖第三方的动画库来实现，你必须为这种效果单独定制，神奇移动就是一个典型的例子。神奇移动是 Keynote 中的一个动画效果，如果某个元素在连续的两页 Keynote 同时存在，在页面切换时，该元素从上一页的位置移动到下一页的位置，非常神奇。在转场中怎么实现这个效果呢？最简单的方法是截图配合移动动画：伪造那个元素的视图添加到 containerView 中，从 fromView 中的位置移动到 toView 中的位置，这期间 fromView 和 toView 中的该元素视图隐藏，等到移动结束恢复 toView 中该元素的显示，并将伪造的元素视图从 containerView 中移除。 UIView 有几个convert方法用于在不同的视图之间转换坐标： func convertPoint(_ point: CGPoint, toView view: UIView?) -&gt; CGPoint func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint 对截图这个需求，iOS 7 提供了趁手的工具，UIView Snapshot API： func snapshotViewAfterScreenUpdates(_ afterUpdates: Bool) -&gt; UIView //获取视图的部分内容 func resizableSnapshotViewFromRect(_ rect: CGRect, afterScreenUpdates afterUpdates: Bool, withCapInsets capInsets: UIEdgeInsets) -&gt; UIView 当afterScreenUpdates参数值为true时，这两个方法能够强制视图立刻更新内容，同时返回更新后的视图内容。在 push 或 presentation 中，如果 toVC 是 CollectionViewController 并且需要对 visibleCells 进行动画，此时动画控制器里是无法获取到的，因为此时 collectionView 还未向数据源询问内容，执行此方法后能够达成目的。UIView 的layoutIfNeeded()也能要求立即刷新布局达到同样的效果。 Mask 动画 左边的动画教程：How To Make A View Controller Transition Animation Like in the Ping App；右边动画的开源地址：BubbleTransition。 Mask 动画往往在视觉上令人印象深刻，这种动画通过使用一种特定形状的图形作为 mask 截取当前视图内容，使得当前视图只表现出 mask 图形部分的内容，在 PS 界俗称「遮罩」。UIView 有个属性maskView可以用来遮挡部分内容，但这里的效果并不是对maskView的利用；CALayer 有个对应的属性mask，而 CAShapeLayer 这个子类搭配 UIBezierPath 类可以实现各种不规则图形。这种动画一般就是 mask + CAShapeLayer + UIBezierPath 的组合拳搞定的，实际上实现这种圆形的形变是很简单的，只要发挥你的想象力，可以实现任何形状的形变动画。 这类转场动画在转场过程中对 toView 使用 mask 动画，不过，右边的这个动画实际上并不是上面的组合来完成的，它的真相是这样： 这个开发者实在是太天才了，这个手法本身就是对 mask 概念的应用，效果卓越，但方法却简单到难以置信。关于使用 mask + CAShapeLayer + UIBezierPath 这种方法实现 mask 动画的方法请看我的这篇文章。 高性能动画框架 有些动画使用 UIView 的动画 API 难以实现，或者难以达到较好的性能，又或者两者皆有，幸好我们还有其他选择。StartWar 使用更底层的 OpenGL 框架来解决性能问题以及 Objc.io 在探讨转场这个话题时使用 GPUImage 定制动画都是这类的典范。在交互控制器章节中提到过，官方只能对 UIView 动画 API 实现的转场动画实施完美的交互控制，这也不是绝对的，接下来我们就来挑战这个难题。 自定义容器控制器转场 压轴环节我们将实现这样一个效果： Demo 地址：CustomContainerVCTransition。 分析一下思路，这个控制器和 UITabBarController 在行为上比较相似，只是 TabBar 由下面跑到了上面。我们可以使用 UITabBarController 子类，然后打造一个伪 TabBar 放在顶部，原来的 TabBar 则隐藏，行为上完全一致，使用 UITabBarController 子类的好处是可以减轻实现转场的负担，不过，有时候这样的子类不是你想要的，UIViewController 子类能够提供更多的自由度，好吧，一个完全模仿 UITabBarController 行为的 UIViewController 子类，实际上我没有想到非得这样做的原因，但我想肯定有需要定制自己的容器控制器的场景，这正是本节要探讨的。Objc.io 也讨论过这个话题，文章的末尾把实现交互控制当做作业留了下来。珠玉在前，我就站在大牛的肩上继续这个话题吧。Objc.io 的这篇文章写得较早使用了 Objective-C 语言，如果要读者先去读这篇文章再继续读本节的内容，难免割裂，所以本节还是从头讨论这个话题吧，最终效果如上面所示，在自定义的容器控制器中实现交互控制切换子视图，也可以通过填充了 UIButton 的 ButtonTabBar 来实现 TabBar 一样行为的 Tab 切换，在通过手势切换页面时 ButtonTabBar 会实现渐变色动画。ButtonTabBar 有很大扩展性，改造或是替换为其他视图还是有很多应用场景的。 实现分析 既然这个自定义容器控制器和 UITabBarController 行为类似，我便实现了一套类似的 API：viewControllers数组是容器 VC 维护的子 VC 数组，初始化时提供要显示的子 VC，更改selectedIndex的值便可跳转到对应的子视图。利用 Swift 的属性观察器实现修改selectedIndex时自动执行子控制器转场。下面是实现子 VC 转场的核心代码，转场结束后遵循系统的惯例将 fromView 移除： class SDEContainerViewController: UIViewController&#123; ... //发生转场的容器视图，是 root view 的子视图。 private let privateContainerView = UIView() var selectedIndex: Int = NSNotFound&#123; willSet&#123; transitionViewControllerFromIndex(selectedIndex, toIndex: newValue) &#125; &#125; //实现 selectedVC 转场： private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int)&#123; //添加 toVC 和 toView let newSelectedVC = viewControllers![toIndex] self.addChildViewController(newSelectedVC) self.privateContainerView.addSubview(newSelectedVC.view) newSelectedVC.didMoveToParentViewController(self) UIView.animateWithDuration(transitionDuration, animations: &#123; /*转场动画*/ &#125;, completion: &#123; finished in //移除 fromVC 和 fromView。 let priorSelectedVC = viewControllers![fromIndex] priorSelectedVC.willMoveToParentViewController(nil) priorSelectedVC.view.removeFromSuperview() priorSelectedVC.removeFromParentViewController() &#125;) &#125; &#125; 实现转场就是这么十几行代码而已，其他容器 VC 转场过程做了类似的事情。回忆下我们在动画控制器里做的事情，实际上只是上面代码中的一部分。转场协议这套 API 将这个过程分割为五个组件，这套复杂的结构带来了可高度自定义的动画效果和交互控制。我们温习下转场协议，来看看如何在既有的转场协议框架下实现自定义容器控制器的转场动画以及交互控制： 转场代理：既有的转场代理协议并没有直接支持我们这种转场方式，没关系，我们自定义一套代理协议来提供动画控制器和交互控制器； 动画控制器：动画控制器是可复用的，这里采用动画控制器章节封装的 Slide 动画控制器，可以拿来直接使用而不用修改； 交互控制器：官方封装了一个现成的交互控制器类，但这个类是与 UIKit 提供的转场环境对象配合使用的，而这里的转场显然需要我们来提供转场环境对象，因此UIPercentDrivenInteractiveTransition无法在这里使用，需要我们来实现这个协议； 转场环境：在官方支持的转场方式中，转场环境是由 UIKit 主动提供给我们的，既然现在的转场方式不是官方支持的，显然需要我们自己提供这个对象以供动画控制器和交互控制器使用； 转场协调器：在前面的章节中我提到过，转场协调器(Transition Coordinator)的使用场景有限而关键，也是由系统提供，我们也可以重写相关方法来提供。这个部分我留给读者当作是本文的一道作业吧。 下面我们来将上面的十几行代码(不包括实际的动画代码)使用协议封装成本文前半部分里熟悉的样子。 协议补完 模仿 UITabBarControllerDelegate 协议的 ContainerViewControllerDelegate 协议： //在 Swift 协议中声明可选方法必须在协议声明前添加 @objc 修饰符。 @objc protocol ContainerViewControllerDelegate&#123; func containerController(containerController: SDEContainerViewController, animationControllerForTransitionFromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? optional func containerController(containerController: SDEContainerViewController, interactionControllerForAnimation animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#125; 在容器控制器SDEContainerViewController类中，添加转场代理属性： weak var containerTransitionDelegate: ContainerViewControllerDelegate? 代理的定位就是提供动画控制器和交互控制器，系统打包的UIPercentDrivenInteractiveTransition类只是调用了转场环境对象的对应方法而已，执行navigationController.pushViewController(toVC, animated: true)这类语句触发转场后 UIKit 就接管了剩下的事情，再综合文档的描述，可知转场环境便是实现这一切的核心。 在文章前面的部分里转场环境对象的作用只是提供涉及转场过程的信息和状态，现在需要我们实现该协议，并且实现隐藏的那部分职责。&lt;UIViewControllerContextTransitioning&gt;协议里的绝大部分方法都是必须实现的，不过现在我们先实现非交互转场的部分，实现这个是很简单的，主要是调用动画控制器执行转场动画。在「实现分析」一节里我们看到实现转场的代码只有十几行而已，动画控制器需要做的只是处理视图和动画的部分，转场环境对象则要负责管理子 VC，通过SDEContainerViewController提供 containerView 以及 fromVC 和 toVC，实现并不是难事。显然由我们实现的自定义容器 VC 来提供转场环境对象是最合适的，并且转场环境对象应该是私有的，其初始化方法极其启动转场的方法如下： class ContainerTransitionContext: NSObject, UIViewControllerContextTransitioning&#123; init(containerViewController: SDEContainerViewController, containerView: UIView, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController)&#123;...&#125; //非协议方法，是启动非交互式转场的便捷方法。 func startNonInteractiveTransitionWith(delegate: ContainerViewControllerDelegate)&#123; //转场开始前添加 toVC，转场动画结束后会调用 completeTransition: 方法，在该方法里完成后续的操作。 self.privateContainerViewController.addChildViewController(privateToViewController) //通过 ContainerViewControllerDelegate 协议定义的方法生成动画控制器，方法名太长了略去。 self.privateAnimationController = delegate.XXXmethod //启动转场并执行动画。 self.privateAnimationController.animateTransition(self) &#125; //协议方法，动画控制器在动画结束后调用该方法，完成管理子 VC 的后续操作，并且考虑交互式转场可能取消的情况撤销添加的子 VC。 func completeTransition(didComplete: Bool) &#123; if didComplete&#123; //转场完成，完成添加 toVC 的工作，并且移除 fromVC 和 fromView。 self.privateToViewController.didMoveToParentViewController(privateContainerViewController) self.privateFromViewController.willMoveToParentViewController(nil) self.privateFromViewController.view.removeFromSuperview() self.privateFromViewController.removeFromParentViewController() &#125;else&#123; //转场取消，移除 toVC 和 toView。 self.privateToViewController.didMoveToParentViewController(privateContainerViewController) self.privateToViewController.willMoveToParentViewController(nil) self.privateToViewController.view.removeFromSuperview() self.privateToViewController.removeFromParentViewController() &#125; //非协议方法，处理收尾工作：如果动画控制器实现了 animationEnded: 方法则执行；如果转场取消了则恢复数据。 self.transitionEnd() &#125; &#125; 在SDEContainerViewController类中，添加转场环境属性： private var containerTransitionContext: ContainerTransitionContext? 并修改transitionViewControllerFromIndex:toIndex方法实现自定义容器 VC 转场动画： private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int)&#123; if self.containerTransitionDelegate != nil&#123; let fromVC = viewControllers![fromIndex] let toVC = viewControllers![toIndex] self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。 self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!) &#125;else&#123;/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/&#125; &#125; 这样我们就利用协议实现了自定义容器控制器的转场动画，可以使用第三方的动画控制器来实现不同的效果。 不过要注意这几个对象之间错综复杂的引用关系避免引用循环，关系图如下： 交互控制 交互控制器的协议&lt;UIViewControllerInteractiveTransitioning&gt;仅仅要求实现一个必须的方法: func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) 根据文档的描述，该方法用于配置以及启动交互转场。我们前面使用的UIPercentDrivenInteractiveTransition类提供的更新进度的方法只是调用了转场环境对象的相关方法。所以，是转场环境对象替交互控制器把脏活累活干了，我们的实现还是维持这种关系好了。正如前面说的，「交互手段只是表现形式，本质是驱动转场进程」，让我们回到转场环境对象里实现对动画进度的控制吧。 怎么控制动画的进度？这个问题的本质是怎么实现对 UIView 的 animateWithDuration:animations:completion:这类方法生成的动画的控制。能够控制吗？能。 动画控制和 CAMediaTiming 协议 这个协议定义了一套时间系统，是控制动画进度的关键。UIView Animation 是使用 Core Animation 框架实现的，也就是使用 UIView 的 CALayer 对象实现的动画，而 CALayer 对象遵守该协议。 在交互控制器的小节里我打了一个比方，交互控制器就像一个视频播放器一样控制着转场动画这个视频的进度。依靠 CAMediaTiming 这套协议，我们可以在 CALayer 对象上对添加的动画实现控制。官方的实现很有可能也是采用了同样的手法。CAMediaTiming 协议中有以下几个属性： //speed 作用类似于播放器上控制加速/减速播放，默认为1，以正常速度播放动画，为0时，动画将暂停。 var speed: Float //修改 timeOffset 类似于拖动进度条，对一个2秒的动画，该属性为1的话，动画将跳到中间的部分。 //但当动画从中间播放到预定的末尾时，会续上0秒到1秒的动画部分。 var timeOffset: CFTimeInterval //动画相对于父 layer 延迟开始的时间，这是一个实际作用比字面意义复杂的属性。 var beginTime: CFTimeInterval Core Animation 的文档中提供了如何暂停和恢复动画的示例：How to pause the animation of a layer tree。我们将之利用实现对进度的控制，这种方法对其中的子视图上添加的动画也能够实现控制，这正是我们需要的。假设在 containerView 中的 toView 上执行一个简单的沿着 X 轴方向移动 100 单位的位移动画，由executeAnimation()方法执行。下面是使用手势控制该动画进度的核心代码： func handlePan(gesture: UIPanGestureRecognizer)&#123; switch gesture.state&#123; case .Began: //开始动画前将 speed 设为0，然后执行动画，动画将停留在开始的时候。 containerView.layer.speed = 0 //在transitionContext里，这里替换为 animator.animateTransition(transitionContext)。 executeAnimation() case .Changed: let percent = ... //此时 speed 依然为0，调整 timeOffset 可以直接调整动画的整体进度，这里的进度控制以时间计算，而不是比例。 containerView.layer.timeOffset = percent * duration case .Ended, .Cancelled: if progress &gt; 0.5&#123; //恢复动画的运行不能简单地仅仅将 speed 恢复为1，这是一套比较复杂的机制。 let pausedTime = view.layer.timeOffset containerView.layer.speed = 1.0 containerView.layer.timeOffset = 0.0 containerView.layer.beginTime = 0.0 let timeSincePause = view.layer.convertTime(CACurrentMediaTime(), fromLayer: nil) - pausedTime containerView.layer.beginTime = timeSincePause &#125;else&#123;/*逆转动画*/&#125; default:break &#125; &#125; 取消转场 交互控制动画时有可能被取消，这往往带来两个问题：恢复数据和逆转动画。 这里需要恢复的数据是selectedIndex，我们在交互转场开始前备份当前的selectedIndex，如果转场取消了就使用这个备份数据恢复。逆转动画反而看起来比较难以解决。 在上面的 pan 手势处理方法中，我们如何逆转动画的运行呢？既然speed为0时动画静止不动，调整为负数是否可以实现逆播放呢？不能，效果是视图消失不见。不过我们还可以调整timeOffset属性，从当前值一直恢复到0。问题是如何产生动画的效果？动画的本质是视图属性在某段时间内的连续变化，当然这个连续变化并不是绝对的连续，只要时间间隔够短，变化的效果就会流畅得看上去是连续变化，在这里让这个变化频率和屏幕的刷新同步即可，CADisplayLink可以帮助我们实现这点，它可以在屏幕刷新时的每一帧执行绑定的方法： //在上面的/*逆转动画*/处添加以下两行代码： let displayLink = CADisplayLink(target: self, selector: &quot;reverseAnimation:&quot;) displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode) func reverseAnimation(displayLink: CADisplayLink)&#123; //displayLink.duration表示每一帧的持续时间，屏幕的刷新频率为60，duration = 1/60。 //这行代码计算的是，屏幕刷新一帧后，timeOffset 应该回退一帧的时间。 let timeOffset = view.layer.timeOffset - displayLink.duration if timeOffset &gt; 0&#123; containerView.layer.timeOffset = timeOffset &#125;else&#123; //让 displayLink 失效，停止对当前方法的调用。 displayLink.invalidate() //回到最初的状态。 containerView.layer.timeOffset = 0 //speed 恢复为1后，视图立刻跳转到动画的最终状态。 containerView.layer.speed = 1 &#125; &#125; 最后一句代码会令人疑惑，为何让视图恢复为最终状态，与我们的初衷相悖。speed必须恢复为1，不然后续发起的转场动画无法顺利执行，视图也无法响应触摸事件，直接原因未知。但speed恢复为1后会出现一个问题：由于在原来的动画里 fromView 最终会被移出屏幕，尽管 Slide 动画控制器 UIView 动画里的 completion handle 里会恢复 fromView 和 toView 的状态，这种状态的突变会造成闪屏现象。怎么解决？添加一个假的 fromView 到 containerView替代已经被移出屏幕外的真正的 fromView，然后在很短的时间间隔后将之移除，因为此时 fromView 已经归位。在恢复speed后添加以下代码： let fakeFromView = privateFromViewController.view.snapshotViewAfterScreenUpdates(false) containerView.addSubview(fakeFromView) performSelector(&quot;removeFakeFromView:&quot;, withObject: fakeFromView, afterDelay: 1/60) //在 Swift 中动态调用私有方法会出现无法识别的选择器错误，解决办法是将私有方法设置为与 objc 兼容，需要添加 @objc 修饰符。 @objc private func removeFakeFromView(fakeView: UIView)&#123; fakeView.removeFromSuperview() &#125; 经过试验，上面用来控制和取消 UIView 动画的方法也适用于用 Core Animation 实现的动画，毕竟 UIView 动画是用 Core Animation 实现的。不过，我们在前面提到过，官方对 Core Animation 实现的交互转场动画的支持有缺陷，估计官方鼓励使用更高级的接口吧，因为转场动画结束后需要调用transitionContext.completeTransition(!isCancelled)，而使用 Core Animation 完成这一步需要进行恰当的配置，实现的途径有两种且实现并不简单，相比之下 UIView 动画使用 completion block 对此进行了封装，使用非常方便。转场协议的结构已经比较复杂了，选择 UIView 动画能够显著降低实现成本。 上面的实现忽略了一个细节：时间曲线。逆转动画时每一帧都回退相同的时间，也就是说，逆转动画的时间曲线是线性的。交互控制器的协议&lt;UIViewControllerInteractiveTransitioning&gt;还有两个可选方法： optional func completionCurve() -&gt; UIViewAnimationCurve optional func completionSpeed() -&gt; CGFloat 这两个方法记录了动画采用的动画曲线和速度，在逆转动画时如果能够根据这两者计算出当前帧应该回退的时间，那么就能实现完美的逆转，显然这是一个数学问题。恩，我们跳过这个细节吧，因为我数学不好，讨论这个问题很吃力。推荐阅读 Objc.io 的交互式动画一文，该文探讨了如何打造自然真实的交互式动画。 最后的封装 接下来要做的事情就是将上述代码封装在转场环境协议要求实现的三个方法里： func updateInteractiveTransition(percentComplete: CGFloat) func finishInteractiveTransition() func cancelInteractiveTransition() 正如系统打包的UIPercentDrivenInteractiveTransition类只是调用了 UIKit 提供的转场环境对象里的同名方法，我实现的SDEPercentDrivenInteractiveTransition类也采用了同样的方式调用我们实现的ContainerTransitionContext类的同名方法。 引入交互控制器后的转场引用关系图： 回到SDEContainerViewController类里修改转场过程的入口处： private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int)&#123; ... if containerTransitionDelegate != nil&#123; let fromVC = viewControllers![fromIndex] let toVC = viewControllers![toIndex] self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。 //interactive 属性标记是否进入交互状态，由手势来更新该属性的状态。 if interactive&#123; priorSelectedIndex = fromIndex //备份数据，以备取消转场时使用。 self.containerTransitionContext?.startInteractiveTranstionWith(containerTransitionDelegate!) &#125;else&#123; self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!) &#125; &#125;else&#123;/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/&#125; &#125; 实现手势控制的部分就如前面的交互控制器章节里的那样，完整的代码请看 Demo。 顺便说下 ButtonTabButton 在交互切换页面时的渐变色动画，这里我只是随着转场的进度更改了 Button 的字体颜色而已。那么当交互结束时如何继续剩下的动画或者取消渐变色动画呢，就像交互转场动画的那样。答案是CADidplayLink，前面我使用它在交互取消时逆转动画，这里使用了同样的手法。 关于转场协调器，文档表明在转场发生时transitionCoordinator()返回一个有效对象，但系统并不支持当前的转场方式，测试表明在当前的转场过程中这个方法返回的是 nil，需要重写该方法来提供。该对象只需要实现前面提到三个方法，其中在交互中止时执行绑定的闭包的方法可以通过通知机制来实现，有点困难的是两个与动画控制器同步执行动画的方法，其需要精准地与动画控制器中的动画保持同步，这两个方法都要接受一个遵守&lt;UIViewControllerTransitionCoordinatorContext&gt;协议的参数，该协议与转场环境协议非常相似，这个对象可以由我们实现的转场环境对象来提供。不过既然现在由我们实现了转场环境对象，也就知道了执行动画的时机，提交并行的动画似乎并不是难事。这部分就留给读者来挑战了。 尾声：转场动画的设计 虽然我不是设计师，但还是想在结束之前聊一聊我对转场动画设计的看法。动画的使用无疑能够提升应用的体验，但仅限于使用了合适的动画。 除了一些加载动画可以炫酷华丽极尽炫技之能事，绝大部分的日常操作并不适合使用过于炫酷或复杂的动画，比如 VCTransitionsLibrary 这个库里的大部分效果。该库提供了多达10种转场效果，从技术上讲，大部分效果都是针对 transform 进行动画，如果你对这些感兴趣或是恰好有这方面的使用需求，可以学习这些效果的实现，从代码角度看，封装技巧也很值得学习，这个库是学习转场动画的极佳范例；不过从使用效果上看，这个库提供的效果像 PPT 里提供的动画效果一样，绝大部分都应该避免在日常操作中使用。不过作为开发者，我们应该知道技术实现的手段，即使这些效果并不适合在绝大部分场景中使用。 场景转换的目的是过渡到下一个场景，在操作频繁的日常场景中使用复杂的过场动画容易造成视觉疲劳，这种情景下使用简单的动画即可，实现起来非常简单，更多的工作往往是怎么把它们与其他特性更好地结合起来，正如 FDFullscreenPopGesture 做的那样。除了日常操作，也会遇到一些特殊的场景需要定制复杂的转场动画，这种复杂除了动画效果本身的复杂，这需要掌握相应的动画手段，也可能涉及转场过程的配合，这需要对转场机制比较熟悉。比如 StarWars，这个转场动画在视觉上极其惊艳，一出场便获得上千星星的青睐，它有贴合星战内涵的创意设计和惊艳的视觉表现，以及优秀的性能优化，如果要评选年度转场动画甚至是史上最佳，我会投票给它；而我在本文里实现的范例，从动画效果来讲，都是很简单的，可以预见本文无法吸引大众的转发，压轴环节里的自定义容器控制器转场也是如此，但是后者需要熟知转场机制才能实现。从这点来看，转场动画在实际使用中走向两个极端：日常场景中的转场动画十分简单，实现难度很低；特定场景的转场动画可能非常复杂，不过实现难度并不能一概而论，正如我在案例分析一节里指出的几个案例那样。 希望本文能帮助你。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"},{"name":"投稿","slug":"投稿","permalink":"https://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"}]},{"title":"Swift 烧脑体操（四） - map 和 flatMap","slug":"swift-gym-4-map-and-flatmap","date":"2016-03-05T12:15:34.000Z","updated":"2024-01-16T01:47:08.735Z","comments":true,"path":"2016/03/05/swift-gym-4-map-and-flatmap/","permalink":"https://blog.devtang.com/2016/03/05/swift-gym-4-map-and-flatmap/","excerpt":"","text":"索引Swift 烧脑系列文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 前言Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。 Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。 这是本体操的第四节，练习前请做好准备运动，保持头脑清醒。 我之前一直以为我是懂 map 和 flatMap 的。但是直到我看到别人说：「一个实现了 flatMap 方法的类型其实就是 monad。」我又发现这个熟悉的东西变得陌生起来，本节烧脑体操打算更细致一些介绍 map 和 flatMap，为了下一节介绍 monad 做铺垫。 准备运动：基础知识 数组中的 map 和 flatMap数组中的 map 对数组元素进行某种规则的转换，例如： let arr = [1, 2, 4]// arr = [1, 2, 4]let brr = arr.map &#123; &quot;No.&quot; + String($0)&#125;// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;] 而 flatMap 和 map 的差别在哪里呢？我们可以对比一下它们的定义。为了方便阅读，我在删掉了定义中的 @noescape 、throws 和 rethrows 关键字，如果你对这些关键字有疑问，可以查阅上一期的烧脑文章： extension SequenceType &#123; public func map&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T) -&gt; [T]&#125;extension SequenceType &#123; public func flatMap&lt;S : SequenceType&gt;(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element]&#125;extension SequenceType &#123; public func flatMap&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T]&#125; 我们从中可以发现，map 的定义只有一个，而 flatMap 的定义有两个重载的函数，这两个重载的函数都是接受一个闭包作为参数，返回一个数组。但是差别在于，闭包的定义不一样。 第一个函数闭包的定义是：(Self.Generator.Element) -&gt; S，并且这里 S 被定义成：S : SequenceType。所以它是接受数组元素，然后输出一个 SequenceType 类型的元素的闭包。有趣的是， flatMap 最终执行的结果并不是 SequenceType 的数组，而是 SequenceType 内部元素另外组成的数组，即：[S.Generator.Element]。 是不是有点晕？看看示例代码就比较清楚了： let arr = [[1, 2, 3], [6, 5, 4]]let brr = arr.flatMap &#123; $0&#125;// brr = [1, 2, 3, 6, 5, 4] 你看出来了吗？在这个例子中，数组 arr 调用 flatMap 时，元素[1, 2, 3] 和 [6, 5, 4] 分别被传入闭包中，又直接被作为结果返回。但是，最终的结果中，却是由这两个数组中的元素共同组成的新数组：[1, 2, 3, 6, 5, 4] 。 需要注意的是，其实整个 flatMap 方法可以拆解成两步： 第一步像 map 方法那样，对元素进行某种规则的转换。 第二步，执行 flatten 方法，将数组中的元素一一取出来，组成一个新数组。 所以，刚刚的代码其实等价于： let arr = [[1, 2, 3], [6, 5, 4]]let crr = Array(arr.map&#123; $0 &#125;.flatten())// crr = [1, 2, 3, 6, 5, 4] 讲完了 flatMap 的第一种重载的函数，我们再来看第二种重载。 在第二种重载中，闭包的定义变成了：(Self.Generator.Element) -&gt; T?，返回值 T 不再像第一种重载中那样要求是数组了，而变成了一个 Optional 的任意类型。而 flatMap 最终输出的数组结果，其实不是这个 T? 类型，而是这个 T? 类型解包之后，不为 .None 的元数数组：[T]。 我们还是直接看代码吧。 let arr: [Int?] = [1, 2, nil, 4, nil, 5]let brr = arr.flatMap &#123; $0 &#125;// brr = [1, 2, 4, 5] 在这个例子中，flatMap 将数组中的 nil 都丢弃掉了，只保留了非空的值。 在实际业务中，这样的例子还挺常见，比如你想构造一组图片，于是你使用 UIImage 的构造函数，但是这个函数可能会失败（比如图像的名字不存在时），所以返回的是一个 Optional 的 UIImage 对象。使用 flatMap 方法可以方便地将这些对象中为 .None 的都去除掉。如下所示： let images = (1...6).flatMap &#123; UIImage(named: &quot;imageName-\\($0)&quot;) &#125; Optional 中的 map 和 flatMap其实 map 和 flatMap 不止存在于数组中，在 Optional 中也存在。我们先看看定义吧： public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123; case None case Some(Wrapped) public func map&lt;U&gt;( f: (Wrapped) throws -&gt; U) rethrows -&gt; U? public func flatMap&lt;U&gt;( f: (Wrapped) throws -&gt; U?) rethrows -&gt; U?&#125; 所以，对于一个 Optional 的变量来说，map 方法允许它再次修改自己的值，并且不必关心自己是否为 .None。例如： let a1: Int? = 3let b1 = a1.map&#123; $0 * 2 &#125;// b1 = 6let a2: Int? = nillet b2 = a2.map&#123; $0 * 2 &#125;// b2 = nil 再举一个例子，比如我们想把一个字符串转成 NSDate 实例，如果不用 map 方法，我们只能这么写： let date: NSDate? = NSDate()let formatter = NSDateFormatter()formatter.dateFormat = &quot;YYYY-MM-dd&quot;var formatted: String? = nilif let date = date &#123; formatted = formatter.stringFromDate(date)&#125; 而使用 map 函数后，代码变得更短，更易读： let date: NSDate? = NSDate()let formatter = NSDateFormatter()formatter.dateFormat = &quot;YYYY-MM-dd&quot;let formatted = date.map(formatter.stringFromDate) 看出来特点了吗？当我们的输入是一个 Optional，同时我们需要在逻辑中处理这个 Optional 是否为 nil，那么就适合用 map 来替代原来的写法，使得代码更加简短。 那什么时候使用 Optional 的 flatMap 方法呢？答案是：当我们的闭包参数有可能返回 nil 的时候。 比如，我们希望将一个字符串转换成 Int，但是转换可能失败，这个时候我们就可以用 flatMap 方法，如下所示： let s: String? = &quot;abc&quot;let v = s.flatMap &#123; (a: String) -&gt; Int? in return Int(a)&#125; 我在这里还发现了更多的使用 map 和 flatMap 的例子，分享给大家：http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/。 map 和 flatMap 的源码 Talk is cheap. Show me the code. – Linus Torvalds 为了更好地理解，我们去翻翻苹果开源的 Swift 代码，看看 map 和 flatMap 的实现吧。 数组的 map 的源码源码地址是：https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift，摘录如下： public func map&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) rethrows -&gt; [T] &#123; let count: Int = numericCast(self.count) if count == 0 &#123; return [] &#125; var result = ContiguousArray&lt;T&gt;() result.reserveCapacity(count) var i = self.startIndex for _ in 0..&lt;count &#123; result.append(try transform(self[i])) i = i.successor() &#125; _expectEnd(i, self) return Array(result)&#125; 数组的 flatMap 的源码（重载函数一）刚刚也说到，数组的 flatMap 有两个重载的函数。我们先看第一个的函数实现。源码地址是：https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb。 public func flatMap&lt;S : SequenceType&gt;( transform: ($&#123;GElement&#125;) throws -&gt; S ) rethrows -&gt; [S.$&#123;GElement&#125;] &#123; var result: [S.$&#123;GElement&#125;] = [] for element in self &#123; result.appendContentsOf(try transform(element)) &#125; return result&#125; 对于这个代码，我们可以看出，它做了以下几件事情： 构造一个名为 result 的新数组，用于存放结果。 遍历自己的元素，对于每个元素，调用闭包的转换函数 transform，进行转换。 将转换的结果，使用 appendContentsOf 方法，将结果放入 result 数组中。 而这个 appendContentsOf 方法，即是把数组中的元素取出来，放入新数组。以下是一个简单示例： var arr = [1, 3, 2]arr.appendContentsOf([4, 5])// arr = [1, 3, 2, 4, 5] 所以这种 flatMap 必须要求 transform 函数返回的是一个 SequenceType 类型，因为 appendContentsOf 方法需要的是一个 SequenceType 类型的参数。 数组的 flatMap 的源码（重载函数二）当我们的闭包参数返回的类型不是 SequenceType 时，就会匹配上第二个重载的 flatMap 函数。以下是函数的源码。 public func flatMap&lt;T&gt;( @noescape transform: ($&#123;GElement&#125;) throws -&gt; T? ) rethrows -&gt; [T] &#123; var result: [T] = [] for element in self &#123; if let newElement = try transform(element) &#123; result.append(newElement) &#125; &#125; return result&#125; 我们也用同样的方式，把该函数的逻辑理一下： 构造一个名为 result 的新数组，用于存放结果。(和另一个重载函数完全一样) 遍历自己的元素，对于每个元素，调用闭包的转换函数 transform，进行转换。(和另一个重载函数完全一样) 将转换的结果，判断结果是否是 nil，如果不是，使用使用 append 方法，将结果放入 result 数组中。（唯一差别的地方） 所以，该 flatMap 函数可以过滤闭包执行结果为 nil 的情况，仅收集那些转换后非空的结果。 对于这种重载的 flatMap 函数，它和 map 函数的逻辑非常相似，仅仅多做了一个判断是否为 nil 的逻辑。 所以，面试题来了：「什么情况下数组的 map 可以和 flatMap 等价替换？」 答案是：当 map 的闭包函数返回的结果不是 SequenceType 的时候。因为这样的话，flatMap 就会调到我们当前讨论的这种重载形式。而这种重载形式和 map 的差异就仅仅在于要不要判断结果为 nil。 下面是一个示例代码，可以看出：brr 和 crr 虽然分别使用 map 和 flatMap 生成，但是结果完全一样： let arr = [1, 2, 4]// arr = [1, 2, 4]let brr = arr.map &#123; &quot;No.&quot; + String($0)&#125;// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;]let crr = arr.flatMap &#123; &quot;No.&quot; + String($0)&#125;// crr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;] Optional 的 map 和 flatMap 源码看完数组的实现，我们再来看看 Optional 中的相关实现。源码地址是：https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift，摘录如下： /// If `self == nil`, returns `nil`. /// Otherwise, returns `f(self!)`.public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) rethrows -&gt; U? &#123; switch self &#123; case .Some(let y): return .Some(try f(y)) case .None: return .None &#125;&#125;/// Returns `nil` if `self` is `nil`, /// `f(self!)` otherwise.@warn_unused_resultpublic func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U?) rethrows -&gt; U? &#123; switch self &#123; case .Some(let y): return try f(y) case .None: return .None &#125;&#125; Optional 的这两函数真的是惊人的相似，如果你只看两段函数的注释的话，甚至看不出这两个函数的差别。 这两函数实现的差别仅仅只有两处： f 函数一个返回 U，另一个返回 U? 。 一个调用的结果直接返回，另一个会把结果放到 .Some 里面返回。 两个函数最终都保证了返回结果是 Optional 的。只是将结果转换成 Optional 的位置不一样。 这就像我老婆给我说：「我喜欢这个东西，你送给我吗？不送的话我就直接刷你卡买了！」。。。买东西的结果本质上是一样的，谁付钱本质上也是一样的，差别只是谁动手而已。 既然 Optional 的 map 和 flatMap 本质上是一样的，为什么要搞两种形式呢？这其实是为了调用者更方便而设计的。调用者提供的闭包函数，既可以返回 Optional 的结果，也可以返回非 Optional 的结果。对于后者，使用 map 方法，即可以将结果继续转换成 Optional 的。结果是 Optional 的意味着我们可以继续链式调用，也更方便我们处理错误。 我们来看一段略烧脑的代码，它使用了 Optional 的 flatMap 方法： var arr = [1, 2, 4]let res = arr.first.flatMap &#123; arr.reduce($0, combine: max)&#125;````这段代码的功能是：计算出数组中的元素最大值，按理说，求最大值直接使用 `reduce` 方法就可以了。不过有一种特殊情况需要考虑：即数组中的元素个数为 0 的情况，在这种情况下，没有最大值。我们使用 Optional 的 `flatMap` 方法来处理了这种情况。arr 的 `first` 方法返回的结果是 Optional 的，当数组为空的时候，`first` 方法返回 .None，所以，这段代码可以处理数组元素个数为 0 的情况了。## 烧脑的 `map` 和 `flatMap`### 关于取名![](http://ww1.sinaimg.cn/large/65dc76a3gw1f0sygrb8chj20c606egmg.jpg)&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&gt;&gt;-- Phil Karlton有一位大师说，计算机世界真正称得上难题的就只有两个：第一个是缓存过期问题，第二个就是取名字。作为文章最后的烧脑环节，我们来聊聊取名字这个事吧。我来提几个看起来「无厘头」的问题： * 数组的 `map` 函数和 Optinal 的 `map` 函数的实现差别巨大？但是为什么都叫 `map` 这个名字？ * 数组的 `flatMap` 函数和 Optinal 的 `flatMap` 函数的实现差别巨大？但是为什么都叫 `flatMap` 这个名字？ * 数组的 `flatMap` 有两个重载的函数，两个重载的函数差别巨大，但是为什么都叫 `flatMap` 这个名字？在我看来，这样的取名其实都是有背后的原因的，我试着分享一下我的理解。我们先说结论，然后再解释。这段结论来自：&lt;http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/&gt;。 * 数组和 Optional 的 `map` 函数都叫一样的名字，是因为它们都是 [Functor](https://en.wikipedia.org/wiki/Functor)。 * 数组和 Optinal 的 `flatMap` 函数都叫一样的名字，是因为它们都是 [Monad](https://en.wikipedia.org/wiki/Monad_(functional_programming))。![](http://ww3.sinaimg.cn/large/65dc76a3gw1f0scj26hf9j205805k3yk.jpg)好吧，我猜你心里开始骂娘了：「为了解释一个问题，引入了两个新问题：谁知道什么是 Functor 和 Monad ！」不要着急，我们先说严谨的结论有助于更好地总结和归纳，我下面试着解释一下 Functor 和 Monad 。### FunctorFunctor 在 [Wikipedia](https://en.wikipedia.org/wiki/Functor) 上的定义非常学术。我想了一个相对比较容易理解的定义：所谓的 Functor，就是可以把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。通常情况下，我们会把这个函数叫做 `map`。什么叫做「封装过的值」呢？数组就是对值的一种封装，Optional 也是对值的一种封装。如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum（如下所示）。 enum Result { case Success(T) case Failure(ErrorType)} 一个值能否成为「封装过的值」，取决于这个值的类型所表示的集合，通过 `map` 函数，能否映射到一个新集合中。这个新集合，也要求能够继续使用 `map` 函数，再映射到另外一个集合。我们拿数组和 Optional 类型来检查这个规则，就会发现是符合的： * 数组可以通过 `map` 函数，生成一个新的数组，新的数组可以继续使用 `map` 函数。 * Optional 可以通过 `map` 函数，生成一个新的 Optional 变量，新的 Optional 变量可以继续使用 `map` 函数。所以，数组 和 Optional 都是 Functor。### Monad如果你能理解 [Functor](https://en.wikipedia.org/wiki/Functor)，那么 [Monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) 就相对容易一些了。所谓的 Monad，和 Functor 一样，也是把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。不过差别在于: * Functor 的函数定义是从「未封装的值」到「未封装的值」的 * Monad 的函数定义是从「未封装的值」到「封装后的值」的。下面我举例解释一下：刚刚我们说，数组 和 Optional 都是 Functor，因为它们支持用 `map` 函数做「封装过的值」所在集合的变换。那么，你注意到了吗？map 函数的定义中，输入的参数和返回的结果，都不是「封装过的值」，而是「未封装的值」。什么是「未封装的值」？ * 对于数组来说，「未封装的值」是数组里面一个一个的元素，map 函数的闭包接受的是一个一个的元素，返回的也是一个一个的元素。 * 对于 Optional 来说，「未封装的值」是 Optional 解包出来的值，map 函数的闭包接受的是解包出来的值，返回的也是解包出来的值。下面是数组的示例代码，我故意加上了闭包的参数，我们再观察一下。我们可以发现，`map` 的闭包接受的是 Int 类型，返回的是 String 类型，都是一个一个的元素类型，而不是数组。 &#x2F;&#x2F; map 的闭包接受的是 Int 类型，返回的是 String 类型，都是一个一个的元素类型，而不是数组。let arr &#x3D; [1, 2, 4]let brr &#x3D; arr.map { (element: Int) -&gt; String in “No.” + String(element)} 下面是 Optional 的示例代码，我也故意加上了闭包的参数。我们可以发现，`map` 的闭包接受的是 Int 类型，返回的是 Int 类型，都是非 Optional 的。 &#x2F;&#x2F; map 的闭包接受的是 Int 类型，返回的是 Int 类型，都是非 Optional 的。let tq: Int? &#x3D; 1tq.map { (a: Int) -&gt; Int in a * 2} 我们刚刚说，对于 Monad 来说，它和 Functor 的差异实在太小，小到就只有闭包的参数类型不一样。数组实现了 `flatMap` ，它就是一种 Monad，下面我们就看看 `flatMap` 在数组中的函数定义，我们可以看出，闭包接受的是数组的元素，返回的是一个数组（封装后的值）。 &#x2F;&#x2F; 闭包接受的是数组的元素，返回的是一个数组（封装后的值）let arr &#x3D; [1, 2, 3]let brr &#x3D; arr.flatMap { (element:Int) -&gt; [Int] in return [element * 2]} 下面是 `flatMap` 在 Optional 中的定义，我们可以看出，闭包接受的是 Int 类型，返回的是一个 Optional（封装后的值）。```。// 闭包接受的是 Int 类型，返回的是一个 Optional（封装后的值）let tq: Int? = 1tq.flatMap &#123; (a: Int) -&gt; Int? in if a % 2 == 0 &#123; return a &#125; else &#123; return nil &#125;&#125; 所以本质上，map 和 flatMap 代表着一类行为，我们把这类行为叫做 Functor 和 Monad。它们的差异仅仅在于闭包函数的参数返回类型不一样。所以，我们才会把数组和 Optional 这两个差别很大的类型，都加上两个实现差别很大的函数，但是都取名叫 map 和 flatMap。 多重 Optional我们在第一节烧脑文章中提到过多重 Optional，在使用 map 的时候不仔细，就会触发多重 Optional 的问题。比如下面这个代码，变量 b 因为是一个两层嵌套的 nil，所以 if let 失效了。 let tq: Int? = 1let b = tq.map &#123; (a: Int) -&gt; Int? in if a % 2 == 0 &#123; return a &#125; else &#123; return nil &#125;&#125;if let _ = b &#123; print(&quot;not nil&quot;)&#125; 解决办法是把 map 换成 flatMap 即可。 总结讨论完了，我们总结一下： 数组和 Optional 都能支持 map 和 flatMap 函数。 数组的 flatMap 有两个重载的实现，一个实现等价于先 map 再 flatten，另一个实现用于去掉结果中的 nil。 通过阅读源码，我们更加深入理解了 map 和 flatMap 函数内部的机制。 我们讨论了 map 和 flatMap 的取名问题，最后得出：一个类型如果支持 map，则表示它是一个 Functor；一个类型如果支持 flatMap，则表示它是一个 Monad。 我们讨论了 map 中使用不当造成的多重 Optional 问题。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"Swift 烧脑体操（三） - 高阶函数","slug":"swift-gym-3-higher-order-function","date":"2016-02-27T01:25:51.000Z","updated":"2024-01-16T01:48:51.532Z","comments":true,"path":"2016/02/27/swift-gym-3-higher-order-function/","permalink":"https://blog.devtang.com/2016/02/27/swift-gym-3-higher-order-function/","excerpt":"","text":"索引Swift 烧脑系列文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 前言Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。 Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。 这是本体操的第三节，练习前请做好准备运动，保持头脑清醒。 准备运动：基础知识 在上一节里面，我们其实已经涉及到了高阶函数了。在 Wikipedia 中，是这么定义高阶函数（higher-order function）的，如果一个函数： 接受一个或多个函数当作参数 把一个函数当作返回值 那么这个函数就被称作高阶函数。下面是一个简单的排序的例子，在这个例子中，传进去的参数就是一个函数： let numbers = [1, 4, 2, 3]let res = numbers.sort &#123; $0 &lt; $1&#125; Trailing Closure Syntax上面的代码看着不像是函数作为参数存在，这是因为 Swift 的 Trailing Closure 特性。Swift 允许当函数的最后一个参数是闭包的时候，以紧跟 &#123; &#125; 的形式，将最后一个闭包的内容附加在函数后面。 所以，以下两行代码是等价的： // 正常写法，函数是作为 sort 的参数arr.sort(&#123; $0 &lt; $1 &#125;)// Trailing Closure 写法，更简洁明了arr.sort &#123; $0 &lt; $1 &#125; 常见用法示例高阶函数在 Swift 语言中有大量的使用场景，我们先来看一看常见的用法： 遍历我们可以用 map 方法来对数组元素进行某种规则的转换，例如： let arr = [1, 2, 4]// arr = [1, 2, 4]let brr = arr.map &#123; &quot;No.&quot; + String($0)&#125;// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;] 求和我们可以用 reduce 方法，来对数组元素进行某种规则的求和（不一定是加和）。 let arr = [1, 2, 4]// arr = [1, 2, 4]let brr = arr.reduce(0) &#123; (prevSum: Int, element: Int) in return prevSum + element&#125;// brr = 7let crr = arr.reduce(&quot;&quot;) &#123; if $0 == &quot;&quot; &#123; return String($1) &#125; else &#123; return $0 + &quot; &quot; + String($1) &#125;&#125;// crr = &quot;1 2 4&quot; 筛选我们可以利用 filter 方法，来对数组元素进行某种规则的过滤，例如： let arr = [1, 2, 4]// arr = [1, 2, 4]let brr = arr.filter &#123; $0 % 2 == 0&#125;// brr = [2, 4] 遍历即使是以前最简单的遍历，我们也可以用高阶函数的写法，将遍历需要的操作，以函数参数的形式传入 forEach 方法中，例如： let arr = [1, 2, 4]arr.forEach &#123; print($0)&#125; 烧脑体操下面我们来看看高阶函数一些比较烧脑的细节。 用高阶函数来隐藏私有变量高阶函数使得代码逻辑可以用函数为主体来进行封装，下面我将详细解释一下这句话。 在面向对象的世界里，逻辑存在的基本单元是对象，每个对象代表着一个最小可复用模块。在对象的内部，由高内聚的成员变量和成员函数构成。这些函数相互调用，并且操作对象的内部成员变量，最终对外产生可预期的行为。 但是利用高阶函数，我们可以同样做到与对象类似的，高内聚的成员变量和成员函数，下面我就举一个具体的例子。 下面的代码中，我们用类的方式，实现了一个 Clock 类， Clock 类实现了一个 getCount 方法，每次调用的时候返回的值 +1。为了测试代码，我们定义了两个实例 c1 和 c2，它们都可以正常输出预期的值。 class Clock &#123; var count: Int = 0 func getCount() -&gt; Int &#123; return ++count; &#125;&#125;let c1 = Clock()c1.getCount() // 得到 1c1.getCount() // 得到 2let c2 = Clock()c2.getCount() // 得到 1 那么接下来，我们用高阶函数的方式，来做一下同样的事情。我们先看代码： func getClock() -&gt; () -&gt; Int &#123; var count: Int = 0 let getCount = &#123; () -&gt; Int in ++count; &#125; return getCount&#125;let c1 = getClock()c1() // 得到 1c1() // 得到 2let c2 = getClock()c2() // 得到 1 在上面的代码中，我们这里定义了一个 getClock 函数，这个函数可以返回一个 getCount 函数。然后，不太一样的地方是，这个 getCount 函数持有了一个外部的变量 count。于是，这个函数也变得有了状态（或者你也可以说它有了 Side Effect）。每次调用这个函数的时候，返回的值都会变化。 另一方面，因为count变量是 getClock 这个高阶函数的内部变量，所以它并没有像全局变量一样使得封装性被打破。getClock函数仍然可以看作一个高内部的可复用模块，并且对外隐藏了实现细节。 所以，Swift 语言的高阶函数以及闭包可以 capture 外部变量的特性，使得代码逻辑可以以函数作为主体来进行封装，这将使得我们的代码组织更加灵活。 当然，如果滥用，这也会造成代码组织变得更加混乱。 面试题题目一另一个烧脑的故事是来自于一个朋友的面试题。在面试中，面试官要求他用数组的 reduce 方法实现 map 的功能。 这个题目实在是非常蛋疼，不过用来烧脑倒是不错，大家感兴趣的话可以先想想，再翻下面的参考答案。 题目二不过说回来，虽然题目一有些奇怪，但是它确实考查了对于高阶函数灵活使用以及对 reduce 方法的理解。大家还可以试试这些题目： 问题一：用 reduce 方法找出数组中的最大值。 问题二：用 reduce 方法一次求出数组中奇数的和、以及偶数乘积。 题目三高阶函数另一个魔力就是可以链式调用，大家可以尝试这么一道题目：求一个数组中偶数的平方和。 参考答案题目一let arr = [1, 3, 2]let res = arr.reduce([]) &#123; (a: [Int], element: Int) -&gt; [Int] in var t = Array(a) t.append(element * 2) return t&#125;// res = [2, 6, 4] 题目二问题二的参考答案： let arr = [1, 3, 2, 4]let res: (Int, Int) = arr.reduce((0, 1)) &#123; (a :(Int, Int), element: Int) -&gt; (Int, Int) in if element % 2 == 0 &#123; return (a.0, a.1 * element) &#125; else &#123; return (a.0 + element, a.1) &#125;&#125;// res = (4, 8) 题目三以下是参考答案： let arr = [1, 3, 2, 4]let res = arr.filter &#123; $0 % 2 == 0 &#125;.map &#123; $0 * $0 &#125;.reduce(0) &#123; $0 + $1 &#125; 总结总结一下本次烧脑锻炼到的脑细胞： 学习了 Swift 语言中的一些使用高阶函数的示例，包括 map, reduce, filter 等。 学习了利用高阶函数来构造以函数为主体的功能模块。 练习了一些奇怪的面试题。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"Swift 烧脑体操（二） - 函数的参数","slug":"swift-gym-2-function-argument","date":"2016-02-27T01:23:29.000Z","updated":"2024-01-16T01:49:43.041Z","comments":true,"path":"2016/02/27/swift-gym-2-function-argument/","permalink":"https://blog.devtang.com/2016/02/27/swift-gym-2-function-argument/","excerpt":"","text":"索引Swift 烧脑系列文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 前言Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。 Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。 这是本体操的第二节，练习前请做好准备运动，保持头脑清醒。 准备运动：基础知识面向对象语言的世界观对于很多面向对象的编程语言来说，在思考问题时，总是把「对象」作为考虑问题的基本出发点。 面向对象的程序设计通过以下三大规则，构建出程序设计的基础，它们是： 封装（Encapsulation），将一个相对独立的逻辑涉及的变量和函数放到一个类中，然后对外暴露少量接口，使其高内聚，低耦合。 继承（Inheritance），子类可以继承父类的变量和函数，并且可以修改或扩展父类的行为。 多态（Polymorphism），父类的指针可以指向子类的实例，在运行时程序语言支持找到子类对应的函数实现。 在以上三大准则的基础上，再引入一些设计原则，比如： 单一职责原则（Single Responsibility），每个类只应该做一件事情。 不要重复原则（Don’t Repeat Yourself），相同（或相似）的代码不应该重复两次。 好的组合优于继承（Better Composition over Inheritance），尽量使用组合而不是继承来设计。 于是，程序世界就基于这些规则和原则，产生出了设计模式，进而能更加精准地指导我们的编程行为。这就像我们学习几何，先学习几条公理，然后以后的大量定理都通过公理证明而来。 举个例子，单例模式（Singleton Pattern）其实就是封装和单一职责原则的产物。代理模式（Delegate Pattern) 也是单一职责和封装中的面向接口设计的思想的产物。 但是，在面向对象语言的世界观里面，函数都是作为一个附属物存在的。函数通常附属于一个具体类的某个方法中。或许有一个函数它根本都不需要任何对象作为容器，为了这个世界的统一，我们还是会构造一个类，把这个函数放进去。比如，在小猿搜题中，我们就有一个叫 ImageUtils 的类，里面放了操作图像的各种各样的静态方法，有一些图象操作函数其实也不太通用，但是总得找一个类放不是。 在一些面向对象语言的世界中，如果把对象称作 OOP 的一等公民的话，那么函数就是二等公民。 函数式编程在 Swift 的世界中，函数并不是二等公民。是的，Swift 引入了大量函数式编程的特性，使得我们能够把函数当作一等公民来对待。 一等公民有什么权利呢？那就是函数可以像对象一样，被赋值、被当作参数传递、参与计算或者当作结果被返回。 我们先来看一段函数被赋值的例子，在下例中，我们将一个函数赋值给一个名为 myFunc 的变量，然后调用它。 let myFunc = &#123; () -&gt; String in return &quot;Tang Qiao&quot;&#125;let value = myFunc()// value 的值为 &quot;Tang Qiao&quot; 我们再来看一个函数被当作运算结果返回的例子。在这个例子中，我们希望构造一个「加法器」工厂，这个工厂能够接受一个参数 addValue，返回一个加法器函数，这个加法器函数能够将传递的参数加 addValue 之后返回。以下是实现的代码： func addFactory(addValue: Int) -&gt; (Int -&gt; Int) &#123; func adder(value: Int) -&gt; Int &#123; return addValue + value &#125; return adder&#125; 有了上面这个函数，我们就可以构造一个 +2 的函数，然后使用它，如下所示： let add2 = addFactory(2) // 构造一个 +2 的函数let result = add2(3) // 运算，传入 3，得到 5 函数的参数但是在本次「烧脑体操」中，全面介绍函数式编程明显不太现实，所以我们仅从函数的参数来深入学习一下，看看在 Swift 语言中，函数的参数能够有多复杂。 参数的省略我们先来简单看看函数参数的省略吧，因为有类型推导，函数的参数在 Swift 中常常可以被省略掉，特别以匿名函数（闭包）的形式存在的时候。 我们来看一个数组排序的例子： let array = [1, 3, 2, 4]let res = array.sort &#123; (a: Int, b: Int) -&gt; Bool in return a &lt; b&#125; 如果一个函数返回类型可以通过推导出来，则返回类型可以省略。所以以上代码中的 -&gt; Bool 可以删掉，变成： let array = [1, 3, 2, 4]let res = array.sort &#123; (a: Int, b: Int) in return a &lt; b&#125; 如果一个函数的参数类型可以推导出来，则参数的类型可以省略。所以以上代码中的 : Int 可以删掉，变成： let array = [1, 3, 2, 4]let res = array.sort &#123; (a, b) in return a &lt; b&#125; 如果函数参数的个数可以推导出来，也可以不写参数。那怎么使用这些参数呢？可以用 $0, $1 这样的方式来引用参数。所以以上代码中的 (a, b) 可以删掉，因为这样的话，参数和返回值都省略了，所以in也可以省略了，变成： let array = [1, 3, 2, 4]let res = array.sort &#123; return $0 &lt; $1&#125; Swift 还有一个规则，如果函数的 body 只有一行，则可以把 return 关键字省略了，所以以上代码可以进一步简化成： let array = [1, 3, 2, 4]let res = array.sort &#123; $0 &lt; $1&#125; 最后一个简化规则更加暴力，因为 &lt; 符号也是一个函数，它接受的参数个数，类型和返回值与 sort 函数需要的一样，所以可以直接简化成： let array = [1, 3, 2, 4]let res = array.sort( &lt; ) 拿这个的方法，同样可以把我们刚刚写的 addFactory 做简化，最后简化成如下的形式： // 简化前func addFactory(addValue: Int) -&gt; (Int -&gt; Int) &#123; func adder(value: Int) -&gt; Int &#123; return addValue + value &#125; return adder&#125;// 简化后func addFactory(addValue: Int) -&gt; (Int -&gt; Int) &#123; return &#123; addValue + $0 &#125;&#125; 函数参数中的其它关键字有些时候，我们的函数接受的参数就是另外一个函数，例如 sort，map，所以我们在看代码的时候，需要具备熟悉这种写法的能力。 我们来看看数组的 map 函数的定义吧： public func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T] 这个函数定义中出现了几个我们刚刚没提到的关键词，我们先学习一下。 @noescape@noescape，这是一个从 Swift 1.2 引入的关键字，它是专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。以下是苹果的文档原文： A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments. 什么情况下一个闭包参数会跳出函数的生命期呢？很简单，我们在函数实现内，将一个闭包用 dispatch_async 嵌套，这样这个闭包就会在另外一个线程中存在，从而跳出了当前函数的生命期。这样做主要是可以帮助编译器做性能的优化。 如果你对此感兴趣，这里有一些更详细的介绍供你学习： https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521 http://nshint.io/blog/2015/10/23/noescape-attribute/ throws 和 rethrowsthrows 关键字表示：这个函数（闭包）可能抛出异常。而 rethrows 关键字表示：这个函数如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。 throws 关键字的存在大家都应该能理解，因为总有一些异常可能在设计的时候希望暴露给上层，throws 关键字的存在使得这种设计成为可能。 那么为什么会有 rethrows 关键字呢？在我看来，这是为了简化很多代码的书写。因为一旦一个函数会抛出异常，按 Swift 类型安全的写法，我们就需要使用 try 语法。但是如果很多地方都需要写 try 的话，会造成代码非常啰嗦。 rethrows 关键字使得一些情况下，如果你传进去的闭包不会抛出异常，那么你的调用代码就不需要写 try。 如果你对此感兴趣，这里有一些更详细的介绍供你学习： http://robnapier.net/re-throws 函数作为函数的参数刚刚说到，函数作为一等公民，意味着函数可以像对象一样，被当作参数传递或者被当作值返回。对此，我们专门有一个名称来称呼它，叫做高阶函数（higher-order function）。 在刚刚那个数组的 map 函数中，我们就看到了它接着另外一个函数作为参数，这个函数接受数组元素类型作为参数，返回一个新类型。 public func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T] 有了 map 函数，我们就可以轻松做数组元素的变换了。如下所示： let arr = [1, 2, 4]// arr = [1, 2, 4]let brr = arr.map &#123; &quot;No.&quot; + String($0)&#125;// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;] 烧脑的参数好了，现在进入参数烧脑游戏的正式环节。 我们需要构造一个工厂函数，这个函数接受两个函数作为参数，返回一个新的函数。新函数是两个函数参数的叠加作用效果。 举一个具体的例子，假如我们有一个 +2 的函数，有一个 +3 的函数，那用这个工厂函数，我们可以得到一个 +5 的函数。 又比如我们有一个 *2 的函数，有一个 *5 的函数，用这个工厂函数，我们就可以得到一个 *10 的函数。 那这个函数如何写呢？我们先看答案吧： func funcBuild(f: Int -&gt; Int, _ g: Int -&gt; Int) -&gt; Int -&gt; Int &#123; return &#123; f(g($0)) &#125;&#125;let f1 = funcBuild(&#123;$0 + 2&#125;, &#123;$0 + 3&#125;)f1(0) // 得到 5let f2 = funcBuild(&#123;$0 * 2&#125;, &#123;$0 * 5&#125;)f2(1) // 得到 10 这个函数充分反映了函数作为一等公民的地位。但是，我们同时也看出来，函数作为参数存在时，对于程序的可读性带来了挑战。好在我们有 typealias，通过 typealias，我们可以将函数的类型写得更加易读，比如上面的代码，就可以修改成如下形式： typealias IntFunction = Int -&gt; Intfunc funcBuild(f: IntFunction, _ g: IntFunction) -&gt; IntFunction &#123; return &#123; f(g($0)) &#125;&#125; 现在看看代码，是不是清晰了很多？ 参数中的范型当函数中的参数再引入范型之后，函数的功能更加强大，但是可读性进一步下降。比如刚刚的例子，限制函数只能是 Int -&gt; Int 其实是没有必要的，我们将两个函数拼成一个函数，只需要保证一个函数的输出类型，与另一个函数的输入类型匹配即可。所以，刚刚的例子，可以进一步用范型改造： func funcBuild&lt;T, U, V&gt;(f: T -&gt; U, _ g: V -&gt; T) -&gt; V -&gt; U &#123; return &#123; f(g($0)) &#125;&#125;let f3 = funcBuild(&#123; &quot;No.&quot; + String($0) &#125;, &#123;$0 * 2&#125;)f3(23) // 结果是 &quot;No.46&quot; 在上面这个例子中，我们保证函数 g 的输出类型是 T，函数 f 的输入类型是 T。这样，在例子中，我们将一个 *2 的函数与一个数字转字符串的函数拼接起来，构造出一个先乘 2，再转字符串的函数。 相应的例子还有很多，比如 WWDC 中就介绍过一个给函数增加缓存机制的代码，在该代码中，任意一个不带缓存功能的函数，经过改造，都可以变成一个带缓存功能的函数。代码如下，大家可以自行学习一下： func memoize&lt;T: Hashable, U&gt;( body: (T)-&gt;U ) -&gt; (T-&gt;U) &#123; var memo = Dictionary&lt;T, U&gt;() return &#123; x in if let q = memo[x] &#123; return q &#125; let r = body(x) memo[x] = r return r &#125;&#125; 总结总结一下本次烧脑锻炼到的脑细胞： Swift 是一个结合面向对象编程和函数式编程特性的语言。 函数在 Swift 中是一等公民，可以被赋值、被当作参数传递、参与计算、当作结果被返回或被动态创建。 因为有类型推导，函数的参数有各种省略规则。 函数作为参数时，有 @noescape，throw 和 rethrow 关键字需要了解。 函数作为参数时，不易阅读。合理使用 typealias 可以使源码结构更清晰。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"Swift 烧脑体操（一） - Optional 的嵌套","slug":"swift-gym-1-nested-optional","date":"2016-02-27T01:21:32.000Z","updated":"2024-01-16T01:52:29.399Z","comments":true,"path":"2016/02/27/swift-gym-1-nested-optional/","permalink":"https://blog.devtang.com/2016/02/27/swift-gym-1-nested-optional/","excerpt":"","text":"索引Swift 烧脑系列文章列表： Swift 烧脑体操（一） - Optional 的嵌套 Swift 烧脑体操（二） - 函数的参数 Swift 烧脑体操（三） - 高阶函数 Swift 烧脑体操（四） - map 和 flatMap Swift 烧脑体操（五）- Monad Swift 烧脑体操（六）- 类型推断 前言Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。 Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。 这是本体操的第一节，练习前请做好准备运动，保持头脑清醒。 准备运动：Optional 的介绍 王巍的《Swifter》(http://swifter.tips/buy)一书中，介绍了一个有用的命令：在 LLDB 中输入 fr v -R foo，可以查看 foo 这个变量的内存构成。我们稍后的分析将用到这个命令。 在 Swift 的世界里，一切皆对象，包括 Int Float 这些基本数据类型，所以我们可以这么写：print(1.description)。 而对象一般都是存储在指针中，Swift 也不例外，这就造成了一个问题，指针为空的情况需要处理。在 Objective-C 中，向一个 nil 的对象发消息是默认不产生任何效果的行为，但是在 Swift 中，这种行为被严格地禁止了。 Swift 是一个强类型语言，它希望在编译期做更多的安全检查，所以引入了类型推断。而类型推断上如果要做到足够的安全，避免空指针调用是一个最基本的要求。于是，Optional 这种类型出现了。Optional 在 Swift 语言中其实是一个枚举类型： public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123; case None case Some(Wrapped)&#125; Optional 的嵌套Optional 类型的变量，在使用时，大多需要用if let的方式来解包。如果你没有解包而直接使用，编辑器通过类型推断会提示你，所以看起来这套机制工作得很好。但是，如果 Optional 嵌套层次太多，就会造成一些麻烦，下面我们来看一个例子。 let a: Int? = 1let b: Int?? = alet c: Int??? = b 在这个机制中，1 这个 Int 值被层层 Optional 包裹，我们用刚刚提到的fr v -R，可以很好的看出来内部结构。如下图： (lldb) fr v -R a(Swift.Optional&lt;Swift.Int&gt;) a = Some &#123; Some = &#123; value = 1 &#125;&#125;(lldb) fr v -R b(Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;) b = Some &#123; Some = Some &#123; Some = &#123; value = 1 &#125; &#125;&#125;(lldb) fr v -R c(Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) c = Some &#123; Some = Some &#123; Some = Some &#123; Some = &#123; value = 1 &#125; &#125; &#125;&#125; 从这个示例代码中，我们能看出来多层嵌套的 Optional 的具体内存结构。这个内存结构其实是一个类似二叉树一样的形状，如下图所示： 第一层二叉树有两个可选的值，一个值是 .None，另一个值类型是 Optional&lt;Optional&lt;Int&gt;&gt;。 第二层二叉树有两个可选的值，一个值是 .None，另一个值类型是 Optional&lt;Int&gt;。 第三层二叉树有两个可选的值，一个值是 .None，另一个值类型是 Int。 那么问题来了，看起来这个 Optional.None 可以出现在每一层，那么在每一层的效果一样吗？我做了如下实验： let a: Int? = nillet b: Int?? = alet c: Int??? = blet d: Int??? = nil 如果你在 playground 上看，它们的值都是 nil，但是它们的内存布局却不一样，特别是变量 c 和 变量 d： (lldb) fr v -R a(Swift.Optional&lt;Swift.Int&gt;) a = None &#123; Some = &#123; value = 0 &#125;&#125;(lldb) fr v -R b(Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;) b = Some &#123; Some = None &#123; Some = &#123; value = 0 &#125; &#125;&#125;(lldb) fr v -R c(Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) c = Some &#123; Some = Some &#123; Some = None &#123; Some = &#123; value = 0 &#125; &#125; &#125;&#125;(lldb) fr v -R d(Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) d = None &#123; Some = Some &#123; Some = Some &#123; Some = &#123; value = 0 &#125; &#125; &#125;&#125; 变量 c 因为是多层嵌套的 nil，所以它在最外层的二叉树上的值，是一个 Optional&lt;Optional&lt;Int&gt;&gt;。 变量 d 因为是直接赋值成 nil，所以它在最外层的二叉树上的值，是一个 Optional.None。 麻烦的事情来了，以上原因会造成用 if let 来判断变量 c 是否为 nil 失效了。如下代码最终会输出 c is not none。 let a: Int? = nillet b: Int?? = alet c: Int??? = blet d: Int??? = nilif let _ = c &#123; print(&quot;c is not none&quot;)&#125; 解释在我看来，这个问题的根源是：一个 Optional 类型的变量可以接受一个非 Optional 的值。拿上面的代码举例，a 的类型是 Int?，b 的类型是 Int??，但是 a 的值却可以赋值给 b。所以，变量 b（类型为 Int??），它可以接受以下几种类型的赋值： nil 类型 Int? 类型 Int?? 类型 按理说，Swift 是强类型，等号左右两边的类型不完全一样，为什么能够赋值成功呢？我查了一下 Optional 的源码，原来是对于上面第 1，2 种类型不一样的情况，Optional 定义了构造函数来构造出一个 Int?? 类型的值，这样构造之后，等号左右两边就一样了。源码来自 https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift，我摘录如下： public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123; case None case Some(Wrapped) @available(*, unavailable, renamed=&quot;Wrapped&quot;) public typealias T = Wrapped /// Construct a `nil` instance. @_transparent public init() &#123; self = .None &#125; /// Construct a non-`nil` instance that stores `some`. @_transparent public init(_ some: Wrapped) &#123; self = .Some(some) &#125;&#125; 以上代码中，Optional 提供了两种构造函数，完成了刚刚提到的类型转换工作。 烧脑体操好了，说了这么多，我们下面开始烧脑了，以下代码来自傅若愚（https://github.com/lingoer）在不久前 Swift 大会（http://atswift.io/#speaker）上的一段分享： var dict :[String:String?] = [:]dict = [&quot;key&quot;: &quot;value&quot;]func justReturnNil() -&gt; String? &#123; return nil&#125;dict[&quot;key&quot;] = justReturnNil()dict 以下是代码执行结果： 我们可以看到，我们想通过给这个 Dictionary 设置一个 nil，来删除掉这个 key-value 对。但是从 playground 的执行结果上看，key 并没有被删掉。 为了测试到底设置什么样的值，才能正常地删掉这个 key-value 键值对，我做了如下实验： var dict :[String:String?] = [:]// first trydict = [&quot;key&quot;: &quot;value&quot;]dict[&quot;key&quot;] = Optional&lt;Optional&lt;String&gt;&gt;.Nonedict// second trydict = [&quot;key&quot;: &quot;value&quot;]dict[&quot;key&quot;] = Optional&lt;String&gt;.Nonedict// third trydict = [&quot;key&quot;: &quot;value&quot;]dict[&quot;key&quot;] = nildict// forth trydict = [&quot;key&quot;: &quot;value&quot;]let nilValue:String? = nildict[&quot;key&quot;] = nilValuedict// fifth trydict = [&quot;key&quot;: &quot;value&quot;]let nilValue2:String?? = nildict[&quot;key&quot;] = nilValue2dict 执行结果如下： 我们可以看到，以下三种方式可以成功删除 key-value 键值对： dict[&quot;key&quot;] = Optional&lt;Optional&lt;String&gt;&gt;.None dict[&quot;key&quot;] = nil let nilValue2:String?? = nil; dict[&quot;key&quot;] = nilValue2 所以，在这个烧脑之旅中，我们发现，一个 [String: String?] 的 Dictionary，可以接受以下类型的赋值： nil String String? String?? 如果要删除这个 Dictionary 中的元素，必须传入 nil 或 Optional&lt;Optional&lt;String&gt;&gt;.None ，而如果传入 Optional&lt;String&gt;.None，则不能正常删除元素。 好吧，实验出现象了，那这种现象的原因是什么呢？ 还好苹果把它的实现开源了，那我们来一起看看吧，源文件来自：https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb，以下是关键代码。 public subscript(key: Key) -&gt; Value? &#123; get &#123; return _variantStorage.maybeGet(key) &#125; set(newValue) &#123; if let x = newValue &#123; // FIXME(performance): this loads and discards the old value. _variantStorage.updateValue(x, forKey: key) &#125; else &#123; // FIXME(performance): this loads and discards the old value. removeValueForKey(key) &#125; &#125;&#125; 所以，当 Dictionary 的 value 类型为 String 时，如果你要设置它的值，它接受的是一个 String? 类型的参数。而因为我们刚刚例子中的 value 类型为 String?，所以正常情况下它需要的是一个 String?? 类型的参数。在上面的失败的例子中，我们传递的是一个 String? 类型的值，具体值为 Optional&lt;String&gt;.None，于是在执行时就会按以下的步骤来进行： 我们传递一个值为 Optional&lt;String&gt;.None，类型为 String? 的参数。 因为传的参数类型是 String?，而函数需要的是 String??，所以会执行 Optional 的构造函数，构造一个两层的 Optional。 这个两层 Optional 的值为 Optional.Some(&lt;Optional&lt;String&gt;.None&gt;) 进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，因为两层的 Optional，所以 if let 判断它不是 nil。 所以代码执行到 _variantStorage.updateValue(x, forKey: key)，把 Optional.None 当成值，设置给了相应的 key。 如果你没理解，可以再翻翻最初我们对多层嵌套 nil 变量的实验和分析。 我们再看看传递参数是 Optional&lt;Optional&lt;String&gt;&gt;.None 的情况，步骤如下： 我们传递一个值为 Optional&lt;Optional&lt;String&gt;&gt;.None，类型为 String?? 的参数。 因为参数类型是 String??，函数需要的类型也是 String??，所以参数不经变换，直接进入函数调用中。 这个时候参数的值不变，还是 Optional&lt;Optional&lt;String&gt;&gt;.None。 进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，Optional&lt;Optional&lt;String&gt;&gt;.None 用 if let 判断，得到它是 nil。 所以代码执行到 removeValueForKey(key)，Dictionary 删除了相应的 key-value 键值对。 总结好了，「烧脑体操」第一节就做完了，运动一下是不是感觉神清气爽？ 总结一下本次烧脑锻炼到的脑细胞： Optional 可以多层嵌套。 因为 Optional 的构造函数支持，所以可以将一个类型为 T 的值，赋值给一个类型为 T? 的变量。 因为 Optional 的构造函数支持，所以可以将 nil 赋值给一个任意嵌套层数的 Optional 变量。 将 Optional 嵌套的内容是 nil 时，大家要小心 if let 操作失效问题。 多层 Optional 嵌套容易烧脑细胞，尽量避免在工程中使用或触发。 遇到问题可以翻翻苹果在 Github 开源的 Swift 源码。 愿大家玩得开心！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"从 Octopress 迁移到 Hexo","slug":"from-octopress-to-hexo","date":"2016-02-16T11:05:46.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/02/16/from-octopress-to-hexo/","permalink":"https://blog.devtang.com/2016/02/16/from-octopress-to-hexo/","excerpt":"","text":"序言我的博客之前一直使用的是 Octopress，不过 Octopress 已经很久没有更新了。而且 Octopress 是基于 Ruby 的，生成博客文章的速度真的是非常非常慢，每次我使用 rake preview 命令时，我的 MacBook 的 CPU 就会狂转。最新的一次我试图在新 MBP 上搭建 Octopress 博客环境失败了，这让我打定主意更换掉它。 之后我调研了一下，最终决定迁移到 Hexo，主要的原因是： Hexo 的原理和 Octopress 一样，都是生成静态文件，这样可以方便地托管到 GitHub 和 GitCafe 上。 Hexo 是基于 Node 的，而 Node 的速度非常快。 Hexo 对 Octopress 的迁移很友好，图片引用方式完全一样，所以我的博客文章不需要做什么改动。 迁移本来应该在春节前就做完的，不过我在选择 Hexo 的主题上犯难了，Hexo 自带的主题丑极了，而我试了将近 10 个主题，都不满意。最终，我发现了 SwiftGG 使用的主题 Jacman，于是决定就它了！ 整个迁移过程大概如下： 安装 Hexo首先使用如下命令安装 Hexo： npm install -g hexo-cli 创建一个新的博客接着我们创建一个新的博客目录： $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 以上命令完成后，会在目标目录生成以下的目录结构： .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 相比 Octopress，Hexo 的目录结构更加简单： _config.yml 是博客的配置文件。 scaffolds 是博客文章模板。 source 是博客文章目录。 themes 存放主题风格文件。 迁移和配置迁移起来还是很方便，把以前 Octopress 的 source/_post 目录下的文章，拷贝到 Hexo 的同名目录下即可。 以前的图片目录，也可以直接拷贝到 source/images 目录下。 Google 统计相关的设置可以在 jacman 的 _config.yml 文件中配置。我以前用的评论系统太旧了，这次正好换成了多说，同样也是在 jacman 的配置文件中设置。 修改界面选择 Hexo 的另一个原因就是它的结构很简单，比较方便我定制。我在迁移完博客文章后，对 jacman 主题进行了一些定制。删掉了底部的作者介绍，然后在右侧边栏加上了我的微信公众号介绍。如果你想看看我是如何定制的，可以直接查看我 Fork 出来的 jacman 项目上的 Commits 即可，项目地址在 这里。 发布文章Hexo 支持直接发布到 GitHub，不过我在配置好 _config.yml 文件后，执行 Hexo deploy 一直失败！Hexo 一直卡在生成页面过程中，没有任何报错，这使得我也不知道如何修复它。 最终，我自己写了一个小脚本来做发布工作： #! /bin/zshhexo cleanhexo generatecd publicgit initgit add .git commit -m &quot;update at `date` &quot;git remote add origin git@github.com:tangqiaoboy/tangqiaoboy.github.com.git &gt;&gt; /dev/null 2&gt;&amp;1echo &quot;### Pushing to Github...&quot;git push origin master -fecho &quot;### Done&quot;git remote add gitcafe git@gitcafe.com:tangqiaoboy/tangqiaoboy.git &gt;&gt; /dev/null 2&gt;&amp;1echo &quot;### Pushing to GitCafe...&quot;git push gitcafe master:gitcafe-pages -fecho &quot;### Done&quot; 如果你遇到了和我一样问题的话，把以上脚本稍做修改应该也能很好地工作。 总结Octopress 已经过时，建议有时间的朋友都可以尝试替换掉它。Hexo 算不上完美，但还算是一个不错的替代方案。","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://blog.devtang.com/tags/blog/"}]},{"title":"人员、流程和产品上的思考 - 读《启示录》总结","slug":"inspired-summary","date":"2016-02-16T05:32:33.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/02/16/inspired-summary/","permalink":"https://blog.devtang.com/2016/02/16/inspired-summary/","excerpt":"","text":"《启示录：打造用户喜爱的产品》 出版于 2011 年，作为最早一批出版的关于产品经理图书，直到现在仍然非常畅销。它的作者是 eBay 前产品副总裁 Marty Cagan。 Marty Cagan 的这本书有点文集的感觉，从任何一章开始读，都不会感觉到突兀。很多文章最初应该是以博客的形式发表在 http://www.svpg.com/articles/ 网站上的。整体上图书的文章分为三大部分：人员、流程和产品。以下是一些读书总结。 人员图书的第一部分是「人员」，用了 10 个章节来阐述。前 5 章主要介绍互联网产品研发中的关键角色定义以及职责，后 5 个章节介绍了一些人员招聘和管理的心得。 Marty Cagan 认为互联网研发的角色包括：产品经理、用户体验设计师、项目管理人员、开发团队、运维团队、产品营销人员，并且他分别讲解了这些角色的职责和工作内容差别。 具体在执行上，其实有可能一人身兼多职，比如我们小猿搜题的产品经理同时需要负责做项目管理相关的推进和协调工作。也可能一个职位被拆分成多个细分的工作方向，比如用户体验设计师在网易公司就会拆分成负责交互效果和负责视觉效果的设计师。 书中我印象比较深刻的是对产品经理和项目经理的讨论。Marty Cagan 在书中是这么介绍的： 产品经理产注的是定义有价值的产品。 项目经理关注如何执行计划以交付产品。 书中提到了项目经理需要的能力包括： 工作紧迫感 善于捕捉问题 思路清晰 用数据说话 果断 判断力 态度（不能找延期的借口） 所以这里面涉及的技能差别巨大，那为什么我们在创业时选择让产品经理身兼项目管理工作呢？除了希望团队保持人员在数量上的敏捷之外，我们认为产品经理如果能够具备这样的能力，会使得他们能具有更有大局观。这个大局观说实际点，就是知道自己的产品方案在执行时会有多大具体的开发成本，在做妥协的时候，知道如何的产品调整会有助于开发团队更快地产出。 流程这部分用了 20 个章节，介绍了做产品的各种流程和做事方法。 其中涉及的很多流程，已经被广泛接受，并成为事实上的标准做法。比如基于 Scrum 的敏捷软件开发方法，虽然有一些公司不完全采用 Scrum，但是其中的看板、站立会议等实践仍然被借鉴融入到了日常工作流程中。 作者推荐产品经理用「高保真」原型来代替产品文档。对于「高保真」原型，作者还在网站上提供了详细的示例：http://www.svpg.com/examples，我看了之后感觉还是比较惊讶，因为这个 原型 的「高保真」程度已经到了让人看不出来是原型的程度。 就我了解到的大多数公司，都还是用 Axure 或 Omni Graffle 来制作产品文档，其远远谈不上「高保真」，我对所有产品都应该用「高保真」原型来制作存疑。 产品这部分用了 9 个章节，介绍了一些做产品的心得。例如： 第 32 章让我们提防做一些小众需求的功能，主要是给那些做企业级应用的公司的建议。 第 34 章介绍了产品背后涉及的人性：贪婪、恐惧、欲望。这里面的道理谁都懂，不过要真正应用到产品中，还需要长久的思考。之前听一个朋友说，不管是德州扑克，还是炒股，都是一个「克服贪婪与恐惧的游戏」。道理谁都懂，但是能玩好德州扑克和炒股挣钱的人并不多。 第 35 章介绍的情感接纳曲线也是涉及人性的话题，他指出很多人的决策都是为了宣泄情绪，关注并利用到这一点之后，就可以做出广受欢迎的产品。书中举的是关于非理性消费的例子，比如环保主义者就会花很多钱买普锐斯（丰田公司的混合动力汽车），但是其实他们更多的是为情绪买单。作者认为非理性消费本质是对不满情绪的过度反应，是放大后的情感需求在作怪。 对于如何寻找这种需求，作者提出可以把自己想像成一个新生的人，一切东西都是新鲜的，然后感受产品对自己内心的细微影响。这种目标用户的代入感或许是一个产品经理的必修课程吧。 总结图书最后用两章进行了一个总结，包括整理出一个「最佳实践经验」和「产品经理的反省清单」。我对此体会并不深，但是考虑到可能自己还没悟到，所以先摘录如下： 「最佳实践经验」有十条： 1、产品管理的职责 2、用户体验 3、机会评估 4、特约客户 5、产品原则 6、人物角色 7、探索（定义）产品 8、使用原型 9、用户参与原型测试 10、根据数据进行改进 「产品经理的反省清单」也有十条： 1、产品能吸引目标消费用户的关注吗？ 2、设计是否人性化，好操作？ 3、能赢得过竞品么？ 4、了解目标用户吗？ 5、是否有别于其他的产品呢？ 6、产品能正常运行么？ 7、是否完整，销售是否能够完成。 9、特色是否与目标用户一致。 10、产品值钱吗？值多少钱？ 11、了解团队其他成员的想法吗？ 作为最早一批出现的介绍产品经理工作的书籍，《启示录》非常适合入门，特别是适合有一些具体产品工作实践的同学阅读。本书不太好的地方就是内容组织的条理性太差，并且涉及的内容通常并没有很深入展开。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"通过他人完成任务的艺术 - 读《领导梯队》","slug":"the-leadership-pipeline-summary","date":"2016-02-16T05:24:31.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/02/16/the-leadership-pipeline-summary/","permalink":"https://blog.devtang.com/2016/02/16/the-leadership-pipeline-summary/","excerpt":"","text":"《领导梯队》 是美团的 陈晓亮 同学推荐给我的，看完了一段时间，但是一直没有整理读书笔记，这次趁着春节回顾了一下本书。 领导力就是通过他人去完成任务的学问。本书通过对六个典型的管理层级最经常出现的问题，从领导技能、时间管理能力、工作理念三个方面进行了分析，提出了改进建议。 本书对管理层级的划分非常宏大，看起来像是给一个上万人集团公司写的一样，书中甚至有一章是教你如何做 CEO，这可能与本书的作者拉姆·查兰长期从事管理方面的教学工作有关。而我因为刚刚从一个开发人员转型做管理工作，所以我主要阅读的图书的前两章，里面涉及了如何「从管理自我到管理他人」。 对于每一个领导阶段，书中都从如下三个方面进行了工作指导： 领导技能：培养胜任新职务所需要的新能力，提升领导力。 时间管理：重新配置时间精力资源，决定如何高效工作。 工作理念：更新工作理念和价值观，让工作聚焦重点。 而这三个方面，也是我常常困惑的地方。我常常问自己： 作为一个技术转管理的人，我应该如何学习和提高？ 我应该如何安排自己的日常工作时间？ 有什么核心的方法论来指导自己？ 而这些问题，我试图从本书中得到答案，有一些找到了，也有一些没找到。 从管理自我到管理他人我们大部分初入职场的人刚开始都是个人贡献者，随着能力的提高，有一些人在自己专业领域上做出了出色的成绩。而公司往往会给这些人增加更多的职责，这些职责很多时候都是涉及沟通、组织和管理的。所以，这些优秀的个人贡献者，开始迎接他们的第一次转型挑战，尝试学会从管理自我到管理他人。 书中也提到，优秀的个人贡献者和优秀的管理人员所需要的技能树并不一样。所以并不是每一个人都是能够完成这一转变。而就我所在的互联网行业来看，很多时候，优秀的个人贡献者也不一定需要做这个转变，也能在技术领域一路提升，成为技术专家。 例如阿里的 多隆，就是一位一直坚持在技术领域的专家，他做到了阿里的合伙人。我也见到一些朋友坚持在一线做技术，其薪资待遇高于那些做管理的人。所以这个职位转变更多需要是内心的喜欢和坚持。如果转型失败，后果很可能是自废武功—-既弱化了专业的职业技能，又是一个失败的管理者。 我们先来看看书中指出管理他人的技能树吧： 领导技能书中指出管理他人首先需要的技能是「领导技能」，具体包括： 制定计划（项目计划，预算计划和人员计划） 工作设计 人员选拔（其实就是招聘） 授权（工作安排） 绩效监督 教练辅导与反馈 绩效评估 奖励与激励 沟通与营造工作氛围 为部门发展建立上下左右的良好关系 获取资源 与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下： 技术或者业务能力 团队协作能力 为了个人利益和个人成员建立的人际关系 合理运用公司的工具、流程和规则 书中将以上内容分为了三类：界定和布置工作、提高下属的胜任能力、建立人际关系。我觉得分得并不清晰，我按个人理解，用工作方式再次进行了分类： 自己思考的工作：制定计划、工作设计、绩效评估 与人沟通的工作：授权、教练辅导与反馈、营造工作氛围、获取资源、奖励与激励 自己执行的工作：人员选拔、绩效监督 所以我觉得一个好的一线管理人员，应该有思考和规划的能力、沟通能力、以及执行力。执行力在个人贡献者阶段其实也有锻炼，所以主要需要学习的是思考和规划的能力、沟通能力。 沟通能力似乎和演讲一样，就是一个多练习才能提高的技能。我平时会注意观察和总结自己的言语表达方式，以及观察别人的沟通方式，能感受到自己在一点点进步。 思考和规划的能力似乎也是一个需要花时间来积累的事情。好在很多时候规划并不是我来做的，所以我对此承担的压力并不大。 时间管理时间管理方面的技能，具体包括： 年度时间计划（时间安排、项目进度） 与下属沟通的专门时间（一是自己的需要，二是下属的需要） 为部门和团队工作设定时间方面的优先次序 与其他部门、客户和供应商沟通的时间 与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下： 遵守工作上下班时间 遵守工作的进度安排 其实简单来说，以前是别人给自己安排工作，现在需要自己给自己安排工作了。每天的时间怎么分配，花在哪些事情上，一线经理需要开始思考了。 我当前主要的工作内容包括参与产品讨论，参与技术讨论，跟进项目上线，与运营同事沟通，与我的领导沟通，与主要具体负责人定期沟通。除此之外，还有团队的工作安排，一些面试工作。 我以前会主动承担一些开发任务，但是我发现这其实是不太合适的，因为我的时间沟通工作比较多，所以开发工作时间很多时候并不能保证进度。我以前也会过多地参与到项目进度推进中，现在发现也是不太合适的，这方面的工作我更多交给了相应的产品经理来完成。 但是，我对自己的时间安排也不尽满意。主要是我不太清楚我应该如何安排每天事情的优先级，以及当某一天没有固定安排的时候，我应该做什么事情。我有一些例行的事情可选，但是并没有安排好，例如： Check 一下和团队的人哪些人很久没有一对一沟通过，如果没有的话做一次。 关注 Pipe 上产品的各项指标，看是否有异常的、未被发现的数据。 关注用户反馈，看看用户都在说什么。 在 QQ 上找一些用户聊聊天。 关注自己的产品细节，反复使用。 关注竞争对手的功能改进。 看用户的原始数据（Frog，上传的图片）。 思考人员、流程和产品，各自有没有什么问题。 这些问题在本书中没有涉及，我通过和我的领导郭常圳沟通，最终确定的结论是：我们把工作分为「被动工作时间」和「主动工作时间」。 被动工作时间包括：定期的产品过稿、美术过稿、Scrum会议、邮件、在QQ上或当面主动来找我的事情。 主动工作时间包括：刚刚提到的看产品数据、看用户反馈，看原始数据等事情。 郭常圳认为，我们应该把主动工作时间「例行化」，「例行化」是指每天抽出固定的时间来做这些事情，这样使得这些事情不被遗漏和忽视。在例行化的事情之外，我需要更多的留出「主动思考」时间，「主动思考」是最重要，并且是将这些输入转化成想法或决策的关键过程。 所以，我刚刚提到的那些事情，都应该变成每天例行做的事情。 工作理念书中提到的工作理念的技能，具体包括： 通过他人完成任务 下属员工的成功（就是自己的成功） 管理性工作和修养 部门的成功（就是自己的成功） 像一位真正的管理者 正直诚实 与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下： 通过个人能力完成任务 高质量的技术或专业化工作 遵循公司的价值观 这一部分涉及成就感的转变，以前个人贡献者的成就感来源于自己的努力和成长。现在一线管理人员的成就感变成了下属的成功和团队的成功。不但如此，一线管理人员还需要在各方面对下属进行辅导，帮助他们工作得更舒服，更开心。 另外，我对正直诚实这条也感触很深。公司大了之后，很多文化就是来自于创始人以及一些核心员工。如果管理人员不能做到正直诚实，那么公司很可能变得充满了「政治斗争」，一但工作变成了维护自己利益以及小集团的利益，那么对公司的伤害是巨大的。 总结本书的内容组织稍显混乱，虽然把领导技术、时间管理、工作理念作为每个阶段层级的主要改变内容，但是在具体阐述时，又会以另外一个角度展开。比如「 从管理自我到管理他人」一章的内容展开时，是按界定和布置工作、提高下属的胜任能力、建立人际关系作为内容小节阐述。而「从管理他人到管理经理人员」一章的内容，又是按「四个领导技能」展开。 本书很多章节总结性的内容散乱，最终以 QA 或故事的方式，列出一系列问题和回答来作为主要的章节内容，虽然很多内容读起来很有道理，但是使读者很难抽取出核心观点，也可能作者本身也没能总结出核心观点。 本书对于我的帮助是，我从中得到了不少指导性的规则，也帮助我梳理了自己的工作内容。虽然它没有解决我的所有问题，但是至少帮助我完成了对问题列表的整理和思考。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"和时间做朋友 - 读《奇特的一生》","slug":"make-friend-with-time","date":"2016-02-16T05:04:28.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/02/16/make-friend-with-time/","permalink":"https://blog.devtang.com/2016/02/16/make-friend-with-time/","excerpt":"引言 一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。 —— 古罗马哲学家：赛纳卡 今天要介绍的是 《奇特的一生》 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。 以下是我的读书感受。","text":"引言 一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。 —— 古罗马哲学家：赛纳卡 今天要介绍的是 《奇特的一生》 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。 以下是我的读书感受。 和时间做朋友今年罗振宇的新年跨年演讲主题叫：「时间的朋友 2015」，听着名字就很酷，而李笑来老师的《把时间当做朋友》也是我非常喜欢的一本书。看吧，大家都喜欢谈时间。时间，是这个世界上人人都有的东西，但却又是最昂贵的东西。 为了节约时间，我们发明了汽车、火车、飞机代替了马车。我们发明了电活代替了电信。我们发明了电梯代替了楼梯。我们每天使用的微信，也代替了以前的短信。一切的发明，都为我们省下了大量时间，但是奇怪的是，我们越来越感到时间不够用。 你有这样的感受吗？晚上在电脑或手机面前看电影或者是刷微博，稍微不留神，就到了零晨 12 点了。但是我还记得小时候，家里偶尔会停电，那个时候点一盏蜡烛，大家围在蜡烛前面聊天，感觉聊了好久好久，来电后一看，才过了不到半个小时。 时间就是这样一个顽皮的小孩，当你认真看他的时候，他会像蜗牛一样慢慢地一秒一秒往前爬；当你忘记他的时候，他就会飞奔起来，等你发现的时候，你才发现人生在世，几十个年头也就一眨眼的功夫。 当今世界被移动互联网颠覆着，但时间的分配几乎同两千年以前的时代一模一样：「我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事。」 今年我三十二岁了，有些时候会感觉很恐怖，搞互联网这个行业，有些时候晚上难免加班，熬夜之后身体明显会很不舒服，要过好几天才能缓过来，而以前大学在学校宿舍，打 Dota（一种多人联机对战游戏）玩到零晨 2，3 点也不觉得困。我希望我的「奔四」的这些年头，能够更有效，更有价值地度过。 所以，我们需要和时间做朋友，因为我们不希望一辈子就像眨眼一样就过去，而我们完全不记得曾经在这个世界上留下过什么。 时间统计法《奇特的一生》 在介绍了柳比歇夫的大量评价和成就之后，在第七章介绍了「时间统计法」。「时间统计法」实在太简单了，其实就是每做一件事情，记录下它花费的时间。然后，每周、每月、每年汇总和分类，看自己的时间是如何用掉的。 在时间统计法之上，本书也提出了一些注意细节，我总结如下。 应该统计纯时间本书强调时间统计法应该计算纯时间： “工作中的任何间歇，我都要刨除。我计算的是纯时间，” 柳比歇夫写道，“纯时间要比毛时间少得多。所谓毛时间，就是你花在这项工作上的时间。” 常常有人说，他们一天工作十四五个小时。这样的人可能是有的。可是拿纯时间来说，我一天干不了那么多。我做学术工作的时间，最高纪录是 11 小时 30 分。 有七八个小时的纯工作时间，我就心满意足了。我最高纪录的一个月是 1937 年 7 月，我一个月工作了 316 小时，每日平均纯工作时间是 7 小时。如果把纯时间折算成毛时间，应该增加 25% 到 30%。我逐渐改进我的统计，最后形成了我现在使用的方法。 学会利用碎片时间书中把碎片时间称作「时间下脚料」： 他只是想方设法利用每一分钟，利用任何所谓的 “时间下脚料”：乘电车、坐火车、开会、排队……还是在克里米亚，他已经注意到边走路边打毛衣的希腊女人。每一次散步，他都用来捕捉昆虫。在那些废话连篇的会议上，他演算习题。 学会集中注意力 应当学会不受周围环境的干扰，用在工作上的 3 个小时应当是真正做工作的 3 个小时，不想不相干的事，不听同事的谈话，不听铃声和笑声，也不听收音机…… 在这方面，我推荐大家使用番茄工作法，非常有效。 学会总结任何的学习活动，都应该最终有总结，这样的学习才是真正的有价值的学习。我面试 iOS 开发的时候，喜欢问他们最近看了什么书，让他们讲一个最近看的「印象最深刻」的知识。大多数人都能回答出书名，但是想不起来书中讲了什么。 如果你看了一本书，但最终全部忘掉了，那就相当于没看。哦不对，应该更糟糕，因为你不但什么都没记住，还浪费了时间。 柳比歇夫有种罕见的才能——随便哪本书的作者，凡有独特的见解，他都极善于汲取。有的书，一张纸就够；某些大部头书，需要几张纸来归纳。它们的精华同它们的厚度怎么也不相称：大量的插图、表格、附页、书皮。 不要说没有时间人们常说，太忙了，没有时间做某某事。其实这是一个借口。如果你自己尝试做一下时间统计的话，你就会发现时间大把大把的有，只需要你有执行力。 而且，大部分情况下，稀缺的资源才会被珍惜。如果让你把工作辞掉，把时间留出来专门做一件事，你反倒很可能做不好。 书中是这么说的： 我想以我的一个朋友来作为反面的例子。他曾经是一个很不错的科学家，后来又担任过一个很大的研究所的所长。马上我又想起我熟悉的一个作家类似的遭遇，随即又联想起另一个作家。职务确实剥夺了他们很多的时间，而且妨碍他们开展工作。但久而久之他们就习惯了这些客观情况的制约。他们都幻想能摆脱，并经常说，到了那个时候，他们就要大干自己心爱的工作了，因为陷于各种繁杂应酬活动是很难写出书来，更不可能从事科学研究。他们终于摆脱出来了。每个人都盼到了这么一天。但很快发现，他们谁也不能工作了。 我们是机器人吗书中的柳比歇夫严格记录了几十年自己的时间花费，让人看起来像机器人一样。我们是机器吗？我们为什么要把自己的生活弄得像机器一样严格而呆板？ 对此，我的体会是，人生很多时候，需要我们把自己当做机器一样，执行自己预先的规划。比如对于我个人来说，坚持写微信公众号文章这件事情，到底有多大的意义？我不知道，但是我知道放弃一件事情非常容易，但坚持做一件事情，很可能会收获巨大。所以，这个名为「iOS 开发」的公众号我一写就是三年。有些时候不知道写些什么 iOS 开发的东西，我就写读书笔记，创业感悟。 现在我从技术转管理了，在时间计划上，我的领导常圳建议我把主动工作时间「例行化」。「例行化」是指每天抽出固定的时间来做固定事情，这些固定的事情包括：看产品数据、看用户反馈，看原始数据等，你觉得这些事情会有趣吗？其实不怎么有趣，但是这些事情对我的工作有很大的帮助，所以在这些事情上，我需要把自己变成「机器人」，不带有任何情绪地、认真地把它做好。 对于写书也是一样，我在写《iOS 开发进阶》的时候，刚开始兴奋，周末可以写一整天，然后就慢慢变得烦躁而疲倦了。我可以找相当多的借口放弃：创业太累、时间不够、稿费太少 …… 但是，我还是把自己当机器人一样，按照之前计划的章节安排，一章一章写。 我们不是机器人，但是我们内心足够强大，才能使得自己像机器人一样。 这其实也代表着心智的成熟。 一万小时定理《异类》一书中揭示了成功的秘密：大量不管天赋多么高的人，都是经过 10000 小时的训练，才成为专家的。不管是钢琴家（书中以 6 岁就开始作曲的莫扎特为例），还是程序员（书中以 Java 语言的作者乔伊和微软的创始人比尔盖茨为例），他们都是由于环境的优势，早早地完成了 10000 小时训练，才成为人们眼中的天才的。 而本书 《奇特的一生》 中介绍的时间统计法，其实就是一种实际可操作的「一万小时定理实践手册」。 通过对未来五年的规划，然后定出每年的年度目标，然后进一步进行拆解成月度目标，再结合时间统计法来计划每天的工作，并且检查自己工作完成情况，我们就会惊喜地发现，按这个进度我们很可能达成目标。 当然，《奇特的一生》 中讲了另外一种情况：主人公柳比歇夫通过时间统计法，最终发现自己在 72 岁设立的写作目标并不实际，所以他最终调整了写作的内容，放弃了一部分章节，使得书稿能够最终完成。但这何尝不是一种合理的调整，他避免了柳比歇夫临死前才发现时间不够，后悔莫及的情况。 Scrum 的计划和回顾看完了时间统计法，突然发现这个方法其实和 Scrum 有着非常惊人的相似度： 制定长远目标，对应 Scrum 的 Milestone 的概念。 制定年度、月度目标，对应 Scrum 的每一个 Sprint。 每天的工作计划和时间统计，对应 Scrum 的每日站会。 定期的时间统计总结，对应 Scrum 的燃尽图和回顾会议。 短期和长期目标的达成，对应 Scrum 的评审会议。 时间统计法以及它的一些指导思想，其实就类似一个人生的 Scrum 规则。 Scrum 强调组织的透明、检验和适应。时间统计法强调对自己的透明、检验和适应： 对自己的透明，是指用时间统计法，了解自己的时间花费到底在哪里。 对自己检验，是指看自己长远目标的完成进度是否理想。 对自己的适应，是指定期总结自己的时间花费，看是否有改进的空间。 类的自省与人的自我回顾现代的高级语言，类和对象都会有「自省」的能力。自省是说，这个对象在运行时，能够了解自己。比如 Java 语言，可以通过反射，了解自己的类名、成员变量和成员函数。C++ 语言可以通过 RTTI 达到同样的效果。而我们熟悉的 Objective-C 的 Runtime 也非常强大，不但可以了解自己，还可以动态修改类的成员函数实现。 我之所以认为 Swift 语言还不完善，也是因为 Swift 语言在这方面的能力还比较弱，我感觉苹果在未来的版本中一定会增加这方面的特性。 「自省」的能力代表着一系列高级的编程技巧，Java 可以通过反射做到 IOC（反转控制），Objective-C 可以做到动态打补丁。而人呢，如果能够做到自我的回顾、总结和调整，那么也就能不断进步了。 《奇特的一生》 中的时间统计法是一种特别简单可操作的方法，使你具备「自省」的能力。 不要崇拜天才作者在书中这么说：「我之所以对柳比歇夫产生兴趣，正由于他不是天才，因为天才是无法分析的，好在天才也不用去研究。天才只适合于让大家来赞美。」 这个世界基本上没有天才，我们也不需要崇拜天才，大部分成功的人都和你我一样，学习那些优秀的人做得好的地方，努力让自己提高一些。不要和天才比，要和自己比，这种价值观是我喜欢并坚持的。 目标之外：不要成为「时间的奴隶」很难有一种理论体系能够解释所有现象，牛顿的物理学三大定理那么牛逼，也只能在宏观世界中适用。时间统计法也是一样，我们不能指望它解决我们所有的问题。 更进一步地，我们不能让我们成为「时间的奴隶」。这个世界并不是所有事情都能用时间来衡量价值，所以我们不能只关注长远目标，忘记了留意身边那些美好的瞬间。 所以，任何事情都有一个度，在你还没有学会好好利用时间的时候，你应该尝试用时间统计法来改进自己的时间规划；当你已经有很好的时间规划的时候，或许留一些随意时间，反倒是好的。 本书的主人公柳比歇夫就是这样一个人，他虽然是一个坚持做了几十年时间统计法的「强迫症患者」，但是他同样会花大量的时间回复书信，很多书信仅仅是向他求教一些专业知识。他从长远规划中安排出了这些时间，来帮助那些素不相识的朋友，这让我感受到了他的可爱。 总结这是一本非常有意思的书，讲了一个看起来细毫没有技术含量的生活方式：时间统计。但是，它让主人公柳比歇夫获得了人生的快乐和成就，希望我们大家都能够找到这样的快乐和成就。 愿大家猴年大吉！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"教你阅读图书的「方法论」- 评《如何阅读一本书》","slug":"how-to-read-a-book-summary","date":"2016-01-17T01:58:18.000Z","updated":"2024-09-20T12:43:08.626Z","comments":true,"path":"2016/01/17/how-to-read-a-book-summary/","permalink":"https://blog.devtang.com/2016/01/17/how-to-read-a-book-summary/","excerpt":"","text":"引言最近常圳给我推荐了 《如何阅读一本书》 这本书。这本书最初出版于 1940 年，然后于 1970 年进行了增补改写。到现在已经面世 70 多年，在我写这篇笔记的时候，该书在京东上的 销售排名 位于社会科学销量榜第 2 名，可见该书是多么畅销。 在花两周读完本书之后，我最大的收获是学会了如何更加科学地阅读。在本书中，作者将阅读分为四个层次，并且逐条讲解每一个层次的阅读方法，以及需要达到的目标。本书将阅读分为如下四个层次： 基础阅读 检视阅读 分析阅读 主题阅读 我一直对这 4 个偏学术的名词记不太清，我对这四个层次的理解如下： 基础阅读，是指基本的识字和认识能力，能够知道每个字和句子表面的意思。这个确实也没什么好多说的，全书第 3 章花了一共 8 页简单介绍了一下。我想这一层次的内容主要可以使得全书的理论结构更加完整。 检视阅读，是指的快速获得图书重要信息的能力，其实就是略读。但是本书有价值的地方在于，他提供了一套略读的方法指导，使得你能够更科学地快速获得全书的概要信息。 分析阅读，其实就是精读，作者对于分析阅读提出了一系列问题，让我们通过回答这些问题，来辅助我们获得书本背后作者想传达的思想。 主题阅读，其实就是把含有相似内容的书籍综合起来一起读，从而对目标知识产生更全面的理解。这就像我们大学时要写某个具体领域的研究论文，然后就会用一些关键词在学校图书馆或期刊上搜索，然后把这些同一领域的图书或期刊都借出来系统学习。 所以，我认为本书的牛逼之处并不在于提出了阅读的 4 个层次，即使没有本书，我们在实际生活中也会自觉的在阅读中，根据自己的需要，采用不同的层次来阅读。本书之所以受欢迎，是因为它对于每个阅读层次，都有一套具体的、可执行的操作方法，有了这套「方法论」，大家可以按步就班地来做更加科学地阅读。 我们常常会出现这样一个对话场景： A 说：「某某书你看过了吗？」B 回答说：「看过了，挺不错的！」A 问：「讲了什么？」B 说：「呃。。。不记得了。」 我想《如何阅读一本书》的价值就在于这儿吧，它让以上这种场景尽可能地避免了。我们来看看它的「方法论」到论是什么样的。 检视阅读基础阅读我就不介绍了。因为基本的识字和认识能力应该是每一个成年人都应该具有的。我们直接来看看检视阅读的方法。 检视阅读的第一阶段：系统的略读。具体的做法如下： 先看书名页，然后如果有序就先看序。 研究目录页。 如果书中附有索引，也要检阅一下。 读一下出版者的介绍（如果有）。 开始挑几个看起来跟主题息息相关的篇章来看。 把书打开，随意浏览，念个一两段，有时候连续读几页，但不要太多。 检视阅读的第二阶段： 不要在不懂的地方停下来深究（查询或思索）。 注意阅读速度（文中还介绍了一些速读的技巧：如避免「半出声」的阅读，用手指快速移动来控制眼睛停留时间等）。 分析阅读作者认为一个主动的阅读者，需要解决如下四个问题： 这本书整体上在谈些什么？ 作者细部说了什么，怎么说的？ 这本书讲得是否有道理？是全部有道理，还是部分有道理？ 这本书跟你有什么关系？ 为了解决以上问题，作者将分析阅读分成如下几个阶段。 第一阶段（解决问题 1），找出一本书在谈些什么的四个规则： 依照书本的科类与主题作分类。 用最简短的句子说出整本书在谈些什么。 按照顺序或关系，列出全书的重要部分。 找出作者在问的问题，或作者想解决的问题。 第二阶段（解决问题 2）：诊释一本书的内容规则 诊释作者的关键字，与他达成共识。 由最重要的句子中，抓住作者的重要主旨。 知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。 确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。 第三阶段（解决问题 3 和 4）：像是沟通知识一样地评论一本书的规则 智慧礼节的一般规则： 除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。 不要争强好胜，非辩到底不可。 在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。 批评观点的特别标准： 证明作者的知识不足。 证明作者的知识错误。 证明作者不合逻辑。 证明作者的分析与理由是不完整的。 在我看来，第三阶段指出的批评观点的标准，使得人们更加容易清楚自己的立场是如何而来的。作者是这样说的：「如果你不能用相关证据显示作者是知识不足、知识有误，或不合逻辑，你就不能反对他」。很多人面对一些结论的时候，表现出强烈的反对，但是如果你发现他不能按以上标准来反对的话，就说明他并不真正在反对，只是「不喜欢」这个结论，而这只是在表达一种情绪或者偏见。我们应该尽量避免陷入情绪中，或者至少应该在陷入情绪中时，知道自己当前只是在发泄，而不是在讨论问题。 主题阅读作者将主题阅读分为两个阶段。 第一阶段：准备： 针对要研究的主题，列出书单。 浏览书单中的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。 第二阶段：阅读： 从书单中的书中，找出与主题最相关的章节。 根据主题创造出一套中立的词汇，带引作者与你达成共识。 建立一个中立的主旨，列出一连串的问题，使大多数的作者为解读这些问题提供了他们的回答。 界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。 分析这些讨论。 主题阅读的理想上要保持客观，当你要解读作者的某个观点时，必须从他文章中引一段话来并列。 总结《如何阅读一本书》是一本用「方法论」来指导阅读行为的图书。这本书将阅读分为四个阶段，每个阶段又细分为一些具体的执行方法。使用书中介绍的方法，可以使得我们更快、更有效地获取图书中的关键信息。 更宽泛地说，《如何阅读一本书》培养的是一种获取有效信息的手段和习惯，不管是阅读图书，还是阅读博客、邮件以及平时讨论问题，我们都可以利用书中提到的分析阅读的方法，来获得有效的信息。另外，当涉及争论时，书提到的批评别人观点的方法也非常客观，这会使得大家的争论会更加理智。 本书不太好的地方在于内容太过啰嗦，如果能够将内容再精简一半，我可能会更喜欢一些。另外，将「略读」和「精读」换个名字成「检视阅读」和「分析阅读」，也让我觉得有些太夸张了一些。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"MagicalRecord 作者 Saul Mora 的故事","slug":"saul-introdution","date":"2016-01-12T14:20:45.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/01/12/saul-introdution/","permalink":"https://blog.devtang.com/2016/01/12/saul-introdution/","excerpt":"","text":"这次 Swift 开发者大会上，我认识到了一位新朋友，他叫 Saul Mora（如上图），听到这个名字时我没有什么感觉，但是随后旁边的一个朋友介绍道：「他是 MagicRecord」的作者之一，我突然眼睛亮了。 不知道有多少人听过 MagicRecord，MagicRecord 是一个基于 Core Data 的库，可以让你更加方便地使用 Core Data。在我学习 Core Data 时，曾经抱怨过 Core Data 一些设计过于繁琐，使用不方便，那时就常常会听到人们说：「你应该使用 MagicRecord」。而 MagicalRecord 的 Github 首页上 https://github.com/magicalpanda/MagicalRecord ，已经有了 8000 多的 Star 数。 在我进一步和 Saul Mora 聊天时，我才发现，他的作品远远不只是 MagicRecord。他还是著名的 iOS 网站 Ray Wenderlich 的图书《Core Data by Tutorials》作者，并且发表了很多文章在 Ray Wenderlich 上。另外，他也是一个有趣的人，他维护着他的名为 NSBrief 的 podcast：http://nsbrief.com，采访了很多 iOS 和 Mac 的开发者。 好了，现在关键来了，Saul Mora 在硅谷工作得有些腻了，而且他想学习中文，于是他现在来到了中国，打算在北京、上海或成都找一份 iOS 开发的工作。 我想，这对于很多公司来说，都是一个千载难逢的机会，来招募到一位全球顶尖的 iOS 开发者。所以，如果你对 Saul 感兴趣，可以将你的公司介绍、希望他过去做的事情、大概的待遇，以及任何你觉得可以吸引他的信息，发到他的邮箱： &#x53;&#97;&#x75;&#x6c;&#x40;&#99;&#x61;&#115;&#x61;&#x64;&#101;&#x6d;&#111;&#114;&#x61;&#46;&#99;&#111;&#109; 对了，Saul 现在还在学习中文，所以他还不能很流利地用中文交流。所以如果邮件用英文写的话，会更有利于他考虑工作机会哟。 感谢 Saul 给开源社区的贡献，也祝福他在中国能够开始一段愉快的经历！ 以下是 Saul 写的自我介绍： About Saul Saul Mora is an American iOS developer. He has been involved with the iOS community for several years. He has helped start Cocoaheads and NSCoderNight meetups in Phoenix, Arizona and Denver, Colorado. He is the author of MagicalRecord (http://magicalrecord.com), the iOS framework for use with Core Data. Saul is a co-author of Core Data by Tutorials (http://www.raywenderlich.com/store/core-data-by-tutorials) published with Ray Wenderlich (http://raywenderlich.com) Over the past few years, Saul has produced the NSBrief podcast (http://nsbrief.com) to talk to many developers in the iOS and Mac development community. Saul has also shared his knowledge in person all over the world giving talks at many developer conferences in the USA and Europe. Saul has spent the last year in Silicon Valley and has recently decided to move to China to pursue his goal to become fluent in the Chinese language. He is eager to meet iOS developers everywhere and share his knowledge and experience with all the developers in China.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"首届 Swift 开发者大会见闻","slug":"atswift-conference-summary","date":"2016-01-10T14:31:55.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/01/10/atswift-conference-summary/","permalink":"https://blog.devtang.com/2016/01/10/atswift-conference-summary/","excerpt":"","text":"今天是中国 iOS 开发者的一次聚会，因为首届 Swift 开发者大会在北京成功举办了。这次会议的质量很高，大会的相关 keynote 和 视频，稍后都会在官网上公开，所以没能参会的同学可以关注官网（ http://atswift.io/ ）的内容更新。我作为大会的主席（其实基本没出什么力）全程参与了全天的大会，在此记录下一些参会的见闻。 先说说本次的大会的演讲内容吧。这次大会的 Keynote 可在此下载。 2016.02.29更新：中国首届swift开发者大会的视频已经放出：http://www.imooc.com/learn/600 Chris开场的是 objc.io 的创始人 Chris Eidhof。Chris 是大会演讲者中唯一没有准备 keynote 的人，但是演讲相当精彩。Chris 虽然没有 keynote，但是内容是精心准备过的，他先用 playground 简单介绍了一些 Swift 的内容后，就转到一个游戏 Demo 的重构工作中，整个重构工作包括几点： 用 typealias 去掉 NSUserDefaults 的依赖。 用 protocol 来代替继承。 用 extension 来实现 protocol。 尽量用 struct。 全程用 testcase 来验证重构过程。 最终，我们看到了一个重构之后的游戏 Demo，相比以前的工程，重构后的项目代码更短，逻辑更清晰。 人们常说，Talk is cheap, show me the code。 Chris 用行动让我们看到如何写出更好的 Swift 代码。 傅若愚傅若愚来自 thoughtworks，和我一样是成都人。他这次的演讲主题是《越过 OC 与 Swift 间的鸿沟》，对于正在经历从 OC 到 Swift 转型的各位来说，非常实际。 他从一段代码来引出了大家的好奇，下面这段代码，居然会有两种输出结果，你猜出来是什么原因了吗？ someArray = [1, 2, 3]var result = someArray.map(&#123;&quot;No. \\($0)&quot;&#125;) 接着傅若愚介绍了从 OC 转到 Swift 需要注意的地方： 优先用 protocol 而不是继承 更多通过 annum, struct, extension 来达成目的。 最后，他展示了一个利用函数式编程来重构代码的例子。 GregGreg 是加拿大多伦多的一位 iOS 自由职业者，亚裔，看起来非常像中国人，但是其实他不会说中文。他在为著名 的 raywenderlich.com 撰写博客。本次他分享的是《Swift Style》。 在介绍了编写易读的代码的重要性之后，他从以下 3 方面介绍了他的 Swift 经验： Value types Protocol Safety 提问环节的时候，Chris 当托似地问了一个非常有趣的问题：「你最近 1 年在写 Swift 代码上有何转变？」。 这个问题非常有意思，Greg 说他现在用了更多的 guard 关键词，然后 Greg 也说到，他写习惯 Swift 之后，因为养成了强类型检查的习惯，他偶尔回去写 oc 的时候会不停地 check 各种 nil。 李洁信李洁信是下午第一场，非常犯困的时间。洁信稍微有一些紧张，内容是关于《Swift 中的协议编程》，他把这些内容都梳理得挺好的，讲得挺清楚。 王巍喵神王巍是下午第二场，王巍的主题是《如何打造一个让人愉快的框架》，喵神的准备非常充分，演讲过程中还各种卖萌，实在是非常可爱。喵神主要从以下几个方面介绍了框架的开发： 静态库和框架的对比 包和依赖管理 创建框架 一些 Tips 发布框架 持续集成 如果你希望基于 Swift 来开发一个 framework，非常值得看看喵神的分享。 包涵卿包涵卿讲的是《Swift 函数式编程实践》，这块其实是挺难讲的，前面的一些函数式编程的基础还好，比如柯里化之类，但是后面估计比较难理解，我不知道现场有多少人听懂了 Monad 的概念，不过这个确实是比较挑战的话题。 翁阳这场话题茶歇回去之后听了一半，所以没怎么整理出来笔记。有些遗憾。 周楷雯周楷雯的分享里介绍了各种性能优化的技巧。可惜他当时手机变砖，有一些着急，讲得比较快，很多点感觉展开讲会更好一些。 后记这次 Swift 大会中还做了一些有趣的调查，在此将数据分享给大家： 这次有 3&#x2F;4 的听众来自外地！ 现场有 1&#x2F;3 的听众已经开始将 Swift 应用于公司项目开发中。 这次大会的组委会都很棒，包括梁杰、裕波、王臣汉、陈雨恒、李涛（还有一些我没能记住名字的同学）都对这次大会付出了大量心血。作为一个非赢利性的 Swift 大会，我觉得他们做到了内容的高质量，期待明年的第二届大会如期进行！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"}]},{"title":"ReactiveCocoa 讨论会","slug":"reactive-cocoa-discussion","date":"2016-01-03T07:22:13.000Z","updated":"2024-01-06T14:52:37.925Z","comments":true,"path":"2016/01/03/reactive-cocoa-discussion/","permalink":"https://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/","excerpt":"","text":"前言ReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。 但是，相对于传统的 MVC 架构，ReactiveCocoa 的函数式编程方式的学习曲线陡峭，业界也没有丰富的图书资料，这使得大家对这种技术望而却步。这次，我邀请了一些行业内关注和使用 ReactiveCocoa 的内行，进行了一次关于 RAC 的讨论会，会上大家主要聊了 RAC 在使用中的各种问题，我们希望这次讨论会能够让重新全面审视这个开发框架。 讨论成员本次讨论会邀请到的讨论者来自美团，百度，蘑菇街等公司。讨论前为了先相互认识，我让大家自我介绍了一下，并且顺便简单介绍各自所在的团队人数以及使用 RAC 的时长，以下是大家的自我介绍： 臧成威，来自美团，团队基本都在使用 RAC，从 14 年初开始使用 RAC。在美团搞过 RAC 的几期培训，有丰富的经验。 李忠 (limboy)，来自蘑菇街。李忠的博客（http://limboy.me/）上有很多介绍 RAC 的高质量文章。（这次讨论会李忠当时有事没有参加，事后对相关问题留言表达了自己的看法） 唐晓轩 (txx)，来自礼物说，团队四个人，目前 “只有” 礼物说这一款产品。从年初开始使用 RAC，到现在正在安利 Android 团队使用 RXJava。 孙源 (sunnyxx)，来自百度，从 13 年年底开始接触 RAC，当时边学边用 RAC 写了一个完整的项目，那时候还没现在这么火（当时 Limboy 的文章看了好几遍），后来在项目中在一个完整模块中尝试使用过，因为大家对函数响应式编程了解程度差别很大，导致代码几乎无法维护，随后重构。现在也有时用到，但都用于某个特定的功能的便捷实现上，无 MVVM，基本不会跨类使用。 雷纯锋，来自广州支点网络科技股份有限公司，团队三个人使用 RAC ，从 12 年 6 月份开始使用 RAC ，公司项目一直使用的是 RAC。项目中一直也是用的 MVVM + RAC 的结构，另外我也有在维护一个 MVVM + RAC 的开源项目，叫 MVVMReactiveCocoa。 汤圣罡 (lexurs)，来自新味，2 个 iOS。RAC 经验两年。目前在用 Overcoat+Mantle+ReactiveCocoa 实现的网络层，某些逻辑多的页面也喜欢用 RAC 实现。因为想全部改成 Swift，正在投靠 RxSwift 和 PromiseKit 的过程中。 李雄略 (听榆大叔)，来自网家缘科技，分 2 个产品，每个产品 2 个 iOS 开发，从 14 年 3 月份开始使用 RAC，已在 3 个项目中使用 RAC。 蓝晨钰 (lancy)，来自猿题库，没有在公司项目使用过 RAC。个人喜欢 RAC，私底下写过 RAC 的小项目，读过 RAC 源码，但对 RAC 在大型项目中和团队合作中持谨慎态度，猿题库的架构是类 MVVM 架构，但没有引入 RAC。 唐巧（就是本文作者），来自猿题库，团队分 3 个产品，每个产品约 4 个 iOS 开发，没有在公司正式使用过 RAC，自己私下写过几百行 RAC 的代码，对于 RAC 是比较保守的一个人。 好了，以下就是我们具体讨论的一些问题。 讨论：如何在团队内推广并用「正确的姿势」使用 RAC？大家提到在使用 RAC 的时候，出现的一些问题，例如： 不是太精通 RAC 的同学往往写出来的非常难以维护 不知道新队友的 RAC 培养路径，Functional Programming -&gt; MVVM -&gt; …. 对于难以维护的问题，臧成威的意见是： 这个美团这边的解决方案主要是 review，review 可以保证项目中所有人的范式是相同的，大家对于不同的写法都会有充分的讨论，而我们的新手主要是参考旧代码的风格写出新代码，所以并没有发生难以维护这一现象。 但是前提是需要有很熟悉的人来带领，团队中熟悉 RAC 的人员基数得以保证。而且美团的 RAC 使用还是逐步放量的，从一开始的 UI 层使用，到底层逻辑层的使用，最后才到了 MVVM 的粘合层使用，这样避免了泛滥。 总结来说，对于 RAC 这样厚重的库，引入的时候的 review 是必要的，否则可控性太差，最后就难以收场了。 总结起来就是：1、review + 有熟练的人带；2、逐步放开使用。 对于人才的培养，臧成威的意见是： RAC 的培养，从我这边三期的培训来看，课程的安排是这样的六节： 1. FRP 的思想概要 2. RAC 的 operations 介绍 3. 冷信号与热信号解惑 4. 生命周期指南 5. disposable 和多线程 6. 实战分享 其中先建立 FRP 的思想，虽然看起来是最远的，但是确实是后续使用和教学的基础。 一起培训大概有 30-50 人来听，课程一种持续三周，每周 2 节课、课程过后的 2 周，就可以发现代码中的 rac 使用明显提升 另外补充一点，关于新手学习，最不建议的就是在不了解 FRP 原理和一些基础概念的情况下，盲目的看源代码。我见过太多的同学，花费了很多的时间通览源码，但是根本没有用途。因为从思想到源代码是经历了很多雕琢的。里面有太多的 bugfix，太多的折中。 所以你看的时候，抛开了本质，一味的查看边界的处理，最后大都觉得痛苦，难用，难以掌握收场。 唐巧：RAC 确实和其它的开源库性质上差别比较大，思想方面需要学习的比较多。 是的，关键是思想。所以，一定要先从 “道” 上建立思想，然后从 “术” 上掌握使用，最后才是通览源码，掌握其原理。 第一节是道的课程，第二节是术的课程。这两节下来就知道能干什么了。 雷纯锋意见也与臧成威一致。 唐晓轩介绍了一下他自己的学习过程： 我是反着做的，先把 rac 当作 blocks kit 用 之后 看 racstream 的各种 operations，知道 rac 有哪些运算 其次 看 rac 的 uikit 扩展都是怎么实现的 最后才是函数式思维。 我顺着臧成威的回答，问了一下通常使用 RAC 的规范是什么，臧成威回答道： 大家可以参考这样的一条规范来做，首先通过 RACSignal#return RACSignal#createSignal 这类的创建一个 OOP 世界到 FRP 世界的一个转换，从而得到一个 Signal。 之后 signal 在不接触 OOP 的情况下进行数据的各类变换，注意 FP 的引用透明和变量不可变特性。 最后用 RAC 宏、RACSignal#subscribe、NSObject+liftSelect 这些操作把 FRP 的世界带回到 OOP 的世界里。 臧成威还很体贴地画了一个示意图，非常给力： 讨论：大公司的大型 (臃肿) App 是否适合使用 RAC？由于第一个话题臧成威贡献最多内容，加上美团是大家所知道的使用 RAC 最多的大型 App，所以这个话题还是由臧成威首先回答，以下是他的发言。 越大型的 app，说明内部的逻辑越复杂。而 RAC 从某几方面可以简化逻辑，使得代码从书写到执行都可以较为简化的完成功能 我大概总结了几个适用的场景。RAC 总结来说就是：数据随着时间而产生，所以能想到的三点比较适合用 RAC： 一、UI 操作，连续的动作与动画部分，例如某些控件跟随滚动。 二、网络库，因为数据是在一定时间后才返回回来，不是立刻就返回的。 三、刷新的业务逻辑，当触发点是多种的时候，业务往往会变得很复杂，用 delegate、notification、observe 混用，难以统一。这时用 RAC 可以保证上层的高度一致性，从而简化逻辑上分层。 只要有通知的业务逻辑，RAC 都方便有效化解。 雷纯锋：概括的说，应该就是统一所有异步事件吧。 不适用的场景，与时间无关的，需要积极求解的计算，例如视图的单次渲染。 接着发言的是百度的孙源： 我这是百度知道，体量比较小，可以随便玩。 我们现在就用它做点小功能，举个例子吧，聊天页面那个键盘弹出时 input bar 跟随滚动的功能，原来写需要接通知、写回调，现在在一个函数里面用 RAC 就比较方便。 像这种小功能，主要是方便开发，让 “干一个事儿的代码写在一个地方”。 雷纯锋说他们的使用还是比较多： 基本上异步的事件能用 RAC 的都用的 RAC。 不过代理方法用 RAC 的比较少，比如 UITableView 的代理方法一般都是直接写了。 用 RACSubject + RACComand 来简化和统一应用的错误处理逻辑，这个算比较经典的吧。 臧成威说：UI 交互上的点确实好多，比如下拉刷新、上拉导航条变透明。 实时响应用户的输入，控制按钮的可用性，这点用 RAC 来实现非常简单。 李雄略说： 我们主要用来处理界面上的数据显示，以及 UI 的交互操作上，不会用来写代理。 对于这个话题，似乎大家的答案还是比较一致，即：大型 App 是适合使用 RAC 的。 讨论：都说调试 RAC 很痛苦，是否有一些调试技巧和经验分享？臧成威说： 的确很痛苦，跟断点有的时候计算堆栈都要等几分钟。 关于调试，RAC 源码下有 instruments 的两个插件，方便大家使用。 signalEvents 这个可以看到流动的信号的发出情况，对于时序的问题可以比较好的解决。 diposable 可以检查信号的 disposable 是否正常 小伙伴们看了纷纷惊叹，表示以前没有用过这个神器。 雷纯锋接着分享： 我的理解是一般给信号一个名字，然后通过下面的打印方法来进行调试。 /// Logs all events that the receiver sends.- (RACSignal *)logAll;/// Logs each `next` that the receiver sends.- (RACSignal *)logNext;/// Logs any error that the receiver sends.- (RACSignal *)logError;/// Logs any `completed` event that the receiver sends.- (RACSignal *)logCompleted; 李雄略说： 我是用 log 方法来做的： DExecute((&#123; setenv(&quot;RAC_DEBUG_SIGNAL_NAMES&quot;, &quot;RAC_DEBUG_SIGNAL_NAMES&quot;, 0); [signalUserGeo setNameWithFormat:@&quot;signalUserGeo&quot;]; signalUserGeo = [signalUserGeo logAll];&#125;)); 李忠的补充： 调试的话，如果是性能调试，主要是经验 +Instruments，经验类似于：少用 RACCommand、RACSequence 这样的，Instruments 可以用它的 Time Profile 来看。 如果是 Bug 调试，主要还是靠 Log，配合一些 Xcode 插件，比如 MCLog(可以很方便地过滤日志)，如果要还原堆栈的话，就加一个断点。 接下来大家讨论起来： 臧成威：其实 instruments 也差不多，只是第一，不需要提前调用 logAll 这些；第二，可以利用 instruments 的筛选功能，不会看 log 看到眼花。 雷纯锋：实际调试起来好用吗？ 臧成威：好用的，还可以看到发出 value 的堆栈。 雷纯锋：使用 instruments 来调试的频率大吗？或者说在什么情况下会去用 instruments 调试呢？ 臧成威：一般调查问题的时候就它来查。比如某个信号接不到输出。 臧成威：或者输出的值里面有错误的，但是是经过 merge、zip 等好多操作混合出来的，不知道源头是神马。 雷纯锋：也就是说一般是在有问题，然后分析不出来的时候，才使用吗？ 臧成威：是的，一般是调查问题的时候用的，不是开发的时候用的，因为打开是比较慢的。 李雄略：为了方便，我们保证一个 RACSignal 只会给订阅者 send 一种类型的 value，所以就手动给 signal 加了部分泛型支持： @interface RACSignal&lt;__covariant ObjectType&gt; : RACStream RACSignal&lt;NSString *&gt; *signal &#x3D; … 孙源：用泛型，然后 map 之后呢 李雄略：map 无法支持 臧成威：RAC3 里面就有不错的泛型推导，但是是基于 swift 的。 臧成威：这个我也想过，但是语言不支持，基本上是搞不定的 孙源：调试这块也就是 log name 了。作者 guide 里面也是这么弄，用 Instrument 已经是高级技巧。 臧成威：加 log 比较不好的就是容易眼花，还有不好还原当时的堆栈。 孙源：我一般遇到问题，都是看代码脑补一遍过程，函数式就好在这里，基本上看着对了结果就没错。脑回路逻辑推导。 臧成威：是的，推导很有道理。我觉得 sunnyxx 说的是王道，所以培训，给大家建立思维很重要。 雷纯锋：恩，分析清楚整个运算过程是很重要的 讨论：RAC 相比 RxSwift 和 PromiseKit 有哪些优缺点 ?臧成威继续分享： RAC vs RxSwift 的情况是这样： 从支持度来说，RAC 对 Cocoa 的支持更好。但是从标准性、性能来讲 RxSwift 更胜一筹。 因为毕竟是 Rx 团队的亲生项目。还有，OC 只有 RAC 支持，RxSwift 搞不定。 雷纯锋：需要在 Obj-C 下和 Swift 下，分别来比较吧？那 Obj-C 下，用 RAC 应该是没有疑问的了吧，那在 Swift 下呢？ Swift 场景下，由于 OC 做好的 bridge，所以 RAC3swift，仍然有不错的整合性。例如 notification、observer 这些。但是 RxSwift 与框架无关，所以这些功能需要自己补了。 但是 RxSwift 比较标准，和 RxJS、RxJava 所有定义统一，所以迁移过来很容易。但 RxJS 和 RxJava 的原始用户比较少，这点不大明显。 这是 Rx 和 RAC 的对比。 RAC3 swift 版有个特性，就是热信号传导，这点 RxSwift 没有。对于特定的场景来说，热信号传导更好。 PromiseKit 是一种异步库，思想和 FRP 不一样。 PromiseKit 应该和 js 的 promise 库差不多的意思吧，这个我是靠猜的。 讨论：RAC 在工程中使用范围的界限，往往一处 RAC 就会引起和他相关模块的 RAC 化，如何确定界限呢？臧成威：这个我觉得有点危言耸听了吧，对上对下是可以有效包装，逐步放量的。 臧成威：默认作为一种上下模块的通信协议，也不是很危险的事，所以我觉得没有太大的风险。上层拿到一个 RACSignal 就当做一个 BlockKit 的回调方式就可以。这样可以有效控制代码。 雷纯锋：这个我觉得要看模块之间用什么来通信吧。 李忠：这个我觉得还是跟使用场景有关。如果只是简单的对外暴露一个 property，外部直接 KVO 即可，甚至不用关心 RAC。但如果在一些比较复杂的场景使用 RAC 的话，很难做到对上层透明，除非内部的封装做得足够彻底。 李忠：比如网络请求，返回一个 RACSignal，然后外部 subscribeNext 之后，想要取消怎么办？这时只能保存一个 RACDisposable 变量，然后在适当的时机调用 dispose 方法；或者要等待 2 个请求一起完成，再做一些事情（当然可以通过 semaphore &#x2F; dispatch_group 来做，但这样就丢了 RAC 的特性）等等。 李忠：所以还是要在项目初期就想清楚，如果团队成员对 RAC 都比较熟悉，那自然最好。如果其他人不太了解，甚至抵触，这时就要避免在复杂的场景下使用。 讨论：有什么学习 RAC 好的资料吗？臧成威：李忠的博客不错：http://limboy.me/ 唐巧：之前雷纯峰特别推荐美团的几篇博客：http://tech.meituan.com/tag/ReactiveCocoa 李忠：coursera 上有一门课是讲 Reactive Programming 的 ( https://www.coursera.org/course/reactive ) ，也会讲到 Functional Programming。 雷纯锋：我写的这篇是范围比较广一点。http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/ 《ReactiveCocoa v2.5 源码解析之架构总览》 另外要关于 Monad 的也有一篇，http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/ 《Functor、Applicative 和 Monad》 雷纯锋：raywenderlich 上的文章：http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1、http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2、http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1、http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2。 唐巧：我之前看过一本 《Functional Reactive Programming on iOS》，不过还是不够深入。 臧成威：话说，看懂 Haskell，理解 RAC 就不是难事了。 雷纯锋：是的，所以如果要理解 RAC 的思想的话，Haskell 可以学一下。http://learnyouahaskell.com/ RACSequence 的性能问题讨论到最后大家还涉及到了 RACSequence 的性能问题。记录如下： 臧成威：了解了概念后，看源码就很爽了，是 OC 语言的典范。 臧成威：不过看了 RACSequence 的实现，性能是无法使用的。 雷纯锋：无法使用？你们不用 RACSequence 吗？ 臧成威：是的，Sequence 的性能很差。 臧成威：由于 OC 没有引用透明和尾递归优化。 雷纯锋：你们没有过吗？ 臧成威：你试试 100 个长度的数组进行遍历排序，然后再变回来就明白了。 臧成威：现在都去掉了。 雷纯锋：它主要是用来实现懒计算吧。 雷纯锋：方便集合的转换吧，常规的遍历也不会使用它吧？ 臧成威：就是说集合转换的性能太差了。 雷纯锋：恩，以后留意一下 总结本次分享内容的主要贡献来自美团的臧成威同学，从美团的实践中我们也能看到，在有充足经验的人指导下，RAC 不但可以应用于大型项目，也可以工作得很舒服。 最后感谢参加这次讨论会的臧成威、李忠、唐晓轩、孙源、雷纯锋、汤圣罡、李雄略、蓝晨钰，希望他们的分享对大家有所帮助。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"2015 年个人总结","slug":"2015-summary","date":"2016-01-02T11:08:13.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2016/01/02/2015-summary/","permalink":"https://blog.devtang.com/2016/01/02/2015-summary/","excerpt":"","text":"关于创业今年猿题库顺利拿到了 D 轮 6000 万美元的 融资，估值 3.6 亿美元。而我负责的 小猿搜题，也从年初的几十万用户，增长到了 5000 多万用户。 今年是小猿搜题的风光年，我们上了「天天向上」，在各种黄金档节目中打电视广告，整体用户数据增长惊人。研究组、市场运营、内容部门各种给力，使得产品技术工作进展得非常顺利。 下图是小猿搜题登上 AppStore 教育榜榜首的截图。 我的工作对于我自己来说，2015 年的工作主要分成上半年和下半年两个阶段。 上半年，我一边负责小猿搜题的 iOS 开发工作，一边负责小猿搜题技术团队的组建和协调工作。小猿搜题当前大部分同事都是在上半年入职到这个团队的。 下半年，团队成员磨合得差不多了，团队里面 iOS 同事也成长起来了，我自己能够从 iOS 具体的开发工作中脱身，使得我更多地关注产品和团队了。 下半年自己的工作主要聚焦到了管理业务和管理团队上，每天组织协调和沟通的事情很多，除了 Scrum 的定期会议外，我还得参加产品的 Scrum 会议和产品过稿，还有美术的过稿。另外，我时不时也需要和运营的同事沟通协调。 有时候忙完一整天不知道时间是如何过去的，然后又看着自己 iOS 开发技能慢慢变弱，有一种焦虑感。于是我首先开始多读书，接着就是总结，试图调整自己。 数据分析的工作让我知道任何的改进都是应该基于数据的，这样更加理性。所以，我拿了一个小本子，记录自己每天的详细时间花费情况。于是就有了下图这样的一页一页的记录。 这样大概记录了一周多，我基本上知道了自己的时间是如何花掉的了。然后，我开始归类自己的时间花费，看看主要花在了哪些地方。对于一些优先级不高的事情，我会注意调整它，不要让它把重要的事情给耽误了。 我也开始总结一个产品技术负责人的工作。在想得差不多了之后，我利用每周一早上和 CTO 的沟通机会进行讨论，最终，我完成了文章：《涅槃重生:我的技术转管理之路》，并且在北京架构师峰会上做了相应的技术转管理分享。 现在我不那么焦虑了，不过觉得自己还是需要多学习和提高。 图书出版《iOS 开发进阶》 在 2015 年 1 月份顺利出版，然后首印 3000 册迅速卖掉了，出版社加印了 2000 册，然后过一周又卖光了，然后他们加印了 5000 册。之后又陆续有加印，最终到年底的时候，《iOS 开发进阶》销售了 17000 册，我听出版社老师说，这个成绩在技术图书里面是算相当好的。 虽然称不上完美无缺，我个人对这本书的自评是问心无愧的。我用 Scrum 的管理方式来管理这本书的写作过程，我想在互联网时代，按时发布产品比什么都重要，所以，虽然有很多想继续完善的地方，我还是把它付印了。我也把写这本书的过程总结下来，完成了 《我是如何完成《iOS 开发进阶》的编写的》，希望能给想出书的同行一些帮助。 由于我从一线 iOS 开发工作中脱离，《iOS 开发进阶》很可能不会再更新出第二版了，17000 册这个成绩，对于当时 30 岁的我来说，还算是一个不错的里程碑。这次写作让我感受到了出版的乐趣，其实我自己还在蕴量一些写作素材，或许以后会给大家一些新的分享。 写作今年在博客上完成了 45 篇原创博客文章，差不多一周一篇的节奏。因为 iOS 开发做得少了，所以我的文章中涉及 iOS 开发技术细节的内容少了很多。 我仔细分析了一下今年的博客文章，内容涉及面很广。包括一些 iOS 开发方面的文章，如： 写 iOS SDK 注意事项 iOS 开发中的争议（一） iOS 开发中的争议（二） 被误解的 MVC 和被神化的 MVVM 另外，我也向「娱乐记者」转变，采访了一些国内新出现的 iOS 大牛，以及报道一些行业新闻，比如 谈谈苹果开源 Swift 专访 YYKit 作者 ibireme: 开源大牛是怎样炼成的 我更不务正业地写起了硬件的评测： Apple Watch 使用体验 当然，最离谱的就是我开始卖软件了，我和荔枝数码合作先后卖了 Reveal 和 Charles 两款 iOS 开发中需要的效率工具软件，也为此写了一些文章： Reveal 中国特惠活动 Charles 从入门到精通 (中国 5 折特惠) 因为工作关系，我也开始总结自己的技术转管理收获，完成了： 浅析一对一沟通 涅槃重生:我的技术转管理之路 在产品工作上面，总结了： 数据的秘密（上）- 为什么要关注数据 数据的秘密（下）- 如何分析数据 读书另外，今年开始认真写读书笔记，完成了： 《引爆点》读书心得 《从 0 到 1 》读书笔记 《成为技术领导者》读书心得 《异类》读书心得 《逆转》读书心得 其实还看了一些别的书，包括《格鲁夫给经理人的第一课》、《增长黑客》、《领导梯队》等，但是都没有完成笔记，之后打算补上。 iOS 技术图书也看了不少，要说推荐，还是王巍的 《Swifter》 和 Kevin 的 《Producter》 。《Swifter》适合给新手入门用，《Producter》是一本跨界的书，适合 iOS 开发者用来开拓自己的眼界。 好奇心2015 年我特别提醒自己要有好奇心，于是就做了很多有趣的事情。 比如，因为搬家和装修，我自己学习了换门锁、换马桶盖子、换马桶的上水管、组装板材家俱、在墙上钻孔这些技能，感觉还挺有意思的，有些时候就感觉在摆弄大号的积木玩具一样。 比如，因为对社群经济感兴趣，交了 1024 元加入了池建强和李笑来老师建的付费群。 比如，因为对 「在行」 这个 App 感兴趣，在上面接单，约见了五位朋友。 好奇心给我带来了极大的收获，比如池老师的那个付费群，我最终不但收获了不少有意思的分享，而且学习了当前社群的运作模式。在「在行」上接单不但收到了一些咨询费，更多的是认识了很多有趣的人，比如说罗飞。 如果要说好奇心给我带来的最大收获，那可能就是「iOS 开发」微信公众号的运营了。 从时间上看，我的「iOS 开发」微信公众号已经运营 3 年多了： 2013 年 2 月 21 日，我开始在微信公众号里发表 iOS 开发相关内容。 2013 年 12 月累积发表了 140 条信息，累积了 5600 名粉丝。 2014 年 12 月累积了 1 万名粉丝。 2015 年 12 月累积了 3 万名粉丝。 最主要的是，我原本没指望做这个事情有什么收获，但是从 2015 年起，开始有各种互联网企业找我投放广告。在这里感谢我的主要广告主： UPYUN：UPYUN 是国内领先的云服务提供商，专注于为开发者提供静态文件的云存储、云处理和 CDN 加速服务。 100Offer：用「拍卖」的方式来提供高端互联网人才招聘的网站。 拉勾网：最专业的互联网招聘平台，我自己就从上面招到了不少同事。 InfoQ：InfoQ 了提供中国最高质量的技术会议和技术文章，我自己也是 InfoQ 的社区编辑。现在 InfoQ 创始人 Kevin 把业务做得更广，成立了 极客邦科技，在极客邦科技之下，除了 InfoQ 之外，另外组建了高端技术人员社交网络 EGO、IT 职业学习平台 StuQ 和 企业培训服务 GIT。 再次感谢你们，是你们让我这个自媒体有肉吃。 同时，我也要感谢我的读者，谢谢你们忍受偶尔出现的广告。我仔细算了一下，现在广告的频率是每月 2-3 次。你们放心，我会努力控制广告频率，如果控制不住，我就会涨价的！ 未来的计划2016年，希望自己： 每月至少完成一篇读书笔记。 每周坚持发至少一篇微信公众号文章。 个人 Milestone 小猿搜题团队组建成功，并且获得 5000 万用户量。 「iOS 开发」微信公众号获得了 3 万粉丝，并开始有广告收入。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"培训机构出来的 iOS 学员怎么了？","slug":"resume-cheat-story","date":"2015-12-24T14:23:45.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/12/24/resume-cheat-story/","permalink":"https://blog.devtang.com/2015/12/24/resume-cheat-story/","excerpt":"","text":"事件回放前几天在 iOS 开发群里看到有人贴了一个 v2ex 上的帖子（地址： https://www.v2ex.com/t/244437 ） ，大概说收到了 1000 多份某培训机构出来的学员简历。这些简历让他发现了一些问题： 面试表现比较差 大多有伪造工作经历的行为 以下是他的文章原文： 公司坐标：杭州。 由于公司业务发展，需要新招一位 iOS 开发工程师，这周 HR 平均每天给我安排了三场面试。 一周过去了，这些面试者给我的印象都很糟糕，并且……很蹊跷，今天找 HR 了解了一下。 结果出现了令我震惊的事情， HR 在「智联」「 51job 」「拉勾」三个渠道发布了招聘，半个月收到了超过一千份 iOS &gt; 简历，而同时招聘的其他技术岗位却很少有人投递简历。 分析了一下这些简历的特征： 1.户籍绝大多数是某地（非地图炮，仅是数据统计） 2.几乎全部刚从外地来杭州 3.几乎全部上家公司是外包公司 4.很多人上家公司不一样，但简历中写的项目却是一样的 5.简历上宣称的工作年限都是 1 年左右 其实上面这几条，我都可以「理解」 但是，这个数量着实让人震惊。 我有一些推测，怕被喷，先不说了。 你们怎么看? 有人把这个问题贴到知乎上，引来了一些知情者的回复，见 https://www.zhihu.com/question/38703692 。 原来这些都是培训机构出来的学员，然后为了获得一次面试，就编造了工作公司和经历，并且隐藏了自己的培训经历。 今天就想和大家聊聊这个沉重的话题。 诚信的恶性循环首先我们说说简历造假吧。在我看来，简历造假还是时常遇到的。我认识礼物说的 CTO，我们 iOS 群里常常有朋友面试时遇到说自己在礼物说工作过的候选人，为什么呢？还不是网上有一堆高仿礼物说的 APP，自己下载下来看看，然后就可以假装是自己做的了。 为什么很多候选人选择造假呢？除了简历不够好之外，造假很多时候确实有用。对于很多小公司来说，面试官自己也不懂如何面试 iOS 开发，那么就特别容易被忽悠。 但是，一个公司里面有 iOS 开发者，然后再稍微懂一些面试技巧的话，简历造假是很容易发现的。关于怎么在面试中鉴别造假，我们在下一节聊。 我们先聊聊看造假会造成什么危机呢？对于面试公司来说，如果他发现面试的效率特别低，或者招进来的人干活不行时，他会怎么办呢？ 我觉得他会很直接地开地图炮，把一类人直接刷掉，不再给面试机会。这类人是哪些人？简历雷同的、培训机构培训出来的人。 这样公平吗？对候选人肯定不公平，但是公司招人也需要讲效率的，面试候选人其实成本特别高。 所以造假这个行为，最终伤害的是候选人本人，以及培训机构的信誉。 如何在面试中鉴别造假其实挺简单的，首先面试的时候不要设置固定问题，然后根据候选人的回答情况来深入问细节。 就比如说一个候选人说他做过礼物说，那就有很多可以深入问的，比如问他： 礼物说有几个 iOS 开发 大家是如何分工的 你负责的那块最主要的难点在哪里 团队整个协作的过程 在开发的时候有没有遇到需求变更 功能上线后大概的数据是什么样的 你觉得哪些地方还需要改进 你们主要的竞争对手是谁，他们在哪些技术方面比你们做得好 一个谎话要编容易，难的是每一个细节都编得面面俱到，所以深入细节问，很容易就会露馅。 我是培训机构学员怎么办简单地说，公司招一个人最终级的目的还是把活干好。如果一个培训机构的学员，没有实际的工作能力，单凭几个月的培训就想一劳永逸地找一份好工作，这是不现实的。 互联网技术日新月异，iOS 开发每年技术都在更新，如果指望所有知识都是从培训机构那儿获得，那么早晚都会被淘汰。 所以，即使你当前是培训机构出来的学员，也必须培养自己实际解决问题的能力和自学能力。这样才能一点点地增强自己的实力。 另外说一个残酷的现实，公司一般不会给你大块的上班时间用来学习新知识的。所以大多数学习充电过程只能是在下班后或周末。 我们应该怎么看待培训机构学员我自己就招过一个培训机构出来的学员，她还是一个女生，现在工作得挺棒的。她是非计算机专业毕业的，参加培训机构学了 3 个月就来我们公司面试。她能通过面试，很大程度上是因为她不止参加了培训班的课，而且自己在网上学习了计算机数据结构和算法的基础知识，而且是看的国外的课程。 当时面试时我完全没有考查她 iOS 知识，因为她承认只参加了 3 个月的培训。所以我考查了一下她自学数据结构和算法的情况。结果让我觉得她是一个自学能力还不错的女生，所以我就把她招了进来。 刚进来带她做 iOS 费了一些精力，但是很快她就可以上手自己做事情了。现在，我已经完全把小猿搜题的 iOS 端交给她来负责。我想她就是一个培训机构出来学员的成功案例。 我们并不鄙视培训机构的学生，但是我们不认同那些没有自学能力，认为参加 3 个月培训就可以拿高薪的「投机者」。这个行业虽然高薪，但是也很辛苦，如果没有兴趣和毅力，是没办法做好的。 搞 iOS 开发到底需要什么核心能力大家看了我上次采访的 YYKit 作者的文章 后，或许就能明白，其实一个人核心的能力就是学习能力。有强大的学习能力，那么就可以像 YYKit 作者那样，才接触 iOS 开发一年多就可以开源出大量优秀的作品。 基本上，一个人在一个领域坚持投入大量的时间，很难做得不好。所以你是一个培训机构的学员，苦于找不到工作。与其简历造假拿到面试机会，倒不如再多花花精力，自己多专研一些代码，写一些 App，不要那么急功近利，我想结果都会好很多。 愿培训机构出来的 iOS 学员都能找一份好工作。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"涅槃重生:我的技术转管理之路","slug":"from-dev-to-manager","date":"2015-12-18T13:32:00.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/12/18/from-dev-to-manager/","permalink":"https://blog.devtang.com/2015/12/18/from-dev-to-manager/","excerpt":"","text":"一个程序员的理想我从高中就开始接触计算机并开始编程，我非常喜欢编程，我一直以为我会写一辈子代码。 我从毕业就一直做技术，开始一年是做 Java 语言的服务器开发，开发过网易邮箱和微博的后台，后来转而做 iOS 开发。 因为喜欢，我几乎把我所有的非工作时间也投入到技术中去。当然，并非是把工作带回家，而是专研技术或者从事技术写作。 于是这几年，我积累了超过 150 篇原创技术文章，在 iOS 技术圈子里面也小有名气，也出版了一本《iOS 开发进阶》的书，微博和微信公众号的粉丝数也都超过了 3 万。 我做得很开心。 我一直以为，我会是一个好码农，我会一直在技术上深入下去。 但是，改变有些时候就是来得那么突然。 涅槃重生我还记得那一天，2014 年 7 月 17 日，我当时受到邀请，在广州的微信分享 iOS 开发技术。当天晚上，我接到郭常圳（我们的 CTO）的电话，知道要做小猿搜题这个项目，并且这个项目「由我负责」。 于是，我开始了技术转管理之路。 通过从以前的项目组中抽调人手，小猿搜题这个产品技术团队很快组建出来了。我在开发 iOS 版的小猿搜题客户端的同时，也开始了我的管理工作。 现在经过了一年半，我们不但组建成了一支充满战斗力的团队，成收获了不小的成绩： 小猿搜题产品一年时间获得了 5000 万的用户。 我们团队在开发上做到了每周一次迭代，两周一次版本发布。 技术管理的总结在我的工作中，我慢慢总结出在创业公司中做技术管理工作的「方法论」。我把我的技术管理工作分成以下几个部分：管理业务，管理团队，管理技术。 管理业务做为互联网公司，我们奉行简单直接的沟通，所以我很多时候并不需要涉及人员的管理工作，更多的时候是业务的管理工作。业务的管理工作主要是围绕着一个具体要做的技术开发功能点展开。具体包括： 任务分解和分配 制定大概的开发排期 每天了解开发进度 讨论和跟进各种具体的技术问题 协调一些产品需求变更 响应一些市场同事的需求 跟进相关功能上线 在这方面，我们主要是采用 Scrum 的开发方式，见《适合码农工作时玩的游戏：Scrum》。 我们在整个迭代（Sprint）过程中引入四个会议：计划会议，每日站会，评审会议和回顾会议。通过事先简单的计划，再加上这四个会议中的详细讨论，我基本能够做到： 通过计划会议：比较合理的安排开发排期、分配任务。 通过每日站会：每天了解开发进度，会后讨论和跟进各种具体的技术问题 对于产品需求变更和市场同事需求的响应，我主要利用自己在 Sprint 执行过程中的时间来展开。我会根据当前需求的大小和紧迫程度，来决定是否插入到当前的 Sprint 中。如果插入到当前的 Sprint 工作量太大，我会适当做一些 Sprint 内容的调整。 跟进相关功能的上线主要是开发快要结束的时期，我会和产品同事一起试用最新的功能，了解 Bug 修复的进度，上线的风险情况。在大部分出现风险的情况下，我们都希望用适度加班的方式解决，所以我们上线当晚有时候会工作得比较晚。在无论如何都搞不定的情况下，我们可能会调整上线时间。 在业务涉及跨部门合作的时候，相关的进度管理会更麻烦一些。因为各部门自己的进度安排不一致，所以就会存在「等着联调」的情况。另外联调时出现问题也容易出现没人主动出来解决的情况。这些都需要负责人更频繁地沟通和推进，以保证按时上线。 在每周的工作中，我的管理业务的工作大概花费是 2 天左右。 管理团队刚刚也说到，互联网公司不怎么需要管人，那么管理团队主要是做什么事情呢？我认为主要是两件事情：招人和带人，所谓的搭班子和带队伍。 招人招聘这事情实在太重要了，所以必须要团队负责人参与。人才的招聘除了从公开的渠道收取简历、从猎头或同事那里得到推荐以外，还包括定向的找一些自己熟悉的前同事或某个领域的知名大牛，这些工作都是非常花费时间的。 在招人上，我们主要用到了找前同事，内部推荐发伯乐奖，以及进行技术分享和开源代码来获得社区影响力的方式。 值得一提的是，我们对于开源社区的贡献也得到了肯定，我们的基础架构组负责人陈恒因为多次为 Hbase 贡献代码，所以成为了 Hbase 的 Committer，而全中国拥有 Hbase 的 Committer 的公司在此之前只有三家，而且中国的 Hbase 的 Committer 不到 10 人。 在每周的工作中，招聘大概会占用我半天到一天的时间。 带人人才招进来了，能否顺利融入团队，团队负责人以及这个人的导师（mentor）非常重要。需要做的事情包括： 平时多交流沟通。 在新人遇到问题时，热心地解答。 引导新人熟悉公司的工作方式。 一对一沟通来源于 Intel 公司，在最近很火的一本书 《创业维艰》 中里面也提到过。《创业维艰》的作者本·霍洛维茨是被誉为「硅谷最牛的 50 个天使投资人」之一，先后在初期投资了 Facebook、Twitter、Groupon、Skype。 他在书中对一对一沟通介绍到，一对一沟通最主要的意义是：可以使得信息从下而上地传递。从而获得在其它渠道不易获得的信息，保证透明。 适合一对一沟通的内容有很多，包括： 不成熟的看法 迫在眉睫的问题 精彩的想法 倾诉焦虑 抱怨 这些内容都不适合在别的场景中出现，比如：不成熟的看法，如果在部门的正常会议或邮件中提出，会让人觉得未经过深思熟虑。又比如一些焦虑或抱怨，如果通过一些渠道宣泄给其他同事，其实也是不好的。一对一沟通让这些内容有了一个不错的出口。 5 年前我刚毕业加入网易有道的时候，我的老大，也是我现在创业公司的 CTO 郭常圳就开始和我做一对一沟通。我非常享受每次沟通的过程。现在我也开始和别人做一对一沟通，我也开始关注一对一沟通的技巧。我们认为最大的技巧是：作为管理者，要多听少说，让员工成为沟通的中心。郭常圳有一个特别「老土」的办法，就是：不主动说话。通过这种方式，强迫让员工选择他们想聊的话题。 在《创业维艰》一书中，也介绍了一些适合用来引导的问题： 当前产品还有哪些可以提高的地方？ 我们部门的最大问题是什么，为什么？ 如果有，你觉得工作中有哪一点令你感觉不舒服？ 你觉得谁的工作最优秀，为什么？ 我们的产品哪方面不尽如人意？ 我们错失的最大机遇是什么？ 哪些是我们应该做而没有做的？ 你自己希望未来在哪些方面能有提高？ 有什么我能为你做的事情？ 我大概保持每个月和每个组内同事都有一次一对一沟通，有很多时候，我是通过「请他们吃饭」来完成的。一对一沟通需要一个舒适的环境，所以在咖啡厅或饭桌上，可能都比在办公室的效果要好一些。 一对一沟通的另一个核心要素是要坦诚，这就像 Scrum 指南中用「游戏规则」来描述内容一样，如果管理者做不到坦诚，那么同事就不会把这当作是一次有效的沟通机会。坦诚的沟通方式是：所有问题都真诚的回答，不掩饰问题，也不回避问题。如果沟通双方能够做到坦诚，即使是一个棘手的问题，那么双方也会从「解决问题」的角度，尽量寻找可能的办法。 除此之外，定期组织一些团队活动，让团队每个人之间建立友谊，也是我努力在做的。这在很多大公司是 HR 部门做的事情，在我们创业公司里面，也变成团队负责人的工作之一了。 什么是领导力 关于管理团队，我也特别喜欢《成为技术领导者》一书中的观点，关于本书，更多的请见《成为技术领导者》读书心得》。书中是这么说的： 所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。 我想：在强调平等、创新、自由的互联网公司里面，这可能就是领导力最好的定义吧。 管理技术作为一个技术负责人，产品在技术上的架构是否合理？随着用户量的增长，现有架构能否胜任？当运营活动发生时，突发的流量会有多少，服务器是否能够承受住压力？未来技术上的架构应该如何演进？除了服务器端，客户端应该在哪些技术方案上投入研究力量？这些都是技术负责人需要考虑和决策的。 我同时做过服务器端和移动端的开发工作，不过由于最近几年都是做移动端的开发，所以服务器端的架构技术细节我其实并不是专家。所以我在这方面做得算不上很好。可能是运气好吧，有几次服务器的压力问题，我们都及时发现并且解决了，但是时间都挺紧迫的。现在，我会花时间把服务器端的架构图画出来，然后一块一块考虑，看看有没有更优的方案，并且和服务器端的同学讨论。 在客户端上，我只是对 iOS 开发比较熟悉，对 Android 了解得并不深入。所以我会让技术同学自己提一些技术改进方案，我参与 Review，我想他如果能说得有理有据，还是可以授权他在技术上深入的。 其实每个平台的技术管理可能都需要更多的「授权」，因为具体做事情的人，会比技术管理者更清楚地了解细节。而对细节的深入了解，才是改进技术架构的方案来源。所以，尽量招靠谱的人，那么在管理技术上的工作就只需要遵守「尽量授权」的原则来就可以了。 管理技术还包括公司技术氛围的建立，我主要在以下这些方面下了一些工夫： 推进技术 wiki 的使用 推进 iOS 端每周一次的技术分享 推进 Code Review 以及代码质量 Wiki 是一个非常好用的知识管理工具，前提是每个同事都参与贡献内容。所以作为一个管理者需要用言行来指导新同事学会用 Wiki。我会主动将重要内容记录在 wiki 上，对于一些同事发的邮件内容，我也会要求他整理到 wiki 上。 iOS 端的技术分享也是需要管理者推进的。我之前在网易有道的时候，这方面的活动基本上是大家自愿的方式来进行。这其实对分享者要求很高，一般的人很难达到这种意识，所以当时有道 iOS 端的技术分享很少。因此，我还是认为「半强制」的分享方式更适合当前团队。 「半强制」的分享规则需要大家认同，在一个相对轻松的环境下达成一致，为此我专门组织了一次交流会，大家相互认识一下，一顿吃喝之后，再约定分享规则。现在看起来，大家其实有很多想分享的内容，在 Wiki 上，很多一两个月才轮到他的人，都已经把分享的主题确定了。 Code Review 也是一个需要推动的事情，我们使用 Git 和 Gerrit，做到了所有的提交必须 review 通过之后，才能 merge 进代码仓库。另外我们也在 wiki 上规定了详细的代码风格要求。Code Review 如果做得好，不但可以在代码风格上达成一致，还能让新同事从中学习到一些良好的编程习惯，一些潜在的 Bug 也可能在 Code Review 中被发现，实在是值得坚持的事情。 产品负责人除了技术负责人的管理业务，管理团队，管理技术工作外，我另外还是小猿搜题的产品负责人，所以我还承担着技术负责人之外的一些工作。这些工作最主要的就是对产品的管理工作。 产品工作看似简单，实则复杂，而我作为一个工作多年的程序员，在这方面的经验非常少。所以我在参与产品讨论时，一开始都比较惶恐。后来我慢慢发现，产品经理的思维还是有章可循，便开始总结和学习，我看了不少产品经理的书，而郭常圳的多次指导也对我的帮忙意义巨大。其实做产品的原则就那么多，重要的还是多思考和体会，把那些原则融入自己的理解。 「场景化思维」是我学到的第一点，我还记得郭常圳带着我们学习乔布斯推出第一代 iPhone 时的演讲，乔布斯非常会讲故事，在用户具体的场景中介绍自己的产品。好的产品经理会将自己「代入」目标用户的使用场景中，解决用户的主要痛点和问题。做为技术人员，我常常陷入产品逻辑完备的泥潭中，但是「场景化思维」使得我能够重新跳出细节，关注主要功能设计是否合理。 「关注数据」是我学到的第二点，产品经理在打磨细节方面，如果能够关注产品数据，那么就很容易找到改进的方向，并且在后期验证自己的想法。关于这个，详细的请看：数据的秘密（上）- 为什么要关注数据 和 数据的秘密（下）- 如何分析数据。 我曾经犹豫自己是否应该学习写产品稿，郭常圳说不用，他说你只需要多看产品经理的产品稿，多思考和比较，慢慢就会有产品的感觉。我发现这一点还是管用的。以前用一个新的 App，作为开发者，我会关注它的功能在技术上如何实现，而我现在，不光会关注技术实现，还会想它的产品设计思路。打开了这扇窗户后，我就能在日常生活的每一天里，通过思考来提升自己的产品能力。 作为产品负责人，我主要的工作是参与产品稿的评审和美术稿的评审，同时会参与决定未来要做的功能，将其安排到产品工作中。另外，我也会关注产品的各项指标数据，保证重要的产品数据都是看过的。 我每周花在产品评审和美术评审大概是半天到一天，每周花在关注产品各项指标数据上的时间大概是半天到一天。 我做得不好的地方做为一个技术转管理的新人，我觉得我的工作还是有挺多问题。 首先，我刚开始还是太迷恋技术了，有一些开发工作我仍然主动参与。但是实践之后发现，因为我的事情太多太杂，使得我很难保证自己承担的开发工作的进度。所以我现在学会主动把任务交给别人做，如果一件事情不是必须我才能做的，我就交给别人。所以现在技术上，我只参与 iOS 端的 Code Review 工作了。我将更多的精力，放在一些不得不由我做的沟通和项目推进方面的工作上。 接着，我有很长一段时间没能很好地安排好产品计划和研发的进度。好的产品计划应该要领先开发一个以上的迭代周期，这样在技术开发当前版本时，下一个版本功能就在设计和评审当中，使得大家的工作都不受影响。而小猿搜题的产品计划有一阵一直没能很舒服地领先技术，这让很多时候开发同事并不舒服。 解决的办法是我们让产品文档的完成时间点也尽量精准，对于一个大的产品功能设计，我们会定好初版（我们内部叫做 1 版本）、详细版（我们内部叫 5 版本）、完善版（我们内部叫 9 版本）的时间点。产品经理需要努力在时间点内保证产出，这样其实反倒使得大家会关注产品设计的主要问题，在细节上不过分纠结。 最后，我在招聘上的成绩也比较一般，没有能够为团队招来很多有经验的人，所以小猿搜题现有团队还是新人居多。新人的好处是容易和团队文化保持一致，但是在经验上，还是需要更多的锻炼。 总结小猿搜题从 2014 年 7 月 17 日立项，到 10 月上线，再到元旦正式对外推广，到现在在不到一年的推广时间内，已经积累了超过 5000 万的用户。而我，也随着小猿搜题，从一个纯技术的 iOS 程序员，成长成为它的产品技术负责人，虽然也犯了一些错误，我感觉自己的进步还是很快的。 我也希望我的故事能够激励其他的技术同行，能够勇敢地接受新的挑战。在快速变化的移动互联网时代，快速迭代演进的不止有 App，也包括我们自己，愿大家都能活得精彩！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"专访 YYKit 作者 ibireme: 开源大牛是怎样炼成的","slug":"yykit-auther-interview","date":"2015-11-26T12:47:13.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/11/26/yykit-auther-interview/","permalink":"https://blog.devtang.com/2015/11/26/yykit-auther-interview/","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言第一次听到 ibireme 这个名字，是看到他在 微博上分享 了 YYText 开源库。当时我第一眼见到 YYText 的功能示意 GIF 图时（下图所示），就被它丰富的功能吸引了。YYText 应该是我见到过的功能最强大的基于 CoreText 的排版框架了。 令人惊讶的是，YYText 虽然代码量很大（超过一万行），但它只是 ibireme 的作品之一。ibireme 利用业余时间完成了 YYKit 工具库，包括： YYModel — 高性能的 iOS JSON 模型框架。 YYCache — 高性能的 iOS 缓存框架。 YYImage — 功能强大的 iOS 图像框架。 YYWebImage — 高性能的 iOS 异步图像加载框架。 YYText — 功能强大的 iOS 富文本框架。 YYKeyboardManager — iOS 键盘监听管理工具。 YYDispatchQueuePool — iOS 全局并发队列管理工具。 YYAsyncLayer — iOS 异步绘制与显示的工具。 YYCategories — 功能丰富的 Category 类型工具库。 我和一些朋友挑选了一些其中的组件代码阅读，大家都认为质量非常高，大家对它的评语是这样的： 打算自己撸一个 JSON 转 model 的，专门看了 YYModel 的代码，果然屌。 YYKit 超级好用。 对比一下，感觉自己一年都没写代码。 怎么会有如此完美的工程师？真想抽一周时间宅在家里把 YYKit 的源码重敲一遍。 之后我抽空学习了一下 ibireme 的博客（http://blog.ibireme.com/），上面有多篇介绍他对于 iOS 开发中各种问题的研究，例如他在开发 YYModel 时，调研和评测 了包括 Mantle 和 MJExtension 在内的多款开源库。这种专业认真的做事态度让我非常佩服，也让我对 YYModel 的质量充满信心。 然后，我有幸得到了 ibireme 的 QQ 和微信号，所以和他交流了多次。这时我才知道 ibireme 是一个 90 后，在优酷从事 iOS 开发工作。而这些所有的开源库，都是他在业余时间完成的。 我想大家很可能对 ibireme 的学习和成长的经历感兴趣，而且 ibireme 的故事很可能会激励更多有激情的 iOS 开发新人，利用业余时间学习、Coding 和分享，最终让国内的 iOS 开发技术氛围更好。所以，我向 ibireme 发出了采访邀请，ibireme 欣然接受了。于是，让我们来一起揭开这位神秘人物的面纱吧。 采访 唐巧：你好 ibireme，能否先向读者简单介绍一下自己？ ibireme：大家好，我叫郭曜源，是一个 iOS 开发者，现居北京，就职于优酷土豆。喜欢代码，爱好设计与音乐。 唐巧：我发现 YYKit 是在这个月初上传到 github 上的，但是它的代码量非常大，能否介绍一下每个部分大概花了你多长时间？ ibireme：Category 等工具类大部分都是这一两年工作和业余时间攒下来的。文本和图片相关的那几个项目是今年年初开始写起的，陆陆续续写了半年多。YYModel 花的时间最少，只有大概两个周末。 唐巧：为什么选择一次性开源这么多代码，而不是一个一个开源呢？ ibireme：最初这些代码我都是写在一个工程里，代码量比较多，相互之间也有很多依赖。准备发布时，我觉得这样很不方便别人使用，这才按功能拆开成一个个小的组件，然后一起发布的。 唐巧：这些开源库在国内外都收到了大量的好评，这个有没有超出你的预期？ ibireme：发布前我有预期会收到不少关注，但是发布后收到的好评还是大大超出我的预料。最令我惊讶的是 Facebook 和 Uber 等国外的工程师也关注到这个项目，并且还以此向我发出了工作邀请，这让我非常激动。 唐巧：你对 YYKit 后续的发展上有什么计划吗？ ibireme：现在只是计划进行一些正常的维护工作，保证稳定性。未来如果有合适的东西，我也会尝试加到里面的，但应该不会有太大改变了。 唐巧：YYKit 是你的业余作品，我很好奇你是如何保证工作之余还有这么高产的？ ibireme：最近一年我工作不太忙，很少加班，空闲时间比较多。另外我比较宅，平时喜欢待在家里做一些喜欢的事情。说起来，应该是充足的时间加上个人兴趣让我完成了这些项目吧。 唐巧：你如何看待 Swift 语言，有没有计划过用 Swift 重写你的 YYKit？ ibireme：相对于 Objective-C 来说，我觉得 Swift 无疑是更优秀、更现代的语言。目前我对 Swift 研究并不多，工作中也没有用到，但未来我会把时间更多投入到 Swift 中去。YYKit 中不少东西更适合于 C&#x2F;Objective-C，所以我没有计划用 Swift 重写整个项目。我可能会用 Swift 写一些新的东西，以充分发挥 Swift 的特性。 唐巧：你在 iOS 开发上是如何快速成长起来的？有没有什么心得可以分享给 iOS 开发新手？ ibireme：我接触 iOS 开发的时间很早，但是一直都是在工作之余靠着兴趣自学的。14 年我还在人人网时，部门内部有个新项目需要 iOS 开发，我才得以有机会在工作中使用 iOS 相关的技术。全职转为 iOS 开发后，我花费了大量的时间阅读和学习各种开源的代码、研究其中的实现原理、尝试自己实现相关技术、尝试在工作中使用，这使得我在 iOS 开发技术上进步很快。对于 iOS 开发来说，我觉得自学能力是很重要的。主动去研究一些优秀的开源项目、多在工作中实践和学习，这样就能逐步提升个人技术水平了。 唐巧：你觉得哪些开发者对你影响最大？ ibireme：可能平时我更喜欢看代码，对于开发者我倒是了解的不多吧。如果要选一位的话，我会选 Linus Torvalds。他的一句话我很喜欢：”Talk is cheap, show me the code”。 唐巧：在技术领域，你对未来有什么学习规划吗？ ibireme：在 iOS 方面，我可能会针对 Swift、音频处理和合成等方面投入更多精力。另外我第一份工作是 Java 后台开发，工作时前后端、数据库相关的东西也都接触过，所以如果有时间的话我也会继续学习这些技术，即使不用在工作上，也能开拓眼界吧。 结束语刚刚 ibireme 在介绍自己学习方法的时候，提到了两点我认为非常关键，一个就是大量地阅读优秀项目的源代码，另一个就是自己动手实践来尝试。 我在很久以前，分享过我认为 iOS 开发者可以提高自己能力的各种方法，见 《iOS 开发如何提高》，里面也提到阅读开源代码和多写代码。我感觉 ibireme 将这一点做到了极致，因此他在短短一年多的时间，就能够成长成为在业界有影响力的开源项目作者。 我们处在一个信息爆炸的时代，每一天都有大量的 iOS 开发文章出现，我们对这些文章如饥似渴，但是很多时候又浅尝辄止。像 ibireme 这样，专心阅读几个开源项目，然后自己动手真正实践，或许才是正确的学习方式。 希望 ibireme 的故事能够激励那些渴望成长成为牛人的 iOS 开发新人，也希望在中国能够出现更多像 YYKit 这样的优秀的开源项目，与大家共勉。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://blog.devtang.com/tags/Interview/"}]},{"title":"Charles 从入门到精通","slug":"charles-introduction","date":"2015-11-14T04:00:47.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/11/14/charles-introduction/","permalink":"https://blog.devtang.com/2015/11/14/charles-introduction/","excerpt":"","text":"目录及更新说明更新记录： 2013 年 12 月，第一版。 2015 年 11 月，增加 Rewrite 相关介绍。 2016 年 8 月，增加 Charles 4 的介绍，反向代理功能和设置外部代理，并且介绍了如何解决与翻墙软件的冲突。 本文的内容主要包括： Charles 的简介 如何安装 Charles 将 Charles 设置成系统代理 Charles 主界面介绍 过滤网络请求 截取 iPhone 上的网络封包 截取 Https 通讯信息 模拟慢速网络 修改网络请求内容 给服务器做压力测试 修改服务器返回内容 反向代理 设置外部代理，解决与翻墙软件的冲突 总结 Charles 限时优惠Charles 4 正版限时优惠优惠活动（限时：2016 年 8 月 8 日 - 15 日），优惠 30 元，点击领取优惠券。 简介 Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 Charles 4 新增的主要功能包括： 支持 Http 2。 支持 IPv6。 安装 Charles去 Charles 的官方网站（http://www.charlesproxy.com）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。 将 Charles 设置成系统代理之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。 启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 Charles 主界面介绍 Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 Structure 视图将网络请求按访问的域名分类。 Sequence 视图将网络请求按访问的时间排序。 大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。 对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。 过滤网络请求通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法： 方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuantiku.com , 那么只需要在 Filter 栏中填入 yuantiku 即可。 方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示： 通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。 方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。 截取 iPhone 上的网络封包Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。 Charles 上的设置要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示: iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示： 在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示： 设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。 截取 Https 通讯信息安装证书如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。 首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示： 需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示： 这样，对于该 Host 的所有 SSL 请求可以被截取到了。 截取移动设备中的 Https 通讯信息如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示： 按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。 模拟慢速网络在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示： 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示： 我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示： 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。 我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示： 接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。 修改服务器返回内容有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map 功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 www.yuantiku.com（线上服务器）。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。 下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示： 我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则： 完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示： Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。 Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。 下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。 需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 反向代理Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上。例如，在下图中，我将本机的 61234 端口映射到了远程（www.yuantiku.com）的80端口上了。这样，当我访问本地的 61234 端口时，实际返回的内容会由 www.yuantiku.com 的 80 端口提供。 设置外部代理，解决与翻墙软件的冲突Charles 的原理是把自己设置成系统的代理服务器，但是在中国，由于工作需要，我们常常需要使用 Google 搜索，所以大部分程序员都有自己的翻墙软件，而这些软件的基本原理，也是把自己设置成系统的代理服务器，来做到透明的翻墙。 为了使得两者能够和平共处，我们可以在 Charles 的 External Proxy Settings 中，设置翻墙的代理端口以及相关信息。同时，我们也要关闭相关翻墙软件的自动设置，使其不主动修改系统代理，避免 Charles 失效。 总结通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。 愿本文帮助大家成为 Charles 的专家，祝大家玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"被误解的 MVC 和被神化的 MVVM","slug":"mvc-and-mvvm","date":"2015-11-02T14:06:39.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/11/02/mvc-and-mvvm/","permalink":"https://blog.devtang.com/2015/11/02/mvc-and-mvvm/","excerpt":"","text":"被误解的 MVCMVC 的历史MVC，全称是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。 MVC 的概念最早出现在二十世纪八十年代的 施乐帕克 实验室中（对，就是那个发明图形用户界面和鼠标的实验室），当时施乐帕克为 Smalltalk 发明了这种软件设计模式。 现在，MVC 已经成为主流的客户端编程框架，在 iOS 开发中，系统为我们实现好了公共的视图类：UIView，和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开 MVC 这种设计模式。 但是，几十年过去了，我们对于 MVC 这种设计模式真的用得好吗？其实不是的，MVC 这种分层方式虽然清楚，但是如果使用不当，很可能让大量代码都集中在 Controller 之中，让 MVC 模式变成了 Massive View Controller 模式。 Controller 的臃肿问题何解？很多人试图解决 MVC 这种架构下 Controller 比较臃肿的问题。我还记得半年前 InfoQ 搞了一次移动座谈会，当时 BeeFramework 和 Samurai-Native 的作者 老郭 问了我一句话：「什么样的内容才应该放到 Controller 中？」。但是当时因为时间不够，我没能展开我的观点，这次正好在这里好好谈谈我对于这个问题的想法。 我们来看看 MVC 这种架构的特点。其实设计模式很多时候是为了 Don&#39;t repeat yourself 原则来做的，该原则要求能够复用的代码要尽量复用，来保证重用。在 MVC 这种设计模式中，我们发现 View 和 Model 都是符合这种原则的。 对于 View 来说，你如果抽象得好，那么一个 App 的动画效果可以很方便地移植到别的 App 上，而 Github 上也有很多 UI 控件，这些控件都是在 View 层做了很好的封装设计，使得它能够方便地开源给大家复用。 对于 Model 来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。比如我当时在做有道云笔记 iPad 版的时候，我们就直接和 iOS 版复用了所有的 Model 层的代码。在创业做猿题库客户端时，iOS 和 iPad 版的 Model 层代码再次被复用上了。当然，因为和业务本身的数据意义相关，Model 层的复用大多数是在一个产品内部，不太可能像 View 层那样开源给社区。 说完 View 和 Model 了，那我们想想 Controller，Controller 有多少可以复用的？我们写完了一个 Controller 之后，可以很方便地复用它吗？结论是：非常难复用。在某些场景下，我们可能可以用 addSubViewController 之类的方式复用 Controller，但它的复用场景还是非常非常少的。 如果我们能够意识到 Controller 里面的代码不便于复用，我们就能知道什么代码应该写在 Controller 里面了，那就是那些不能复用的代码。在我看来，Controller 里面就只应该存放这些不能复用的代码，这些代码包括： 在初始化时，构造相应的 View 和 Model。 监听 Model 层的事件，将 Model 层的数据传递到 View 层。 监听 View 层的事件，并且将 View 层的事件转发到 Model 层。 如果 Controller 只有以上的这些代码，那么它的逻辑将非常简单，而且也会非常短。 但是，我们却很难做到这一点，因为还是有很多逻辑我们不知道写在哪里，于是就都写到了 Controller 中了，那我们接下来就看看其它逻辑应该写在哪里。 如何对 ViewController 瘦身？objc.io 是一个非常有名的 iOS 开发博客，它上面的第一课 《Lighter View Controllers》 上就讲了很多这样的技巧，我们先总结一下它里面的观点： 将 UITableView 的 Data Source 分离到另外一个类中。 将数据获取和转换的逻辑分别到另外一个类中。 将拼装控件的逻辑，分离到另外一个类中。 你想明白了吗？其实 MVC 虽然只有三层，但是它并没有限制你只能有三层。所以，我们可以将 Controller 里面过于臃肿的逻辑抽取出来，形成新的可复用模块或架构层次。 我个人对于逻辑的抽取，有以下总结。 将网络请求抽象到单独的类中新手写代码，直接就在 Controller 里面用 AFNetworking 发一个请求，请求的完数据直接就传递给 View。入门一些的同学，知道把这些请求代码移到另外一个静态类里面。但是我觉得还不够，所以我建议将每一个网络请求直接封装成类。 把每一个网络请求封装成对象其实是使用了设计模式中的 Command 模式，它有以下好处： 将网络请求与具体的第三方库依赖隔离，方便以后更换底层的网络库。实际上我们公司的 iOS 客户端最初是基于 ASIHttpRequest 的，我们只花了两天，就很轻松地切换到了 AFNetworking。 方便在基类中处理公共逻辑，例如猿题库的数据版本号信息就统一在基类中处理。 方便在基类中处理缓存逻辑，以及其它一些公共逻辑。 方便做对象的持久化。 大家如果感兴趣，可以看我们公司开源的 iOS 网络库：YTKNetwork。它在这种思考的指导下，不但将 Controller 中的代码瘦身，而且进一步演化和加强，现在它还支持诸如复杂网络请求管理，断点续传，插件机制，JSON 合法性检查等功能。 这部分代码从 Controller 中剥离出来后，不但简化了 Controller 中的逻辑，也达到了网络层的代码复用的效果。 将界面的拼装抽象到专门的类中新手写代码，喜欢在 Controller 中把一个个 UILabel ，UIButton，UITextField 往 self.view 上用 addSubView 方法放。我建议大家可以用两种办法把这些代码从 Controller 中剥离。 方法一：构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。 方法二：用一个静态的 Util 类，帮助你做 UIView 的拼装工作。这种方式稍微做得不太彻底，但是比较简单。 对于一些能复用的 UI 控件，我建议用方法一。如果项目工程比较复杂，我也建议用方法一。如果项目太紧，另外相关项目的代码量也不多，可以尝试方法二。 构造 ViewModel谁说 MVC 就不能用 ViewModel 的？MVVM 的优点我们一样可以借鉴。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。 这样抽象之后，View 只接受 ViewModel，而 Controller 只需要传递 ViewModel 这么一行代码。而另外构造 ViewModel 的过程，我们就可以移动到另外的类中了。 在具体实践中，我建议大家专门创建构造 ViewModel 工厂类，参见 工厂模式。另外，也可以专门将数据存取都抽将到一个 Service 层，由这层来提供 ViewModel 的获取。 专门构造存储类刚刚说到 ViewModel 的构造可以抽奖到一个 Service 层。与此相应的，数据的存储也应该由专门的对象来做。在小猿搜题项目中，我们由一个叫 UserAgent 的类，专门来处理本地数据的存取。 数据存取放在专门的类中，就可以针对存取做额外的事情了。比如： 对一些热点数据增加缓存 处理数据迁移相关的逻辑 如果要做得更细，可以把存储引擎再抽象出一层。这样你就可以方便地切换存储的底层，例如从 sqlite 切换到 key-value 的存储引擎等。 小结通过代码的抽取，我们可以将原本的 MVC 设计模式中的 ViewController 进一步拆分，构造出 网络请求层、ViewModel 层、Service 层、Storage 层等其它类，来配合 Controller 工作，从而使 Controller 更加简单，我们的 App 更容易维护。 另外，不知道大家注意到没，其实 Controller 层是非常难于测试的，如果我们能够将 Controller 瘦身，就可以更方便地写 Unit Test 来测试各种与界面的无关的逻辑。移动端自动化测试框架都不太成熟，但是将 Controller 的代码抽取出来，是有助于我们做测试工作的。 希望本文能帮助大家掌握正确使用 MVC 的姿势，在下一节里，我将分享一下我对 MVVM 的看法。 被神化的 MVVMMVVM 的历史MVVM 是 Model-View-ViewModel 的简写。 相对于 MVC 的历史来说，MVVM 是一个相当新的架构，MVVM 最早于 2005 年被微软的 WPF 和 Silverlight 的架构师 John Gossman 提出，并且应用在微软的软件开发中。当时 MVC 已经被提出了 20 多年了，可见两者出现的年代差别有多大。 MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。所以，MVVM 模式有些时候又被称作：model-view-binder 模式。 具体在 iOS 中，可以使用 KVO 或 Notification 技术达到这种效果。 MVVM 的神化在使用中，我发现大家对于 MVVM 以及 MVVM 衍生出来的框架（比如 ReactiveCocoa）有一种「敬畏」感。这种「敬畏」感某种程度上就像对神一样，这主要表现在我没有听到大家对于 MVVM 的任何批评。 我感觉原因首先是 MVVM 并没有很大程度上普及，大家对于新技术一般都不熟，进而不敢妄加评论。另外，ReactiveCocoa 本身上手的复杂性，也让很多人感觉到这种技术很高深难懂，进而加重了大家对它的「敬畏」。 MVVM 的作用和问题MVVM 在实际使用中，确实能够使得 Model 层和 View 层解耦，但是如果你需要实现 MVVM 中的双向绑定的话，那么通常就需要引入更多复杂的框架来实现了。 对此，MVVM 的作者 John Gossman 的 批评 应该是最为中肯的。John Gossman 对 MVVM 的批评主要有两点： 第一点：数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。 第二点：对于过大的项目，数据绑定需要花费更多的内存。 某种意义上来说，我认为就是数据绑定使得 MVVM 变得复杂和难用了。但是，这个缺点同时也被很多人认为是优点。 ReactiveCocoa函数式编程（Functional Programming）和响应式编程（React Programming）也是当前很火的两个概念，它们的结合可以很方便地实现数据的绑定。于是，在 iOS 编程中，ReactiveCocoa 横空出世了，它的概念都非常 新，包括： 函数式编程（Functional Programming），函数也变成一等公民了，可以拥有和对象同样的功能，例如当成参数传递，当作返回值等。看看 Swift 语言带来的众多函数式编程的特性，就你知道这多 Cool 了。 响应式编程（React Programming），原来我们基于事件（Event）的处理方式都弱了，现在是基于输入（在 ReactiveCocoa 里叫 Signal）的处理方式。输入还可以通过函数式编程进行各种 Combine 或 Filter，尽显各种灵活的处理。 无状态（Stateless），状态是函数的魔鬼，无状态使得函数能更好地测试。 不可修改（Immutable），数据都是不可修改的，使得软件逻辑简单，也可以更好地测试。 哇，所有这些都太 Cool 了。当我看到的时候，我都鸡冻了！ 我们应该客观评价 MVVM 和 ReactiveCocoa但是但是，我突然想到，我好象只需要一个 ViewModel 而已，我完全可以简单地做一个 ViewModel 的工厂类或 Service 类就可以了，为什么要引入这么多框架？现有的 MVC 真的有那么大的问题吗？ 直到现在，ReactiveCocoa 在国内外还都是在小众领域，没有被大量接受成为主流的编程框架。不只是在 iOS 语言，在别的语言中，例如 Java 中的 RxJava 也同样没有成为主流。 我在这里，不是想说 ReactiveCocoa 不好，也不是想说 MVVM 不好，而是想让大家都能够有一个客观的认识。ReactiveCocoa 和 MVVM 不应该被神化，它是一种新颖的编程框架，能够解决旧有编程框架的一些问题，但是也会带来一些新问题，仅此而已。如果不能使好的驾驭 ReactiveCocoa，同样会造成 Controller 代码过于复杂，代码逻辑不易维护的问题。 总结有一些人总是追赶着技术，有什么新技术不管三七二十一立马就用，结果被各种坑。 又有一些人，总是担心新技术带来的技术风险，不愿意学习。结果现在还有人在用 MRC 手动管理引用计数。 而我想说，我们需要保持的是一个拥抱变化的心，以及理性分析的态度。在新技术的面前，不盲从，也不守旧，一切的决策都应该建立在认真分析的基础上，这样才能应对技术的变化。 版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"浅析一对一沟通","slug":"one-on-one-summary","date":"2015-10-25T10:06:42.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/10/25/one-on-one-summary/","permalink":"https://blog.devtang.com/2015/10/25/one-on-one-summary/","excerpt":"","text":"引言一对一沟通，又被称作一对一会议、One-on-one 等，是互联网公司常用的沟通方式。一对一沟通虽然被广泛使用，但是涉及的文章却很少，我主要通过两本书来获得它的一些知识，这两本书是《格鲁夫给经理人的第一课》和《创业维艰》。 这两本书的作者都非常有名，格鲁夫是 Intel 公司的总裁，成功带领 Intel 公司完成了从半导体存储器到微处理器的转型。《创业维艰》的作者本·霍洛维茨是硅谷的顶级 VC，投资了 Facebook、Twitter 等公司。 除此之外，我本人也是一对一沟通的实践者，从刚毕业踏入职场开始，我就经历着一次又一次的一对一沟通。 在本文中，我们将浅析一对一沟通的细节。 概述在《格鲁夫给经理人的第一课》一书中，格鲁夫对「一对一沟通」的介绍如下： 在英特尔，一对一会议通常是由经理人召集他的部属召开的，这也是维系双方从属关系最主要的方法。一对一会议主要的目的在于互通信息以及彼此学习。经过对特定事项的讨论，上司可以将其技能以及经验传授给下属，并同时建议他切入问题的方式；而下属也能对工作中碰到的问题进行汇报。 在我看来，一对一沟通的意义是可以使得信息从下而上地传递。从而获得在其它渠道不易获得的信息，保证透明。 讲一个我自己的故事。我有一阵子在开发中饱受产品调整之苦，很多时候刚刚做完一个产品功能的开发，然后产品需求就改了。对于一个对代码「有爱」的人来说，刚刚写完的几千行的代码要删掉，这个心情是非常沮丧的。 于是我就在一次和郭老大的一对一沟通中提出了这个问题。郭老大在表达同情之后，邀请我参加了一次产品的讨论会。在产品讨论会中，我看到大家都非常努力地在讨论产品方案，从而了解到，产品同事也非常不容易，他们需要在非常有限的时间内做出完整的产品方案，所以难免出现小的调整。而对于创业公司来说，「按时交付」是第一优先级的事情，所以我在这之后，接受产品调整的心态上就好受了很多。 我想这就是一次成功的一对一沟通。它首先让我的糟糕心情得到了宣泄，另外，它化解了我对于产品同事的抱怨，通过参与产品讨论，我甚至产生了对他们也不容易的「同理心」，能够理解他们也是在不得已的情况下，才调整产品方案的。最终，我们都接受了软件开发中的不完美，为了保证创业中按时交付，快速迭代的做事方式，和产品同事一起努力把事情做好。 适合讨论的问题从我刚刚的故事中，大家可以看到，「倾诉焦虑」适合用来做为一对一沟通的内容。其实，适合作为一对一沟通的内容还包括： 不成熟的看法 迫在眉睫的问题 精彩的想法 倾诉焦虑 抱怨 以上这些内容，除了在一对一沟通中交流之外，很难找到别的渠道来有效解决。比如，对一些公司做事方式的不成熟看法或误解，如果是和同事在私下讨论，可能让误解加深。又比如，在和同事合作中产生的抱怨，如果将抱怨公开，很可能造成不好的影响。 一对一沟通构造了一个渠道，这个渠道自下而上，使得以上这些内容都能够被倾听，从而被解决。 因为这是一个「自下而上」的渠道，所以员工的主动性就非常重要。在一对一沟通中，上司多听少说，让员工成为沟通的中心。上司应该引导员工表达他的核心观点（如果有的话）。如果可能，也可以试试让员工来安排一对一沟通。 建立舒适的沟通环境你会对一个陌生人敞开心扉吗？显然不会。那如果上司和员工平常极少聊天和沟通，那他们就不太容易讨论尖锐的问题。所以，上司应该尽可能和员工建立友谊。平时多聊聊天，在休息的时候聊些工作无关的话题，组织团队的 Team Building 活动，都有助于大家成为朋友。 另外，如果大家沟通的时候是坐在办公室里，那么员工的心情是不那么放松的，因为办公室始终是一个讨论工作的环境，让人无法放松。可能的话，可以尝试找一个公司的休息区，坐在沙发上沟通，或者直接走出公司，找一个咖啡厅点杯饮料，在咖啡厅里面聊天，都是不错的选择。 如果能请员工吃个饭，然后饭后聊聊天，散散步走一走，那么就更棒了。舒适的沟通环境有助于双方在放松的心情下交流，有助于大家更加平等地对话。 保持真诚沟通要有效，保持真诚是必要的前提，否则员工不可能将心中的问题提出来。 保持真诚需要不敷衍任何员工提出的问题，不管这个问题有多尖锐。如果你也不知道如何解决这个问题，不妨和员工一起讨论讨论，看看员工能不能一起寻找可行的办法。切忌不要讲空话和套话，一旦员工发现这是一个无效的沟通渠道之后，「自下而上」的通道就被关闭了。 保持真诚也需要坦白和诚实，坦白使得沟通双方能够尽可能地保证透明。足够的透明才能让员工理解上司的想法，从而达到双方考虑问题的方式一致，进一步言行一致后，大家就会产生近似的处事方式，上司就可以将事情充分授权给员工了。 但是，坦白也不是说不留秘密，如果一个问题你觉得不方便讨论，就坦白地说不方便讨论，并且如果可能，尽量给出理由。 适当引导并不是每一个员工都懂得一对一沟通的重要性，也不是每一个员工都能主动倾述问题，寻求帮助。很多程序员的性格都是比较内向的，有一些甚至不善于表达自己。 所以，虽然员工是一对一沟通的「主角」，但是上司也是需要进行适当的引导。对于上司已经发现的员工工作中的困难，可以适当的主动提出来，以便于更好地讨论，这也会让员工感到很体贴。 如果员工没有问题，一对一沟通也可以用于上司向员工传授工作经验和技巧渠道，这样员工可以向上司学习各种知识。 如果没有什么谈的，适合用来引导的问题也包括： 当前产品还有哪些可以提高的地方？ 我们部门的最大问题是什么，为什么？ 如果有，你觉得工作中有哪一点令你感觉不舒服？ 你觉得谁的工作最优秀，为什么？ 假如你是我，你会做何调整？ 我们的产品哪方面不尽如人意？ 我们错失的最大机遇是什么？ 哪些是我们应该做而没有做的？ 你自己希望未来在哪些方面能有提高？ 有什么我能为你做的事情？ 沟通的频率一对一沟通应该多久一次？在《创业维艰》一书中，本·霍洛维茨认为一对一沟通需要保证至少一个月一次。而格鲁夫认为，需要根据部属对工作的熟悉度，而进行不同程度的掌控。如果他处理的是新项目，你应该提高和他沟通的频率；反之，如果他对这个项目已经游刃有余，你可能一个月一次就够了。 另外，格鲁夫还认为，事情变化的速度也是影响一对一沟通频率的因素。比如市场和产品的变化就比技术的变化要快，所以市场部门的一对一沟通可能需要更频繁一些。 所以，并没有不变的沟通频率，但是几个月都不沟通明显是不太合适的。 沟通的时长一个问题要展开进行讨论和交流，15 分钟肯定是不够的，所以一对一沟通需要留有足够的时间。通常为了保留足够的 buffer，一对一沟通都至少是一个小时，并且可以根据实际讨论的内容有适当地延长。 沟通的效果除了能够帮助员工有效地解决问题之外，一对一沟通还有以下效果。 成功授权格鲁夫称「一对一会议有巨大的杠杆率」，因为这都是通过上司和下属间建立起共同的信息基础，以及近似的处事方式来达成的。这也是要达到「成功授权」的唯一途径。 相互学习如果上司想作好决策，那么他在会议中「从下属身上学到的东西」也同样很重要。格鲁夫说他对于 Intel 的很多决策想法，都是来自于一对一沟通中员工的意见。格鲁夫是一个程序员出行，他不懂制造和供应链，但是不影响他在一对一沟通中，从员工中学习这方面的知识，从而做出相应的决策。 家庭生活格鲁夫说，他有两个正值青春期的女儿，他尝试在家里的餐厅和孩子进行一对一沟通，在那个相对私密的场合，他们可以较严肃地谈一些细微且复杂的事情。 所以我惊喜地发现，一对一沟通对于家庭成员之间同样有效。 总结一对一使得企业里面的组织，产生了自下而上的沟通渠道，从而能够使得组织内的每一个人更加舒服地工作，让团队凝聚力更强。 本质上来说，一对一沟通就是构建一个私密的、轻松的、真诚的、有效的环境，两个人在一起讨论问题和相互学习。理论上，不管是公司内的管理，还是公司之间的合作，还是朋友之间的相处，还是家庭成员之间的交流，一对一沟通都能够发挥出它的效果。 看了这篇文章，明天你打算和谁来一场「一对一沟通」？ 版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"iOS 比 Android 还不安全? - 记一次和阿里资深安全工程师蒸米的交流","slug":"talk-with-zm-about-ios-security","date":"2015-10-22T14:12:16.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/10/22/talk-with-zm-about-ios-security/","permalink":"https://blog.devtang.com/2015/10/22/talk-with-zm-about-ios-security/","excerpt":"","text":"引言10 月 15 日晚上，我参加了 MDCC（ http://mdcc.csdn.net/ ）大会晚上的英雄宴，宴会上见到了 XcodeGhost 的研究者，阿里巴巴资深安全工程师蒸米。 蒸米是最早在乌云上公开 XcodeGhost 的工作原理的人。在后续 XcodeGhost 的服务器关闭后，蒸米也介绍了通过 DNS 污染来接管 XcodeGhost 木马的技术。让大家对于 iOS 平台的安全有了新的认识。 之前我和蒸米在微博上多次私信交流，这次当面见到真人非常开心。蒸米是一个性格开朗阳光的人，看起来非常年轻，一问之下才知道他 26 岁就提前博士毕业了，毕业之后一直在阿里从事安全方面的工作。 以下是我们讨论的一些总结。 Xcode 的安全这次 XcodeGhost 事件之后，让大家把安全的焦点集中在了编译器上。估计大家不会还从迅雷或网盘下载 Xcode 了吧？但是这样就安全了吗？ 蒸米在交流中提到，其实仅仅这样 Xcode 也是不安全的。为什么呢？因为我们在 Mac 上总要安装软件吧？有很多 Mac 下的软件并不通过 Mac AppStore 销售，而是以安装包的形式来独立发布。而安装这类 APP 时，常常需要用户输入登陆密码来获得更改系统内容的权限。这个时候，如果是一个恶意软件，偷偷修改了你本地的 Xcode，比如安装一个恶意的插件，你如何防？有些人习惯从一些非法网站去下载盗版的 Mac 软件，这个时候，你的 Xcode 安全也暴露在风险之中。 第三方库的安全这个是我自己的一个脑洞大开的想法，由于某些原因，国外的 Cocoapods 源很慢，所以常常有一些人宣称自己基于国内的服务，建立了镜像源。如果想做一点恶意行为的话，这些人完全是可以修改一些常用的第三方库（例如 AFNetworking），把 XcodeGhost 的代码植入进去。如果真的有人做了，你还能信任这些国内的镜像源吗？ Safari 保存密码的问题蒸米在和我交流中，也提到了对于 Safari 保存密码的安全性问题。就蒸米当场给我的演示可以看出，在设置里面的 Safari -&gt; 密码一栏，经过 Touch ID 验证，就可以将你的所有登录过的帐号密码查询到。而在 iPhone 5 一类没有 Touch ID 的 iOS 设备中，这些密码是被 4 位的锁屏密码保护，这个保护是极其弱的。如果你网上 google 一下，就可以找到专门暴力破解 4 位锁屏密码的工具。 看着蒸米当场的演示，真是把我吓了一大跳。同学们，你们有没有 Touch ID 的 iOS 设备吗？哪一天它要是丢了，你知道意味着你 Safari 所有登录密码可能被盗吗？ 为什么 iOS 系统比 Android 还不安全 ?蒸米在交流中一直强调他的观点，他认为 iOS 系统比 Android 还不安全。这一点让我非常不解，我当即指出：iOS 程序有 sandbox 限制，无法随意做高危险的事情，比如 Android 深受其害的扣费短信一条，iOS 程序很难做到自动发送。因为首先 iOS 程序很难在后台自动启动，另外，自动发送短信也是被系统禁止的。 但是蒸米解释让我觉得也很有道理，他的理由主要有以下几点： iOS 的系统漏洞更多iOS 的系统漏洞其实比 Android 更多，Android 因为是开源的系统，所以相关的漏洞更容易被发现和修复，而 iOS 是封闭的系统，它的漏洞只能指望苹果自己的工程师来修复。 就在我和蒸米交流的当天（10 月 15 日），国内的盘古团队宣布完成了 iOS 9 的越狱。而这距离 iOS 9 正式发布（9 月 17 日）才刚刚满一个月。蒸米说，其实越狱团队早就完成越狱的技术工作了，只不过需要完成越狱相关的产品以及等一个比较合适的时间点发布。所以，很有可能在 iOS 9 还在 Beta 版的时候，相关的漏洞就已经收集到了。 相对来说，Android 的最新版其实相当安全。不过 Android 的问题是 ROM 更新太慢，由于大多数 ROM 都经过了厂商的定制，使得大多数人无法及时更新到最新的操作系统，这个问题极大地降低了 Android 的安全性。 iOS 的系统版本和机型非常集中iOS 的系统版本非常集中，一般都是最新发布的 2 个大版本。另外 iPhone 机型也非常少，每年固定出一款。这使得黑客可以针对单一系统或机型挖掘出来的漏洞，得到极其方便地扩散和影响。 还记得早年 iOS 系统上面发面的 PDF 漏洞吗？用户只需要访问一个指定网址，就可以完成越狱过程。如果在未来有一个黑客找到一个类似这样的高级漏洞，那么受影响的很可能是所有的 iOS 用户。 相对来说，Android 的机型分散反但成了它的优势，我们自己开发小猿搜题 App 时，就那么几个界面都适配得要吐血，黑客的恶意程序难保不在一些机型上出现适配问题。除了硬件，Android 的 ROM 也是被修改得千差万别，所以黑客很难有精力把它的恶意程序做到完美适配。 iOS 系统更容易让人放松警惕我们尝试过用 IDA 逆向国内的 iOS App，发现国内的包括腾讯，阿里，百度，网易等，都没有对自己的 iOS App 源码进行混淆。而在 Andorid 端的，不但 50% 的 App 都经过了加壳和代码混淆，而且还有不少这方面的创业公司出现。这次在 MDCC 大会展台中就出现了多家做 Android 安全的公司。 我在交流中问蒸米，我们逆向了支付宝和淘宝的 iOS 客户端，发现代码都没有混淆，为什么呢？蒸米说，我们混淆了支付宝核心支付相关的代码，另外的代码混淆的推进，不是我一个人能做到的，需要等时机成熟。 我想这就是现状，大家对于 iOS 系统更多的时候是放心的，所以反倒容易翻船。就像我上面提到的 Safari 密码保护的问题，有多少人注意到它可能带来的安全问题呢？ XcodeGhost 是不是也是大家对 Mac OS 系统的一种放松警惕的行为？一些朋友在网上下载盗版的 Mac App 是不是一种放松警惕的行为？这些最终都可能成为黑客攻击的关键点。 提一个开放性的问题：如果你逆向了微信 iOS 客户端，你可以做哪些攻击？ Sandbox 真的就是绝对安全吗我在反驳蒸米时，提到了系统的 Sandbox 对于 App 的各种限制。蒸米指出，其实有好多方法来突破 Sandbox，比如调用系统的私有 Api（不要问我如何绕过苹果审核），又比如借助一些 iOS 的漏洞。 完美的越狱对漏洞的要求比较高，因为它需要保证即使系统重启，越狱状态也同样能保持。而如果你的目的如果不是完美越狱，而是干一些坏事的话，对漏洞的要求就不是那么高了。 你知道吗？中国的越狱团队还会向苹果上报漏洞，蒸米说这是为了 Reputation，一般是把手里多得觉得不太好用的漏洞报出去，你就可以想像这个封闭系统的质量了。 总结我最后问蒸米，是不是可以这样说：「iOS 和 Android 就是俩落难兄弟，都觉得对方弱，其实都差不多，全身都是洞，都不安全？」。蒸米说是的，毕竟开发者不是安全工程师，安全工程师们也不会开发，所以漏洞是在所难免的。 那这个事情就无解了吗？我想很可能是的，我们能做的，就是尽量提高安全意识，尽量小心，毕竟黑客也是会考虑性价比，挑软柿子欺负。最后蒸米向我推荐了 fireeye 的攻击检测网址，上面可以看到全球正在发生的黑客攻击行为 https://www.fireeye.com/cyber-map/threat-map.html ，我想这可能就是现实吧。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"写给那些傻傻的，想做服务器开发的应届生","slug":"why-fresh-wants-to-do-server-dev","date":"2015-10-07T04:05:50.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/10/07/why-fresh-wants-to-do-server-dev/","permalink":"https://blog.devtang.com/2015/10/07/why-fresh-wants-to-do-server-dev/","excerpt":"","text":"前言猿题库刚刚结束了北京地区的大规模校园招聘，国庆之后打算转战外地进行校招。我本人深度参与了此次的校招工作，包括笔试题命题、面试题命题以及具体的面试工作。 我在面试中发现了一个非常有意思的现象，就是大多数应届生都想做服务器端开发，但是他们却又不清楚服务器端开发具体要做些什么。 我和同事聊天的时候说起此事，我们认为可能应届生觉得：做服务器端开发可以让自己写的程序运行在很多台机器上，并且处理海量的数据，这很「牛逼」。而做客户端或前端开发太简单，成长会比较小。 于是我就写了本文，想给这些单纯的应届生泼泼冷水。先说说我的背景吧，我同时做过服务器端和客户端的开发。我在网易有道做过 1 年半的服务器端开发，产品涉及网易邮箱和微博产品，之后做了 3 年的 iOS 开发，产品涉及有道云笔记，猿题库和小猿搜题，所以我能够给大家分享服务器端和客户端开发的差别。 对服务器开发的误解很多应届生认为做服务器端开发可以处理海量数据，管理上百台服务器。 但是 —- 处理海量数据就牛逼了？NO！ 服务器端开发经过多年的发展，对于海量数据的处理早有了很多固定的解决方案。不管是用云服务，还是用 Hbase ，你都可以很轻松地依赖开源库，解决海量数据的存储问题。 还有一些同学想做大数据分析，如果你写过 MapReduce 程序就不会这么想了。现在的 MapReduce 程序写起来太 easy 了，很多时候简单到你就只需要写一条类似 SQL 的查询就行了。 运行在上百台服务器上就牛逼了？NO！ 现在虚拟化技术发展迅猛，像小猿搜题所有服务都通过 Docker 来部署。很多时候，部署上线就是在 Web 管理界面上点击一个「Deploy」按钮即可。即使在过去，实际操作这些上百台服务器的也是运维同学，轮不到你来操作。 所以，除了 YY 一下这些程序跑在多个机器上，这并没有什么可以带来成就感的地方。 还有一些应届生觉得自己在学校做过网站，觉得在服务器开发方面有基础，做这方面更顺手。NO！企业里面的服务器开发完全不是你想的那样，基本上大家在学校做网站的经验等于零。 服务器开发的苦我给大家分享一下做服务器开发有什么苦的地方吧。 永远只能半夜上线做为互联网公司，我们希望给用户提供 7 x 24 的不间断服务，那么服务万一需要中断怎么办？半夜上线呗。 根据我多年的观察，晚上 12 点一般都是上网高峰，所以上线一般都是凌晨 3 点-4 点的时候进行。但是，你以为上线就是凌晨 3 点点一下「Deploy」按钮就完了吗？NO! 一般上线都会涉及功能升级，难免会有考虑不周到的情况，于是就会发生，上线出问题的情况。 上线出问题怎么办？在网易，我们一般是两种做法： 在线调试和修改 Bug，通常顺利的话，到早上 7，8 点的时候一般就能搞定了。 在线调试和修改 Bug，如果不顺利的话，到早上 7，8 点的时候回滚数据。然后，我们需要回家休息半天之后，继续在下一个凌晨 3 点上线。 当然，不会每次上线都是这种大升级，但是基本上，1、2 个月搞一次这种大上线还是挺常见的。 相对来说，客户端同学在这方面要轻松得多。iOS 和 Android 都是提交应用市场审核，所以客户端的同学可以选一个白天上班的时候提交审核，而不用等到半夜。 永远需要立即响应服务器端的问题，只要出现，影响都是巨大的，所以服务器端的同学需要随时待命，一旦有服务器异常报警，就立即处理，以免影响到用户。所以做服务器开发的同学手机都是开着的，在服务不稳定时，一不小心，几十条报警短信就过来了。服务器开发出去旅游什么的，一般都带着笔记本，以便出问题时能够及时响应。 相对来说，客户端同学在这方面要轻松得多，因为即使出现了 Bug，iOS 和 Android 客户端也是无法马上修复的，因为用户手机中的版本不会立即更新。所以客户端同学最多也是加班发布一个紧急版本提交审核，在时间上不会像服务器端那么着急。 另一方面，很多客户端的 Bug，可以通过服务器端通过一些「兼容」来处理，这其实就是替客户端「擦屁股」。例如，假设某应用的 iOS 1.2.0 版本当获得服务器端返回的用户头象是 png 格式的时候会闪退，那么服务器端可以特殊处理，对于这个版本的应用把 png 图片转成 jpg 返回。你看，最终还是服务器端同事成了要立即响应的人。 服务器端轮子太多服务器端的开发经过了 10 多年的发展，而客户端的开发才刚刚兴起。2009 年 iPhone 3GS 推出之后，国内才有人做 iOS App 的开发，Android 开发的兴起也基本在同一时期。算下来，客户端的开发才经历了 6 年而已。而服务器端的开发呢？光 Spring 就出现了 10 多年了。 服务器端的技术长久发展的结果就是，基本上每个业务需求都已经有现成的轮子了。所以做服务器端开发很多时候就是学习各种开源组件的用法，并且熟悉这些组件的一些性能特点和坑。 你以为这很容易吗？其实不是的！这些轮子发展那么多年，已经非常复杂了，光 Spring 就包括非常多的特性，写一本 1000 页的书来介绍它也不为过。如果不是多年的使用，你能搞明白它的各种功能的优缺点吗？如果你搞不明白，遇到问题的时候除了抓瞎还能干嘛？ 所以做服务器端的同学，要经过非常长时间学习（至少半年左右），才能上手进行实际的开发工作。上手之后，又需要经过非常长时间的学习，才能够熟悉自己使用的各种开源组件的特点和使用细节。 相对来说，客户端同学在这方面要轻松得多，基本上不管是 iOS 还是 Android，新手只需要一个月左右就能入门，三个月左右就能够比较熟练了。 分工与细化刚刚说到服务器端复杂，这带来的结果就是分工与细化。每个做服务器开发的同学，可能只会涉及服务器开发的某一部分的业务逻辑和功能，甚至是某一部分业务逻辑的某一层。比如我在网易邮箱做服务器端开发时，就只是负责 Restful Api 这一层的开发工作。 从业务上来说，将复杂的系统拆分，然后每个人做独立的某一块当然是好的。但是对个人来说，服务器端开发却使终是一块迷雾环绕的大山，在这座大山上，你对你走过的路线很熟悉，而那些你没有接触过的服务器端技术，你使终是不清楚的。 对于一个服务器端开发同学，特别是进入大公司的应届生来说，在他头几年的工作中，肯定只会围绕着非常小一块功能业务来学习，那么一两年之后，他顶多是熟悉了他工作涉及的那些东西，对于别的东西仍然是不清楚的。 从这一点来说，去创业型的公司做服务器端开发又要比去大公司要好得多。 相对来说，客户端同学在这方面要爽得多。因为移动开发技术刚刚兴起，很多技术方案和框架还没有复杂到无法全面掌握的程度。移动开发技术就像一棵快速成长的小树，客户端同学将有幸伴随着它一起成长，等 5 年之后，移动开发技术成变成一棵参天大树，这一代的程序员，将会是唯一亲身经历它演进的人，每一处演进带来的改变，都将使得我们更加深刻理解移动开发系统的设计原则。 眼界和非技术成长某种程度上说，服务器端开发在业务方面是轻松的，因为他们只需要设计好 API 接口，返回 JSON 数据，不用考虑 UI 的设计，交互细节的处理。服务器端开发经过了多年的发展，单元测试和性能测试框架也非常成熟，所以开发起来非常有章法。 所以服务器端的同学大多数时候只需要关注纯技术的知识，例如如何保证高可用，高扩展性，高并发，数据一致性，数据安全等。 客户端就苦了，UI 需要和美术设计得完全一样，交互细节还需要做到流畅，很多时候产品用一用觉得一些 UI 和交互有问题，我们还需要被迫接受调整。另外在测试上，因为和界面耦合太紧，虽然业界有一些解决方案，但基本上不管是 iOS 和 Android 都还没有非常成熟好用的单元测试框架。大部分的测试工作都是由黑盒的手工测试完成的。 但是，正因为客户端需要密切和产品经理，UI 设计师打交道，所以他们会频繁接触到产品设计思想和设计思想。这使得客户端的同学更加容易学习和积累编程之外的技能，包括产品和设计的思想以及沟通能力。另外，因为用户的 bug 都是通过客户端反馈，客户端同学还更容易接触到真实的用户。 所以相对于服务器端同学来说，客户端的同学的眼界更宽，由于非技术方面的沟通更多，所以他们的非技术方案的成长也越多。 技术挑战和工资待遇从纯技术上的挑战来说，服务器端明显更大。服务器端开发动辄超过 10 人的团队，代码量稍微复杂一些就是接近百万行。而客户端一个平台的研发大多数也就在 5 人左右，代码量多在 10 万行以内。 但是，技术挑战大就表示工资待遇高吗？NO！市场价格是由供求关系来平衡的。虽然客户端的技术挑战小，但是基本上所有应届毕业生都想做服务器端开发，所以没有人做客户端开发呀！于是很多公司被迫从培训机构招人，很多人刚刚培训了 3 个月，就可以拿非常高的工资。这一点和 Web 前端类似，牛逼的 Web 前端人才非常少，但是不影响这个领域稍微牛逼一点的人拿非常高的薪水。 另一方面，由于服务器端人才的饱和，也使得竞争变得非常激烈，除非你成为这个领域的顶级人才，否则从平均薪资来说，做客户端开发的同学应该和服务器端的同学类似。 总结其实我这篇文章故意写得很片面，目的就是想让各位应届生同学们能够更加辩证地看待互联网行业中的工作。与其什么都不懂傻傻地选择服务器端开发，倒不如做客户端开发更有前途。 我以上所说的，都是错的。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"数据的秘密（下）- 如何分析数据","slug":"how-to-monitor-data","date":"2015-09-03T12:54:31.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/09/03/how-to-monitor-data/","permalink":"https://blog.devtang.com/2015/09/03/how-to-monitor-data/","excerpt":"","text":"前言上一篇文章中，我们介绍了为什么要关注数据，在本文中我将分享具体如何做。 关注宏观和细节大多数人都能做到关注宏观的数据，拿互联网产品来说，日活，月活，流失率，NPS（净推荐值），这些都是宏观的数据。宏观数据能够反映出产品的整体状况，是值得长期关注的。 但是在宏观之外，我们还应该关注一些细节的数据。拿日活来说，我们可以再进一步进行分析，比如： 日活中新用户所占的比例 日活中 iOS 和 Android 的各自占比 日活中大家集中活跃的时间段 日活中用户的会话（Session）次数分布，时长分布 日活中用户平均使用你的产品核心功能的次数 当你把数据拿放大镜看得更细的时候，你可能就会发现一些问题。带着这些问题，你进一步分析，就可以找到更多信息。 举一个我们创业产品小猿搜题的例子，我们发现日活中的用户，有相当一部分用户只是注册了，但是并没有使用我们产品的核心功能，于是我们担心会不会有一些付费推广渠道「刷量」。 所以，我们将新增用户中不活跃的比例按渠道来划分。通过这样的划分，我们很容易找到那些效果差的渠道，从而选择更有效的推广渠道。 关注原始数据原始数据是什么？就是那些不是通过别的数据计算出来的，不能被分割的数据。这些数据是最最真实的，而其它通过计算出来的数据，因为进行了二次加工，所以不一定能够完全反映出产品的问题。 再举一个小猿搜题的例子，我们为了研究 NPS 给我们打零分的用户。把这些用户的搜索数据、操作记录都抽样出来，一个用户一个用户看，然后进行分类整理。最终我们发现这里面小学生用户占比很高，从而调整了产品的策略，在内容和算法上对小学生进行了兼顾。 关注原始数据除了能改进产品外，还能在技术上提高代码的质量。我们曾经遇到过一个很难复杂的 Bug，在我们的测试机中都无法复现，但是我们通过分析相关用户的操作记录，找到了具体崩溃的操作方法。 虽然该操作方法不能在我们自己的机器上复现 Bug，但是我们却能找到相关的关键代码。通过一些针对这些代码的讨论，我们就找到了 Bug 的原因。现在回想起来，如果没有这些原始数据，要修复这个 Bug 就要困难很多了。 关于面试其实不光做产品要看「原始数据」，面试一个人也是。我在面试的时候，会选一个候选人简历上的事情，进行深入了解。我会让他提供详细相关工作的数据和事例。通过这些「原始数据」，我能够更加方便地「还原他真实的工作场景」，从而对他的工作质量作出尽量客观的评价。 举个例子，有一个产品实习生候选人在简历上写他运营了一个微信公众号，「粉丝逾千，单日粉丝增量 200 以上，数篇文章阅读量超过 3000」。但是在面试中，详细追问这些数字，我们才发现他说的「逾千」是指 1000，而「单日粉丝增量 200 以上」是指的最高的一天，其它信息也都是有夸大的成分。 还有一次，我面试一个技术候选人，这个候选人说他有代码洁癖，觉得前公司的代码「很乱，受不了」。但是我让他具体举几个例子的时候，他却很难说出实际的例子。还有候选人说他喜欢看技术书，但是却无法说出他印象最深的一本技术书以及其中的部分观点。 通过了解细节，我们就可以揭开简历中光鲜描述的外衣，了解到事情背后的细节，这对我们评价候选人至关重要。 数据可视化数据可视化是指将原本枯燥的数据，用折线图、饼图、柱状图等方式呈现出来，它可以使我们更容易发现数据的规律，也更容易发现数据的异常。 在小猿搜题项目中，数据可视化多次给我们带来巨大的帮助，包括： 了解数据的特点：我们将小猿搜题的 QPS 按每小时为频率画出成一条折线图，所以我们很容易知道我们服务器高峰期的时间段以及访问量。 发现服务异常：我们将服务器搜索的失败率占比画出成一个饼图，有一天，这个饼图中显示出失败率突然变高了。同时，每日的 NPS 分数突然也变低了很多。我们借此发现了新扩容的一台服务器故障。因为那台服务器是新加的，所以运维忘记了增加监控，如果没有数据可视化的帮助，这个故障可能会持续更长时间。 监控核心质量：我们将小猿搜题的一些核心指标画成折线图，然后大家都努力让核心指标更优。 发现恶意攻击：一些重要指标，我们都会可视化出来，这样当这些数据指标变化时，我们就会进一步分析原因，从中我们还发现了一些竞争对手恶意的攻击行为。 数据可视化工具我们当然不可能所有的数据可视化都是自己手工用 Excel、Numbers 之类的工具来生成。所以，我们开发了一个数据可视化的平台，我们把它叫做 flyboard。 flyboard 提供了各种数据可视化的方式，包括数字，折线图，饼图，环形图，柱状图等。如下图所示： 我们将所有的原始数据都归集到分布式存储 Hbase 中，然后通过配置一些定时的计算任务，就可以以几乎实时地方式，看到产品的各项可视化指标。 这些指标，有宏观的，也有一些比较细分的，如果我们对某项指标的数值有疑问，我们就会进一步写一些分析脚本，来从 Hbase 中计算一些数据进行检查。 在猿题库公司，我们的三个产品（猿题库、小猿搜题、猿辅导）的办公区域，都挂着一个巨大的显示器，这个显示器除了用于 Scrum 的每日站会同步进度外，平时都用 flyboard 显示着产品的各项核心数据。 悄悄告诉你一个秘密，我们的 flyboard 可视化平台是开源的，项目地址是：https://github.com/yuantiku/flyboard ，在 Github 上你可以下载到完整的代码，我们也附有完整的安装使用说明文档。如果你还没有使用任何数据可视化工具，欢迎尝试一下 flyboard。 学习写 SQL由于有 Hadoop、Hbase 、 Hive 的存在，产品经理也可以通过一些简单的 SQL 语句，就可以生成 MapReduce 任务，进行分布式的数据分析运算。 所以数据分析最最常用的办法就是写 SQL。在很多公司，产品经理都在这方面能力比较欠缺，这使得产品经理在需要数据时，需要向技术提需求。技术会根据自己的工作排期。这样一来一回，一般一个简单的数据分析都需要一天时间。 这样的低效率的方式，会扼杀产品经理的一些数据分析需求，特别是那种需要探索式发现的数据分析工作。因为这种工作需要不停地根据数据分析的结果，调整各种策略来写尝试的 SQL。 所以在猿题库，我们希望产品经理都能有基本的数据分析能力，一些简单的 SQL 都是需要自己能够写的。当然，一些特别复杂的 SQL，产品经理可能还是需要向技术同事咨询。 具体如何写 SQL，市面上已经有非常多的相关书籍了，我在这里就不再展开介绍了。 数据查看和分析一定要方便如果你仔细观察就会发现，很多革命性的产品就只是让某件事情更方便了一点点。智能手机其实只是让你上网更方便了一点，但是这种方便使得人们从以前有「离线和在线」的状态，变成了永久在线。于是，移动互联网诞生了，本质上来说，移动互联网就是一种人们永久在线的网络，但是就是这么一点点的方便，使得很多行业被完全颠覆。 而数据分析也是一样，我们应该尽量让数据触手可得，这样我们才能将数据分析的效率最大化，一定程度上的效率提升就会产生质变，使得我们专注于数据做更多事情。 我们之前移动端统计用 Flurry，但是 Flurry 在中国实在太慢了，即使挂上国外的 VPN 也很慢！如果产品经理每次登录 Flurry 要 10 秒钟的话，那么他就可能将注意力临时转移到别的事情上，然后就可能忘记本来要看的数据。 为了让数据触手可得，我们放弃了对 Flurry 的使用，我们自己开发了日志收集平台，然后自己写日志计算程序，将一些核心指标全部自己计算在 flyboard 上，我们也另外开发了一套数据分析平台，实现 Flurry 中的类似功能。现在，我们已经能够非常舒服地分析数据了。 所以，如果你的公司不能很方便的查看和分析数据，那么一定要想办法改进，这些数据就像人的神经系统一样，传递着产品的健康数据，重视这些数据，才能够做好产品。 总结总结一下本文中的观点： 重视宏观数据和细节 关注原始数据 数据可视化 学会用 SQL 数据查看和分析一定要方便","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"数据的秘密（上）- 为什么要关注数据","slug":"why-we-need-monitor-data","date":"2015-09-02T12:39:18.000Z","updated":"2024-01-06T14:52:37.924Z","comments":true,"path":"2015/09/02/why-we-need-monitor-data/","permalink":"https://blog.devtang.com/2015/09/02/why-we-need-monitor-data/","excerpt":"","text":"前言由于科技的进步，以及数据「数字化」地存储，使得现代人类可以获得海量的数据。而有了这些海量的数据之后，借助于一些数据分析工具和方法，我们就可以从数据中找到社会运行的「秘密」。 在工作中，借助这些「秘密」，我们有可能发现商业中的新机会，也可能验证或推翻自己的一些猜想。数据分析，使得我们对「秘密」的探索有了一个可靠的方法。 在本文中，我想分享一下工作中学到的发现数据中秘密的心得。 稻盛和夫的故事我们先看看 稻盛和夫 挽救日航的故事吧。他的这段传奇经历曾经被很多媒体报道，我将故事摘要如下： 2010 年 1 月 19 日，日本航空公司申请破产保护。日航有 58 年历史，一度被视作日本战后经济繁荣的骄傲象征。 2010 年 2 月 1 日，受日本首相邀请，稻盛和夫答应出日航董事长，一年之后，日航扭亏为盈，利润是对手全日空的三倍。仅仅用了一年时间，日航做到了三个第一，一个是利润世界第一，一个是准点率世界第一，一个是服务水平世界第一。 在日航重新上市之后，稻盛和夫分享了他 挽救日航的秘密。这里面涉及的内容很多，其中有很重要的一条，就是稻盛和夫非常重视日航具体的运营数据，他花了很大的力气来优化数据的获取，从而能够对日航的现状进行判断。 稻盛和夫是这样说的： 我担任董事长后，最为吃惊的是，公司的各项统计数据不仅不全，而且统计时间很长很慢，往往需要 3 个月之后才能搞全数据，以至于经营者无法迅速掌握公司的运营情况。所以，在对企业内部进行改革时，我特别关注统计工作。经过改革，现在各个部门的数据做到即有即报，公司详尽的经营报告，做到了一个月内完成。 如果把日航看过一个生病了的病人，稻盛和夫的做法其实和现代医学的做法类似，就是首先进行各项检查，获得病人的身体指标信息，有了这些检查数据，我们就可以利用各种基于数据的经验，来进行病情诊断和治疗。所有的治疗手段又可以通过再次的检查来验证，从而进一步改进治疗方法。 人做为一个生命体，全身密布的神经负责着各种信息的传递，所以我们的大脑能够接受到各种信息，从而做出决策，饿了吃饭，冷了加衣服，保证着我们身体的健康。 而企业没有天生的神经系统，所以数据收集和分析就显得异常重要了。日航作为一家运营了 50 多年的公司，居然在这方面做得非常差，难怪会进入破产的边缘。而稻盛和夫用的办法也很简单，先让数据能够收集起来，那么后续依据数据做决策就不再那么困难了。 Monitor your data（监控你的数据）我刚毕业的时候加入的是网易公司，当时负责做网易邮箱的底层 Restful Api。当时我们部门的老大郭常圳常常讲要「monitor your data」，我当时作为一个应届生，刚开始对这个口号不太理解。我当时想：数据当然是重要的，但是也不值得老挂在嘴边讲吧？但是后来我才慢慢发现，这其实确实非常重要。 作为程序员，我们开发一个后台服务，大家有没有测试过以下数据： 这个服务能够承受多少的 QPS（每秒访问量）？ 平均响应时间和 99% 的响应时间是多少？ 如果服务器压力增加，我们能不能通过简单的加机器来解决，需要加多少台机器？ 当前线上服务瓶颈在哪里？ 按当前的增长速度，多久我们得需要加机器？ 当时郭常圳带领我们，将我们做的每一个服务都进行了详细的压力测试，我们对于我们的服务承受力有着非常详细的数据测试结果。 这一点每个公司都做到了吗？其实不是。我还记得我们后来和网易的网站部共同开发网易微博后台，当时我们因为要将邮箱微博和网易微博数据合并，需要进行在线的数据迁移。我当时负责数据迁移工作，在我向网站部询问我应该用多大的请求压力来迁移数据时，对方只是回答：“尽量慢点”。 我当时就傻掉了，谁能告诉我什么叫 “尽量慢点”？于是我只能小心翼翼，一点一点地增加压力，最后我发现，他们的数据库其实一点压力都没有，我根本就不用控制压力都不会影响线上服务。但是，由于他们「monitor your data」做得不好，所以他们对任何可能的压力都心怀恐惧，不敢乱动。 后来我也私下和他们求证了一下，他们果然完全不知道他们的服务器能够承受多少 QPS。大家也可以问问自己公司的服务器同事，自己的服务器能够承受的 QPS 是多少，就知道自己的公司在这一点上做得好不好了。 而现在，数据驱动的思维更加深入到互联网开发中了。因此，国外的 New Relic 这类公司，才可以获得上亿美金的估值。 New Relic 的工作原理是放很多小的探针到你的程序代码中，这些探针收集到非常详细的程序运行数据，就可以为你优化服务器提供有效的建议。 产品上的「monitor your data」如果说技术上的「monitor your data」只是影响服务稳定性的话，那么产品上的「monitor your data」就会决定产品的成败了。 我认为产品上的数据分析有以下作用。 验证想法在互联网行业工作这么多年，我发现了一个秘密，就是任何新的互联网产品，都不是靠用户调研或数据分析来的。 因为用户调研非常难做，稍不注意就会被别的因素影响，所以乔布斯曾经说他从来不做用户调研。而数据分析对于一个新产品来说，会陷入无米之炊的尴尬境地。 所以很多新产品的第一版都是创始人或产品经理「拍脑袋」的产物。这一点其实是非常现实的做法。「拍脑袋」依赖于创始人的经验，如果创始人经验丰富，那么很可能产品对了 7 分，错了 3 分。另外那 3 分的错误假设，可以在产品上线后迅速通过数据来验证，从而迭代修正这些假设。 所以数据分析对于产品来说，第一大作用就是验证（或推翻）产品经理的假设，从而使产品能够得到快速迭代改进。 发现新的秘密很多时候，数据分析不光会得到你的产品本身的状态，还会发现一些新的机会。借助这些新发现，我们对产品产生新的认识。 拿我们的创业产品「小猿搜题」来说，我们一直在监控它的 NPS（净推荐值） 数据。为了把数据分析得更加细致，我们把打 NPS 0 分的用户行为进行了抽样分析，最终我们发现，虽然我们的 slogon 叫「初高中拍照搜题利器」，但是却有大量的小学生用户在使用我们的产品。 我们并没有为小学生做任何的产品上的优化，所以造成了这部分用户没有被很好的满足。所以，我们最近在内容和搜索算法上针对小学生做了特别优化，同时将产品的 slogon 修改成了「中小学拍照搜题利器」。 如果没有细致的数据分析，我们可能就错过了几千万的潜在用户。 发现数据规律一个产品会有非常多的指标，日活，月活，留存率，年龄分布，用户使用习惯等，产品经理应该对这些指标了如指掌，在对这些数据熟悉之后，产品经理就可以发现数据中的变化规律或异常点，从而对产品带来一些改进。 在这一点上，我喜欢讲林彪的一个故事。 1948 年辽沈战役开始之后，在东北野战军前线指挥所里面，每天深夜都要进行例常的 “每日军情汇报”：由值班参谋读出下属各个纵队、师、团用电台报告的当日战况和缴获情况。 那几乎是重复着千篇一律的枯燥无味的数据：每支部队歼敌多少、俘虏多少；缴获的火炮、车辆多少、枪支、物资多少。 司令员林彪的要求很细，俘虏要分清军官和士兵，缴获的枪支，要统计出机枪、长枪、短枪；击毁和缴获尚能使用的汽车，也要分出大小和类别。 经过一天紧张的战斗指挥工作，人们都非常疲劳。整个作战室里面估计只有定下这个规矩的司令员林彪本人、还有那个读电报的倒霉参谋在用心留意。 1948 年 10 月 14 日，东北野战军以迅雷不及掩耳之势，仅用了 30 小时就攻克了对手原以为可以长期坚守的锦州之后，不顾疲劳，挥师北上与从沈阳出援的敌精锐廖耀湘基团二十余万在辽西相遇，一时间形成了混战。战局瞬息万变，谁胜谁负实难预料。 在大战紧急中，林彪无论有多忙，仍然坚持每晚必作的 “功课”。一天深夜，值班参谋正在读着下面某师上报的其下属部队的战报。说他们下面的部队碰到了一个不大的遭遇战，歼敌部分、其余逃走。与其它之前所读的战报看上去并无明显异样，值班参谋就这样读着读着，林彪突然叫了一声 “停！” 他的眼里闪出了光芒，问：“刚才念的在胡家窝棚那个战斗的缴获，你们听到了吗？” 大家带着睡意的脸上出现了茫然，因为如此战斗每天都有几十起，不都是差不多一模一样的枯燥数字吗？林彪扫视一周，见无人回答，便接连问了三句： “为什么那里缴获的短枪与长枪的比例比其它战斗略高”？ “为什么那里缴获和击毁的小车与大车的比例比其它战斗略高”？ “为什么在那里俘虏和击毙的军官与士兵的比例比其它战斗略高”？ 人们还没有来得及思索，等不及的林彪司令员大步走向挂满军用地图的墙壁，指着地图上的那个点说：“我猜想，不，我断定！敌人的指挥所就在这里！” 随后林彪口授命令，追击从胡家窝棚逃走的那部分敌人，并坚决把他们打掉。各部队要采取分割包围的办法，把失去指挥中枢后会变得混乱的几十万敌军切成小块，逐一歼灭。 廖耀湘对自己静心隐蔽的精悍野战司令部那么快就被发现、打掉，觉得实在不可思议，认为那是一个偶然事件，输得不甘心。当他得知林彪是如何得出判断之后说，“我服了，败在他手下，不丢人。” 有些时候，一个数据中的异常点，就是一次决定性的机会。而产品经理只有做好「monitor your data」，才能抓住这样的机会。 培养产品直觉有一些产品，产品经理自己就是目标用户，所以可以比较容易用同理心来分析出用户的需求。但是像我们猿题库这次创业，目标用户都是初高中生，我怎么知道这些 00 后的需求、想法和兴趣爱好？ 除了多和他们聊天，多用他们喜欢的产品外，分析他们的行为数据也至关重要。郭常圳常常说：“我们做产品要有场景化思维，要还原用户当时真实的使用场景”。而通过分析一些用户使用数据，就有助于我们还原用户使用场景。 这种事情做得多了，我们就会更加了解用户了，慢慢就形成了产品的直觉。 总结关注数据和数据分析能力，是互联网时代生存的基本技能。不管是做产品还是做技术，养成「monitor your data」的习惯，都可以让你将工作做得更加出色。 本文讲完了为什么要关注数据，在下一篇里，我将分享具体如何做。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"我所理解的执行力","slug":"talk-about-execution","date":"2015-08-15T12:31:12.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/08/15/talk-about-execution/","permalink":"https://blog.devtang.com/2015/08/15/talk-about-execution/","excerpt":"","text":"从百度说起百度的文化里面，除了最近几年讲的「狼性」以外，还有从公司成立之初就一直讲的「简单可依赖」。这里面的「可依赖」三个字，在我看来，就是一种对执行力的理解。 我们从小长到大，父母其实给了我们依赖的感觉。为什么会有这样的感觉呢？因为无论什么事情，父母都会想尽办法帮我们解决，让我们能够在遇到任何棘手的问题时，都能想到向他们求助。 在企业里面，执行力做好了，给别人的感觉也就是「可依赖」。比如市场推广里面赶一个时间点，需要技术配合。如果技术负责人每次都能够在市场给出的时间点前，把任务完成，那么就给了同事「可依赖」的感觉。 那么技术部门做到这一点容易吗？其实一点都不容易。作为程序员，大家都知道，估计软件开发时间是一个非常难的事情，因为软件开发是一种智力密集型的创新工作，很难有两次开发完全一模一样的东西，所以开发中会出现很多未知的困难，这些极大的影响了对时间的估计。《人月神话》这本书就全面地暴露了软件工程的现实。 不光技术部门不容易做到执行力，其他任何部门也一样。市场营销的部门通常需要借助外界的友商或工具，任何外界的拖后腿也会影响他们的工作。 内容部门需要保证内容的质量，很多时候需要在内容形式上有创新，所以也不是紧迫的工作就可以简单加班完成。 在我们猿题库创业的时候，我们也有对执行力的理解，相对于百度来说，我们的口号更简单直接，总结出来是五个字：「把事情搞定」。「把事情搞定」是一种更直接的价值观，其实如果我们每个人都能「把事情搞定」，那么肯定带给别人的就是一种「可依赖」的感觉了。 如何作到有执行力那么，如何做到有执行力呢？这件事情很难，但我觉得有几下几点可以尝试。 坚持，永远不放弃对目标的努力小时候很喜欢看《灌篮高手》，其中有一个镜头印象特别深刻，当时安西教练在三井最绝望的时候说：“直到最后一刻，都不能放弃希望，一旦死心的话，比赛就结束了。” 所以，执行力要做好的第一点就是，需要对目标永不放弃。这意味着当我们遇到困难时，我们需要打起百分之两百的精神，想可能的解决方案。 我有一个大学同学修了英语双学位，打算报英语专业 8 级考试时，因为自己的失误，结果错过了报名时间。当她打电话给学校的教务处时，教务处老师严励地批评了她，并且拒绝替她补报。假如你是教务处老师，我想你肯定想维持这种制度，否则以后的学生工作怎么展开？ 那如果是你，你会放弃吗？我这个朋友想了很多办法，最终你猜怎么着？她通过研究，发现学校只是替大家报名专 8 的考试，于是她打到国家的考试中心，了解到考试中心也是可以接受个人报名的。由于学校需要把报名信息汇总到国家的考试中心，于是学校的报名截止日期比国家的早。于是她最终跑了几趟考试中心，成功补救了自己的错误。 在我们实际工作中，这样的例子会有很多。比如你遇到一个特别难修的 Bug，是不是就一定搞不定呢？我记得小猿搜题就出现过一次特别难修的 Bug，只存在于部分 iPhone 5 手机上，但是又不是百分之百复现，当时所有认识人的 iPhone 5 手机上都测试了，还是无法复现 Bug。但是我们的 iOS 开发同事并没有灰心，一条条看涉及用户的操作记录，最终从用户的操作行为数据上看出来了特点，从而猜到了 Bug 可能的地方。最终，我们没能在一台真机上复现 Bug，但是还是修复了它。 很多时候，再想一想，再试一试，可能就能找到问题的解决办法。 责任心，多替别人着想很多事情的完成，都不是一个人的努力，而是大家合作的结果。而我认为执行力的第二点，就是要有责任心，替别人着想。 很多事情在执行过程中会出现一些意外或疏漏，如果我们只管自己手头上的事情，那么最后由于别人和自己没配合好，最终也没有把事情搞定。从结果上来说，如果事情最终大家没能一起做成，那么自己是算不上有执行力的。 替别人着想，就是把团队看成一个木桶，大家除了把自己的工作做好外，还要主动地去把短板提高。这里短板可以是指： 一些能力不足的新人 一些未明确指定的工作 一些意外发生的事件，也未明确指定谁来完成 一些别人忽视的工作 例如，当我们发现同事的工作有些疏漏，比如技术实现上有一个潜在的 Bug 或者产品上有一个特殊情况没有考虑到，那作为一个有责任心的同学，就应该积极和技术、产品同事沟通，看是自己理解错了，还是确认是一个问题。 又比如来了新同事，我们可能不是他指定的 mentor，但他可能在工作中遇到各种各样的问题，如果我们正好坐在他旁边，那么 mentor 不在时，积极帮助新人解决问题也是一种对团队负责的态度。 又比如另外一个组的同事在开发的时候遇到一个技术问题，通过邮件组或 QQ 群向大家求助，如果你正好解决过此类问题，那么即便你很忙，也应该尽量给予相应的帮助。 当大家是一个团队的时候，团队的执行力就不是简单的大家的执行力求和，而取决于大家相互之间的帮助，否则这个团队的执行力会非常差。 全栈，努力提高自己的综合能力执行力的第三点要素，是要努力提高自己的综合能力。 一个技术人员如果只关心技术不懂产品，一个产品经理如果只关心产品设计不管实现，那么是无法做好工作的。 对于一个互联网公司的员工，市场推广，运营，产品和技术都是非常重要的，有时间跨界了解一下对方的工作，不但可以了解到对方工作的挑战，从而更加尊重对方，而且可以使自己在工作时更能替别人着想，使别人的工作更舒服。 我的朋友 Kevin 几个月前写了一本 《Producter》 的书，这是一本跨界的书，涉及到了设计，研发，营销，这就是一本很值得大家提高综合能力的学习材料。 综合能力除了指业务上的，还包括非业务的，比如自我和团队的激励。对于一个有执行力的人，你需要交给他事情就行了。如果你还需要时不时关心他的心理状态，时不时给他打打气，那么我认为这也是需要提高的地方。 以下是一个鸡汤，说得有点过，其实表达的意思就是大家需要学习自我心理调节和激励。 任何团队的核心骨干，都必须学会在没有鼓励，没有认可，没有帮助，没有理解，没有宽容，没有退路，只有压力的情况下，一起和团队获得胜利。成功，只有一个定义，就是对结果负责。如果你靠别人的鼓励才能发光，你最多算个灯泡。我们必须成为发动机，去影响其他人发光，你自然就是核心！如果你只看眼前的困难和压力，固步自封，再强的团队都带不动你！ 总结永远不放弃对目标的努力（坚持）、多替别人着想（责任心）、努力提高自己的综合能力（全栈），以上就是我所理解的执力力。 欢迎大家留言讨论。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"《异类》读书心得","slug":"the-story-of-success-book-summary","date":"2015-08-02T15:13:21.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/08/02/the-story-of-success-book-summary/","permalink":"https://blog.devtang.com/2015/08/02/the-story-of-success-book-summary/","excerpt":"","text":"最近读完了《异类》这本书，作者是格拉德威尔（Gladwell）。这是一本很薄的书，内容也多是以讲故事的方式，所以读起来会非常轻松畅快。 这是一本讲成功的书，以前我们都认为成功都是靠天赋 + 努力。而这本书告诉我们，成功的因素远远不止这些。还有一些很重要的成功因素被我们忽略了。 除了个人的天赋和努力外，成功的因素还包括： 社会环境（选拔规则） 家庭环境（家教方式） 时代环境（时间窗口带来的机会） 民族性格特征（文化传承） 运气（机遇） 下面，我们来分别看看这些成功的因素。 天赋和努力我们先说说天赋和努力吧。 在天赋方面，作者认为，智商超过 120 之后，差别就不大了。书中说道： 智商与成功只在一定程度上相互关联，一旦某人的智商超过 120 分，此时更高的智商并不意味着同比转化成更多的现实优势。 书中以特曼的天才儿童研究作为故事，讲述了特曼从 25 万个学生中，选出了 1470 名智商在 140～200 的儿童，然后跟踪记录这些高智商儿童的受教育的经历、婚姻、病例、心理健康表、每一次的提拔或者跳槽。 最终特曼发现，这些儿童的成就和智商并没有那么大的关系。 在努力方面，10000 小时定理还是再次出现，不管天赋多么高的人，都是经过 10000 小时的训练，才成为专家的。不管是钢琴家（书中以 6 岁就开始作曲的莫扎特为例），还是程序员（书中以 Java 语言的作者乔伊和微软的创始人比尔盖茨为例），他们都是由于环境的优势，早早地完成了 10000 小时训练，才成为人们眼中的天才的。 不知道大家算过没有，每天坚持 10 小时，10000 小时大概需要 3 年的时间。所以如果你想成为某个行业的专家（比如 iOS 开发），其实挺简单，每天坚持在这个领域练习 10 小时，那么 3 年之后你应该就可以做到。 当然，这是周末不休息的情况下，如果考虑周末休息，那么应该需要 5 年时间了。 社会环境对成功的影响书中以加拿大冰球队队员大多集中在 1 月份作为例子，指出这些球员被选出来，除了他们的天赋以外，更重要的是他们出生在 1、2 月份。因为加拿大的选拔规则： 加拿大冰球队按年龄分组所依据的分界线是 1 月 1 日，即从 1 月 1 日到当年 12 月 31 日之间出生的球员将会被分在同一组。也就是说，一个 1 月 1 日出生的选手，是在跟许多年纪比他小的队友争夺晋级权。 而年龄大几个月而显现的微弱优势，会在孩子的成长过程中不断积累，最终引导孩子走向成功或不成功，自信或不自信的轨道中，其影响会延伸许多年。 社会学家罗伯特·默顿援引《新约·马太福音》，把这种现象叫作 “马太效应”。“凡是有的，还要加给他，叫他有余；没有的，连他所有的，也要夺过来。” 成功者，换句话说，就是获得这些特殊机遇的人，他们因此最终取得了更大的进步。 马太效应使得我们小时候的一些优势，可以慢慢被积累放大，最终成为巨大的优势。 所以有一些家长为了小孩早点上学而改年龄，这样其实是不对的，因为这会造成这个小孩一直在早期处于竞争的劣势，从而丧失一些被选拔机会。 家庭教育对成功的影响通过对比中产阶级和低收入家庭对于教育的不同方式。作者指出中产阶级的「协同教育」（concerted cultivation）对孩子的发展更为有利。书中写道： 协同教育倾向于 “发掘孩子的天分，培养孩子的主动性和技能”。作为对照，低收入家庭对孩子的教育策略为 “自然成长”（accomplishment of natural growth）。这些家长只把抚养子女成人看作自己的责任，而把孩子的成长与发展看作孩子自己的事儿。 其实简单来说，协同教育培养的就是孩子的情商。通过引导，家庭教育可以让孩子找到自己的兴趣，沟通，与人良好相处，自我表达等能力。 但是书中也说到，两种教育方式也存在争议，因为 “自然成长” 的学生自主性更好。 拿我个人来说，我其实从小到大就是被 “散养” 的那一类。就我感觉，被 “散养” 的学生如果能够有较强的自主性，然后有机会通过别的方式来自我提高，那么自主性会成为 “自然成长” 的学生的相当大的优势。 时代环境对成功的影响时间环境如果合适，就会给你一份特别好的工作机会。盖茨出生于 1955 年，乔布斯出生于 1955 年，施密特出生于 1955 年，大家看出来了吧？ 另外，作者指出了一份好的工作应该具备的属性：自主性、复合性、付出与回报的关联性。 能赚多少钱并不是使我们快乐的最终源泉，使我们快乐的源泉是这份工作在多大程度上能让我们实现自我。 我的理解是： 自主性使得我们需要发挥自己的创新和思考。 复合性使得我们的工作并不单调。 付出与回报的关联性使得我们的任何努力都可以得到正向激励，从而强化我们的努力行为。 民族性格特征对成功的影响作者例举了： 游牧民族因为害怕牲口被偷，所以产生了好斗的性情：他们必须通过自己的言行表明自己不是弱者。 大韩航空的多次空难原因与民族性格的关系：韩国社会有严格的等级文化。 亚洲人受惠于稻田文化，以及中国人对数字的发音，对数学能力的影响。 个人主义与集体主义的特点。 知道自己传承的民族性格优点和缺点，就可以更容易理解别人的成功。 运气（机遇）对成功的影响总会有各种非常随机的事情，他们虽然看似微小，产生的结果却像蝴蝶效应一样巨大。 我毕业时本来打算去 IBM 的，因为一个朋友的一句 “过来看看吧”，而选择去有道面试 “玩一玩”。结果我从传统的软件行业，转到了互联网行业，现在更进一步，在移动互联网行业发展。如果没有那个朋友在 QQ 上的那句调侃的话，我完全无法想像我现在的生活。 生活中总是有各种各样的不确定性，让我们对未来充满着憧憬，或许这就是生命的有趣之处吧。 这是一本好书，推荐大家阅读～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"MOI 模型 - 读《成为技术领导者》","slug":"become-a-tech-leader-summary","date":"2015-08-01T04:23:32.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/08/01/become-a-tech-leader-summary/","permalink":"https://blog.devtang.com/2015/08/01/become-a-tech-leader-summary/","excerpt":"","text":"最近看完了温伯格的 《成为技术领导者》，本书英文名叫《Becoming A Technical Leader》。这是一本看起来很快，但是理解起来很慢的书，害怕自己看完书后过一段时间就忘了，于是我还是花时间整理了我阅读时的笔记和摘要。 图书一共有 24 个章节，分成 5 大部分。有一些章节完全以讲故事的方式展开，另外有一些章节又是以罗列知识点的方式展开讨论。全书结构如下： 第一大部分：定义。算是总体概括，介绍了领导力的定义以及领导方式模型等内容。 第二大部分：创新。领导方式模型之一。 第三大部分：激励。领导方式模型之一。 第四大部分：组织。领导方式模型之一。 第五大部分：转变。 在分享我的流水帐似的笔记之前，先说说给我印象最深的几个书中的观点吧。 观点一：领导力究竟是什么？ 所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。 所以领导力应该注重过程管理而不是管理人，在过程中帮助大家发挥更大的能力。书中打了一个比方，就像园丁培育种子那样，不是揠苗助长，而是催生种子自身的力量。 领导力就是催生他人身上的创造力和生产力。这对于技术领域的工作更适用，因为在技术团队中，大家的工作量不好衡量，工作细节需要创造力和努力。 从某种意义上说，技术人员转型做领导，在方面应该是偏弱的，因为创造环境是需要更多的与环境交互，而技术人员更多擅长的是与计算机交互。与环境交互所需要的技能和与计算机交互所需要的技能是完全不一样的。 所以，对于技术人员来说，成为技术领导的道路并不容易。 观点二：实践作者指出对于管理来说，其实是实践大于理论的，所以作者在「学习成为组织者」一章中，首先就提出了实践，并且指出：组织人的很多理论「表面上看」是相互矛盾的，所以需要实践的指导，才能理解其特定环境下的意义。对于一些当前不是领导的人，作者列出了一些实践的方式，例如：职业协会，社团等。 光实践不行，还需要思考，观察和试验就是思考的具体方式。观察是说发现社交环境里面的一些「秘密」或规律。试验是说想一些办法来验证自己的假设。 作者举了一个例子，比如观察大家在开会时坐的位置，出游的时候让孩子收拾行李，观察孩子的行为方式。 通过观察和试验，可以让自己形成分析和思考的习惯，另一方面，我感觉这也是培养好奇心的方式。 观点三：写日记本书的译者余晟在序言中用「身份证掉了怎么办？捡起来。」来比喻写日记。简单来说，在确定一些事情怎么做之后，简单的重复和坚持就能收获效果。很多事情没有技巧，只有 10000 小时的规律，你坚持在某项事情上投入时间，就能够获得相应的收获。 总结出来就是 4 个字：切忌浮躁！ 观点四：一些常识我在工作中积累了一些「常识」，在本书中得到了更一步的确认，这些常识包括： 因为具体的 Coding 工作做得少了，做技术领导肯定会影响自己的编程实践能力。 不要做那些已经分配给别人的任务，即便必须让手下人犯错误。 不能因为害怕犯错或丢脸就不尝试心中想做的事情。 讨论问题的时候需要就事论事，不能为了争论赢而争，也不能带有个人情绪。 这是一本不错的书，推荐大家阅读。 读书摘要和总结以下是详细的每一章的摘要和总结。总结中加入了我自己的思考，不一定正确，仅供参考。 第一部分：定义第一章 领导力究竟是什么定义了领导力。 所谓领导力，就是创造这样一个环境，每个人都能在其中发挥出更多的能力。 所以领导力应该注重过程管理而不是管理人，在过程中帮助大家发挥更大的能力。书中打了一个比方，就像园丁培育种子那样，不是揠苗助长，而是催生种子自身的力量。 领导力就是催生他人身上的创造力和生产力。这对于技术领域的工作更适用，因为在技术团队中，大家的工作量不好衡量，工作细节需要创造力和努力。 第二章 领导方式模型介绍了领导方式模型 MOI。 讲了故事，从学弹玻璃球，说明即使合理的指导也不一定有用。因为人们需要克服自己性格的缺陷。 领导力 MOI 模型： M - 激励 (motivation)：奖品或是磨难 O - 组织 (organization)：组织结构 I - 头脑或创新 (ideas, innovation) 第三章 解决问题的方式介绍了解决问题的方式，分三个方面： 理解问题 管理思维 保证质量 理解问题： 细心阅读规范 鼓励成员认真阅读规范 解决分歧时，要回到最初的问题 从客户处获得规范清晰的定义和额外信息 工作进行一段时间之后，能更好理解某些需求的意义时，再回头看看规范。 这个其实就是产品里面讲的了解真实的、原始数据，基于原始数据做决策。 管理思维 这一点更多是想关于想法的交流，作者提出： 要为了团队，敢于放弃自己原本坚持的想法 不要为了自负而坚持自己的想法 如果别人没有充分理解自己的想法理由，则应该坚持表达。 明确批评想法而不是批评人 考虑想法实施的时间成本 根据形势变化，要学会重新考虑以前考虑过的想法 这一点有一些涉及开会时的交流技巧，有一些涉及工作内容管理。 保证质量 作者提出了一些办法，包括进展中测试质量，观察进展速度，动态评估速度等。 第 4 章 领导的成长首先介绍了领导力的成长是阶段性的，刚开始成长很快，然后进入一段平滑期，然后又快速成长。整体是一个阶梯的方式在上升。 似乎本章就只讲了这个。 第 5 章 我做不到，因为。。。指出了一些借口，比如： 我不是领导。作者指出领导力和领导是两个概念。我的技术会退步。这个我感同身受呀！文章似乎没有给出答案。只是说这是一个 “艰难的选择”。 第二部分 创新第 6 章 创新的三大障碍本章如题，讲了三个障碍： 不能从旁观者的角度看待自己。学会观察自己和别人是一个好办法。也可以让别人来观察自己，给自己找问题。 没问题综合症。其实就是需要倾听，了解对方真正想表达的内容。要点：不打断别人，了解清楚对方的需求，不着急下结论或提供解决方案。 看不见其他办法，以为方法只有一个。 感觉作者有点绕，转化一下，就是：自省，倾听，开放。 第 7 章 加深自我了解的工具每天花 5 分钟写日记。 第 8 章 提升创新能力别害怕犯错，偷窃（别人的想法） 第 9 章 眼光其实是讲的看问题的角度。以及通过良好的角度看待问题，从而实现的自我的思想控制。 第三部分：激励第 10 章 激励他人的第一大障碍这章主要讲交流上容易产生的误解。简单来说，表达沟通要清晰，避免产生误解。如果产生了误解，也应该想办法控制自己的情绪。 第 11 章 激励他人的第二大障碍里面通过讲故事，提了很多经验，包括： 关系到生存问题时，必须把人放在第一位，别无选择。 如果不是高度技术化的工作，领导就可以通过威慑来领导，而不需要太强的能力。 有强大技术背景的人可以把任何任务都转化为技术任务，以逃避他们不想做的事情。（即本来沟通说一句话的事情就可以避免很多开发的活，却不能主动沟通） 不关心人的领导没有可以领导的人，除非手下人别无选择。 如果你不能提供什么实质的内容，却假装有内容，那么无论你多么关心别人，都不会吸引他们。 面向任务的领导往往都高估了自己的成就。 我们所做的工作，几乎无一真正重要到必须牺牲执行者的未来。 如果任务很复杂，就没有哪位领导能够保证不会「百密一疏」。 要成为成功的领导，就不能对人性有细毫抑制。 如果你是领导，以平常心对待他人就是你的任务， 在此之外，没有其他值得完成的任务。 第 12 章 帮助其他人会发生的问题在帮助的时候明确信息，避免让对方产生误解。 第 13 章 学会激励他人始终真诚（无论你是否刻意），来自《人性的弱点》卡耐基的书。 第 14 章 力量从何处来这部分首先讲了关系的力量和技术的力量。 然后，作者似图说明，不应该当想着力量，这里的力量似乎是指一个人的权力或影响力。而应该寻求自己真正应该追求的东西，比如团队的表现，大家是否工作舒服。 本章最后的一些问题比较有意思： 如果你中了五百万彩票，你要做什么？没有钱的时候，是什么阻止你做这些事情？ 你现在想要掌握什么力量？如果你放弃了，最坏结果是什么？最好结果是什么？ 第 15 章 力量、缺陷与一致简单来说，就是要保证自己真正的真诚，一致。如果做得不好，就应该努力改变自己。 第四部分 组织第 16 章 培养组织力从头到尾讲了一个力量转换的故事，其实是说了解清楚自己的筹码，用自己筹码投资更有价值的事情，那些可以提升自己能力的事情。 作为领导，更需要注意用自己的力量为团队成员谋福利，包括成长的机会和更舒服的工作环境。 第 17 章 团队有效的组织形式主要介绍了几种组织的决策形式，并且讨论了各自的优缺点。这些组织形式包括： 独立解决 投票 强势领导（其实就是领导说了算） 一致意见（大家在充分沟通信息的情况下，共同参与决策） 结论是没有什么必然最好的组织形式。 如果讨论的时间充分的话，一致性决策应该是比较好的决策方式。但是并不是所有事情都可以通过一致性意见来决策，比如讨论时间不足以大家达成一致，信息交流不够充分，大家由于知识背景或经验的原因造成观点不一致。 一个解决问题的组织，他的功能应该是创造一个环境，让大家： 理解问题 管理思维 保证质量 第 18 章 有效组织的障碍作者列出了以下障碍： 抓大目标，英文原文是 Playing big games，我的理解是简单的下命令，而不关注事情的细节，难点，以及执行者的特点，沟通推进的步骤等。简单来说，就是那种只享受着下命令的爽快，却不关注把事情搞定背后需要的整个过程的细节的人。 把人当机器，例如搞过多的标准和流程，以为这些规则就可以让事情做成。 亲自动手，这个是技术人员升到管理人员常常经历的一个时期，刚开始什么都想亲自做，但是领导的职责不是解决单个问题，而是创造一个环境，让许多问题都可以在其中解决。 奖励低效组织，组织不是要解决问题，而是要避免问题。如果都看见明显的危机了，说明之前的规划就有问题了。这一条说起来容易做起来难，比如安全问题，都是遇到了这方面的问题再解决，如果在要问题出现之前就避免，公司领导会不会觉得安全部门没什么用处？ 解决问题的领导的全部目标就是：创造一个环境，其中每个人都能解决问题，做出决策，再执行这些决策。 第 19 章 学习成为组织者实践这方面其实是实践大于理论的，所以本章作者首先就提出了实践，并且指出：组织人的很多理论「表面上看」是相互矛盾的，所以需要实践的指导，才能理解其特定环境下的意义。 对于一些当前不是领导的人，作者列出了一些实践的方式，例如：职业协会，社团等。 观察与试验光做不行，还需要思考，观察和试验就是思考的具体方式。观察是说发现社交环境里面的一些「秘密」或规律。试验是说想一些办法来验证自己的假设。 作者举了一个例子，比如观察大家在开会时坐的位置，出游的时候让孩子收拾行李。 通过观察和试验，可以让自己形成分析和思考的习惯，另一方面，我感觉这也是一种好奇心的方式。 寻找差异：他们在尽力做到最好作者介绍说其实组织的每一个人都在尽力做到最好，组织的组织行式或问题，也可能是在历史中为了解决某一个特定环境下的问题而遗留下来的。 所以，「理解」现有组织存在的原理是第一步，在理解之后，才可以做改进。 找出接错的电线上一节说老的团队，这一节说新的团队问题一般是理解错误造成的。 为差异正名本节是说每个人都有自己的性格特点。差异是正常的，合理的。比如在信息方面，有人用直觉来获得信息，有人用数据来获得信息。 文中推荐了 Myers-Briggs 模型，以及《Please Understand me》。但未展开介绍模型和书的内容。 把自己当做团队的模型再一次提到 Myers-Briggs 模型，指出内向的人依靠内部知识来充实自己，向外的人依赖外部资源（可能就是交流吧）来充实自己。 成功后仍要改变一旦建立了有影响力的团队，自己的任何调整会团队的影响都是巨大的，需要更慎重。 第五部分：转变第 20 章 领导要面对的考核通过一个老师上课的故事，来介绍老师是如何面对挑战的。 另外故事中讨论了关于评分的问题，这个和企业中的 KPI 类似，是一个不太好搞的事情，作者介绍了两个观点： 首先大家需要建立信任。 自己要相信这套规则。 第 21 章 通过自己的领导力考验其实就是不断自省，找自己做得还不够好的地方。保持学习的饥渴，永不满足现状。 第 22 章 个人转变计划介绍了一些可以提高自己的办法，类似于流行的「逃离舒适区」的概念。就是找一些新鲜的事情，仔细观察，从中尝试看看有没有什么收获。 第 23 章 时间从哪里来介绍了一些做事技巧： 不要重复你已经布置下去的任务。这一点常圳也提到过。如果一件事情你自己已经做得非常熟练了，那么就交给别人来做。这样的好处是：你可以指导新人，新人也可以从中得到锻炼。 不过这样牺牲的是这件事情本身的完成时间，在指导阶段，你自己直接做花的时间，肯定比让新人做 + 你进行指导的时间少。 但是长远看来，这样的方式对组织和个人都是有利的，所以还是应该尝试。 不要争论技术细节来证明你的技术优势如果你还需要争论技术细节，就说明你的技术声望还没有建立。所以不要试图通过争论来证明你的技术优势，而是应该通过建立自己的技术声望，来避免在技术细节上进行长时间的争论。 自己区分事情的主次，不要靠危机来安排你的行为想起了《道德经》里面的经典段落：悠兮，其贵言。功成事遂，百姓皆谓 “我自然”。 好的领导应该避免危机，但是在没有危机的情况下，领导和大家可能都会觉得 “这个人没事干，没什么用 “。 本章小节： 不要做那些已经分配给别人的任务，即便必须让手下人犯错误 不要操心细节 不要浪费时间证明自己的全知全能 不要浪费时间争论 关注自己无事可做的时候在做什么 分享阅读成果 充分利用机会进行交流 倾听他人已经学到的知识 第 24 章 支持从哪里来本章主要介绍大家要学会利用自己的社交网络来构建自己的「支持系统」，这包括： 自己的技术圈子，需要时可以咨询他们。 批评者，可以指出自己的问题。 可以倾述的朋友，或者可以维持自己开心的事情。 后记后记中讲了两个故事，还挺有意思。 第一个故事是作者的护士为了戒除他住院手术时产生的止痛针（吗啡）的瘾，直接强制拒绝他的要求。 第二个故事是作者的 IBM 领导，在他提出想做管理的时候，他的上司并不是拒绝，而是让他尝试列出他当前做管理的优点和缺点。作者通过这种方式达到了自省的目的，发现自己当前并不适合做管理，从而暂时放弃了要求。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"让我们再谈谈 iOS 安全","slug":"ios-security-book-recommendation","date":"2015-07-11T12:27:25.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/07/11/ios-security-book-recommendation/","permalink":"https://blog.devtang.com/2015/07/11/ios-security-book-recommendation/","excerpt":"","text":"前言安全方面的话题总是聊不完的。这不，国外一家有名的专门攻击别人的安全公司 Hacking Team 自己被 Hack 了，结果有 400 多 G 的攻击资料泄漏出来，包括一些 0-day 的漏洞。这里 有别人写的这次攻击的分析。 我大概看了一下这次的泄漏出来的 资料分析，发现里面还有一些涉及 iOS 的安全。比如： 一个用于记录密码的 iOS 键盘。 一个 iOS 网络底层的代理。 一个 MAC OS 木马。 这些攻击都挺难防的，拿 MAC OS 的木马来说，基本上 Mac 用户都是不装杀毒软件的。虽然大部分应用都是从 Mac App Store 上下载，但是也有不少应用是用自己的渠道来发布的，所以用户稍不注意可能就会中招。 《iOS 应用安全攻防实战》 在几个月前，电子工业出版社的老师找到我说，《iOS 应用安全攻防实战》 这本书的中文版将要出版了，邀请我写一篇推荐序。我正好以前看过它的英文版，是一本相当不错的 iOS 安全方面的著作，所以在此推荐给大家。 《iOS 应用安全攻防实战》的两位译者实力也很强，都是安全方面的专家。其中： 译者肖梓航是 Palo Alto Networks 高级研究员，主要方向是移动平台反病毒和软件安全，也是著名的安全社区「看雪论坛」的版主。 译者李俱顺 @s1mbily 曾就职于支付宝大安全，现在是杭州云柚科技联合创始人。 在写本文的时候，我还顺便检索到了译者李俱顺一次分享：iOS8 应用安全新挑战，也非常适合广大 iOS 开发者用来普及安全知识。 《iOS应用逆向工程》 即然都提到安全了，也顺便再给大家宣传一下，我的朋友吴航写的《iOS应用逆向工程 第2版》也在2个月前顺利出版了。本书第一版卖得很好，不过安全方面的内容业界更新得很快，所以他们将第1版中过时的内容进行了更新，同时增加了更多篇幅。 《iOS应用逆向工程 第2版》偏重攻击方面多一些，不过知道攻击方法后，防范方法也就相对容易想到了，所以同样推荐给大家。 送书我从出版社要了 10 本 《iOS 应用安全攻防实战》，打算送给我的「iOS 开发」微信公众号的读者。具体的送书方式是：我会请一些 iOS 安全方面的朋友来分享一些内容，同时提一些问题，回答得好的朋友，即可获得赠书。 扫描以下图片即可关注该公众帐号。 推荐序以下为 《iOS 应用安全攻防实战》 推荐序《为你的iOS程序穿上安全的外衣》正文： 从有计算机程序开始，安全问题就一直存在，而互联网的流行使得安全问题被进一步放大，所以现在各大互联网公司对于安全都非常重视。我曾经所在的网易公司就有专门的安全部门。安全部门的同事会扮演黑客的角色，对网易旗下的产品进行各种试探性的攻击，从而发现公司产品在安全方面的问题。 在移动互联网快速发展的今天，iOS 应用由于直接运行在用户的手机上，相比运行在服务器的后台服务，更有可能被黑客攻击。恶意的一些攻击手段包括劫持网络通讯、窃取本地数据以及篡改程序行为。很多人把安全问题完全交给 iOS 系统自带的沙盒（Sandbox），但是仅仅靠沙盒也是不够的。因为如果不做其它的防护，一旦沙盒被攻破，那么程序的安全性就完全无法保障了。 而在中国，这样的问题尤为突出，因为中国对软件的版权保护不力，使得盗版软件流行。而 iOS 应用如果需要安装盗版软件，越狱系统是最为方便的方式（另一种方式是用企业签名）。越狱催生出一些 iOS 盗版应用市场，从而出现一些盗版的游戏、软件以及木马病毒的传播。 做为 iOS 应用的开发者，我们当然不希望自己的游戏被修改成无限道具和金币，自己的应用被修改成无需付费就使用应用内付费功能，更不希望黑客在自己的应用中植入木马，窃取受害用户的帐号密码等敏感信息。而这一切，都是沙盒无法保护的。我们需要做更多的安全方面的工作，才能抬高应用被破解和修改的成本，使得自己的应用更加安全。 但是，「猫和老鼠」的游戏每天都在上演，在我们不断增加防御手段的同时，黑客的攻击手段也在不断升级。所以，安全问题会是一个永不过时的话题，没有绝对意义上的安全。我们能做的，就是不断学习和研究，使得当前自己应用的安全水平已经能够防止大多数别有用心的黑客攻击。 那国内 iOS 安全的现状是什么样呢？就我所知，几乎 99% 的 iOS 应用都没有做破解方面的防护。但是，如果你简单做一些代码混淆、反动态库注入、反调试方面的工作，就可以将应用被破解的难度大大提高。另外，如果你使用 IDA 进行 iOS 代码反汇编的话，你几乎可以看到你想看的所有应用的源码。 我还记得 2015 年的春节前夕，微信在其应用中做了一个抢红包的功能，但是这个功能还在测试中，所以被设置成永不开启。但是，我认识的一个做安全的朋友却用本书中介绍的 Cycript 工具，将这个功能打开了，结果造成了相关功能被提前泄漏到了网上。而一些破坏性更强的逆向攻击行为我都不敢将其公开，因为几乎所有应用都在这些攻击方式下不能幸免。 那我个人为什么对安全这么感兴趣呢？其实说来话长，我高中时就开始学习编程，当时的梦想是当一名黑客。于是安全方面的学习就一直伴随着我的职业生涯。而我在学习 iOS 移动开发的时候，带着习惯，我也就开始学习 iOS 开发安全方面的知识。 还记得我学习 iOS 开发安全的时候，曾经看过本书的英文版。本书的内容同时包括了攻击和防御相关的内容，非常适合 iOS 开发工程师学习，并且将其中的实践带到自己的应用中，以保护自己的应用不被攻击。我并不期望本书能够解决所有的安全问题，但是我相信，看过本书的朋友，能够将自己的 iOS 应用在安全方面的得分，从不及格提升到 80 分。 最后，感谢本书的作者、译者，以及电子工业出版社在 iOS 安全方面所做的贡献。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"Apple Watch 使用体验","slug":"apple-watch-usage-exp","date":"2015-06-28T05:47:22.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/06/28/apple-watch-usage-exp/","permalink":"https://blog.devtang.com/2015/06/28/apple-watch-usage-exp/","excerpt":"","text":"虽然做了多年 iOS 开发，但我算不上一个真正意义上的果粉，所以 Apple Watch 出来的时候，我并没有马上下单，而是等到周围有几个朋友买了之后，在征询过他们的意见后，我才决定下单。 我订的是 42mm 的运动版 Apple Watch，三周前，我订的 Apple Watch 寄到了，在使用了三周后，我分享一下我的使用体验。 交互Apple Watch 支持以下几种交互方式： 按下 Digital Crown （数码表冠），在桌面和表盘之间切换。 长按 Digital Crown （数码表冠），启动 Siri。 双击 Digital Crown （数码表冠），回到上一次打开的应用。 单击 电源键，打开常用联络人列表。因为屏幕会根据手腕的动作自动点亮或关闭，所以电源键并不提供类似 iPhone 一样的锁屏功能。 长按 电源键，开机或关机。 同时按住 Digital Crown 和电源键，截屏。 以上是物理按键的交互方式，除去物理按键，整个屏幕也是和 iPhone 一样，支持各种滑动和点击操作的。比如： 下滑，打开通知中心。 上滑，打开常用应用列表。 来电时，手掌整个盖上去可以静音。 比较特别是的，Apple Watch 引入了 Force Touch 技术，可以感受到用户的按下力度，当用力按下屏幕时，一般会激活一些额外的功能。比如在通知中心可以清除所有消息、在表盘可以开启设置表盘功能等。 待机时间Apple Watch 的电池比宣传的牛逼得多，我个人可以连续使用两天不充电。问了一下身边的朋友，大多数人佩戴一整天，到晚上都还剩余了超过 30% 的电量。 下图是某一天的截图，晚上睡觉前，还有55%的电量。 存储从 iPhone 的 Apple Watch 应用里面，可以查到 Apple Watch 的存储容量是 8G。其中 watchOS 系统大概使用了 1G 多，其余空间可供用户使用。不过就我的使用经验来看，因为每个应用体积都很小（10M 以内），加上照片是部分缓存在 Apple Watch 中的，所以整体对存储的需求量非常小。 我现在只使用了不到 500M 的空间，如下图所示： 健身活动Apple Watch 的健身活动应用确实能够让我能够更加关注自己的活动状况，如果我久坐超过一小时，它就会提醒我动一下，这一点让我这个经常一工作就忘了时间的人很喜欢。 除了久坐提醒，Apple Watch 的每日卡路里消耗对我也有一些帮助，能知道我整体的活动量大概是多少。 导航为了体验 Apple Watch 的步行导航功能，有一次去参加在中关村的一个活动时，专门试验了一下。确实方便了很多，以前需要不停看手机上的导航信息，现在一抬手就能看到了。在应该转弯的路口，Apple Watch 会震动提醒。稍稍不爽的是，Apple Watch 的导航现在只支持自带的地图应用。而我手机里面装的高德地图是没法将导航信息传到 Apple Watch 中的，不过我相信苹果会尽快改进。 表盘在尝试了多种表盘之后，我最后的表盘是如下这样，除了能看时间和日期外，表盘还能提供查看当天的工作安排、一个小的计时器、健身状态、电池电量。 我个人是比较喜欢实践「番茄工作法」的，表盘左下角小小的计时器用来设置一个 Timer 非常方便，随时可以提醒我时间剩余量。 表盘中下方是我的健身状态，中午饭后，以及下班回家的时候会看一眼，如果差太多，第二天会注意一下。 表盘右下角是电池电量，其实我测试过很多次，如果每天一充的话，电量肯定是足够的，但是看不到电量剩余比例，心里还是有一种焦虑，所以还是放在那儿了。 最爽的就是表盘正中间的日历功能了，在 Apple Watch 上查看日历比在手机上方便多了。于是，我现在将所有的日程管理都放到日历中了。以前正好买过一个叫 Fantastical 的应用，用它来管理日历非常方便。 第三方应用因为一开始就咨询了朋友，所以我对在 Apple Watch 上使用第三方应用的体验不抱太多期望。实际上，在 Apple Watch 那么小的屏幕上，你确实也没法重度使用应用。 所以，我只是在 Apple Watch 上开启了微博私信、QQ 和微信的推送。一般情况下，我就看看 QQ 和微信的推送信息。我尝试过用 Siri 进行回复，但是内容中只要涉及一点点计算机名词，Siri 的识别正确率就低得完全不可用了。 心跳和涂鸦苹果在介绍 Apple Watch 时，专门介绍了这个功能。就我个人体验来说，这个功能实在没什么用，而且一点也不好玩，即使是情侣之间，也只是会在图新鲜时尝试用一下。 Apple Watch 到底有什么用总结一下 Apple Watch 比较实用的功能。 防止被即时信息打断相信大家都有过这样的经历，有时候手机一响，我们打开一看，原来是条广告短信。虽然没什么用，但是把我们的注意力转移了。而且手机打开了，我们可以顺便就看看新闻，回复个朋友圈留言什么的了。最终自己都不知道自己本来想做什么。 有了 Apple Watch，可以将我们被这部分信息打扰的可能性大大降低，因为你只需要抬手腕，看一眼，就 over 了。Apple Watch 上也不方便看新闻和回复社交网络信息，所以你很可能又接着做你正在做的事情。 了解社交网络的信息我们很多时候无聊，就会打开手机，看看微博上有什么新消息，刷刷朋友圈什么的。而这次阅读类的需求可以很方便地迁移到 Apple Watch 中。因为在 Apple Watch 中更加方便，所以其实它会减少你使漫无目的使用手机的频次。 了解自己的健康状态虽然对于技术宅来说，大多数都不喜欢运动，但是大家都还是希望身体健康的。每隔一小时站立一下，对于我们来说成本非常小，但是对身体又很有好处。Apple Watch 的站立提醒是我非常喜欢的功能。 安排自己的日程方便非常重要，现在很多人拿平板看视频，就是因为它比在电脑上方便。而以前在 iPhone 中要查看日程，至少需要以下几步： 从裤兜里掏出手机或从桌子上拿起手机（一般人不会一直把手机拿手上吧） 右滑解锁，或者输入密码（指纹）解锁 iPhone （我的指纹解锁还老失败） 下滑从 Today Widget 中查看日程或者打开日历应用查看日程 路径达到 3 步就会被很多人闲麻烦放弃了，我就是这样。而有了 Apple Watch 后，以上步骤就简化成一步：抬起手腕。 看起来很小的变化，带来的效果还是惊人的。Apple Watch 现在能够让我非常舒服地管理自己的时间。 Apple Watch 不能做什么Apple Watch 基本不能进行回复操作，Siri 的语音识别基本不可用，QQ 只支持回复简单的例如 “好的” 之类的文字或表情。所以不要指望用 Apple Watch 来进行聊天等行为。 Apple Watch 上第三方的应用还很少，启动起来也很慢，由于屏幕小，即使是看新闻都很不爽。所以不要指望在 Apple Watch 上独立使用需要超过 1 分钟以上阅读的内容。 Apple Watch 并不能替代手机，它只是把手机里面的部分需求，以更好的方式满足了。 总结整体来说，我是非常推荐 iPhone 用户购买 Apple Watch 的，它能使你的工作生活效率得到提升。你还在等什么，现在苹果店就可以直接购买，赶快去体验一番吧！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"基于 CoreText 的排版引擎：进阶","slug":"using-coretext-2","date":"2015-06-27T00:59:55.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/06/27/using-coretext-2/","permalink":"https://blog.devtang.com/2015/06/27/using-coretext-2/","excerpt":"","text":"版权说明原创文章，转载请保留以下信息： 本文节选自我的图书：《iOS 开发进阶 》。 本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。 扫码关注我的「iOS 开发」微信公众帐号： 本章前言在上一篇《基于 CoreText 的排版引擎：基础》中，我们学会了排版的基础知识，现在我们来增加复杂性，让我们的排版引擎支持图片和链接的点击。 支持图文混排的排版引擎改造模版文件下面我们来进一步改造，让排版引擎支持对于图片的排版。在上一小节中，我们在设置模版文件的时候，就专门在模板文件里面留了一个名为type的字段，用于表示内容的类型。之前的type的值都是txt，这次，我们增加一个值为img的值，用于表示图片。 我们将上一节的content.json文件修改为如下内容，增加了 2 个type值为img的配置项。由于是图片的配置项，所以我们不需要设置颜色，字号这些图片不具有的属性，但是，我们另外增加了 3 个图片的配置属性： 一个名为width的属性，用于设置图片显示的宽度。 一个名为height的属性，用于设置图片显示的高度。 一个名为name的属性，用于设置图片的资源名。 [ &#123; &quot;type&quot; : &quot;img&quot;, &quot;width&quot; : 200, &quot;height&quot; : 108, &quot;name&quot; : &quot;coretext-image-1.jpg&quot; &#125;, &#123; &quot;color&quot; : &quot;blue&quot;, &quot;content&quot; : &quot; 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 &quot;, &quot;size&quot; : 16, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;red&quot;, &quot;content&quot; : &quot; 内容、颜色、字体 &quot;, &quot;size&quot; : 22, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;black&quot;, &quot;content&quot; : &quot; 大小等信息。\\n&quot;, &quot;size&quot; : 16, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;type&quot; : &quot;img&quot;, &quot;width&quot; : 200, &quot;height&quot; : 130, &quot;name&quot; : &quot;coretext-image-2.jpg&quot; &#125;, &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot; 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。&quot;, &quot;type&quot; : &quot;txt&quot; &#125;] 按理说，图片本身的内容信息中，是包含宽度和高度信息的，为什么我们要在这里指定图片的宽高呢？这主要是因为，在真实的开发中，应用的模版和图片通常是通过服务器获取的，模版是纯文本的内容，获取速度比图片快很多，而图片不但获取速度慢，而且为了省流量，通常的做法是直到需要显示图片的时候，再加载图片内容。 如果我们不将图片的宽度和高度信息设置在模板里面，那么 CoreText 在排版的时候就无法知道绘制所需要的高度，我们就无法设置CoreTextData类中的height信息，没有高度信息，就会对 UITableView 一类的控件排版造成影响。所以，除非你的应用图片能够保证在绘制前都能全部在本地，否则就应该另外提前提供图片宽度和高度信息。 在完成模板文件修改后，我们选取两张测试用的图片，分别将其命名为coretext-image-1.jpg和coretext-image-2.jpg（和模板中的值一致），将其拖动增加到工程中。向 Xcode 工程增加图片资源是基础知识，在此就不详细介绍过程了。 CTLine 与 CTRun接下来我们需要改造的是CTFrameParser类，让解析模板文件的方法支持type为img的配置。 在改造前，我们先来了解一下CTFrame内部的组成。通过之前的例子，我们可以看到，我们首先通过NSAttributeString和配置信息创建 CTFrameSetter，然后，再通过CTFrameSetter来创建CTFrame。 在CTFrame内部，是由多个CTLine来组成的，每个CTLine代表一行，每个CTLine又是由多个CTRun来组成，每个CTRun代表一组显示风格一致的文本。我们不用手工管理CTLine和CTRun的创建过程。 下图是一个CTLine和CTRun的示意图，可以看到，第三行的CTLine是由 2 个CTRun构成的，第一个CTRun为红色大字号的左边部分，第二个CTRun为右边字体较小的部分。 虽然我们不用管理CTRun的创建过程，但是我们可以设置某一个具体的CTRun的CTRunDelegate来指定该文本在绘制时的高度、宽度、排列对齐方式等信息。 对于图片的排版，其实 CoreText 本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度信息，这样最后生成的CTFrame实例，就会在绘制时将图片的位置预留出来。 因为我们的CTDisplayView的绘制代码是在drawRect里面的，所以我们可以方便地把需要绘制的图片，用CGContextDrawImage方法直接绘制出来就可以了。 改造模版解析类在了解了以上原理后，我们就可以开始进行改造了。 我们需要做的工作包括： 改造CTFrameParser的parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config;方法，使其支持对type为img的节点解析。并且对type为img的节点，设置其CTRunDelegate信息，使其在绘制时，为图片预留相应的空白位置。 改造CoreTextData类，增加图片相关的信息，并且增加计算图片绘制区域的逻辑。 改造CTDisplayView类，增加绘制图片相关的逻辑。 首先介绍对于CTFrameParser的改造： 我们修改了parseTemplateFile方法，增加了一个名为imageArray的参数来保存解析时的图片信息。 + (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123; NSMutableArray *imageArray = [NSMutableArray array]; NSAttributedString *content = [self loadTemplateFile:path config:config imageArray:imageArray]; CoreTextData *data = [self parseAttributedContent:content config:config]; data.imageArray = imageArray; return data;&#125; 接着我们修改loadTemplateFile方法，增加了对于type是img的节点处理逻辑，该逻辑主要做 2 件事情： 保存当前图片节点信息到imageArray变量中 新建一个空白的占位符。 + (NSAttributedString *)loadTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config imageArray:(NSMutableArray *)imageArray &#123; NSData *data = [NSData dataWithContentsOfFile:path]; NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init]; if (data) &#123; NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; if ([array isKindOfClass:[NSArray class]]) &#123; for (NSDictionary *dict in array) &#123; NSString *type = dict[@&quot;type&quot;]; if ([type isEqualToString:@&quot;txt&quot;]) &#123; NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict config:config]; [result appendAttributedString:as]; &#125; else if ([type isEqualToString:@&quot;img&quot;]) &#123; // 创建 CoreTextImageData CoreTextImageData *imageData = [[CoreTextImageData alloc] init]; imageData.name = dict[@&quot;name&quot;]; imageData.position = [result length]; [imageArray addObject:imageData]; // 创建空白占位符，并且设置它的 CTRunDelegate 信息 NSAttributedString *as = [self parseImageDataFromNSDictionary:dict config:config]; [result appendAttributedString:as]; &#125; &#125; &#125; &#125; return result;&#125; 最后我们新建一个最关键的方法：parseImageDataFromNSDictionary，生成图片空白的占位符，并且设置其CTRunDelegate信息。其代码如下： static CGFloat ascentCallback(void *ref)&#123; return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@&quot;height&quot;] floatValue];&#125;static CGFloat descentCallback(void *ref)&#123; return 0;&#125;static CGFloat widthCallback(void* ref)&#123; return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@&quot;width&quot;] floatValue];&#125;+ (NSAttributedString *)parseImageDataFromNSDictionary:(NSDictionary *)dict config:(CTFrameParserConfig*)config &#123; CTRunDelegateCallbacks callbacks; memset(&amp;callbacks, 0, sizeof(CTRunDelegateCallbacks)); callbacks.version = kCTRunDelegateVersion1; callbacks.getAscent = ascentCallback; callbacks.getDescent = descentCallback; callbacks.getWidth = widthCallback; CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callbacks, (__bridge void *)(dict)); // 使用 0xFFFC 作为空白的占位符 unichar objectReplacementChar = 0xFFFC; NSString * content = [NSString stringWithCharacters:&amp;objectReplacementChar length:1]; NSDictionary * attributes = [self attributesWithConfig:config]; NSMutableAttributedString * space = [[NSMutableAttributedString alloc] initWithString:content attributes:attributes]; CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); CFRelease(delegate); return space;&#125; 接着我们对CoreTextData进行改造，增加了imageArray成员变量，用于保存图片绘制时所需的信息。 #import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextImageData.h&quot;@interface CoreTextData : NSObject@property (assign, nonatomic) CTFrameRef ctFrame;@property (assign, nonatomic) CGFloat height;// 新增加的成员@property (strong, nonatomic) NSArray * imageArray;@end 在设置imageArray成员时，我们还会调一个新创建的fillImagePosition方法，用于找到每张图片在绘制时的位置。 - (void)setImageArray:(NSArray *)imageArray &#123; _imageArray = imageArray; [self fillImagePosition];&#125;- (void)fillImagePosition &#123; if (self.imageArray.count == 0) &#123; return; &#125; NSArray *lines = (NSArray *)CTFrameGetLines(self.ctFrame); int lineCount = [lines count]; CGPoint lineOrigins[lineCount]; CTFrameGetLineOrigins(self.ctFrame, CFRangeMake(0, 0), lineOrigins); int imgIndex = 0; CoreTextImageData * imageData = self.imageArray[0]; for (int i = 0; i &lt; lineCount; ++i) &#123; if (imageData == nil) &#123; break; &#125; CTLineRef line = (__bridge CTLineRef)lines[i]; NSArray * runObjArray = (NSArray *)CTLineGetGlyphRuns(line); for (id runObj in runObjArray) &#123; CTRunRef run = (__bridge CTRunRef)runObj; NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run); CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName]; if (delegate == nil) &#123; continue; &#125; NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate); if (![metaDic isKindOfClass:[NSDictionary class]]) &#123; continue; &#125; CGRect runBounds; CGFloat ascent; CGFloat descent; runBounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL); runBounds.size.height = ascent + descent; CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL); runBounds.origin.x = lineOrigins[i].x + xOffset; runBounds.origin.y = lineOrigins[i].y; runBounds.origin.y -= descent; CGPathRef pathRef = CTFrameGetPath(self.ctFrame); CGRect colRect = CGPathGetBoundingBox(pathRef); CGRect delegateBounds = CGRectOffset(runBounds, colRect.origin.x, colRect.origin.y); imageData.imagePosition = delegateBounds; imgIndex++; if (imgIndex == self.imageArray.count) &#123; imageData = nil; break; &#125; else &#123; imageData = self.imageArray[imgIndex]; &#125; &#125; &#125;&#125; 添加对图片的点击支持实现方式为了实现对图片的点击支持，我们需要给CTDisplayView类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的UITapGestureRecognizer可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。 我们这里实现的是点击图片后，先用NSLog打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。 我们先为CTDisplayView类增加UITapGestureRecognizer： - (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super initWithCoder:aDecoder]; if (self) &#123; [self setupEvents]; &#125; return self;&#125;- (void)setupEvents &#123; UIGestureRecognizer * tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(userTapGestureDetected:)]; tapRecognizer.delegate = self; [self addGestureRecognizer:tapRecognizer]; self.userInteractionEnabled = YES;&#125; 然后增加UITapGestureRecognizer的回调函数： - (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer &#123; CGPoint point = [recognizer locationInView:self]; for (CoreTextImageData * imageData in self.data.imageArray) &#123; // 翻转坐标系，因为 imageData 中的坐标是 CoreText 的坐标系 CGRect imageRect = imageData.imagePosition; CGPoint imagePosition = imageRect.origin; imagePosition.y = self.bounds.size.height - imageRect.origin.y - imageRect.size.height; CGRect rect = CGRectMake(imagePosition.x, imagePosition.y, imageRect.size.width, imageRect.size.height); // 检测点击位置 Point 是否在 rect 之内 if (CGRectContainsPoint(rect, point)) &#123; // 在这里处理点击后的逻辑 NSLog(@&quot;bingo&quot;); break; &#125; &#125;&#125; 事件处理在界面上，CTDisplayView通常在UIView的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过delegate模式将图片点击的事件一层一层往外层传递，所以最好使用NSNotification，来处理图片点击事件。 在 Demo 中，我们在最外层的 View Controller 中监听图片点击的通知，当收到通知后，进入到一个新的界面来显示图片点击内容。 注：读者可以将 demo 工程切换到image_click分支，查看示例代码。 添加对链接的点击支持####修改模板文件 我们修改模版文件，增加一个名为 link 的类型，用于表示链接内容。如下所示： [ &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot; 这在这里尝试放一个参考链接：&quot;, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;blue&quot;, &quot;content&quot; : &quot; 链接文字 &quot;, &quot;url&quot; : &quot;http://blog.devtang.com&quot;, &quot;type&quot; : &quot;link&quot; &#125;, &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot; 大家可以尝试点击一下 &quot;, &quot;type&quot; : &quot;txt&quot; &#125;] ####解析模版中的链接信息 我们首先增加一个CoreTextLinkData类，用于记录解析 JSON 文件时的链接信息： @interface CoreTextLinkData : NSObject@property (strong, nonatomic) NSString * title;@property (strong, nonatomic) NSString * url;@property (assign, nonatomic) NSRange range;@end 然后我们修改 CTFrameParser 类，增加解析链接的逻辑： + (NSAttributedString *)loadTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config imageArray:(NSMutableArray *)imageArray linkArray:(NSMutableArray *)linkArray &#123; NSData *data = [NSData dataWithContentsOfFile:path]; NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init]; if (data) &#123; NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; if ([array isKindOfClass:[NSArray class]]) &#123; for (NSDictionary *dict in array) &#123; NSString *type = dict[@&quot;type&quot;]; if ([type isEqualToString:@&quot;txt&quot;]) &#123; // 省略 &#125; else if ([type isEqualToString:@&quot;img&quot;]) &#123; // 省略 &#125; else if ([type isEqualToString:@&quot;link&quot;]) &#123; NSUInteger startPos = result.length; NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict config:config]; [result appendAttributedString:as]; // 创建 CoreTextLinkData NSUInteger length = result.length - startPos; NSRange linkRange = NSMakeRange(startPos, length); CoreTextLinkData *linkData = [[CoreTextLinkData alloc] init]; linkData.title = dict[@&quot;content&quot;]; linkData.url = dict[@&quot;url&quot;]; linkData.range = linkRange; [linkArray addObject:linkData]; &#125; &#125; &#125; &#125; return result;&#125; 然后，我们增加一个 Utils 类来专门处理检测用户点击是否在链接上。主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下： // 检测点击位置是否在链接上+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data &#123; CTFrameRef textFrame = data.ctFrame; CFArrayRef lines = CTFrameGetLines(textFrame); if (!lines) return nil; CFIndex count = CFArrayGetCount(lines); CoreTextLinkData *foundLink = nil; // 获得每一行的 origin 坐标 CGPoint origins[count]; CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins); // 翻转坐标系 CGAffineTransform transform = CGAffineTransformMakeTranslation(0, view.bounds.size.height); transform = CGAffineTransformScale(transform, 1.f, -1.f); for (int i = 0; i &lt; count; i++) &#123; CGPoint linePoint = origins[i]; CTLineRef line = CFArrayGetValueAtIndex(lines, i); // 获得每一行的 CGRect 信息 CGRect flippedRect = [self getLineBounds:line point:linePoint]; CGRect rect = CGRectApplyAffineTransform(flippedRect, transform); if (CGRectContainsPoint(rect, point)) &#123; // 将点击的坐标转换成相对于当前行的坐标 CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect), point.y-CGRectGetMinY(rect)); // 获得当前点击坐标对应的字符串偏移 CFIndex idx = CTLineGetStringIndexForPosition(line, relativePoint); // 判断这个偏移是否在我们的链接列表中 foundLink = [self linkAtIndex:idx linkArray:data.linkArray]; return foundLink; &#125; &#125; return nil;&#125;+ (CGRect)getLineBounds:(CTLineRef)line point:(CGPoint)point &#123; CGFloat ascent = 0.0f; CGFloat descent = 0.0f; CGFloat leading = 0.0f; CGFloat width = (CGFloat)CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;leading); CGFloat height = ascent + descent; return CGRectMake(point.x, point.y - descent, width, height);&#125;+ (CoreTextLinkData *)linkAtIndex:(CFIndex)i linkArray:(NSArray *)linkArray &#123; CoreTextLinkData *link = nil; for (CoreTextLinkData *data in linkArray) &#123; if (NSLocationInRange(i, data.range)) &#123; link = data; break; &#125; &#125; return link;&#125; 最后改造一下CTDisplayView，使其在检测到用户点击后，调用上面的 Util 方法即可。我们这里实现的是点击链接后，先用NSLog打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。 - (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer &#123; CGPoint point = [recognizer locationInView:self]; // 此处省略上一节中介绍的，对图片点击检测的逻辑 CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:self atPoint:point data:self.data]; if (linkData) &#123; NSLog(@&quot;hint link!&quot;); return; &#125;&#125; 注：在 Demo 中工程中，我们实现了点击链接跳转到一个新的界面，然后用 UIWebView 来显示链接内容的逻辑。读者可以将 demo 工程切换到link_click分支，查看示例代码。 Demo 工程的 Gif 效果图如下，读者可以将示例工程用git checkout image_support切换到当前章节状态，查看相关代码逻辑。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"基于 CoreText 的排版引擎：基础","slug":"using-coretext-1","date":"2015-06-27T00:39:56.000Z","updated":"2024-01-06T14:52:37.923Z","comments":true,"path":"2015/06/27/using-coretext-1/","permalink":"https://blog.devtang.com/2015/06/27/using-coretext-1/","excerpt":"","text":"版权说明原创文章，转载请保留以下信息： 本文节选自我的图书：《iOS 开发进阶 》。 本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。 扫码关注我的「iOS 开发」微信公众帐号： 本章前言使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。 本章我们将从最基本的开始，一步一步完成一个支持图文混排、支持图片和链接点击的排版引擎。 CoreText 简介CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。 Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。 下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。 注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。 UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处： CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。 CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取） CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。 基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。 当然，基于 CoreText 的排版方案也有一些劣势： CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。 基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。 在业界，很多应用都采用了基于 CoreText 技术的排版方案，例如：新浪微博客户端，多看阅读客户端。我所在的创业公司的猿题库，也使用了自己基于 CoreText 技术实现的排版引擎，下图是我们产品的一个图文混排的界面（其中所有公式都是用图片的方式呈现的），可以看到，图片和文字排版效果很好。 基于 CoreText 的基础排版引擎不带图片的排版引擎下面我们来尝试完成一个基于 CoreText 的排版引擎。我们将从最简单的排版功能开始，然后逐步支持图文混排，链接点击等功能。 首先我们来尝试完成一个不支持图片内容的纯文字排版引擎。 注意 1：由于整个排版引擎的代码太多，为方便读者阅读，文章中只会列出最关键的核心代码，完整的代码请参考本书对应的 github 项目，项目地址是：https://github.com/tangqiaoboy/iOS-Pro 。 能输出 Hello World 的 CoreText 工程操作步骤我们首先新建一个 Xcode 工程，步骤如下： 打开 Xcode，选择 “File”-&gt;”New”-&gt;”Project”, 在弹出的对话框中，选择 “Single View Application”，然后点击 “Next”。（图 2） 接着填上项目名 CoreTextDemo，然后点击 “Next”。（图 3） 选择保存目录后，我们就成功创建了一个空的工程。 图 2 图 3 在工程目录 “CoreTextDemo” 上右击，选择 “New File”, 然后填入类名CTDisplayView, 并且让它的父类是 UIView。（如下图） 接着，我们在CTDisplayView.m文件中，让其 import 头文件CoreText/CoreText.h，接着输入以下代码来实现其drawRect方法： #import &quot;CTDisplayView.h&quot;#import &quot;CoreText/CoreText.h&quot;@implementation CTDisplayView- (void)drawRect:(CGRect)rect&#123; [super drawRect:rect]; // 步骤 1 CGContextRef context = UIGraphicsGetCurrentContext(); // 步骤 2 CGContextSetTextMatrix(context, CGAffineTransformIdentity); CGContextTranslateCTM(context, 0, self.bounds.size.height); CGContextScaleCTM(context, 1.0, -1.0); // 步骤 3 CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, self.bounds); // 步骤 4 NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@&quot;Hello World!&quot;]; CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attString); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, [attString length]), path, NULL); // 步骤 5 CTFrameDraw(frame, context); // 步骤 6 CFRelease(frame); CFRelease(path); CFRelease(framesetter);&#125;@end 打开程序的 Storyboard 文件：Main_iPhone.storyboard：执行下面 2 步： 将一个 UIView 控件拖动到主界面正中间。（如下图步骤 1） 将该 UIView 控件的类名从UIView修改为CTDisplayView。（如下图步骤 2） 之后，我们运行程序，就可以看到，Hello World 出现在程序正中间了。如下图。 ###代码解释 下面解释一下drawRect方法主要的步骤： 得到当前绘制画布的上下文，用于后续将内容绘制在画布上。 将坐标系上下翻转。对于底层的绘制引擎来说，屏幕的左下角是（0, 0）坐标。而对于上层的 UIKit 来说，左上角是 (0, 0) 坐标。所以我们为了之后的坐标系描述按 UIKit 来做，所以先在这里做一个坐标系的上下翻转操作。翻转之后，底层和上层的 (0, 0) 坐标就是重合的了。 为了加深理解，我们将这部分的代码块注释掉，你会发现，整个Hello World界面将上下翻转，如下图所示。 创建绘制的区域，CoreText 本身支持各种文字排版的区域，我们这里简单地将 UIView 的整个界面作为排版的区域。 为了加深理解，我们将该步骤的代码替换成如下代码，测试设置不同的绘制区域带来的界面变化。 // 步骤 3CGMutablePathRef path = CGPathCreateMutable();CGPathAddEllipseInRect(path, NULL, self.bounds);// 步骤 4NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@&quot;Hello World! &quot; &quot; 创建绘制的区域，CoreText 本身支持各种文字排版的区域，&quot; &quot; 我们这里简单地将 UIView 的整个界面作为排版的区域。&quot; &quot; 为了加深理解，建议读者将该步骤的代码替换成如下代码，&quot; &quot; 测试设置不同的绘制区域带来的界面变化。&quot;]; 执行结果如下图所示： 代码基本的宏定义和 Category为了方便我们的代码编写，我在CoreTextDemo-Prefix.pch文件中增加了以下基本的宏定义，以方便我们使用 NSLog 和 UIColor。 #ifdef DEBUG#define debugLog(...) NSLog(__VA_ARGS__)#define debugMethod() NSLog(@&quot;%s&quot;, __func__)#else#define debugLog(...)#define debugMethod()#endif#define RGB(A, B, C) [UIColor colorWithRed:A/255.0 green:B/255.0 blue:C/255.0 alpha:1.0] 我也为 UIView 的 frame 调整增加了一些扩展，可以方便地调整 UIView 的 x, y, width, height 等值。部分关键代码如下（完整的代码请查看示例工程）： UIView+frameAdjust.h 文件: #import &lt;Foundation/Foundation.h&gt;@interface UIView (frameAdjust)- (CGFloat)x;- (void)setX:(CGFloat)x;- (CGFloat)y;- (void)setY:(CGFloat)y;- (CGFloat)height;- (void)setHeight:(CGFloat)height;- (CGFloat)width;- (void)setWidth:(CGFloat)width;@end UIView+frameAdjust.m 文件： @implementation UIView (frameAdjust)- (CGFloat)x &#123; return self.frame.origin.x;&#125;- (void)setX:(CGFloat)x &#123; self.frame = CGRectMake(x, self.y, self.width, self.height);&#125;- (CGFloat)y &#123; return self.frame.origin.y;&#125;- (void)setY:(CGFloat)y &#123; self.frame = CGRectMake(self.x, y, self.width, self.height);&#125;- (CGFloat)height &#123; return self.frame.size.height;&#125;- (void)setHeight:(CGFloat)height &#123; self.frame = CGRectMake(self.x, self.y, self.width, height);&#125;- (CGFloat)width &#123; return self.frame.size.width;&#125;- (void)setWidth:(CGFloat)width &#123; self.frame = CGRectMake(self.x, self.y, width, self.height);&#125;@end 文章中的其余代码默认都#import 了以上提到的宏定义和 UIView Category。 排版引擎框架上面的 Hello World 工程仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 CTDisplayView 的drawRect方法里面。根据设计模式中的 “ 单一功能原则 “(Single responsibility principle)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。 对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成： 一个显示用的类，仅负责显示内容，不负责排版 一个模型类，用于承载显示所需要的所有数据 一个排版类，用于实现文字内容的排版 一个配置类，用于实现一些排版时的可配置项 注：” 单一功能原则 “(Single responsibility principle)参考链接：http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99 按照以上原则，我们将CTDisplayView中的部分内容拆开，由 4 个类构成： CTFrameParserConfig类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。 CTFrameParser类，用于生成最后绘制界面需要的CTFrameRef实例。 CoreTextData类，用于保存由CTFrameParser类生成的CTFrameRef实例以及CTFrameRef实际绘制需要的高度。 CTDisplayView类，持有CoreTextData类的实例，负责将CTFrameRef绘制到界面上。 关于这 4 个类的关键代码如下： CTFrameParserConfig类: #import &lt;Foundation/Foundation.h&gt;@interface CTFrameParserConfig : NSObject@property (nonatomic, assign) CGFloat width;@property (nonatomic, assign) CGFloat fontSize;@property (nonatomic, assign) CGFloat lineSpace;@property (nonatomic, strong) UIColor *textColor;@end #import &quot;CTFrameParserConfig.h&quot;@implementation CTFrameParserConfig- (id)init &#123; self = [super init]; if (self) &#123; _width = 200.0f; _fontSize = 16.0f; _lineSpace = 8.0f; _textColor = RGB(108, 108, 108); &#125; return self;&#125;@end CTFrameParser类: #import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextData.h&quot;#import &quot;CTFrameParserConfig.h&quot;@interface CTFrameParser : NSObject+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config;@end #import &quot;CTFrameParser.h&quot;#import &quot;CTFrameParserConfig.h&quot;@implementation CTFrameParser+ (NSDictionary *)attributesWithConfig:(CTFrameParserConfig *)config &#123; CGFloat fontSize = config.fontSize; CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL); CGFloat lineSpacing = config.lineSpace; const CFIndex kNumberOfSettings = 3; CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123; &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &amp;lineSpacing &#125;, &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;, &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125; &#125;; CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings); UIColor * textColor = config.textColor; NSMutableDictionary * dict = [NSMutableDictionary dictionary]; dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor; dict[(id)kCTFontAttributeName] = (__bridge id)fontRef; dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef; CFRelease(theParagraphRef); CFRelease(fontRef); return dict;&#125;+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config &#123; NSDictionary *attributes = [self attributesWithConfig:config]; NSAttributedString *contentString = [[NSAttributedString alloc] initWithString:content attributes:attributes]; // 创建 CTFramesetterRef 实例 CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)contentString); // 获得要绘制的区域的高度 CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX); CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil); CGFloat textHeight = coreTextSize.height; // 生成 CTFrameRef 实例 CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight]; // 将生成好的 CTFrameRef 实例和计算好的绘制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例 CoreTextData *data = [[CoreTextData alloc] init]; data.ctFrame = frame; data.height = textHeight; // 释放内存 CFRelease(frame); CFRelease(framesetter); return data;&#125;+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter config:(CTFrameParserConfig *)config height:(CGFloat)height &#123; CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL); CFRelease(path); return frame;&#125;@end CoreTextData类: #import &lt;Foundation/Foundation.h&gt;@interface CoreTextData : NSObject@property (assign, nonatomic) CTFrameRef ctFrame;@property (assign, nonatomic) CGFloat height;@end #import &quot;CoreTextData.h&quot;@implementation CoreTextData- (void)setCtFrame:(CTFrameRef)ctFrame &#123; if (_ctFrame != ctFrame) &#123; if (_ctFrame != nil) &#123; CFRelease(_ctFrame); &#125; CFRetain(ctFrame); _ctFrame = ctFrame; &#125;&#125;- (void)dealloc &#123; if (_ctFrame != nil) &#123; CFRelease(_ctFrame); _ctFrame = nil; &#125;&#125;@end CTDisplayView类： #import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextData.h&quot;@interface CTDisplayView : UIView@property (strong, nonatomic) CoreTextData * data;@end #import &quot;CTDisplayView.h&quot;@implementation CTDisplayView- (void)drawRect:(CGRect)rect&#123; [super drawRect:rect]; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetTextMatrix(context, CGAffineTransformIdentity); CGContextTranslateCTM(context, 0, self.bounds.size.height); CGContextScaleCTM(context, 1.0, -1.0); if (self.data) &#123; CTFrameDraw(self.data.ctFrame, context); &#125;&#125;@end 以上 4 个类中的逻辑与之前 Hello World 那个项目的逻辑基本一致，只是分拆到了 4 个类中完成。另外，CTFrameParser 增加了方法来获得要绘制的区域的高度，并将高度信息保存到CoreTextData类的实例中。之所以要获得绘制区域的高度，是因为在很多实际使用场景中，我们需要先知道所要显示内容的高度，之后才可以进行绘制。 例如，在 UITableView 在渲染时，UITableView 首先会向 delegate 回调如下方法来获得每个将要渲染的 cell 的高度： - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; 之后，UITableView 会计算当前滚动的位置具体需要绘制的 UITableViewCell 是哪些，然后对于那些需要绘制的 Cell，UITableView 才会继续向其 data source 回调如下方法来获得 UITableViewCell 实例： - (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; 对于上面的情况，如果我们使用 CoreText 来作为 TableViewCell 的内容，那么就必须在每个 Cell 绘制之前，就知道其需要的绘制高度，否则 UITableView 将无法正常工作。 完成以上 4 个类之后，我们就可以简单地在ViewController.m文件中，加入如下代码来配置CTDisplayView的显示内容，位置，高度，字体，颜色等信息。代码如下所示。 #import &quot;ViewController.h&quot;@interface ViewController ()@property (weak, nonatomic) IBOutlet CTDisplayView *ctView;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init]; config.textColor = [UIColor redColor]; config.width = self.ctView.width; CoreTextData *data = [CTFrameParser parseContent:@&quot; 按照以上原则，我们将`CTDisplayView`中的部分内容拆开。&quot; config:config]; self.ctView.data = data; self.ctView.height = data.height; self.ctView.backgroundColor = [UIColor yellowColor];&#125;@end 注意：从 Xcode4.0 开始，默认的界面编辑就开启了对于Use Autolayout的使用，但因为我们在代码中直接修改了变量ctView的 frame 信息，所以需要在Main_iPhone.storyboard中将Use Autolayout这一项取消勾选。如下图所示： 以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的： CTFrameParser通过CTFrameparserConfig实例来生成CoreTextData实例。 CTDisplayView通过持有CoreTextData实例来获得绘制所需要的所有信息。 ViewController类通过配置CTFrameparserConfig实例，进而获得生成的CoreTextData实例，最后将其赋值给他的CTDisplayView成员，达到将指定内容显示在界面上的效果。 说明 1：整个工程代码在名为basic_arch的分支下，读者可以在示例的源代码工程中使用git checkout basic_arch来切换到当前讲解的工程示例代码。 说明 2：为了方便操作UIView的frame属性，项目中增加了一个名为UIView+frameAdjust.m文件，它通过Category来给UIView增加了直接设置height属性的方法。 定制排版文件格式对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。 解决的办法很简单，我们让CTFrameParser支持接受 NSAttributeString 作为参数，然后在ViewController类中设置我们想要的 NSAttributeString 信息。 @implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init]; config.width = self.ctView.width; config.textColor = [UIColor blackColor]; NSString *content = @&quot; 对于上面的例子，我们给 CTFrameParser 增加了一个将 NSString 转 &quot; &quot; 换为 CoreTextData 的方法。&quot; &quot; 但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体 &quot; &quot; 大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。&quot; &quot; 例如，如果我们只想让内容的前三个字显示成红色，而其它文字显 &quot; &quot; 示成黑色，那么就办不到了。&quot; &quot;\\n\\n&quot; &quot; 解决的办法很简单，我们让`CTFrameParser`支持接受 &quot; &quot;NSAttributeString 作为参数，然后在 NSAttributeString 中设置好 &quot; &quot; 我们想要的信息。&quot;; NSDictionary *attr = [CTFrameParser attributesWithConfig:config]; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:content attributes:attr]; [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 7)]; CoreTextData *data = [CTFrameParser parseAttributedContent:attributedString config:config]; self.ctView.data = data; self.ctView.height = data.height; self.ctView.backgroundColor = [UIColor yellowColor];&#125;@end 结果如下图所示，我们很方便就把前面 7 个字变成了红色。 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的内容、颜色、字体大小等信息。我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。 我们规定排版的模版文件为 JSON 格式。JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。iOS 从 5.0 开始，提供了名为NSJSONSerialization的类库来方便开发者对 JSON 的解析。在 iOS5.0 之前，业界也有很多相关的 JSON 解析开源库，例如 JSONKit 可供大家使用。 我们的排版模版示例文件如下所示： [ &#123; &quot;color&quot; : &quot;blue&quot;, &quot;content&quot; : &quot; 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 &quot;, &quot;size&quot; : 16, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;red&quot;, &quot;content&quot; : &quot; 内容、颜色、字体 &quot;, &quot;size&quot; : 22, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;black&quot;, &quot;content&quot; : &quot; 大小等信息。\\n&quot;, &quot;size&quot; : 16, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot; 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。&quot;, &quot;type&quot; : &quot;txt&quot; &#125;] 通过苹果提供的NSJSONSerialization类，我们可以将上面的模版文件转换成 NSArray 数组，每一个数组元素是一个 NSDictionary，代表一段相同设置的文字。为了简单，我们的配置文件只支持配置颜色和字号，但是读者可以依据同样的思想，很方便地增加其它配置信息。 接下来我们要为CTFrameParser增加一个方法，让其可以从如上格式的模版文件中生成CoreTextData。最终我们的实现代码如下： // 方法一+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123; NSAttributedString *content = [self loadTemplateFile:path config:config]; return [self parseAttributedContent:content config:config];&#125;// 方法二+ (NSAttributedString *)loadTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123; NSData *data = [NSData dataWithContentsOfFile:path]; NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init]; if (data) &#123; NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; if ([array isKindOfClass:[NSArray class]]) &#123; for (NSDictionary *dict in array) &#123; NSString *type = dict[@&quot;type&quot;]; if ([type isEqualToString:@&quot;txt&quot;]) &#123; NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict config:config]; [result appendAttributedString:as]; &#125; &#125; &#125; &#125; return result;&#125;// 方法三+ (NSAttributedString *)parseAttributedContentFromNSDictionary:(NSDictionary *)dict config:(CTFrameParserConfig*)config &#123; NSMutableDictionary *attributes = [self attributesWithConfig:config]; // set color UIColor *color = [self colorFromTemplate:dict[@&quot;color&quot;]]; if (color) &#123; attributes[(id)kCTForegroundColorAttributeName] = (id)color.CGColor; &#125; // set font size CGFloat fontSize = [dict[@&quot;size&quot;] floatValue]; if (fontSize &gt; 0) &#123; CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL); attributes[(id)kCTFontAttributeName] = (__bridge id)fontRef; CFRelease(fontRef); &#125; NSString *content = dict[@&quot;content&quot;]; return [[NSAttributedString alloc] initWithString:content attributes:attributes];&#125;// 方法四+ (UIColor *)colorFromTemplate:(NSString *)name &#123; if ([name isEqualToString:@&quot;blue&quot;]) &#123; return [UIColor blueColor]; &#125; else if ([name isEqualToString:@&quot;red&quot;]) &#123; return [UIColor redColor]; &#125; else if ([name isEqualToString:@&quot;black&quot;]) &#123; return [UIColor blackColor]; &#125; else &#123; return nil; &#125;&#125;// 方法五+ (CoreTextData *)parseAttributedContent:(NSAttributedString *)content config:(CTFrameParserConfig*)config &#123; // 创建 CTFramesetterRef 实例 CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)content); // 获得要缓制的区域的高度 CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX); CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil); CGFloat textHeight = coreTextSize.height; // 生成 CTFrameRef 实例 CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight]; // 将生成好的 CTFrameRef 实例和计算好的缓制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例 CoreTextData *data = [[CoreTextData alloc] init]; data.ctFrame = frame; data.height = textHeight; // 释放内存 CFRelease(frame); CFRelease(framesetter); return data;&#125;// 方法六+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter config:(CTFrameParserConfig *)config height:(CGFloat)height &#123; CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL); CFRelease(path); return frame;&#125; 以上代码主要由 6 个子方法构成： 方法一用于提供对外的接口，调用方法二实现从一个 JSON 的模版文件中读取内容，然后调用方法五生成CoreTextData。 方法二读取 JSON 文件内容，并且调用方法三获得从NSDictionary到NSAttributedString的转换结果。 方法三将NSDictionary内容转换为NSAttributedString。 方法四提供将NSString转为UIColor的功能。 方法五接受一个NSAttributedString和一个config参数，将NSAttributedString转换成CoreTextData返回。 方法六是方法五的一个辅助函数，供方法五调用。 然后我们将ViewController中的调用代码作一下更改，使其从模版文件中加载内容，如下所示： @implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init]; config.width = self.ctView.width; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;content&quot; ofType:@&quot;json&quot;]; CoreTextData *data = [CTFrameParser parseTemplateFile:path config:config]; self.ctView.data = data; self.ctView.height = data.height; self.ctView.backgroundColor = [UIColor whiteColor];&#125;@end 最后运行得到的结果如下所示，可以看到，通过一个简单的模板文件，我们已经可以很方便地定义排版的配置信息了。 说明：读者可以在示例工程中使用git checkout json_template，查看可以运行的示例代码。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"你会翻转二叉树吗？--谈程序员的招聘","slug":"talk-about-tech-interview","date":"2015-06-16T13:55:41.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"2015/06/16/talk-about-tech-interview/","permalink":"https://blog.devtang.com/2015/06/16/talk-about-tech-interview/","excerpt":"","text":"事件回放2015 年 6 月 10 日，Homebrew 的作者 @Max Howell 在 twitter 上发表了如下一内容： Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off. 事情大概是说，Max Howell 去 Google 面试，面试官说：虽然在 Google 有 90% 的工程师用你写的 Homebrew，但是你居然不能在白板上写出翻转二叉树的代码，所以滚蛋吧。 这件事情如果发生在任何一个应届生身上，那是再正常不过的了，但是偏偏面试者是有名的 Max Howell。于是乎，关于应该如何面试程序员，再一次被大家热烈的讨论。 我看了一下 Quora 和 Hacker News 上的讨论，就此话题说说我的看法。 如何做这道题在说招聘之前，我们先谈谈这道题应该怎么做吧。LeetCode 非常与时俱进地收录了 这道题，我尝试做了一下。由于 LeetCode 不支持用 Objective-C 或 Swift 写，我只好用 Java 来写，但是电脑里面没有装 Eclipse，所以我直接就在 LeetCode 编辑框里面提交了。 编译错了两次，之后运行错了一次，出现了 NullPointerException，于是想到没有检查指针为空，加上检查之后，就通过了。下图是提交记录。 除去 LeetCode 自动生成的注释和方法定义，我所写的整个代码行数为 9 行，大概花了 5 分钟时间。代码如下所示： /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; root.left = invertTree(root.left); root.right = invertTree(root.right); TreeNode tmp = root.left; root.left = root.right; root.right = tmp; return root; &#125;&#125; 那么这道题考查了什么呢？我觉得主要是考查了递归的思想。递归是程序设计的精髓，掌握了他可以将一个大问题分解成小问题，继而求解。比如对于此题来说，反转一个二叉树其实就是： 反转二叉树的左右子树 将左右子树交换 而第 1 步又是一个反转二叉树的问题，所以就可以用递归来处理了。然后再考虑好递归的结束条件，这道题就可以解决了。 这是一道好的面试题吗？如果面试者是一个应届生，我认为这是一道非常好的题目。因为应届生刚刚学完学校的数据结构和算法知识，二叉树和递归都是基本的知识，应该被掌握的。 如果面试者是一个有多年工作经验的人，我认为这道题的难度其实不大，一个人即使多年不使用二叉树，多年不使用递归，但是这种思考还是很容易想到的。当然，所花的时间可能会大一些。所以我并不认为这是一道难题。 但是，对于一个有工作经验的人，考查他的工作内容，或许更有价值。因为相比代码的逻辑思维能力来说，工作方式和解决问题态度，架构设计，设计模式都是更重要的考查点。 当我们面算法题的时候，我们在考查什么？就像 Quora 上提到的那样，算法题面试被广泛应用在各大顶级互联网公司，包括 Google, Facebook, Microsoft, Amazon, Airbnb, Dropbox。在中国，这样的情况同样存在，BAT 的面试也充斥着算法题目。我当年在网易有道面试的时候，每一轮也都问了很多道算法题目。 但是，很多求职者都会问：“工作中用得到这些吗？”，说实话，用得非常少。那么当我们面算法题的时候，我们到底在考查什么？就我的经验来看，我们会从算法面试中考查到以下三点： 计算机的基础知识。一个人基础知识扎实，说明他在学校就很用功。 聪明程度。编程还是一个重智力的工作，智商高的人会在不停地知识更新中快速跟进学习。算法题其实就是计算机专业的智力测试题。这里面，动态规划的算法题目由于变化多，体现得就特别明显，考动态规划其实就是测智力。 沟通能力和思维。面试算法题的时候，一般不会直接让候选人写代码，而是会先一起讨论。通过讨论的过程，了解面试者沟通的能力和考虑问题的方式，也是考查的重点。 考查算法题会不会太片面？是的，算法在工作中运用得比较少，一般人也不会在工作中专门积累解算法题的能力。所以通常做算法题最强的是应届生，因为他们有时间去刷题。而在实际工作中，很多能力，都比算法能力重要。比如对代码的洁癖，对设计模式的理解，对计算机底层（操作系统、网络）的理解，对待工作的态度等。 那么，为什么那么多公司不考查，或者不重点考查这些，而只是问算法题呢？ 答案很简单，因为要在几个小时内了解一个人太难了。通常一场面试只有一个小时，如果要在一个小时内把上面说到的知识点都面面俱到的考查，是做不到的。但是如果花几天来考查，对于公司和求职者都是不可接受的。所以，很多大公司就用面算法题的方式来偷懒，因为这种方式虽然可能会误伤很多优秀的人才，但是不合格的人，要混进去还是相当困难的。 讲一句不好听的，很多公司在招聘的时候，首先根据学校，把非 985 的学校简历都过滤掉，也是一种不太合理，但是有效的方法。清华北大的人一定就牛逼吗？不一定，但是从概率上讲，比南翔技校的人通过面试的机会要高一些。所以，为了提高面试效率和成本，就直接把一般学校的简历过滤掉，这是一个不人道，但是从经济上合理的行为。 我自己也因为这个选拔方式深受打击，我自认为还是非常优秀的，在学校时拿到过 ACM 国际大学生程序设计竞赛的区域赛金牌，也在 IBM 实习过，学校专业课成绩也很好，但是毕业那年我连 Google 的笔试资格都没拿到。因为我不是清华北大的，Google 就在清华北大选人才，就足够了。 我们应该怎么办？现有的面试方式，其实让公司和候选者都不是太爽，主要的原因就是考查的时间太短，能够参考的信息量太小。但是，随着互联网的发展，作为程序员，我们慢慢有了更多的方式来让公司在面试前就了解自己。 我们可以搭建自己的博客，将自己的学习心得总结下来。我们可以将自己写得好的代码开源在 Github 上。我们可以在 stackoverflow 上回答问题，用 reputation 来证明自己的能力。我们还可以给著名的开源项目提 PR，成为重要的 Contributor。我们可以给 InfoQ 网站投稿。我们可以去 QCon 上分享技术。 如果你能在网络上构建起自己的技术能力图，那么对于很多公司来说，或许面试中偏技术性的考查就不那么重要了，面试的过程就可以更轻松愉快了。 但是，不要高兴得太早，要做到上面提到的这些只会比做算法题更难。但是，至少我们可以让自己的实习得到充分展示，能够让面试不那么片面，能够让公司更加全面的了解自己。 所以说最后，机会还是给那些努力的人。如果一个人学校不好，没有做过什么大项目，在网上没有任何可以考查的信息，那么面试的时候，估计等待他的还是各种算法题。 猿题库是如何招聘的？或许你会失望，我们其实就是和 Google 一样，会问大量的算法题。即使你来自名校名企，但是不会翻转二叉树，我们肯定会把你拒掉。 对于有经验的开发者，我们会适当降低算法题的难度，同时考查一些工作经历，但是翻转二叉树这种难度的题目，是必须做出来的。 所以，如果你没有各种社交网络的资料证明自己的实力，那还是老老实实把基础知识准备扎实吧。算法知识虽然用得少，但是在关键时候还是有用的，以后我会另外撰文举例。 愿大家都能找到自己的伯乐～ PS: 我所负责的小猿搜题项目，在半年时间内做到了市场第一的位置，现在想招更多 Java 服务器端和 Android 端开发，待遇和期权高于 BAT，面试要求也会高于 BAT。欢迎大家将简历发到 tangqiao(AT)fenbi.com 。这里有职位说明。 扫码关注我的「iOS 开发」微信公共帐号，及时获得我精选的各种 iOS 文章：","categories":[],"tags":[]},{"title":"谈谈苹果开源 Swift","slug":"talk-about-swift-open-source","date":"2015-06-16T13:02:55.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"2015/06/16/talk-about-swift-open-source/","permalink":"https://blog.devtang.com/2015/06/16/talk-about-swift-open-source/","excerpt":"","text":"在今年的 WWDC 大会上，苹果推出了 Swift 2，给 Swift 语言增加了许多新的特性，同时苹果宣布将开源 Swift 的编译器和标准库。虽然源码还需要等到年底才能放出，但不妨我们来聊聊开源这件事。 开源的互联网环境从整个业界环境来看，开源似乎是现在互联网的标配。其中 Google 是开源的先锋，现在智能手机操作系统基本被 iOS 和 Android 垄断，而 Android 的成功，很大程度上是因为 Google 对 Android 系统的开源，并且对基于 Android 的定制修改采取鼓励的态度。 Android 开源让苹果很受伤，因为这表明 Google 不指望依靠操作系统来建立竞争壁垒了，但是苹果不一样，苹果的大部分利润来自于硬件的销售，而硬件销售的高毛利是依赖软硬件一体带来的生态系统壁垒。如果开源 iOS，那么 AppStore 上海量的软件很可能贡献给其他基于 iOS 系统的兼容设备，从而对苹果的利润产生极大的冲击。 相对于开源操作系统，开源编程语言的编译器和标准库对商业的影响要小得多。所以 Sun 开源了 Java，微软开源了 .net，而苹果开源了 Swift。 那开源 Swift 对苹果有什么影响吗？首先现在 Swift 其实 bug 还比较多，开源 Swift 有助于大家更加积极的为 Swift 报 bug，甚至提 Pull Request。这更加有助于 Swift 的普及。 然后，各种语言都在尝试着不用 Swift 和 Objective-C 来写 iOS 程序。基于 Ruby，Java，JavaScript，C#的各种跨平台的解决方案都有。开源 Swift，也有助于 Swift 语言在其他平台上发展，比如用 Swift 来写 Android 或者后台的 Server，这都是可以想象的，比如最近 Github 上就出现了一个基于 Swift 的 Rails 框架（https://github.com/anynines/Swift-rails-example）。 什么是好的开源项目如果我们观察现在发展得比较好的开源项目，你就会发现开源项目要发展，其实开源仅仅是第一步。为了维护良好的开源社区，开源相关的工作还有很多。例如完善的文档，及时响应社区提的 Issue 和 Pull Request，对各种设计细节进行解释，这些都是需要大量人力的。如果没有搭配以上提到的这些工作，那么开源本身产生的效果将非常有限。 但是如果我们观察苹果以前的开源行为，就会发现其实文档都是非常简陋的。在苹果的开源网站（http://www.opensource.apple.com/）上，很多开源代码都是以非常“裸”的方式公开的，相关的代码架构文档非常少，社区的力量也很少参与贡献代码。 不过 Swift 的编译器和标准库宣布在年底开源，让我对苹果的此次开源抱有了一点希望。很可能苹果这次想做得更好一些，所以想将相关的文档和社区搭建完善之后，再将源码开放。 如果我们观察当前市场上成功的开源项目，就会发现成功的开源项目大多还是由商业公司在主导贡献代码。比如 Hadoop 80% 的代码都是由 Hortonworks 和雅虎贡献的。所以虽然 Swift 开源，但是苹果对于 Swift 的主导地位应该不会有任何变化，社区的力量可能更多的会贡献在 Bug 修复上。 跨平台复用代码今年跨平台复用代码是一个火热的话题，基于 Html5 的 PhoneGap 没有被大多数人接受，所以今年更多的方案是用各种办法产生原生的 UI 界面。我认识的一个前新浪微博的朋友就离职做这方面的创业了。 Swift 的开源让我们对在 iOS 和 Android 上复用一套代码又多了一个选择。不过这个就得完全依靠社区的力量了，我们已经看到有不少这方面的创业公司出现，基于 Swift 的跨平台开发方案能否出现，让我们拭目以待。 PS：扫码关注我的「iOS 开发」微信公共帐号，及时获得我精选的各种 iOS 文章：","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://blog.devtang.com/tags/Interview/"}]},{"title":"打造 iOS 原创内容的生态圈","slug":"build-ios-content-ecosystem","date":"2015-05-23T13:35:37.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"2015/05/23/build-ios-content-ecosystem/","permalink":"https://blog.devtang.com/2015/05/23/build-ios-content-ecosystem/","excerpt":"","text":"故事在说想法之前，我想先讲几个故事。 故事一：新杂志与《Tiny4Cocoa》我敬重的 tinyfool 刚创业的时候，做了一个 App 叫 「新杂志」，这是一个杂志聚合平台。与新杂志平台同期发布的还包括他的《Tiny4Cocoa》杂志，在《Tiny4Cocoa》杂志中，tinyfool 提出了每篇文章稿费 1000 元的价格，我当时还帮助他编辑过两期杂志。但是最终杂志没有继续下去，我觉得主要是以下几个原因： 每一期约稿比较花精力。为了保证质量和篇幅，每一期我需要提前找一些作者要稿子，但是发现不一定能够约到。 稿费都是 tinyfool 自掏腰包，虽然有广告收入，但是 1000 元一篇的成本还是很高。后来我们降到了 500 元，但是即使这样，长期自掏腰包这种状态也是难以维持的。 虽然最终我们没有把《Tiny4Cocoa》做成，但是让优质内容的作者得到回报一直是我心中的理想。 故事二：写书和稿费我身边有一些朋友写书或者是做翻译，比如 onevcat、吴航、破船等，我自己也写了一本《iOS 开发进阶》。我们通过交流发现，当前的现实是，通过写作或翻译并不能给大家带来合理的回报。这里「合理」是说：大家如果选择不写书，而是接个项目或者做别的事情，带来的直接金钱回报是更多的。 于是这种不合理导致了中国国内优质技术图书的缺少，虽然大家觉得一本书卖个将近 100 块钱很贵，但是大多数作者辛苦写一年，出版一本书的版税收入也就 15000 元左右，再扣完 20% 的税就更少了。 虽然大家都是凭着理想写作，但是我还是想让大家获得更加「合理」的收入上的回报。 故事三：转载对原创的不尊重现在很多技术媒体，在转载文章的时候，都没有在醒目的位置注明原始作者和原文链接。因为他们还是想强调自己平台的重要性。另外一方面，有哪家媒体为转载付费吗？我知道的只有 InfoQ 会。而其它媒体，大多数都是悄无声息地将你的文章转载了。 经济学与生态圈为什么我强调要让优质内容作者获得足够的回报呢？这其实是一个简单的经济学道理。经济学的规则如果能够制定得合理，就可以产生的良性的发展，最终构建出生态圈。如果每一个技术作者都能获得体面的收入，那么就会吸引更多的技术人加入到写作和分享的队伍中来。 我的想法那我能做些什么事情呢？2013 年 2 月，我自己建立了一个名为 「iOS 开发」(iOSDevTips) 的微信公众号，在上面分享原始的 iOS 开发文章。坚持了两年多后，我发现由于微信公众号平台对原创作者非常尊重，这可能能够成为一个让原创作者获得不错收入的平台。 所以我在想，我能不能让写 iOS 原创文章的其他作者，也借助我的公众号获得收入呢？于是，现在有一个初级的想法如下： 我的微信公众号 「iOS 开发」已经有 15000 人的订阅量，图文打开率非常高，时不时也会有一些广告收入，我想提供付费的方式来获得授权将大家的原创文章转载到我的公众帐号上，转载会注明作者和大家博客文章的原始链接。这样，大家的每篇原创博客都会有第一笔收入。另外，我还想通过微信的「打赏」来收大家凭借优质内容，获得第二笔的收入。我会把这笔收入也全部转给作者。 这个想法有几个地方还是需要讨论的： 我当前微信公众号的广告收入并不多，一年估计 1 万多的样子。所以我当前并不能拿出丰厚的转载稿费。我构想的是每篇文章大概 50 - 100 元的转载稿费。不过如果大家共同把这个微信公众号的影响力做起来，那么凭借广告收入，我就可以提供更高的转载稿费。 微信的「打赏」功能只支持原创的文章。按照 微信的规定，我只能将获得「独家代理的文章」标识成原创，从而开启「打赏」功能，所以我需要得到作者的授权，获得在微信公众平台上的「独家代理」。 腾讯公司的微信公众号平台对原创作者非常尊重，而且这是当前中国最大的社交平台，我希望借助她的力量，让所有优质的原创 iOS 内容作者，都得到应得的收入作为回报，同时也使得那些优质的内容，得到快速地传播。 对于我个人来说，如果能构建出一个由全中国优秀 iOS 开发者贡献的内容帐号，那将是一个非常有意义的事情。 对于各位「iOS 开发」公众帐号的读者来说，大家以后将不止看到我个人的 iOS 技术文章，还包括我精心挑选的，愿意花钱支付转载费用的文章。大家不必为这些文章支付任何费用，但是偶尔可能会收到一个与 iOS 行业相关的广告。如果你愿意，转发你觉得优秀的文章，或者给优秀的文章适当「打赏」也会让这个生态圈发展得更好。 对于各位 iOS 原创博客作者来说，欢迎大家将自己觉得优秀的博客文章授权给我，我愿意支付相应转载费用，以及提供所有的相关打赏收益。王晓磊的这篇文章 是第一个尝试用这种方式授权给我的作者。 愿我们的行动能够让世界改变一点点。 后记 （2017.11.26）由于我的公众号转型，后续不再打算继续接受投稿，不过我会选一些我认为好的文章主动联系作者授权转载。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"苹果推出了官方的分析工具","slug":"apple-release-analytics-beta","date":"2015-05-01T12:51:29.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"2015/05/01/apple-release-analytics-beta/","permalink":"https://blog.devtang.com/2015/05/01/apple-release-analytics-beta/","excerpt":"","text":"苹果在五月一号这天，向开发者发送邮件，邀请参与他自家的分析工具的试用。虽然现在我们公司猿题库的帐号还处于排队等待的状态中，不过我们可以从苹果的介绍中看出这个工具的特点 无需额外操作 You won’t need any additional code or app updates, and there’s no extra cost. 可见相关功能是直接集成进 iOS 系统中的，对应用来说没有任何其它的代价。 可以做的事情 获得用户查看 App Store 上应用页面的次数和频率 获得用户打开你的应用的频率 检查你的应用销售情况，包括应用内支付 创建自定义的运营活动链接，并且监控该链接带来的效果 了解哪些网站给你的应用页面带来了流量 总结这个分析工具弥补了 iOS 应用长久以来在这方面的功能缺失。由于苹果的限制，上面提到的一些功能，例如统计运营活动效果、统计查看 AppStore 页面效果等功能，第三方工具是无法提供的。 苹果提供这样的工具，有助于开发者更加有效地开展市场推广和运营相关的工作。 稍后我会更新一些使用体验，愿大家玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"QCon 参会笔记","slug":"qcon-2015-note","date":"2015-04-24T13:24:28.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"2015/04/24/qcon-2015-note/","permalink":"https://blog.devtang.com/2015/04/24/qcon-2015-note/","excerpt":"","text":"前言这两天在北京国际会议中心，QCon 全球软件开发大会正如期举行，我有幸参加了此次会议。QCon 此次参会的人数远远超过了主办方的预期，以至于提前关闭了报名通道。大会现场很多演讲人员爆满，现场周围都站满了人。 在会议上，我不但听了很多感兴趣的演讲，还见到了很多在网上多次交流，但从未谋面的好朋友，也认识了很多新朋友。这次交流对我来说收获挺多，在此总结一下。 和 gaosboy 聊天gaosboy 是 SegmentFault 的联合创始人，现在在天猫。他在天猫工作两年了，在做 iOS 基础架构方面的事情。我和他之前在网上交流多次，也是由于他的引荐，我才加入了 InfoQ 的编辑团队。我和他交流了一些团队发展的问题，以及 iOS 的一些技术细节。 关于应用架构和开发方式关于应用开发，天猫是将产品划分成很多组，每个小组的功能做完通过测试后，再 merge 到发布分支，发布分支要发布前，再进行一次集成测试，就可以上线了。这样可以各组之间不必完全同步进行开发，做完的就可以上线，没做完的小组顶多是赶不上某些上线，不会影响别的组的工作。 天猫也做了很多方便后台定制客户端的工作，例如用 JSON 来定制界面，又如将 UI 控件进行标准化。通过和他的交流，我能感受到天猫的产品是很偏重运营的，所以他们在做技术架构的时候，会考虑到怎么方便运营同事能够在后台快速配置生成运营相关的界面。某一方面，他们在努力尝试跨平台的各种方案，也是为了解决运营上的快速变化和配置便捷的需求。这让我认识到，其实没有绝对意义上标准的应用架构，好的应用架构应该是与自己的产品特点紧密联系的，这样才是最合适的。 关于 UIWebView 与 其它界面的混排gaosboy 也给我分享了关于原生界面和 UIWebView 混合排版的一些技巧，还挺有意思的。如果做过这方面工作的朋友就会知道，UIWebView 如果外层再套 UIScrollView，在内部和外部都可以上下滑动时，体验其实是不太好的，通常的做法是把内部的 UIWebView 高度完全展开，使得内部不再可以滑动，然后只用滑动外层的 UIScrollView 即可。 但是这个方案也有一些问题，就是 UIWebView 内容的高度并不是可以很方便地获取的。因为 UIWebView 中的图片资源会异步加载，加上一些 JavaScript 逻辑也可能在 DOM 加载完成后二次操作 DOM 做界面调整，所以原生层很难方便地知道 UIWebView 的高度。 gaosboy 给我分享了他在 SegmentFault 使用的技巧：利用 KVO 来监控 UIWebView 的 contentSize 的变化。这样可以随时知道 UIWebView 的内容高度有变化，然后就可以做相应的调整了。 gaosboy 另外还给我分享了一个 “黑科技”，即将原生的控件直接用 addSubView 插入到 UIWebView 的内部，然后在 UIWebView 内部用 css 控制相应的 padding ，给原生的控件留出相应的空白位置。 这个方案的优点是：这种办法可以保证整个界面只需要一个 UIWebView 即可完成。否则用之前的办法，如果某个界面有几个不相连的地方要用 UIWebView 展示，就得实例化多个 UIWebView 了。 但之所以把它称做 “黑科技”，是因为这种方法也有一些缺点： 一个是直接往系统控件里面插子 view 这种操作有很大风险。因为你不知道哪一天 iOS 系统升级后，这些控件内部的机制有没有调整，会不会造成这种黑科技挂掉。典型的例子就是 iOS8 刚升级那阵，微信的 ActionSheet 都弹不出来了。另外 iOS 8.3 的时候，我记得微信也出现过返回键失灵的情况。这些都是基于系统控件的一些内部机制做了一些事情，由于系统升级机制改变而受到的影响。 由于 padding 是事先留好的，如果是往 UIWebView 的中间插入元素，那么当页面调整后，需要重新更新控件的位置。 但是，这个方案当前确实被 gaosboy 他们在天猫采用过，所以我觉得也是一个挺有意思的、在某些实际场景下可以考虑的方案。 Native 和 Web 融合 - 听天猫前端开发专家鬼道（徐凯）的分享鬼道老师所在的团队是最先尝试使用 React Native 的，之前我总结的 iOS 开发周报中的好几篇文章都是出自他们团队。我在这里将他的分享简单整理如下。 关于 WebView鬼道首先分享了 WebView 在客户端的问题和特点，主要有： 首次加载慢 - 用本地 zip 包来解决 长列表占内存 - 用他们开源出来的 xList 来解决（类似 UITableView 的复用方案，不过我搜了一下，只找到一个 0 star 的项目：xlist，很可能找错了） 动画、w3c 慢 需要做 Hybird API 更新快 可以用 Hotpatch 来修复线上问题 他们做了一套叫 Windvane 的框架，可以对 WebView 的强化，对缓存和网络的扩展。他说好象也开源了，不过我没有搜到，应该是没有开源。 他们另外做了 WebView Crash 监控，通过冷加载，重构，把 Crash 率从 0.7% 降到 0.1%。 分享中还涉及一个技巧：把两倍的图的质量调整到 50%，以节省 WebView 的内存占用。 React NativeNative 可以带来更好的人机交互体验： 手势识别 动画效果 原生控件 更合适的线程模型（如图象解码，文本渲染） Web 上的高效的开发效率和发布能力 业界现在使用 React Native 的应用: FB ads&#x2F;F8 Chinese Flashcards 天猫 比较重要的是，鬼道分享了 React Native 几个重要的性能指标： 内存：React Native 内存上的优势相对 WebView 比较明显，和原生的稍多一点。 CPU：CPU 上也比 WebView 有优势 启动时间：比 WebView 快 1 倍的样子 体积：我问了一下，几百 K 而已 要使用 React Native，基础环境还需要的工作： 埋点方案 缓存打包方案 网络改造 Framework 集成 发布机制改造 jsbundle 优化 Semi-Hybrid App Framework - Geek Zoo Studio 联合创始人 郭虹宇老郭的项目说实话最早应该是被我关注到的，当时他还在做 BeeFramework。他在阿里技术沙龙的第一次分享是我邀请的，他的第一篇采访稿是我代表 InfoQ 做的。老郭一直在尝试 Semi-Hybrid 这种混合编程方案，这个也是我个人挺感兴趣的一个技术方向。 由于我私下和他交流得太多，他的项目我也非常关注，这个分享我获得的新东西不多。但是还是给大家简单介绍一下老郭的这个项目吧。 老郭自己实现了一套浏览器的排版引擎，然后可以将正常的 HTML 和 CSS “翻译” 成原生的控件，这样就可以用 HTML 和 CSS 来写界面了。整个框架使用起来还是很cool的，大家去 star 一下他的这个项目吧，地址是：samurai-native。 最后多说一句，我觉得老郭的方案和 React Native 不是竞争关系。因为这两个框架解决问题的思路完全不一样。如果没有更新逻辑的需求，老郭的方案可能更适合天猫团队。当然，不管是samurai-native还是react native，现在都还没有开源出对 Android端的支持，不过这都只是时间问题。 移动时代用户端问题高效诊断 - 腾讯社交网络运维负责人 马玉明主要讲了移动 App 优化、云诊断技术架构、未来展望。 客户端优化： 网络定时驱动到事件驱动 TCP 粘包和半包处理 网络线程 网关劫持： 下发 HTTP 页面–检测 html 页面并且 webview 展示 下发错误数据 协议和端口限制–后台优化，客户端轮换 ip。私有协议用 443 端口成功率比较高。 异步启动的协议和端口限制 协议包头（异步）检测劫持 移动网络容灾调度： server iplist 拉取和 push 移动终端网络质量数据监控 支持版本、地区、运营商、ip 段，qq 号的调度 具备断网、失效身份、踢下线、屏蔽命令字、进程自杀等能力 其中的很多问题我们都曾经遇到过，比如被运营商封禁这种事情。私下和马玉明聊天，他说他们都不敢把一些内容放到 qq.com 之外的其它域名，因为由于 QQ 的流量很大，运营商是不封禁的，而其它域名，一旦流量太大，很可能就被运营商给封禁了。所以在这方面，由于有移动运营商这一层，在运维上还有挺多事情需要做的。 最后马玉明成分享了他们的云诊断平台：http://huatuo.qq.com 。 美团移动平台背后的技术 - 陈晓亮陈晓亮也从美团的业务出发，介绍了他们的做法。具体细节和最先提到的 gaosboy 的做法不同，但都是为了与自己的业务模式契合。 简单来说，晓亮他们用平台 + 频道来解决业务线种类多、差异大的问题。用 CocoaPods 、Jenkins 等来做代码的依赖和集成。 另外，他们利用类似注册的方法，来解决模块之间的解耦。他们把这个方法叫做 Protal。我听着感觉和 Android 的发 Intent 类似。即每个页面可以向一个中心注册，说我提供哪些服务，然后这个中心就知道每个服务应该用哪个类来处理。当要进行服务切换时，这个中心来负责做相应类的实例化，页面跳转等逻辑。服务在 iOS 里面可以用自定义的 url 来表示。注册中心可以拿一个单例来实现。 关于这种页面之前解耦，其实最早 Facebook 的 three20 框架就有。不过 Facebook 把它叫做 Router。three20 被废弃之后，也有很多人开源相应的解决方案。我记得 gaosboy 就开源过 urlmanager， github 上也有一个叫 HHRouter 的开源库，大家感兴趣可以自已学习下。 另外我才知道，美团他们大量使用了 ReactiveCocoa，有机会真是想好好讨论一下。 这次分享也见到了同在美团的梁士兴，我们以前一起在 IBM 的 Symphony 项目组实习过。 谷歌，投资，创业：懂技术的优势和通病 - 技德科技 CEO 周哲这位 Google 的第 103 号员工在财务自由之后，做了一段天使投资人，然后选择了创业。他给我们讲了他在谷歌、投资、创业中的故事。 在看完《从 0 到 1》之后，再听他的故事，就觉得更加有趣了。因为你会发现，《从 0 到 1》里面提到的，“发现秘密” 这件事情，真是的非常困难的。Google 在早期，在很长一段时间内都没有考虑用广告来赢利，在最初做 Adwords 的时候，也只有 2.5 个工程师在做，而且这些工程师从来不点广告，认为这个东西做出来没人用。 那事情的结果大家都知道了，广告成了搜索引擎公司最大的收入来源。现在看来，大家会觉得这个想法是非常自然的，但是如果真的是这样的话，当时的搜索巨头雅虎就不会把这块业务”OEM“给 Google 来做了。 关于投资，周哲说虽然投兰亭集势成功了，投资主要的收获是那些失败的案例。而且选择创业，自然是认为他看到了另一个未被人发现的” 秘密 “。他讲了好几个故事，包括：教他编程的爸爸不会用 Windows 8，他自己花了 5 分钟不知道 Windows 8 如何关机，他当初是如何嘲笑 iPad 就是一个大一号的 iPhone，为什么大家现在还要用笔记本。最终他觉得当前没有谁在这方面很好地解决了用户的痛点，于是他选择了自己创业。 他的创业作品在 http://www.jide.com/ ，是一个基于 Android 的、带键盘的笔记本。 总结听了两天的 QCon，感觉大会整体的质量在逐年提高，自己的收获也很多，希望明年能够办得更好。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"《从 0 到 1 》读书笔记","slug":"from-0-to-1-book-summary","date":"2015-04-04T07:22:41.000Z","updated":"2024-01-06T14:52:37.922Z","comments":true,"path":"2015/04/04/from-0-to-1-book-summary/","permalink":"https://blog.devtang.com/2015/04/04/from-0-to-1-book-summary/","excerpt":"","text":"我每天坐地铁上班和下班，在路上的时间加起来有1个半小时。但有一个好处是：在地铁上，你除了看书也没什么事情可干。于是，最近看完了《从 0 到 1》。这本书的作者是：彼得·蒂尔（Peter Thiel，PayPal的联合创始人，Facebook的第一位外部投资者）。 不过《从 0 到 1》讲了太多，不得不整理一下，为了方便梳理，我把每一章的核心思想先总结下来，分享给大家。 第一章 未来的挑战 每当我面试应聘者时，都会问这样一个问题：“有没有在什么重要问题上你与其他人有不同看法 ?” 作者用以上内容开头，表达出未来创业的核心是，找到你与大多数人看法不同的地方。反主流的观点使得你的创业有可能成功，因为： 因为反主流，你不会遇到大量同质化的竞争对手，或者大企业切入。 一旦你的观点在未来得到印证，那么你利用时间窗口建立的先发优势就可能成为你的竞争壁垒。 另外书中也在序言中提到： 成功人士总能在意想不到的地方发现价值，他们遵循的是基本原则，而非秘籍。 所以反主流的观点的产生并不是特意 “与众不同”，不是 “为了差异化而差异化”，而是用基本的、科学的方法来进行分析论证，以及用精益创业的方法进行迭代。 用科学的方法寻找 “反主流” 的观点和商业机会 – 这是我对本章的总结。 第二章 像 1999 年那样狂欢 尼采曾在精神 错乱前写道：“个人发生精神错乱很少见，但对群体、政党、国家、时代而言，精神错乱却很普遍。” 如果你能识别出那些精神错乱的大众观点，你就能看到这些观点后隐藏的与之对立的反主流的事实。 作者从 1999 年互联网泡沫谈起，介绍了 “主流观点” 的不停改变。而在这些 “主流观点” 中，很多相对立的做事方法看起来都非常合理。例如对于创业公司来说： 作者提到当前创业中主导的商业思想是： 逐渐超前：不能沉溺在宏大的愿景中，否则会使泡沫膨胀。 保持精简和灵活性：你应该做些尝试，反复实践，把创业当成未知的实验。 改进竞争方式：不要贸然创造一个新市场。 专注于产品，而非销量：唯一持久的增长是病毒式增长。 但其中的对立面其实也很有道理： 大胆尝试胜过平庸保守。 坏计划也好过没有计划。 竞争性市场对收益有负面影响。 营销和产品同样重要。 所以，作者最后提到，其实没有什么 “法则”，以下是作者的总结。 要想建立新一代企业，我们必须扔掉之前陈旧的法则。但这并非意味着那些法则的对立面就一定是正确的：因为就算你有心逃脱，大众洪流也会裹挟着你向前。 相反，要问自己：你对企业的认识有多少基于对以往过错的错误反应形成的？最反主流的行动不是抵制潮流，而是在潮流中，不丢弃自己的独立思考。 独立思考，不随大众，也不刻意抵制潮流 – 这是我对本章的总结。 第三章 所有成功的企业都是不同的作者在本章中介绍了经济学的两个概念：一是完全竞争，二是垄断。他用航空公司和 Google 分别作为这两个概念的示例。前者由于竞争充分，市场上每一家公司都挣得少，后者由于垄断，可以维持非常高的利润率。 本章还介绍了一些技巧来让事实垄断的公司来隐藏事实，以逃避相关的法律监管，相信我们大部分人都还用不到这些。 本章还介绍了一个 “反主流” 的观点，即垄断对消费者是有害还是有利的？作者认为是有利的，因为： 在商界，钱就是一切，或至少是非常重要。垄断者除了想着赚钱外还有余力想其他事情，而非垄断者就不行。在完全竞争中，企业着眼于短期利益，不可能对未来进行长期规划。要想将企业从每日的生存竞赛中解脱出来唯一的方法就是：获取垄断利润。 另外，作者也在书中解释了 “垄断有害” 这种大众观点是如何形成的。最后作者总结到： 成功的企业成功的原因都不同：每个垄断企业都要解决一个独一无二的问题。而失败的企业失败的原因却相同：它们都没有成功避免竞争。 努力形成垄断 – 这是我对本章的总结。 第四章 竞争意识本章讲了很多故事，最终想表达的都是竞争使竞争双方都失败了。因为： 竞争使我们过分重视过去的机会，一味重复过去的模式。 竞争使人出现幻觉，徒劳去抓一些并不存在的 “机会”。 竞争还让人分心，专心于怎么打败对手，而不是找到更好的发展方向。 但是很多时候确实竞争不可避免，所以作者说： 如果你能看出竞争不能带来价值的提升，而是充满破坏力，那你就比大多数人要理智。 保持清醒的竞争 – 这是我对本章的总结。 第五章 后发优势本章首先用 Twitter, Linkin, Pay Pal 举例，指出科技公司在商业上的通常模式，即先烧钱把规模做大，然后再进行收入上的尝试。但也指出 Zynga 和 Groupon 却是这方面的反例。所以核心的问题是：你必须认真思考公司的本质特征。 接着作者介绍了他认为垄断公司的特征： 专利技术：专利技术在某些方面必须比它最相近的替代品好上 10 倍才能拥有真正的垄断优势。如果你能做到 10 倍好，你就可以避开竞争。 网络效应：网络效应使一项产品随着越来越多的人使用变得更加有用。社交一类产品的高估值，都是因为它们具有网络效应。在中国，微信、陌陌、以及创业公司 Nice 都是这一类典型的代表。 规模经济：随着用户量增加，产品的边际成本趋近于零。几乎所有的移动互联网公司都是这样。但小米这类做硬件的公司除外。 品牌优势：品牌是把双刃剑。做得好可以形成竞争优势，但没有只靠品牌发展的科技公司。另外品牌上走下滑路之后，要扭转也是很难的。 接着作者介绍了建立垄断企业的方法： 占领小市场：在一个小的市场里占主导地位比在大的市场里要容易得多。 扩大规模：最成功的公司会先在一个特定的利基市场里占据主导，然后扩展到相邻市场。 不要搞破坏：如果你准备扩张到相邻市场，不要 “破坏”, 要尽可能地躲开竞争。不过该观点可参考，不可照搬。例如在中国，就有 360 这样的通过 “破坏” 性创新来成功的企业。 第六章 成功不是中彩票本章在介绍了各种社会现象后，对精益提出了质疑： 成为企业家的人被告知在商界所有事情的发生都不可预料：我们应该做的就是倾听顾客的需要, 创造 “最基本的可用产品”, 然后反复修正, 最后走向成功。 但是精益是一种方法，而不是目标。对已经存在的事物做出 小的改变可能让你达到局部市场最大化的成绩，但是不能帮助你 取得全球市场的最大化。 但是没有大胆计划的进化不会使你实现从 0 到 1 的跨越。 所以作者指出，长期规划还是最重要的事情。 忘掉 “基本的可用产品” 吧——自从他在 1976 年创立了苹果之后，乔布斯就意识到只有对未来精确地规划，才可以改变整个世界，而非倾听焦点团体的意见或是复制其他人的成功。 但是比较麻烦的是：“长期规划在我们未来不明的追求短期利益的世界里经常被低估。” 这里拿拉手网和美团网举例再好不过了，在所有团购网站都是疯狂烧钱的时候，王兴却能够冷静下来，做长期的规划，做更有效率的推广以及留钱过冬。最终这场竞争的成功者不是烧钱烧得最快的，而是美团这样有长期规划的公司。 要做精益创业，但更需要有长期规划。精益创业就像把事情从 1 做到 100，而长期规划是做从 0 到 1 的跨越。– 这是我对本章的总结。 第七章 向钱看本章介绍了很多有意思的事实。以下是摘抄的部分内容： “撒网式投资，然后祈祷” 这种方法通常会全盘皆输。这是因为风险投资的回报并不遵循正态分布，而是遵循幂次法则：一小部分公司完胜其他所有公司。 风险投资中最大的秘密是：成功基金的最佳投资所获的回报要等于或超过其他所有投资对象的总和。 Facebook, 是我们 2005 年的投资组合里表现最好地，回报比其他所投资公司加起来的还要多。帕兰提尔，是表现第二好的公 司，带来的回报比刨除 Facebook 外所有公司加起来的还要多。 每个人都是一个投资者。你之所以选择一份职业，是因为你相信自己选择的工作在今后的几十年中会变得很有价值。 这种想法用在初创公司上，就是即使你非常有才能，也未必要创建自己的公司。现在自己开公司的人太多了。懂得幂次法则的人在创建企业时会比其他人更犹豫：他们知道加入一个发展迅速的一流企业会获得更大的成功。 拿我自己来说，猿题库发展到现在已经估计 3.6 亿美元，但是如果猿题库最终改变了 K12 的教育产业，那么很可能发展成为一个百亿美金的公司，这么看的话，当前公司每一个同事潜在可能获得的回报都是巨大的。 第八章 秘密文章先介绍了一下 “大学炸弹客” 的观点：认为世界上所有可以改进的事情都被做完了。然后作者对该观点进行了反驳。 事实是还有许多秘密等待我们去探索，只有坚持不懈的探索者才能发现它们。 空中食宿 (Airbnb) 成立之前，游客别无选择，只能高价住旅店，而业主也不能轻易且放心地出租自己空闲的房间。空中食宿看 到了这个未被开发的服务和未被解决的需求，而其他人则没有看到。租车服务公司 Lyft 和 Uber 也是如此。 其实这一章的 “秘密” 就是指第一章的 “反主流” 观点，只是作者再一次换了一种说法。 第九章 基础决定命运作者在本章强调了公司的一些基础的重要性，比如团队： 每个伟大企业都是独一无二的，而重要做好每个事业，有些事情是在起步阶段就必须做好。我经常强调这一点，以至于朋友们戏称它为 “蒂尔定律”：基础没有打好的初创企业是无法挽救的。早先的错误决定一旦做出（比如选错合伙人、挑错员工），之后就很难改正。而要纠正这些错误，公司可能面临几近破产的危机。作为创始人，你的首要工作就是打好基础，因为你无法再有缺陷的基础上创建一个伟大的企业。现在我考虑投资一家初创公司时，会考察其创立团队。技术能力和才华互补固然重要，创始人之间的了解程度和他们合作的默契程度也同样重要。创始人在共同创业前应有深厚的，否则就是在碰运气。 作者接下来讨论了所有权、经营权和控制权，并且分享了他在激励员工方面的看法。 第十章 黑手党式的机制作者在这章中以他创建的 Pal Pay 举例，分享了他认为的理想的公司文化。 为什么放弃去谷歌获取高薪和威望的机会，而去你的公司做第 20 位工程师呢？以下是一些不好的回答：“因为你公司的认股权比其他地方的更有价值。”“因为在你的公司能和世界上最聪明的人一起工作。”“因为你能帮助解决世界上最具挑战性的问题。” 高价股票、聪明同事、具挑战性地问题有什么不对吗？没有——但每个公司都是这种相同的论调，因此这并不能使你独树一帜。千篇一律的话语不能说明为什么应聘者要加入你的公司，而放弃其他的选择。 但有两类好答案：一类是关于公司使命的，一类是关于团队的。如果你能解释为什么公司使命激动人心，那么你就能吸引你需要的员工。不是解释工作的重要性，而是解释为什么你在做别人从未想过要做的重要事情。这是唯一能使其重要性变得独特的方法。 第十一章 顾客不会自动上门本章讲解了市场人员的重要性。 在工程学界，解决方案不是奏效就是失效，所以要评估别人的工作相对容易，外表表象无关紧要。而销售则恰恰相反：他们精心设计活动来改变表象，但不修改实质内容。因此工程师觉得如果这种做法只是雕虫小技，甚至是极不诚实的。 我认为所有的技术人员都应该好好阅读一下本章。就我在猿题库的创业经历来看，市场和运营同事展现出的专业性，使得我们在竞争中占据了非常大的优势，这一点对于我们创业成功是非常重要的。 但是这些工作常常被工程师低估，从而影响互相的合作。相互欣赏和尊重是合作的前提，通过了解市场人员工作的重要性和挑战，有助于研发团队和市场运营团队进行有效地配合，从而将竞争力量发挥到最大。 市场和运营人员的工作难度是高于开发团队的 - 这是我对本章的总结。 第十二章 人类和机器本章仅是作者对于人类和机器如何和谐相处的展望。这方面的影片倒是很多，从经典的《黑客帝国》，到不久前的《黑镜》。科技到底是敌是友，我个人是不知道的，但是无论如何，科技进步是不可阻挡的，不如尽情活在当下，享受生活的乐趣。 第十三章 绿色能源与特斯拉本章完整地分析了特斯拉的成功。作者拿前面几章的观点，在这个故事上一一拆解分析。 之前我们的 CTO 郭常圳也从产品角度和我们分享过关于特斯拉的成功。特斯拉确实在各方面都是一个值得分析和学习的公司。 第十四章 创始人的悖论本章介绍了创始人对于公司的重要性。 苹果的价值主要依赖于某个人的个人愿景。这表明公司创造新技术所运用的这种奇怪方式通常与封建君主制很相像，而不是我们想象中的更 “现代” 的组织。独树一帜的创始人能做出权威决策，激发员工强烈的忠诚度，提前做出未来几十年的规划。自相矛盾的是，经过训练的专业人士组成的毫无人情味的官僚机构虽能够长久持续下去，却鼠目寸光。 创始人的重要性并非源于自身工作带来的价值，事实上，优秀的创始人能使公司的每个人发挥所长。 总结再次总结一下《从 0 到 1》这本书的观点： 用科学的方法寻找 “反主流” 的观点和商业机会。 保持独立思考，不随大众，也不刻意抵制潮流。 努力形成垄断。 保持清醒的竞争，避免陷入仅以打败对手为目标的狭隘竞争。 垄断公司的特征：专利技术、网络效应、规模经济、品牌优势。 刚开始创业时，尽量占领小市场、然后扩大规模、尽量避开竞争。 利用幂次法则，专注做一件事情，做到最好。 创始团队是非常重要的。 市场和运营人员的工作是非常重要的，挑战也是非常大的。 创始人对于公司非常重要。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"iOS 开发中的争议（二）","slug":"ios-dev-controversy-2","date":"2015-03-22T03:06:31.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/03/22/ios-dev-controversy-2/","permalink":"https://blog.devtang.com/2015/03/22/ios-dev-controversy-2/","excerpt":"","text":"打算分享一些有争议的话题，并且表达一下我的看法。这是该系列的第二篇。 在本文中，我想讨论的是：对于 UI 界面的编写工作，到底应该用 xib&#x2F;storyboard 完成，还是用手写代码来完成？ 本着 “使用过才有发言权” 原则，我介绍一下我的经历： 最早在网易开发 “ 有道云笔记 “ 的时候，我们是使用 xib 来制作界面的。 三前年创业编写 “ 粉笔网 “ 的时候，我也是使用 xib 来制作界面的。 之后开发 “ 猿题库 “ 的时候，我尝试了一下使用 storyboard 来制作界面，但最后放弃了。之后我把大部分界面编写工作都改成由手写代码来完成。 在去年开发 “ 小猿搜题 “ 的时候，由于时间紧，我又再一次使用了 storyboard，但是我现在计划将其用手写代码来重构一次。 xib 使用调研情况除了我本人的经历外，我也调研了一下我手机中装的所有的 App 的开发情况，我写了一个脚本，分析了我手机中一共 100 多个 App 包含的 xib 文件的个数。通常情况下一个 App 如果完全通过 xib&#x2F;storyboard 来完成的话，那么编写包含的 xib 个数不应该少于 10 个（注：storyboard 在打包时会被拆解成多个它包含的 xib 文件）。 这个调研的最终结果，以及我分析用的脚本源码在 这里。我挑了一些比较有名的应用列在下面。（我另外也列出了它们包含的 js 的文件数量，这个可以反应出该应用对基于 UIWebView 的 Hybrid 编程的使用情况，不过与本次讨论主题无关。） 软件名字 nib 文件数 js 文件数 Mailbox 2.3.3.ipa 0 0 Twitter 6.0.1.ipa 0 0 objcio 1.0.3.ipa 0 0 播客 2.0.ipa 0 0 知乎日报 2.5.ipa 1 2 百度视频 6.2.2.ipa 1 3 高德导航 9.2.ipa 1 0 优酷 4.3.ipa 2 3 网易云音乐 2.3.1.ipa 2 0 滴滴打车 3.6.2.ipa 3 0 网易新闻 416.ipa 4 1 QQ 5.4.ipa 9 2 猿题库 4.1.0.ipa 9 0 京东 .ipa 10 0 搜狐视频 4.6.3.ipa 10 0 快的打车 3.7.ipa 11 0 小猿搜题 1.4.0.ipa 12 0 WeChat 6.1.1.ipa 13 20 Evernote 7.6.5.ipa 23 25 有道云笔记 4.3.1.ipa 40 11 来往 4.3.2.ipa 48 0 百度地图 7.6.1.ipa 76 227 易到用车 6.2.2.ipa 106 0 网易有道词典 5.2.2.ipa 114 9 美图秀秀 3.5.0.ipa 155 3 支付宝钱包 8.5.3.ipa 158 7 手机淘宝 5.2.4.ipa 188 0 易信 1.4.8.ipa 292 12 大众点评 7.0.2.ipa 1783 5 iMovie 211.ipa 4323 1 以上这个表格说明了即使是比较著名的 App，在使用 xib&#x2F;storyboard 上，也有很大的差异。举几个例子： QQ、WeChat（微信）和易信同属于社交类应用，而且按理说，由于用户量和开发时间更长，QQ 和微信应该比易信更加复杂，但是从 xib 数量上，前者 xib 的数量都非常少。这说明，在 QQ 和微信中，很多界面肯定是通过手写代码来完成的。 滴滴打车、快的打车和易到用车同属于叫车软件，按理说滴滴打车、快的打车同时包含叫出租车和叫专车功能，应该比易到用车功能更多，更复杂。但是前者 xib 的数量都非常少。这也说明，滴滴打车、快的打车的界面很多是通过手写代码来完成的。 另外，像 Mailbox、播客 (Podcast)、Twitter、objcio 这些 App 中 xib 的数量为 0，说明其完全是用手写代码来完成 UI 界面编写的。 当然，也有一些能看出来几乎是由 xib 构成的应用，例如大众点评、美图秀秀、网易有道词典。而苹果的 iMovie 使用了 4000 多个 xib，真让人不敢相信。我后来仔细看了一下，原来是因为 iMovie 做了国际化，每种语言大概有 120 个 xib，因为支持了将近 40 个语言，所以 xib 数量变成了 4000 多个。大众点评的每个 xib 也被切分成了 4 个，具体用处我还没研究，如下是一个示例： ./Payload/DPScope.app/WEDHotelShopInfoMainModule.nib./Payload/DPScope.app/WEDHotelShopInfoMainModule.nib/objects-8.0+.nib./Payload/DPScope.app/WEDHotelShopInfoMainModule.nib/objects.nib./Payload/DPScope.app/WEDHotelShopInfoMainModule.nib/runtime.nib 讨论就上面的调研我们就可以看出，其实大家对于是否应该使用 xib 做界面是有争议的。在实际案例中： 既有像 Twitter，Mailbox，objcio 这样完全不使用 xib 做界面的情况。 也有像 QQ、微信、滴滴打车、网易新闻、猿题库这样少量使用 xib 的情况。 也有像支付宝、大众点评这样重度使用 xib 的情况。 那么我就从我的角度把用与不用 xib 的优缺点表达一下。 使用 xib 和 storyboard 的优点 开发界面所见即所得，可以快速通过拖拽构造界面。 你可以从 storyboard 中很方便地梳理出所有View Controller的界面间的调用关系。这一点对于新加入项目组的开发同事来说，比较友好。 使用 Storyboard 可以使用Table View Controller的 Static Cell 功能。对于开发一些 Cell 不多，但每个 Cell 都不一样的列表类设置界面会比较方便。 通过实现 – (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 方法，每个 View Controller 的跳转逻辑都聚集在一处，这方便我们统一管理界面跳转和传递数据。 Storyboard 可以方便将一些常用功能模块化和复用。例如 WWDC2011 年介绍 Storyboard 的视频就将微博分享功能模块化成一个单独的 Storyboard。 使用 xib 和 storyboard 的缺点 xib 对版本管理是灾难。storyboard 实际上的多个 xib 的集合，所以更容易让多人编辑产生冲突。而虽然它们是 xml 格式，但是冲突解决起来还是不如代码那么容易。 苹果对 xib, storyboard 的设计中带有当前电脑的操作系统版本和 Xcode 版本。所以如果两个协作的开发者电脑操作系统或 Xcode 有不一样的话，每次打开必定会修改这个文件。另外即使操作系统版本和 Xcode 版本一样，有些时候打开看也会造成一些自动的修改。 storyboard 带来的 segue 的概念对于开发来说并不省事，特别是在需要传递参数的时候。如果是用程序内部 trigger 一个 segue，那么需要在另一个回调的地方设置 dest view controller 的参数信息。 我们发现 xib 中设置的颜色值并不精确，RGB 在真机 &#x2F; 模拟器上常常会有 10 多像素的偏差。 xib 和 storyboard 对继承的支持并不友好。无法做界面的继承。 xib 和 storyboard 对搜索支持并不友好，无法方便地在 Xcode 中查找关键词（但是可以通过写 bash 命令来查找）。 storyboard 对组合支持得不太好，不允许在一个 xib 中附带多个子 view。 xib 和 storyboard 不太方便做界面的模块化管理，比如我们想统一修改界面中所有按钮的字体样式，那么在 xib 和 storyboard 只能一个一个手工修改，而如果是代码编写的，则只需要改一个工厂方法的实现即可。 对于复杂的 App，storyboard 的性能会比较差。 关于手写 UI 界面的一些挑战所以我更喜欢用代码编写 UI 界面，加上现在移动开发对于 App 要求的需求越来越强烈，很多复杂的交互效果需要在代码中编写，这种情况下 xib 能提供的帮助越来越有限。 但是 xib 提供的 “所见即所得” 这种优势还是巨大的，如果我们是手写界面，那么调试起来是非常痛苦的。在这一里，我给大家推荐购买 Reveal 这个界面调试工具，Reveal 可以在 App 运行时动态地修改界面元素的参数，这样我们就可以一次性在代码中把界面元素的字体、颜色、位置这些参数在 Reveal 调试好，避免多次重启运行来调试界面。我在我的 《iOS 开发进阶》 书里，也花了一整章来介绍 Reveal 的使用。如下是书中的一个 Reveal 运行时截图： 总结其实，你完全不需要做一个 “艰难的决定”，你可以像 QQ 和微信那样，根据具体情况来选择性的使用 xib 和 storyboard。这里有我的一些建议： 对于复杂的、动态生成的界面，建议使用手工编写界面。 对于需要统一风格的按钮或UI控件，建议使用手工用代码来构造。方便之后的修改和复用。 对于需要有继承或组合关系的 UIView 类或 UIViewController 类，建议用代码手工编写界面。 对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。 对于很多新手来说，他们接触到的都是使用 Interface Builder 来构造界面。希望本文让大家了解到 xib 和 storyboard 在开发中的争议，手写界面并不是一个小众的行为并且有很多好处，希望每一个人都能掌握它，并且在需要的时候根据具体情况来决定是否采用。 愿大家玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"iOS 开发中的争议（一）","slug":"ios-dev-controversy-1","date":"2015-03-15T12:53:41.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/03/15/ios-dev-controversy-1/","permalink":"https://blog.devtang.com/2015/03/15/ios-dev-controversy-1/","excerpt":"","text":"序言打算分享一些有争议的话题，并且表达一下我的看法。这是该系列的第一篇，我想讨论的是：类的成员变量应该如何定义？ 在 Objective-C 的语言的早期，类的私有成员变量是只能定义在 .h 的头文件里面的。像如下这样： @interface ViewController : UIViewController &#123; @private NSInteger _value;&#125; 之后，苹果改进了 Objective-C，允许在 .m 里面添加一个特殊的匿名 Category，即没有名字的 Category，来实现增加类的成员变量。像如下这样： @interface ViewController ()@property (nonatomic) NSInteger value;@end 这样的好处是，这些变量在头文件中被彻底隐藏起来了，不用暴露给使用者。 接着，在 2013 年的 WWDC 中，苹果进一步改进了 Objective-C，允许在 .m 的@implementation 中直接添加类的私有成员变量。像如下这样： @implementation ViewController &#123; NSInteger _value;&#125; 于是，大家对于如何定义私有的成员变量上就产生的分歧。许多人喜欢用匿名的 Category 的方式来定义私有成员变量。但是，我个人更推荐在 @implementation 中直接添加类的私有成员变量。下面我做一些解释。 历史原因首先早期的 iOS 程序员一定知道，在 2011 年 ARC 被推出之前，Objective-C 是需要手工地管理引用计数的。而对类的所有私有成员使用 self.property 的形式，就可以使编译器为我们自动生成管理引用计数的代码。在 2012 年前，这个 feature 还需要使用 @synthesize 关键字来启用的。于是，苹果通过在代码规范中推荐和强调使用 self.property 的编程习惯，来让大家避免在内存管理中遇到问题。而在 ARC 时代，这个编程习惯带来的优势不再存在了，因为编译器会自动为我们管理引用计数，我们只需要关心不要造成循环引用问题就行了。 省心省事刚刚说到，在类中完全使用 _property 的方式来访问私有成员变量，是不会有内存管理上的问题的。但是使用 self.property 的方式来访问私有变量是不是也是一样不会有内存管理上的问题呢？确实也是，但是有一点需要注意：我们最好不要在 init 和 dealloc 中使用 self.property 的方式来访问成员变量，这一点是写在苹果的官方文档里的，我在以前的文章里也介绍过。(见：《不要在init和dealloc函数中使用accessor》） 所以，如果你用 self.property 来访问私有成员变量。那么你需要注意，在 init 和 dealloc 中不使用这种方式。这其实对程序员来说是一个负担，你需要不停提醒自己有没有犯错。如果你使用完全的 _property 的方式来访问私有成员变量，就不用想这一类问题了。 关于隐藏大家知道，self.property 其实是调用了类的 [self property] 方法，所以这其实是有一层方法调用的隐藏，很多时候，我们需要延迟初使化一个类成员的时候，就会把这个成员的初使化方法写在这个 [self property] 方法的实现中。 那么问题来了，当你在阅读别人代码时，看到 self.property 的时候，你会想：这里会不会有一些隐藏的函数实现？于是你需要跳转到其方法实现中去查找。但是在实际开发中，大部分的 property 其实是使用编译器自动生成的 Getter 和 Setter 方法，于是你会找不到实现，这个时候，你才知道：“哦，原来这段代码并没有做自定义的成员初使化工作”。 这种默认的隐藏在代码中多了，会影响代码的阅读和维护。其实大部分的类成员变量都需要在类初使化方法中赋值，大部分的 UIViewController 的成员变量，都需要在 viewDidLoad 方法中赋值。那既然这样，不如直接在相应的方法中用一个名为 setupProperty 方法直接进行初使化。这样的好处是，代码的可读性更好了，self.property 只有需要延迟初使化的情况下才被使用。 关于这个还有一个小故事，我之前 Review 过一个同事的 iOS 端代码，那个同事喜欢把 table view 的数据另外封装成一个类，而我觉得这些数据其实就是一个数组，没必要进行这一层封装，最终我们争论了比较久。我的观点是，一切隐藏都是对代码复杂性的增加，除非它带来了好处，例如达到了代码复用，提高了代码的可维护性等，否则，没有好处的封装只会给代码阅读理解带来成本。就我现在的经历中，大部分的 table view 的数据都可以放在一个数组中，没必要把这个数组封装起来，另外提供一套操作这个数组数据的方法。 简短的代码更易读_property 的写法比 self.property 更短，也更简单。我认为这样写出来的代码更方便阅读。 执行速度更快，IPA体积更小我之前从来没想到过这两者之间的速度和应用体积会有很大差别。不过一个同行（来自国外著名的社交网络公司）告诉我，他们公司发现二者还是有不小的差距，如果你们的应用需要做一些深度优化，可以考虑一下把 self.property 换成 _property。但我觉得，大部分应用都应该是不需要做这种深度优化的。 KVO 和 KVC是的，如果用 _property 这种写法，就不能使用 KVO 和 KVC 了。但是我得反问一下，在一个类的内部，KVO 自己的私有成员变量算是一个好设计吗？我们讲类要”高内聚，低耦合”，KVO 是为了实现观察者模式，让对象之间相互解耦的。如果把 KVO 用在类的内部，KVO 自己的私有成员，我认为其实这不是一个很好的设计。 Computed Properties在 Swift 中，引入了 Computed Properties 的概念，其实这在 Objective-C 中也有，只是没有专门给它名字。如果一个 property 我们提供了对应的 setter 和 getter，并且没有直接使用其对应的 _property 变量，那么这个 property 就是所谓的 Computed Properties。 是的，在类的内部如果直接使用 _property 形式，也无法使用 Computed Properties 了，但我认为这影响不大。其实 Computed Properties 也就是一层对数据存取的封装，我们另外实现两个函数，分别对应数据的 setter 和 getter 功能，就可以达到同样的效果。 循环引用问题微博上的@王_晓磊在评论中提到：直接用私有变量有个需要特别注意的地方，在 block 里直接写 _property 相当于 self-&gt;_property，虽然没写 self，但是暗含了对 self 的retain，容易造成循环引用。要记得用 weakSelf&#x2F;strongSelf 大法。 这一点确实是被很多人忽视的，所以我也一并写在这里，感谢他的补充。 写在最后其实我上面提到的这些问题都是小问题，影响不大。但是代码风格的统一却是大问题。所以不管你们项目中使用的是 self.property 风格还是 _property 风格，问题都不大，但是如果你们同时使用这两种风格，那么就非常不好了。 希望我的这篇文章能让大家了解到在这方面的争论，也希望大家能够在这一点上，在公司内部达成统一。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"流行的方法论 - 读《引爆点》","slug":"tipping-point","date":"2015-03-01T07:32:15.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/03/01/tipping-point/","permalink":"https://blog.devtang.com/2015/03/01/tipping-point/","excerpt":"","text":"春节的时候看到了萧宸宇的博客中一篇名为 《读书笔记 「引爆点」》 的文章。受文章的吸引，于是把 《引爆点》 这本书学习了一下。 《引爆点》的作者格拉德威尔在书中主要讲解了他对于 “流行现象” 的理解。这里面的流行现象可以是指一种感冒流感病毒的传播，也可能指一个军事情报消息的传播，也可能指一种身着打扮的方式，也可能是一种电视节目，甚至是一个地区的犯罪行为。 格拉德威尔的流行理论认为，造成流行现象涉及三个必不可少的因素： 第一法则是个别人物法则，讲影响信息传播的关键人物角色：内行，联系员，推销员。 第二法则是附着力因素法则，这条法则讲的是流行物本身所应具备的要素，它应该具备能让人过目不忘或者留下深刻印象的附着力，比如 iPod 漂亮的外形和一般随身听无法比拟的容量。 第三法则是环境威力法则，意思就是发起流行的环境极端重要。注意：不是重要或者很重要，而是极端重要，甚至一个微小外部环境的变化，就能决定流行或者不流行。 我在读完全书后，按我自己的理解，把这三条法则分为：内部因素、可控因素和不可控因素。 内部因素内部因素就是 《引爆点》 书中指的附着力因素法则。附着力因素法则要求流行事物本身要有趣、有用、能解决用户痛点、让用户产生情感共鸣等要素。 从互联网产品的流行来打比方，内部因素简单来说就是你的产品要好用，这个是流行的基础，任何脱离用户实际需求，不好用的产品，简单靠营销是不管用的。这一点我在读了《史玉柱自述：我的营销心得》我有了更深的体会，我一直以为脑白金是靠地毯式轰炸的广告来成功的，其实不是的，脑白金首先做到的是产品有效（改善睡眠），然后再靠有效的营销手段来成功的。 可控因素可控因素就是《引爆点》书中指的个别人物法则。该法则强调了信息传播的关键节点，如果你的信息传播是那些关键节点的人发起的，则很容易造成流行，否则就很难。 书中举出的 六度理论 的例子，证明大部分的传递都是由那些极少数的明星人物完成的。书中把信息传递的关键人员分成内行，联系员，推销员，分别讲解了这些成员的特点。 于是，问题就转化成如何找到这类关键人员。小米联合创始人黎万强在他写的《参与感：小米口碑营销内部手册》中介绍道，小米最开始在硬件发烧友论坛中找到了 100 位核心用户，邀请这些手机发烧友来参与小米手机的体验和讨论。这就是一次成功的找内行的营销方式。 书中介绍的雷克萨斯轿车在美国刚刚开始销售豪华车时，因为汽车问题需要召回。但是因为雷克萨斯这个品牌当时很新，试用的用户都是汽车内行，于是雷克萨斯选择做了一次极致体验的召回行为，具体包括：给每一个用户打电话，把车加满油，上门处理等。一场本会成为灾难的汽车质量问题却为公司赢得了客户服务的美誉。 具体到 iOS 这个圈子，也有人发现了我其实在 iOS 这个圈子内扮演 “内行”（多年开发经验）+ “推销员”（坚持写博客）的角色。于是找我帮他们转发微博，或者购买博客的广告位。这里顺便感谢我的广告主：蒲公英和 upyun云。 不可控因素我认为环境威力法则属于不可控因素。当然，可能不太严格，但相对来说是，当然，书中也讲了很多通过控制环境变量来改变流行的例子。但是，更多的时候，我们是借环境的天时地利来做事情，而不是逆天而为。雷军讲做 “站在风口上，猪都能飞起来” 也是讲的这个道理。 对于创业来说，其实非常关键的就是把握行业发展的趋势，在别人都没有关注的时候，抢先占领市场，利用时间窗口的优势来建立商业壁垒，这样才能成功。所以我很佩服我们的 CEO 李勇在在线教育完全没有流行的 3 年前，选择创业做在线教育，而今年众多的在线教育项目启动的时候，我们的产品猿题库已经充分利用时间窗口占领了超过 1000 万学生用户，让任何竞争对手都不敢做直接竞争，只能做差异化竞争。 当然，在产品细节、具体营销方式上，利用环境威力法则，在细节上结合热点事件，Duang 一下，这种小的适应环境威力法则的行为还是有用的。 总结看完这本书让我想起了一个叫 “瘟疫公司“ 的iOS平台游戏，在该游戏中，玩家的目标是通过各种方式来改造细菌或病毒，最终让它感染并且杀死所有人。最终玩过几次后，玩家都懂得了成功的要素，对于此： 游戏刚开始时，选一个好的病毒传播点就是利用个别人物法则。 在游戏中，我们不停地进化病毒的各方面的能力，这就是利用附着力因素法则。 在游戏开始，我们要将精力放在传播上，而在游戏后期，我们要将精力放到病毒的毒性上。这样的安排，就是利用了环境威力法则。当然，根据游戏中的随机事件，灵活地调整游戏策略也是利用了环境威力法则。 这是一本好书，可以更加系统地理解流行的产生，以及学会利用流行的法则来做一些决策，推荐大家都看看～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"}]},{"title":"谈谈 React Native","slug":"talk-about-react-native","date":"2015-02-01T08:27:43.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/02/01/talk-about-react-native/","permalink":"https://blog.devtang.com/2015/02/01/talk-about-react-native/","excerpt":"","text":"前言几天前，Facebook 在 React.js Conf 2015 大会上推出了 React Native（视频链接）。我发了一条微博(地址），结果引来了 100 多次转发。为什么 React Native 会引来如此多的关注呢？我在这里谈谈我对 React Native 的理解。 一个新框架的出现总是为了解决现有的一些问题，那么对于现在的移动开发者来说，到底有哪些问题 React Native 能涉及呢？ 人才稀缺的问题首先的问题是：移动开发人才的稀缺。看看那些培训班出来的人吧，经过 3 个月的培训就可以拿到 8K 甚至上万的工作。在北京稍微有点工作经验的 iOS 开发，就要求 2 万一个月的工资。这说明当前移动互联网和创业的火热，已经让业界没有足够的开发人才了，所以大家都用涨工资来抢人才。而由于跨平台的框架（例如 PhoneGap，RubyMotion）都还是不太靠谱，所以对于稍微大一些的公司，都会选择针对 iOS 和 Android 平台分别做不同的定制开发。而 JavaScript 显然是一个群众基础更广的语言，这将使得相关人才更容易获得，同时由于后面提到的代码复用问题得到解决，也能节省一部分开发人员。 代码复用的问题React Native 虽然强调自己不是 “Write once, run anywhere” 的框架，但是它至少能像 Google 的 j2objc 那样，在 Model 层实现复用。那些底层的、与界面无关的逻辑，相信 React Native 也可以实现复用。这样，虽然 UI 层的工作还是需要做 iOS 和 Android 两个平台，但如果抽象得好，Logic 和 Model 层的复用不但可以让代码复用，更可能实现底层的逻辑的单元测试。这样移动端的代码质量将更加可靠。 其实 React Native 宣传的 “Learning once, write anywhere” 本身也是一种复用的思想。大家厌烦了各种各样的编程语言，如果有一种语言真的能够统一移动开发领域，对于所有人都是好事。 UI 排版的问题我自己一直不喜欢苹果新推出的 AutoLayout 那套解决方案，其实 HTML 和 CSS 在界面布局和呈现上深耕多年，Android 也是借鉴的 HTML 的那套方案，苹果完全可以也走这套方案的。但是苹果选择发明了一个 Constraint 的东西来实现排版。在企业的开发中，其实大家很少使用 Xib 的，而手写 Constraint 其实是非常痛苦的。所以出现了 Masonry 一类的开源框架来解决这类同行的痛苦。 我一直在寻找使用类似 HTML + CSS 的排版，但是使用原生控件渲染的框架。其实之前 BeeFramework 就做了这方面的事情。所以我还专门代表 InfoQ 对他进行过采访。BeeFramework 虽然开源多年，而且有 2000 多的 star 数，但是受限于它自身的影响力以及框架的复杂性，一直没有很大的成功。至少我不知道有什么大的公司采用。 这次 Facebook 的 React Native 做的事情相比 BeeFramework 更加激进。它不但采用了类似 HTML + CSS 的排版，还把语言也换成了 JavaScript，这下子改变可以称作巨大了。但是 Facebook 有它作为全球互联网企业的光环，相信会有不少开发者跟进采用 React Native。 不过也说回来，Facebook 开源的也不一定都好，比如 three20 就被 Facebook 放弃了，但是不可否认 three20 作为一个框架，在那个时期的特定价值。所以 React Native 即使没有成功，它也将人们关注的焦点放在了移动开发的效率上了。很可能会有越来越多相关的框架因此涌现出来。 MVVMMVVM 在 Web 开发领域相当火热，而 iOS 领域的 ReactiveCocoa 虽然很火，但是还是非常小众。纠其原因，一方面是 ReactiveCocoa 带来的编程习惯上的改变实在太大，ReactiveCocoa 和 MVVM 的学习成本还是很高。另一方面是 ReactiveCocoa 在代码可读性、可维护性和协作上不太友好。 而 Web 开发领域对 MVVM 编程模式的接受程度就大不相同了，在 Web 开发中有相当多的被广泛使用的 MVVM 的框架，例如 AngularJS。相信 React Native 会推动 MVVM 应用在移动端的开发。 动态更新终于说到最 “鸡冻人心” 的部分了。你受够了每次发新版本都要审核一个星期吗？苹果的审核团队在效率上的低下，使得我们这一群狠不得每天迭代更新一版的敏捷开发团队被迫每 2 周或 1 个月更新一次版本。很多团队上一个版本还没审核结束，下一个版本就做好了。 React Native 的语言是基于 JavaScript，这必然会使得代码可以从服务器端动态更新成为可能。到时候，每天更新不再是梦想。当然，代码的安全性将更一步受到挑战，如何有效保护核心代码的安全将是一个难题。 总结不管怎么样，这确确实实是一个移动互联网的时代，我相信随着几年的发展，移动互联网的开发生态也会积累出越来越多宝贵的框架，以支撑出更加伟大的 App 出现。作为一个移动开发者，我很高兴能够成为这个时代的主角，用移动开发技术改变人们的生活。 愿大家珍惜这样的机会，玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"写iOS SDK注意事项","slug":"write-sdk-tips","date":"2015-01-31T13:44:33.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/01/31/write-sdk-tips/","permalink":"https://blog.devtang.com/2015/01/31/write-sdk-tips/","excerpt":"","text":"我发现即使是像腾讯、小米这样的大厂提供的 SDK，在质量和规范上也有很多问题，而且包括我以及我身边的很多朋友都被恶心到了，所以我就把这些注意事项总结出来，希望大家不要犯同样的错误。 注意事项一：所有类名都应该加前缀说明：没有前缀的类名有冲突的风险。 Bad Case：微信分享的 SDK，文件名：WXApiObject.h，代码如下，其中BaseReq类和BaseResp类都没有加前缀。 @interface BaseReq : NSObject/** 请求类型 */@property (nonatomic, assign) int type;/** 由用户微信号和 AppID 组成的唯一标识，发送请求时第三方程序必须填写，用于校验微信用户是否换号登录 */@property (nonatomic, retain) NSString* openID;@end#pragma mark - BaseResp/*! @brief 该类为微信终端 SDK 所有响应类的基类 * */@interface BaseResp : NSObject/** 错误码 */@property (nonatomic, assign) int errCode;/** 错误提示字符串 */@property (nonatomic, retain) NSString *errStr;/** 响应类型 */@property (nonatomic, assign) int type;@end 注意事项二：所有 category 方法加前缀说明：category 方法如果不加前缀，有冲突的风险。 Bad Case：腾讯分享的 SDK，它为 NSArray 增加了一个 JSONArray 的 category，造成我们本身的同名 category 被覆盖。另外他们为 NSArray 增加的其它 category 和著名的 Cordova 开源库冲突，造成 Cordova 无法使用。 注意事项三：不要将第三方库打包进 SDK说明：尽量不要将第三方库打包进 SDK，如果要打包，最好也要将该第三方库重命名，以避免冲突。 Bad Case：小米的推送 SDK，直接在 SDK 静态库里面编进去一个第三方依赖库，而且这个库还是 ASIHttpRequest。ASIHttp 当前已经处于无人维护状态，很多 Bug 都是大家自己在修复（例如网易就自己维护了一个 ASIHttpRequest 的分支）。在 SDK 中依赖这种库还是比较麻烦的。 注意事项四：做基本的检查和测试说明：SDK 对外公布前应该进行基本的编译检查，不应该有编译器警告存在。 Bad Case：腾讯分享的 SDK。它的 CGIParamsWrap.o 和 TencentOAuth.o 文件里面的方法名冲突了，如下所示： ld: warning: instance method ‘deleteAPIRequestBySeq:’ in category from &#x2F;Users&#x2F;tangqiao&#x2F;work&#x2F;iphone&#x2F;solar-ios&#x2F;lib_common&#x2F;TencentOpenApi&#x2F;TencentOpenAPI.framework&#x2F;TencentOpenAPI(CGIParamsWrap.o) overrides method from class in &#x2F;Users&#x2F;tangqiao&#x2F;work&#x2F;iphone&#x2F;solar-ios&#x2F;lib_common&#x2F;TencentOpenApi&#x2F;TencentOpenAPI.framework&#x2F;TencentOpenAPI(TencentOAuth.o) 注意事项五：文档完整并且正确说明：这就不用解释了吧？ Bad Case: 微信官方的微信支付的示例代码，里面有各种错误，代码都无法编译成功。如下所示的是其中一个错误： 于是还有人专门帮微信另外制作了一个非官方的说明文档，地址在这里：https://github.com/gbammc/WechatPayDemo 注意事项六：支持最新的 CPU 版本说明：去年苹果的一次 Bug，造成上传应用必须支持 arm64 的 CPU 版本，结果众多应用因为依赖的 SDK 不支持 arm64 而无法更新。当然，这次 Bug 出来之后，各 SDK 厂商都紧急做了更新。但是我觉得这种事情如果要做得专业，就应该一开始就紧跟技术更新，及时更新，而不是被迫更新。 总结以上 6 点是我认为写一个 SDK 的最最基本的要求，希望被点名批评的同学能尽快改正哟～ 如果大家在使用其它 SDK 时也发现了类似的问题，欢迎在文章下面留言。希望通过这种方式给开发相关 SDK 的同学一些压力，让他们好好改一下。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"使用蒲公英来做iOS测试应用的分发","slug":"pgy-usage-guide","date":"2015-01-22T11:16:06.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/01/22/pgy-usage-guide/","permalink":"https://blog.devtang.com/2015/01/22/pgy-usage-guide/","excerpt":"","text":"前言我在 《给 iOS 工程增加 Daily Build》 一文中介绍过如何用命令行生成 IPA 文件以及通过 itms-services 协议 来让用户可以直接在网页上安装测试应用。但是这种方法虽然有效，但是还是比较麻烦，因为： 开发者需要自己写相关的 Build 脚本。 开发者需要自己搭建好应用下载的服务器。 如果要做得更友好，开发者还需要部署 CDN 服务、增加扫描二维码下载等功能。 所以本文给大家推荐一个叫 “蒲公英” 的免费服务，帮助开发者能够方便地来做 iOS 应用的测试分发工作。蒲公英于 2014 年 7 月正式上线，我自己使用过一段时间，还是挺满意的。 下面我们就来看看，如何使用 “蒲公英” 来进行测试版本应用的分发工作。 生成 IPA 文件生成应用的 IPA 文件可以使用命令行 xcodebuild exportArchive -exportFormat ipa来完成，也可以使用 Xcode 提供的相应功能。相信大部分同学应该都用过，我就简单介绍一下。 首先将编译的目标机器设置成 “iOS Device”，然后点击”Product”-&gt;”Archive”，Archive 成功之后，就可以在 Xcode 的 Organizer 中看到相应的文件。 接下来点击 Organizer 中的 “Export” 按钮，如下图所示： 在接下来的弹出界面中选择 “Save for Ad Hoc Deployment”。如下图所示： 选择完成后点 Next，Xcode 会自动将测试设备的签名信息附加上，并将相应的 IPA 文件导出。 上传到蒲公英如果是第一次使用蒲公英，我们需要访问 蒲公英的网址 进行注册。注册主要是为了保护测试应用的安全和设置相应的权限（例如设置下载密码）。 注册之后，点击蒲公英网站首页的 “发布应用”，然后选择之前生成的 IPA 文件即可完成上传 IPA 的过程。蒲公英对上传速度进行了很大程度的优化，上传应用速度非常快，下图是我测试上传猿题库的过程（上传 18M 的 IPA 文件大概花了半分钟时间，平均速度应该超过了 500K 每秒）： 上传成功后，蒲公英会自动分析应用的 Bundle ID 信息，将其在 App Store 上的应用介绍和截图获取下来。然后你可以选择设置一个 “安装密码”，以避免一些越狱用户非法安装你的应用。对于小范围试用的应用，建议也不要将其发布到 “应用广场”。如下所示： 设置好所有需要的信息后，点击发布应用，蒲公英会生成一个应用分发的网页。如下图所示： 你可以把这个网页发给你的测试用户: 如果用户在手机上打开这个页面，则可以直接点击 “安装按钮” 来一键下载和安装测试应用。 如果用户在电脑上打开这个应用，则可以用扫描二维码的方式来一键下载和安装测试应用。 一些小技巧 有企业证书的同学，如果将 IPA 在本地用企业证书签名，则可以把蒲公英当作一个企业应用发布渠道，省去部署分发服务器的烦恼，但最好设置安装密码，以免被苹果认为滥用企业证书。 嫌每次打开蒲公英的网页太麻烦？蒲公英提供了 Mac 客户端，所有上传和设置操作都可以在客户端上直接进行。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"对《iOS开发进阶》一书的解释","slug":"explain-ios-pro-book","date":"2015-01-18T02:17:21.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/01/18/explain-ios-pro-book/","permalink":"https://blog.devtang.com/2015/01/18/explain-ios-pro-book/","excerpt":"","text":"《iOS开发进阶》虽然仅仅在互动出版社可以买到，还没有在京东和亚马逊上架，但是在 v2ex 上已经引起了一些讨论和误解，见 此贴。所以我想在这里，对本书的内容和定位做一些解释。 定位《iOS开发进阶》定位于帮助那些iOS开发刚刚入门的同行快速提高自己的水平，适用于至少有3个月以上iOS开发经验的读者。不适合没有任何iOS开发基础的读者阅读。对于iOS熟练开发者，本书也能补充其知识点的可能的盲区，使其相关知识体系更为完善。 我可能需要强调一下，对于iOS熟练开发者（工作时间大于1年），本书也只能做到补充其可能的盲区的作用。或者有一些比较牛的朋友，本书也可能补不了什么盲区。 我自认为其中 “CoreText排版引擎章节”以及第三章的底层原理部分是适合这部分iOS熟练开发者的。但不排除很多熟练开发者对底层原理已经很了解了，同时对CoreText不感兴趣。 所以希望iOS熟练开发者能够在买书前翻阅一下本书目录。 内容本书中的所有内容都是我的原创，但是有部分在博客上公开过，我自己数了一下，一共有9个章节在我的博客上可以看到完整的内容，另外11个章节在我的博客上只能看到部分内容或完全看不到内容。但是很有可能，随着图书的慢慢发售，我将其它未公开的电子版内容放到网上。 经常看我的博客的朋友，可能会有些失望或者觉得不值。所以希望大家在买书前翻阅一下本书目录，以避免买了后悔。 书名有人抱怨说《iOS开发进阶》这个书名太过于有欺骗性，应该叫《iOS开发备忘录》。对此我不太认同，《iOS开发进阶》很好地排除了那些iOS初学者，从书名上他们就会放弃看本书，而如果叫《iOS开发备忘录》就不一定了。另外，任何一个读者都应该看过目录再买书的吧？我不认为本书的书名会有那么大的欺骗性。 质量一些人批评本书的内容质量比国外的 objc.io 和 RW 的书差多了。对此我想说，您批评得对，我还需要努力！但是这不代表本书就没有价值吧？例如CoreText章节，我现在在国内外的图书中，仍然没有看到有谁把这个从浅入深讲完整的呀。第一部分对工具的介绍虽然技术含量低，但也没有谁完整整理过。与其自叹和国外有差距，不如自己实际来努力一下，改善一下国内的知识分享环境，不是更好么？ 最后 我写本书不指望能挣多少钱，实际上它也不能给我带来多少收入。但我真心希望这本书能够帮助到大家。现在看来，本书最合适的读者仍然是刚刚入门3个月的开发者。 请所有购买此书的朋友购买前先看目录：本书目录。一本书不可能适合所有水平的读者，请自己决定。 愿大家玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"我是如何完成《iOS开发进阶》的编写的？","slug":"how-to-finish-ios-pro-book","date":"2015-01-11T12:01:11.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/01/11/how-to-finish-ios-pro-book/","permalink":"https://blog.devtang.com/2015/01/11/how-to-finish-ios-pro-book/","excerpt":"","text":"前言《iOS 开发进阶》 终于出版了，在架构师峰会的签售会上，首批 100 本图书在签售的两天很快就卖光了，前几天首先在互动出版社上架的首批图书也在一天内卖缺货了，能得到读者这么热烈地支持，我还是很惊喜。技术人攻略 的创始人张兰说：“你应该写一篇总结”。我自己也想好好的整理一下这个出版的过程，给大家分享一下此书的写作过程。 ##选择出版社 去年年底，电子工业出版社博文视点的张春雨老师在微博上私信我，问我愿不愿意写一本 iOS 方面的技术书籍。其实在这之前已经有将近 5 个出版社的老师联系过我，但是我都因为创业太忙没有答应。后来有一次差点答应过的一个出版社老师，但因为她坚持要我提供 Word 版本的书稿以及一些沟通上的问题，我最终在签合同前终止了合作。 张老师是足够开明大度的，在写作时间和内容上给了我足够的自由度，前期几乎没有干涉过文稿内容和写作进度（不过后来发现其实是他比较忙，没空管我）。后期也仅仅是对文章表达可能有歧义的地方提建议。这种散养式的风格非常适合我，因为我从来就是一个比较自律，以及喜欢按自己节奏做事的人。 ##写作格式和工具 我之前在某个出版社老师的要求下，曾经也尝试在 Mac 下用 Word 写作。但由于 Mac 下 Word 的糟糕体验以及对代码糟糕的排版支持，那完全就是一段不堪回首的痛苦过程。 而张春雨老师鼓励我用任何喜欢的工具写作，这一点是我同意合作的很大原因。我的博客都是用 markdown 语法来完成的，所以我一开始就打算用 markdown 来写作。 在软件上，我一开始选择 Mou 来写作，但是发现 Mou 对于篇幅超过 1 万字的文章，预览渲染会非常卡，CPU 长期达到 100% 占用。我的最新款 Macbook Air 的风扇呼呼狂响，让我不得不终止了 Mou 的进程。 之后有一段时间我就用 Evernote 或 Sublime text 来写作，它们麻烦之处就是 Evernote 写完之后还需要把图片转成 markdown 的链接。而Sublime text 的问题就是无法方便地预览最后效果。 这一切的不便在我发现 gitbook 后被改变。gitbook 是一个专业的为 markdown 格式写作者提供的图书编写工具。它甚至集成了在线销售相关的功能。它也支持将书稿导出成 PDF、HTML 或 ePub 格式。 以下是 gitbook 的编辑界面（最左边是目录，中间是 markdown 源码，最右边是预览）： 我用 gitbook 完成了此书后半部分的编写。gitbook 有时候会出现两个中文字符在显示时重叠的问题，不过整体体验比 Mou 和 Evernote 要好多了。唯一的一次事故是 gitbook 对中文支持不太好，如果章节名不带中文的话，gitbook 会错误的地将章节覆盖到父级的图书目录，造成其他章节的内容被覆盖。我幸运的将书稿内容保存在了 Dropbox 目录下，所以恢复出来了。 ##配图和示例代码 对于写作中需要的示意图截图，简单的我就直接用 QQ 截图了，复杂的我使用的是 Clarify，它的标记功能比较丰富（不过中文支持比较差）。另外一些类图或架构图，我就直接使用 keynote 来做了。 考虑到技术书籍通常配图都比较少，所以我这次尝试，那时用比较多的配图来做辅助说明。另外我尽量把图书的涉及代码都放到网上，仅仅留一些关键的代码片段以节省篇幅。 ##如何安排时间和控制进度 由于有过写作的经验，所以我预先就估计好了这会是一个一年左右的工作。实际上它确实花了一年时间。 我希望把这个当做一个自己的 “创业项目” 来做，看自己能否执行好一个较长远的规划。我把图书编写拆分成每一个章节的写作工作，然后希望用 1~2 周完成一个章节。这样的好处是每周都可以看到明确的进展和产出。 我具体在做的时候是尝试用 Scrum 的方式来安排自己周末的时间。简单来说就是把书稿的内容进行拆分，然后对于细分到每一个章节的内容进行估分。接着我的每一个周末的目标就是把当周安排的章节写作完成。 当然，人都是需要休息的。所以周末两天我通常不会安排满。我会安排一整天用来写作，而另外一天做小量的修改和休息。如果有加班，就暂停写作。 虽然我没有跑过马拉松，但我感觉写作的体验和跑马拉松类似。前期的起跑和最后的冲刺都比较激动，但是中途长达一年的写作过程却是孤独，枯燥和寂寞的。这个时候，需要自己的坚持和自我鼓励。 ##关于电子版 该书我专门保留了电子版的版权，我本来希望把书放在多看上销售，主要是因为我个人就是多看的重度用户，而且我知道多看对电子书有加密保护。但是后来联系多看阅读时才发现他们已经不和个人作者合作了，他们建议我将版权授权给出版社。这让我感觉非常失望。多看阅读这种作法使得它无法颠覆传统出版社的渠道，另外如果竞争对手允许个人作者的话，多看阅读还可能失去不少优秀的图书的发行机会，进而影响它的电子书平台的地位。 在网上抱怨了此事以后，有一位朋友说可以协助我在豆瓣阅读发布此书。不过经过我试用之后，发现豆瓣的排版后台实在太难用，太花时间，所以我暂时放弃了发布电子版的事宜。 ##关于作品收入 技术书籍的写作通常都是不怎么挣钱的。那拿我的书来说，估计版税一共会有2万块钱。而写作此书大概花掉了我将近一年的周末时间。如果是要专门为了挣钱的话，可以有非常多其它的性价比更高的，更轻松的方式。 但是，如果可以重来，我还是会选择写这本书。传递知识的乐趣和成就感还是比挣钱更有意思一些。也希望有更多的一线开发者投入到写作分享的行列中。 ##一些小结 推荐用 markdown 格式配合 gitbook 写作。 推荐用 Scrum 的方式安排进度。 推荐用 Clarify 作配图标记。 书稿放在 Dropbox 下自动同步会非常安全。当然，你需要学会科学上网。 如果想在 Mac 下写作，那还是找一个不需要 Word 方式审稿的出版社吧，与我合作的电子工业出版社就是这样。博文视点的张春雨老师和刘芸老师(微信号:ly15201392806)都非常不错。 从交稿到出版至少也有 1 个月时间，做好心理准备，前期不要宣传太猛，我这回从签售会到网上能够买到，将近过了一个月。我由于不懂事，签售时宣传得太狠，结果弄得跟饥饿营销似的。 ##写作者的未来 未来互联网的发展会使得传播更加容易，所以我相信：好的内容会更容易获得读者，出版社和书商作为渠道的力量会越来越弱。到那个时候，或许写作真正的能成为很多人的职业，并给他们提供不菲的收入。 到那个时候，我希望我能够成为其中的一员，不但可以随意地选择工作时间和地点，还可以享受传递知识的乐趣和成就感，希望这一天能够早日到来。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"解读2014之iOS篇：拥抱变化","slug":"ios-2014-summary","date":"2015-01-07T13:22:15.000Z","updated":"2024-01-06T14:52:37.921Z","comments":true,"path":"2015/01/07/ios-2014-summary/","permalink":"https://blog.devtang.com/2015/01/07/ios-2014-summary/","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言对于 iOS 技术领域，2014 年是变化巨大的一年。在硬件上，由于苹果发布了更大尺寸的 iPhone 6 和 iPhone 6 plus，使得 iOS 设备的屏幕适配工作也多了起来。这还不包括全新的 Apple Watch 带来的开发上的变化。在软件上，Swift 语言的推出惊呆了整个业界，从 Objective-C 切换成另一个全新语言的代价是巨大的，但我们也看到了它长远的好处以及苹果对此的决心。除了软硬件外，编程语言、中国区、开发社区在 2014 年也有着巨大变化，我们试着用几个关键词来勾勒出 iOS 技术领域在 2014 年所经历的变化。 硬件苹果在 2014 年推出了 iPhone 6 和 iPhone 6 plus，iOS 设备也进入了大屏时代！虽然包括笔者在内的许多朋友都认为：“Plus 实在太大了”，但是从销售量看， iPhone 6 plus 在初期占据了 6 成 的销售量。我本人在实际使用 iPhone 6 plus 几周后，也很快适应了它的屏幕尺寸，现在反而不习惯使用了两年的 iPhone 4s 了。在开发上，iPhone 6 的推出使得 iOS 开发者也开始像 Android 开发者那样，为适配工作担忧。与 Android 开发者不同，iOS 开发在过去多年都是用 “绝对定位” 的方式来放置各种 UI 控件，使用 Autoresizing Mask 就可以轻松搞定 iPhone4 和 iPhone5 屏幕高度的差异问题。但现在不一样了，iOS 开发者需要学习使用 AutoLayout，通过各种 Constraint 来调整 UI 控件，但是很多界面是需要用代码来编写的，所以这方面的开发工作会比较辛苦，好在有 Masonry 这一类的开源库来辅助我们做界面开发工作。 iPhone 6 plus 引入的特有的 3x 的图片问题使 UI 设计师的工作量也大大的增加了。另外，以前由于 Android 设备其实太过于分裂，无法对每种屏幕分辨率都做到精致地设计，所以设计师大多只是用 “凑合用” 的思想来实施 Android 应用的适配。这一点从 Android 大屏手机上的应用呈现就能看出来。而现在同样的方式不太可能被严格的苹果以及挑剔的 iPhone 用户所接受，设计师很可能需要为 iPhone 6 plus 做专门的大屏设计，才能获得用户的芳心。 Apple Watch 的推出让适配工作真正地进入了 Hard 模式。优秀的开发者需要在工程中做好代码地复用，才能让底层的逻辑能够同样运行在 Apple Watch 中。不过这方面的工作还只是猜想，我们得等到 Apple Watch 真正面世的时候，才能真正了解到相关的开发工作有多么不同。 软件苹果在 2014 年的全球开发者大会（World Wide Developer Conference，简称 WWDC）上并没有发布任何新的硬件产品，但展示出其在软件上的各种功能改进和整合上的巨大努力。苹果推出了新的 OS X 10.10 操作系统 Yosemite，它吸收了从 iOS 7 开始的扁平化的设计风格，很多改进的细节都可以看到 iOS 系统对于 OS X 的影响。Yosemite 最吸引我的是 handoff 功能。handoff 功能将 Mac 电脑和 iPhone、iPad 的功能进行了深度整合，当你拥有这三个设备时，它们每一个都可以接打电话和收发短信，你在它们任何一个设备上编辑的文档，也可以实时同步到另一个设备上。handoff 并不是苹果的应用独有的功能，苹果将其相关的 API 都开放给了开发者，所以开发者也可以完全开发出支持 handoff 功能的应用。 相对于 Yosemite 带来的整合方面的改进，新版 iOS 8 的改进的重点则是开放。苹果开放了输入法接口，允许第三方提供输入法。苹果也开放了 Touch ID，允许第三方应用获得指纹信息。HomeKit 则为智能硬件开放了不少可以互操作的接口。另外，iOS 8 还新增了 4000 个新的 API，开放了大量底层 API 接口供应用调用。所以对于普通用户而言，iOS 8 新增的可见功能可能是有限的，但是其开放的大量 API 和新 SDK 释放出了巨大的想象空间，相信会产生更多有趣的应用。 对于一个硬件来说，相关的软件是非常重要的，但是苹果却将它的操作系统和 iWork 办公套件完全免费，这显示出苹果对于软件生态圈不同的理解。而微软至今最大的两大收入还是来自它的 Office 和 Windows 系列操作系统。在微软还在发愁他的新版 Wiindows 10 怎么卖出去时，苹果早已不玩这种 1.0 的商业模式游戏了。 Swift苹果的 Objective-C 语言发明于与 C++ 同时期的上世纪 80 年代初，虽然苹果对其进行了很多次改进，但这终究像给应用打补丁一样，不是特别舒服。这次 Swift 的推出，苹果试图用全新的编程语言来提高 OS X 和 iOS 程序员的开发效率。单从语言特性上来看，Swift 吸收了众多现代编程语言的优秀特性，例如类型推断（Type inference）、范型（Generic）、闭包（Closure）、命名空间（namespace），元组（tuple）等，整体语法上也更加简洁。我们也了解到 Swift 是苹果从 4 年前就开始筹划中的事情，可见苹果在长远规划上对于 Swift 语言的重视，相信未来 Swift 会接替更多 Objective-C 原本的地位，所有 iOS 开发者都应该花时间学习这门全新的语言。 苹果这次推出 Swift 也吸引了大量的讨论，其中比较不正确的观点是认为 iOS 开发的门槛因此而降低了。从我和身边的同行对 Swift 的学习和讨论来看，Swift 并不是一门可以简单上手的语言。并且在未来一到两年内，iOS 开发必然会经历同时使用 Objective-C 和 Swift 的过渡阶段。对于 iOS 开发者，除了必须掌握以前的 Objective-C 语言的知识，还需要学习并不简单的 Swift，可见 iOS 开发的门槛不但没有降低，反而提高了不少。 中国苹果是重视中国的，它在大中华区的销售贡献了约 15% 的全球营收。但是从某些方面看，苹果还是不够重视中国的。很多中国用户抱怨的问题，苹果都一直没有解决。我们来看看苹果对于中国区的用户和开发者，还有哪些需要改进的地方。 刚刚提到的 handoff 功能依赖于苹果的 iCloud，但是苹果的 iCloud 存取速度在中国却是非常糟糕的。笔者试图打开一个通过 iCloud 共享的约为 6M 的视频，但是等了 3 分钟才打开。与此同时，国内的各种网盘服务却能提供非常大的免费容量以及非常快的访问速度。 中国的垃圾短信和骚扰电话一直是非常严重的，而 iMessage 免费发送的特点给了垃圾短信发送提供了很好的平台。苹果到现在都没有推出相关的有效避免垃圾短信的办法，只提供了一个用于反馈垃圾短信的邮箱，整个反馈流程也非常繁琐，需要提供发送者邮件，内容，以及相关截图。笔者反馈了数 10 次之后，也没有得到过任何回应。对于骚扰电话，苹果只提供了事后将该电话号码加入黑名单的功能，这使得用户只能是接了骚扰电话后，才能做相应的手工处理。这些问题从技术上要解决没有任何难度，看看 Android 平台就可以看到这方面的问题被非常完美地解决了。但是苹果却不愿意做相关的努力，这只能说明它还不够重视中国用户。 苹果的 App Store 中国区也是比较混乱的，各种刷榜的应用充斥着排行榜的前几名。苹果在这方面应该是做了很多努力的，但是终究还是做得不够。从很多应用的评论中，我们都能看出刷榜的痕迹。由于这方面直接和收入相关，所以我相信苹果还是会尽力改进的。App Store 还有一个问题是支付不太方便，今年苹果和银联合作，不但推出 1 元的应用，而且允许用户使用银联卡来付费，极大地方便了用户购买应用。 社区、会议和第三方服务国外的 iOS 开发社区今年依然发展红火，比较引人注目的是 objc.io 。 objc.io 每一期的质量都非常高，所以由知名开发者王巍（onevcat）组织的翻译团队会将每一期文章都翻译成中文。国内的博客和社区发展相比国外还是比较慢，参与分享 iOS 技术的独立博客相比以往多了很多，但整体质量还有待提高。 移动开发也实实在在地成为了一个重要的技术领域，QCon 和 ArchSummit 每一届都会有专门的移动专题，可见这方面聚焦了开发者大量的关注。 2014 年国内外都涌现出了大量服务于移动开发者的第三方服务。这些第三方服务作为生态圈的一个重要组成部分，将会方便开发者聚焦核心功能，而不用担心基础设施的搭建。 展望展望 2015 年，笔者认为： 苹果的 iPhone 将会继续占据高端机市场，但千元左右的 Android 机将会占据其它所有的用户，最终 Android 的用户量将远远大于 iPhone 的用户量，但由于 iPhone 用户的优质属性（付费意愿高），所以各大应用将会在这两大平台都会投入足够的开发力量。如果有人能够比较好的解决代码在 iOS 和 Android 平台的复用性问题，将会很大程度上改变现在的开发模式。 Swift 语言将仍然处于发展阶段，Objective-C 依旧会是 iOS 程序开发的主要语言。更多的开发者将会使用混合开发的方式，同时使用 Objective-C 和 Swift 来开发应用。 国内 iOS 开发社区还会进一步发展，会出现更多的移动开发相关的开源基础设施或第三方服务。 苹果很可能会继续不那么重视中国区用户。iCloud 服务依然糟糕，iMessage 垃圾短信依然泛滥，由于害怕 “侵犯用户隐私 “，骚扰电话还是没有很好的解决办法。但苹果在大中华区的收入会继续增加。 由于 Objective-C 和 Swift 相比 Java 语言没有那么普及，Mac 电脑也没有 Windows 电脑普及，这造成 iOS 学习门槛较高。优秀的 iOS 开发者依然是稀缺资源，相比同等的 Android 开发者，iOS 开发者可以获得更多的收入。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"2014年个人总结","slug":"2014-summary","date":"2015-01-01T13:03:18.000Z","updated":"2024-01-06T14:52:37.920Z","comments":true,"path":"2015/01/01/2014-summary/","permalink":"https://blog.devtang.com/2015/01/01/2014-summary/","excerpt":"","text":"2014 年对于我来说是重要的一年，因为一方面我刚好年满 30 岁了，另一方面我的家庭生活和工作都经历了很大的变化。值得总结的包括： 通过分享，进一步提高了自己的技术影响力 创业进一步取得成绩 技术分享2014 年，我的技术分享包括： 在自己的博客上发布了 58 篇技术文章。 在 InfoQ 网站发表了 35 期 “iOS 开发周报”。 在《程序员》杂志和 CSDN 网站上发表文章 4 篇，分别是《从 Facebook 看移动开发的发展》、《iOS 应用安全开发概述》、《WWDC2014，苹果的 “软件” 发布会》、《那些好用的 iOS 开发工具》。 在 InfoQ 网站和《架构师》迷你书上发表文章 4 篇，分别是 《作为码农，我们为什么要写作》、《ReactiveCocoa - iOS 开发的新框架》、《深入理解 Tagged Pointer》、《专访《iOS 测试指南》作者羋峮》。 受朋友邀请，在深圳微信、人人网和豆瓣做了三场技术分享，分享的主题都是：《深入 Objective-C 对象模型》。 11 月 2 日在 CSDN 主办的 MDCC 移动开发者大会上做了一次分享，主题是：“猿题库的流量优化之路”。 12 月 20 日在 InfoQ 主办的 ArchSummit 北京上做了一次分享，主题是：“猿题库客户端的技术细节”。 完成了图书 《iOS 开发进阶》 的写作，100 本签售版很快卖光，不过正式出版得到 2015 年 1 月中旬。 开源了两个猿题库客户端的 iOS 基础库：YTKKeyValueStore 和 YTKNetwork，分别得到了 400 多和 700 多的 star。 微信公共帐号：iOSDevTips 发表了将近 100 篇推送，得到了 10000 多的粉丝。我的微博 @ 唐巧 _boy 分享了上百条技术内容，得到了 13000 多的粉丝。 年初的时候我还会怀疑自己的影响力，但现在已经习惯了成为 iOS 界的 “大 V” 了。微博上分享技术类信息转发常常超过 50 次，也会常常被人 @ 提醒来请教问题。 那我是如何树立起自己的技术影响力的呢？这其实主要是通过写博客的方式。我没有想到，从我 2010 年底开始学 iOS 开发，到现在短短 4 年时间，通过博客我能够获得这么大的影响力。现在我也看到越来越多的人加入到技术分享的行列中，用原创的技术博客给整个社区带来知识的分享，同时收获自己的成长和影响力。 关于创业我们今年顺利拿到了 C 轮 1500 万美元的融资，估值达到 1.25 亿美元。我自己的创业感悟就是觉得决策团队非常牛逼，另外大家的执行力都非常强。我今年除了做日常的 iOS 开发外，还承担了一些别的事情，包括： 指导了一位 iOS 开发零基础的实习生，现在他能够独立的进行开发，非常高兴看着他取得这么大的进步。 指导了一位实习生完成了 Latex 渲染引擎在移动端的移植（但其实主要是他的工作出色），这个工作使得我们的客户端在显示公式上和市面上所有同类应用相比具有决定性优势。 承担了校园招聘的组织工作，大家都被出面试题搞得焦头烂额的，不过最终我们还是搞定了，也收获了不少很有潜力的应届生。 开始负责小猿搜题这个项目，开始更多地思考产品方面的东西，更多的沟通工作，也开始为更多事情焦虑。 负责小猿搜题项目对我是一个新的挑战，之前我作为一个 iOS 程序员，基本上都只需要专注于技术层面上的实现。而现在我不但需要参与产品的讨论，也需要做更多的组织沟通工作。我们团队仍然保持着强大的执行力，小猿搜题从 7 月底立项到 9 月底上线只经历了短短 2 个月时间。而我们的评测数据显示，我们在搜索质量上毫不逊于竞争对手。但我们需要改进的事情还有很多，希望小猿搜题的用户量和活跃度能够超过猿题库，成为又一个拥有海量初高中生用户的产品。 读书今年为了更加深入的掌握 Swift 的函数式编程特性，学习了 Scala 语言以及 coursea 上的 Funtional Programming 相关的课程，不过仍然没有找到感觉。我感觉可能后面多写一些 Swift 程序才能有深入的理解。 今年也读了不少产品的书，包括《我的互联网方法论》、《思考的技术》、《失控》、《定位》等。 个人 Milestone 完成 《iOS 开发进阶》的写作 创业完成 C 轮融资，开始负责小猿搜题项目 有了宝宝","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"《iOS开发进阶》即将出版","slug":"about-ios-pro-book","date":"2014-12-07T11:05:52.000Z","updated":"2024-01-06T14:52:37.920Z","comments":true,"path":"2014/12/07/about-ios-pro-book/","permalink":"https://blog.devtang.com/2014/12/07/about-ios-pro-book/","excerpt":"","text":"关注我博客的人也许发现了，除了每周一期的InfoQ约稿的《iOS开发周报》，我已经很久没有写iOS方面的原创文章了。这主要的原因是：我把周末的时间都用来筹划一本iOS方面的书，这本书叫做《iOS开发进阶》。下面我就给大家介绍一下此书。 我的构思还记得几年前，我在学习iOS开发入门时，发现同行间的交流环境也比较差，自己提高的过程很慢。在出版物方面，我也一直苦于没有找到一本iOS开发进阶方面的图书。随着移动互联网的快速发展，移动开发的人才也慢慢增多，现在同行间的交流环境相比以前好了很多。但是在国内，仍然没有一本原创的iOS进阶方面的图书出现。因此，我萌生了写作的想法。 写作最开始首先是构思的过程，我回顾自己维护多年的iOS开发博客，从里面100多篇关于iOS开发的原创文章中，整理出来涉及iOS开发进阶提高的3个主要的方向：工具、实践、理论。 于是，我围绕着上述的三个方向，把以前的文章作为基础，再进一步完善相关内容，让各自零散的知识点能够衔接起来，成为一个完整的体系。整个写作的过程是痛并快乐着的，为了保证知识完整，最终书稿中有超过50%是新增加的内容。 从知识的难度上，工具、实践、理论这三大部分的难度逐步提高，以保证读者能慢慢适应。而三大部分内容其实各自独立，有经验的读者也可以按兴趣点或具体需求，跳跃性地阅读此书。 定位《iOS开发进阶》定位于帮助那些iOS开发刚刚入门的同行快速提高自己的水平，适用于至少有3个月以上iOS开发经验的读者。不适合没有任何iOS开发基础的读者阅读。 对于iOS熟练开发者，此书也能补充其知识点的可能的盲区，使其相关知识体系更为完善。 内容介绍《iOS开发进阶》分工具、实践、理论三大部分： 第一部分介绍iOS开发的常用工具 第二部分介绍iOS开发中的一些常见的实践经验 第三部分介绍iOS开发中涉及的原理。 如果把成为iOS开发高手比作武林小说中的高手修炼的话，工具、实践和理论的学习就分别对应兵器，招式和内功的修炼。此书希望通过这三方面的综合讲解，以全面提高开发者的技能水平。 好的工具可以使得开发效率成倍的增长。此书第一大部分介绍了iOS开发中的各种工具或服务，通过使用它们，可以极大地方便我们的日常开发和维护，提高开发效率。 一个入门之后的iOS开发者，需要的是更深入的实际开发经验的分享。此书第二部分选择了iOS开发几个常见的实际场景，进一步介绍各种iOS开发进阶的实战技巧。对于一些比较零散的知识技巧，作者也在实战小技巧集锦中进行了介绍。 如果把前两部分比作工具和招式的修炼的话，此书第三部分则是内功的修炼。在第三部分中，此书详细分析了iOS开发涉及的语言对象模型，从而能够帮助读者深入理解语言的各种特性和限制。 出版时间《iOS开发进阶》计划在本月下旬出版，定价65元。但是你也知道，图书一般都是会打折出售的，我估计在京东上应该能够以8折左右的价格购买到它。 一些评价我邀请了一些朋友审阅了《iOS开发进阶》初稿，他们的评价如下： OurCoders站长，资深iOS开发者 tinyfool: 2008年苹果发布第一代iOS SDK至今，已经有6个年头，整个移动开发的热潮也5、6年了，虽时有人说热潮将尽，但人才市场里iOS开发者仍旧非常短缺。特别短缺的是专业的优秀的iOS开发者，在各种工具无比先进的年代，一个优秀的开发者比十个一般的开发者都更有价值，也可以获得相应的回报。 我一直在说，每一个已经在行业里面的开发者，不应该满足于自己是一个可以干活的人，而应该有所追求，要变成行业的佼佼者，这不仅是因为我们都想有更高的收入，而且人本身就该有追求，特别是当你处在这个迅速变化，生机勃勃的行业中。 这本书的作者唐巧在我心中，本身就是我们这个行业中，非常优秀的开发者。但是更值得称赞的是，他提供了这么一本书，让我们也有机会变成更专业的，更优秀的开发者，善莫大焉。 objccn.io创始人、《Swifter》作者 王巍(onevcat)： 作为一本面向中高级 iOS 开发者的书籍，《iOS开发进阶》一书汇总了很多进阶级开发时所常用和必备的知识。阅读本书不但能帮你借助各类工具大幅提升开发效率，也能加深对 iOS 及 Objective-C 背后机制的理解。如果你想在 iOS 开发的道路上百尺竿头，更进一步的话，这本凝聚了作者多年开发实战经验的进阶级图书将是你不可错过的伙伴！ 微信iOS客户端团队负责人 lylechen 唐巧是国内较早从事iOS开发的资深工程师，并在个人博客、InfoQ、公众号等持续更新技术文章，我们也曾邀请他给微信iOS团队分享相关经验。目前市面上缺乏书籍对Objective-C高级特性、Xcode插件等做全面剖析和整理，《iOS开发进阶》很好地填充了此处的空白，相信对广大iOS开发者会有很好的帮助。 网易新闻客户端技术负责人 王聪(robaggio) 本人有幸曾和作者共事，当时他还负责微博后台研发。4年后唐巧转为iOS开发，并成为国内资深专家，主持研发的App也深受市场好评，作者的工作经历本身就是一次完美的『iOS开发进阶』。如果你刚刚提交了第一款AppStore应用，那本书的第一部分定会让你惊叹原来有这么多高效的工具可以帮你；如果你已有一两年iOS开发经验，那你一定会对本书第二部分的各种实战技巧相见恨晚；本书最后部分的底层原理是你成为资深工程师的必备课程。推荐给所有想『进阶』自己的开发者！ 另外，《MacTalk人生元编程》的作者池建强为本书写了非常精彩的推荐序，光是序言的标题《人生如长跑，成长如进阶》就让我觉得既富有哲理，“进阶”二字又和书名相呼应。但我决定暂不把序言放到网上，给读者一些神秘感。 一些感悟虽然已经有100多篇原创博文作为基础，但是整个写作过程我丝毫感受不到轻松。一方面是由于创业，自己的时间有限，写作断断续续。另一方面，由于自己在微博和微信上被不少同行关注，我自己也有很大的压力想把这本书写得尽量好一些。 最后我看着书稿，虽然觉得还可以写得更多一些，但是就像创业一样，任何事情都需要有一个阶段性成果。我相信当前的内容是足够“干货”的，我也能保证市面上没有第二本相似内容的图书，所以还是想尽快让读者看到这份作品。 希望本书能帮助大家进阶成为 iOS 大牛！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"开源一个Key-Value存储工具类","slug":"opensouce-a-key-value-storage-tool","date":"2014-10-03T14:06:18.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"2014/10/03/opensouce-a-key-value-storage-tool/","permalink":"https://blog.devtang.com/2014/10/03/opensouce-a-key-value-storage-tool/","excerpt":"","text":"前言还记得大学刚学数据库那会儿，天真地以为世界上所有的存储都需要用数据库来做。后来毕业后，正值NOSQL流行，那时我在网易参与了网易微博的开发，我们当时使用了有道自己做的“BigTable”— OMAP来存储微博数据，那个时候才发现，其实Key-Value这种简单的存储也能搞定微博这类不太简单的存储逻辑。 相比MYSQL，当数据量上千万后，NOSQL的优势体现出来了：对于海量数据，NOSQL在存取速度上没有任何影响，另外，天生的多备份和分布式，也说数据安全和扩容变得异常容易。 iOS端的尝试后来我从后台转做iOS端的开发，我就尝试了在iOS端直接使用Key-Value式的存储。经过在粉笔网、猿题库、小猿搜题三个客户端中的尝试后，我发现Key-Value式的存储不但完全能够满足大多数移动端开发的需求，而且非常适合移动端采用。主要原因是：移动端存储的数据量不会很大： 如果是单机的应用（例如效率工具Clear），用户自己一个人创建的数据最多也就上万条。 如果是有服务端的应用（例如网易新闻，微博），那移动端通常不会保存全量的数据，每次会从服务器上获取数据，本地只是做一些内容的缓存而已，所以也不会有很大的数据量。 如果数据量不大的话，那么在iOS端使用最简单直接的Key-Value存储就能带来开发上的效率优势。它能保证： Model层的代码编写简单，易于测试。 由于Value是JSON格式，所以在做Model字段更改时，易于扩展和兼容。 实现方案在存储引擎上，2年前我直接选择了Sqlite当做存储引擎，相当于每个数据库表只有Key，Value两个字段。后来，随着LevelDB的流行，业界也有一些应用采用了LevelDB来做iOS端的Key-Value存储引擎，例如开源的ViewFinder。 因为LevelDB本身并不是为移动端设计的，我担心它过于占用内存，我自己也没有看到业界有在移动端针对LevelDB做很详细的测试，连LevelDB的iOS端移植都不是官方做的。加上我自己写的基于Sqlite的Key-Value存储用着也没有什么问题，所以我也就一直没有更换成LevelDB。 开源经过两年的使用和测试，我认为它非常好用，而且代码也非常简单，只有不到400行。所以现在开源分享给大家，这个项目叫YTKKeyValueStore，项目代码在这里。 以下是一个简单的使用示例： YTKKeyValueStore *store = [[YTKKeyValueStore alloc] initDBWithName:@&quot;test.db&quot;];NSString *tableName = @&quot;user_table&quot;;[store createTableWithName:tableName];// 保存NSString *key = @&quot;1&quot;;NSDictionary *user = @&#123;@&quot;id&quot;: @1, @&quot;name&quot;: @&quot;tangqiao&quot;, @&quot;age&quot;: @30&#125;;[store putObject:user withId:key intoTable:tableName];// 查询NSDictionary *queryUser = [store getObjectById:key fromTable:tableName];NSLog(@&quot;query data result: %@&quot;, queryUser); 集成说明使用本项目，你需要将开源代码中的YTKKeyValueStore.h和YTKKeyValueStore.m添加到你的工程中，并且在工程设置的Link Binary With Libraries中，增加libsqlite3.dylib，如下图所示： 由于时间关系，当前还未提供Cocoapods方式集成。 使用说明所有的接口都封装在YTKKeyValueStore类中。以下是一些常用方法说明。 打开（或创建）数据库通过initDBWithName方法，即可在程序的Document目录打开指定的数据库文件。如果该文件不存在，则会创建一个新的数据库。 // 打开名为test.db的数据库，如果该文件不存在，则创新一个新的。YTKKeyValueStore *store = [[YTKKeyValueStore alloc] initDBWithName:@&quot;test.db&quot;]; 创建数据库表通过createTableWithName方法，我们可以在打开的数据库中创建表，如果表名已经存在，则会忽略该操作。如下所示： YTKKeyValueStore *store = [[YTKKeyValueStore alloc] initDBWithName:@&quot;test.db&quot;];NSString *tableName = @&quot;user_table&quot;;// 创建名为user_table的表，如果已存在，则忽略该操作[store createTableWithName:tableName]; 读写数据YTKKeyValueStore类提供key-value的存储接口，存入的所有数据需要提供key以及其对应的value，读取的时候需要提供key来获得相应的value。 YTKKeyValueStore类支持的value类型包括：NSString, NSNumber, NSDictionary和NSArray，为此提供了以下接口： - (void)putString:(NSString *)string withId:(NSString *)stringId intoTable:(NSString *)tableName;- (void)putNumber:(NSNumber *)number withId:(NSString *)numberId intoTable:(NSString *)tableName;- (void)putObject:(id)object withId:(NSString *)objectId intoTable:(NSString *)tableName; 与此对应，有以下value为NSString, NSNumber, NSDictionary和NSArray的读取接口： - (NSString *)getStringById:(NSString *)stringId fromTable:(NSString *)tableName;- (NSNumber *)getNumberById:(NSString *)numberId fromTable:(NSString *)tableName;- (id)getObjectById:(NSString *)objectId fromTable:(NSString *)tableName; 删除数据接口YTKKeyValueStore提供了以下接口用于删除数据。 // 清除数据表中所有数据- (void)clearTable:(NSString *)tableName;// 删除指定key的数据- (void)deleteObjectById:(NSString *)objectId fromTable:(NSString *)tableName;// 批量删除一组key数组的数据- (void)deleteObjectsByIdArray:(NSArray *)objectIdArray fromTable:(NSString *)tableName;// 批量删除所有带指定前缀的数据- (void)deleteObjectsByIdPrefix:(NSString *)objectIdPrefix fromTable:(NSString *)tableName; 更多接口YTKKeyValueStore还提供了以下接口来获取表示内部存储的key-value对象。 // 获得指定key的数据- (YTKKeyValueItem *)getYTKKeyValueItemById:(NSString *)objectId fromTable:(NSString *)tableName;// 获得所有数据- (NSArray *)getAllItemsFromTable:(NSString *)tableName; 由于YTKKeyValueItem类带有createdTime字段，可以获得该条数据的插入（或更新）时间，以便上层做复杂的处理（例如用来做缓存过期逻辑）。 其它两年前写过不少测试用例，后来给弄丢了，所以现在开项项目中还没有测试用例。由于时间关系，更详细的使用说明稍后会更新到项目中。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"写在创业两周年","slug":"startup-2nd-year-summary","date":"2014-10-01T14:06:20.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"2014/10/01/startup-2nd-year-summary/","permalink":"https://blog.devtang.com/2014/10/01/startup-2nd-year-summary/","excerpt":"","text":"一年前写了一篇名为 《写在创业一周年》 的文章，眼看创业已经两年多了，我就寻思着是不是再写一个创业两周年的总结。之所以拖了几个月，一是因为刚刚满两年的时候，我们公司刚刚拿下了 1500 万美元的 C 轮融资，但是还没有对外公开，所以不方便写。二是因为最近在忙 小猿搜题 这个新项目，顾不过来。现在正好国庆了，可以有时间好好思考总结下。 如果说创业第一年，我努力提高了自己的基本功：包括技术实力，沟通能力，执行力，情绪控制等。那么创业第二年，我的提高可能就是更多的思考了。为什么我们能够在短短两年时间就做到 1.25 亿美元的估值？我觉得核心的原因就是：正确的决策 + 强大的执行力。执行力在以前已经说过很多次了，这次想分享一下我们的决策。 创业两年，在我看来我们经历了两次重要的决策。 第一次重要决策是：放弃做粉笔网转而做猿题库。这其实可以拆成两件事情：一、放弃粉笔网，二、决定做猿题库。有些创业公司成功的关键是坚持，有些创业公司成功的关键是转型。在我看来这两者并不矛盾，其实关键是你想清楚了所有的事情。 放弃粉笔网是因为我们想清楚了这个模式是有问题的，所以我们并没有在这上面投入更多的市场推广费用，为团队节省了大量资金。这次试错，我们花的时间不到半年。不过也是因为运营粉笔网，我们发现了新的方向。我们的市场运营同事在邀请老师加入粉笔网时，发现了学生在手机上做题的需求，从而为团队找到了新的努力方向。 我们团队的特点就是执行力强，猿题库从计划到上线，我们只花了 3 个月。猿题库行测上线之后，收到了来自用户的良好反馈，这使得团队一下子确定了方向是正确的，大家的信心都恢复了。 第二次重要的决策是：切入 K12 市场。我们本来打算把所有职业类考试的客户端都做一遍。但是我们的 CEO 李勇觉得这个模式如果被竞争者抢先用来做 K12 市场后，我们会很难受。所以我们主动放弃了很多职业类考试类客户端的开发，转而做猿题库高考。 正因为这次决策，使得我们能够在短短半年时间，就积累起全中国超过 10% 的高考用户（每 9 个高考学生，就有一个用猿题库高考），随后的猿题库初高中整合版本也非常受学生欢迎，登上了 AppStore 教育榜首（我们没有刷榜）。也因为这次决策，才使得我们能够有 C 轮 1.25 亿美元这么高的估值。 虽然我没能参与这两次决策，但是我能感受到公司的管理层在创业上的深度思考，每一步都是经过仔细分析和推敲的。也因为这样，我们团队的大多数人就能够专心到事情的执行层面，把具体的事情做好。 另外，我们公司非常强调 “透明”，李勇会通过邮件或者周五全体会议的方式，将公司的想法传递给每一个人，大家能够知道每一个决策背后的原因，从而在做事情的时候有一个最根本的指导。李勇也多次强调大家有问题要说出来，通过沟通达到相互之间信息的透明。 未来，猿题库应该还会经历很多重要决策，例如怎样用移动互联网的特点获得更多用户，例如如何给用户提供更多增值服务，获得收入。在线教育这个创业方向，与移动互联网结合起来，到底能有多大的想像空间，还需要我们一步一步探索。 我很期待着与团队同事一起，为教育开辟一块新的市场，最终改变教育。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"适合码农工作时玩的游戏：Scrum","slug":"scrum-introduction","date":"2014-09-13T10:23:17.000Z","updated":"2024-01-06T14:52:37.919Z","comments":true,"path":"2014/09/13/scrum-introduction/","permalink":"https://blog.devtang.com/2014/09/13/scrum-introduction/","excerpt":"","text":"前言昨天遇到一个来自微软的面试者，在面试的最后，我简单介绍了一下我们团队使用一周一次的 Scrum 来做项目管理。他回答说：” 我在微软也用 Scrum，不过我们一周两次，时间在周二和周四上午，每次 15 分钟 “。我听了就笑了，我说：“同学，你说的这个应该是 Scrum 的站立会议，Scrum 实际上有 4 个会议，站立会议只是其中一个。另外，标准的站立会议应该每天一次，不是每周两次。” 接着我给他介绍了 Scrum 的 4 个会议，每个会议的意义是什么，他若有所思。 今天和同事吃饭说起这件事情，同事 pw 说：在他所了解到的使用 Scrum 的公司里面，我们应该是执行 Scrum 做得最规范的，同时我们从 Scrum 实践中，收获了非常多。 大约在 3 年前（当时我们团队还在网易），我们团队开始尝试用 Scrum 来进行软件开发的项目管理。在经过了 3 年的摸索和调整后，我们不但多次保证了项目的顺利上线，而且建立起了适合自己团队的工作方式。 正如 Scrum 官方指南所说，“Scrum 是易于理解，但难以精通的”，在此向大家分享我们实践的心得体会，希望更多的开发团队能够运用 Scrum 来流化自己的开发流程。 Scrum 是游戏规则在 Scrum 官方网站 上，提供了中文版本的 《Scrum 指南》，这份只有 14 页的文档的封面上，写下了其最核心原则：游戏规则。 什么是游戏规则？游戏规则是玩游戏的人为了更好地娱乐而制定的规则。所以 Scrum 的规则是为了让大家更开心，更有效地工作，而不是约束大家。事实上由于 Scrum 只是一个框架，所以在实践 Scrum 时，更多的规则需要团队成员共同制定，这更加体现了游戏规则的思想——大家自己制定的规则，必定是得到大家一致同意的、能让大家舒服工作的规则。 Scrum 是基于经验的Scrum 强调经验的重要性，但是经验又是需要不断调整的，所以 Scrum 通过迭代增量的开发方式，来每次调整整个团队的经验，从而来优化可预测性。 例如，我们在开发猿题库时，在每轮 Scrum 的结束时，我们会开回顾会议，将大家每天处理待办事项的速度（我们称做日均 Story Point）总结在 Wiki 中，如下图所示。这样当我们估计一个新一轮的迭代工作是否能够完成时，就可以参考前面几十次的经验，做出更加理性地判断。 Scrum 的三大支柱 透明性、检视、调整是 Scrum 的三大支柱。 透明性是指：团队成员要达到对信息的完全共享，以便对观察到的信息有相同的理解。 检视是指：团队成员要不停地检查自己的状态，类似汽车的定期检查一样，通过检视了解当前项目的状态。 调整是指：团队成员发现出现了会影响项目进度的事件后，要及时寻找对策。 以上的说法有些学术化，我们可以这样理解： 群体智商常常会出现低于个体智商的现象，这是因为个体之间的信息通常不一致，每个人的信息都是片面的，所以造成了观点的片面，而通常情况下团队领导由于接受到的信息更全面，所以他的决策考虑会更周到一些。 但是 Scrum 又强调团队需要是 “自组织” 的，这就需要群体进行决策而不是领导。为了群体更好的决策，所以 Scrum 特别强调信息的透明，这样大家的信息都是充分共享的，而检视是一种保证信息透明的方法，即定期地查看自己和团队的状态，有了信息的透明，这样团队成员就能共同发现项目执行中的问题，进而一起寻找解决办法，从而达到 “自组织” 的团队。 Scrum 的基础游戏规则Scrum 定义了基础的游戏规则，在基础的游戏规则之上，团队可以依据自己的经验，制定更细致的规则。但更细致的规则不应该违背基础的规则。这就像国家的宪法一样，其它法律不能与宪法违背。 那我们来看看 Scrum 有哪些基础的游戏规则。 角色定义 玩三国杀的同学都知道，玩之前大家会抽身份：主公、反賊、忠臣、内奸。而 Scrum 的游戏规则里面，有以下几种身份角色： 产品负责人：产品负责人是管理产品待办列表的唯一责任人，也是产品最终的责任人。（稍后我们在介绍计划会议时，解释什么是产品待办列表。）简单来说，最终如果产品没做好，应该扣产品负责人的工资。 开发团队：开发团队是负责将每轮 Scrum 迭代中计划的功能（可能是产品稿 + 美术稿的形式），交付成可发布的产品的各种专业人员。这里的各种专业人员包括：服务器端开发、Javascript 前端开发、客户端开发、测试人员等。开发团队是真正在玩这个 Scrum 游戏的人，其他人（例如产品负责人都只是部分参与）。 Scrum Master：Scrum Master 类似于杀人游戏中的法官，即游戏组织者。Scrum Master 并不是团队的领导，他仅仅是做一些组织工作，而对于一个 “自组织” 的团队来说，其实真正需要组织的事情也不太多，所以他常常由开发团队中的某一个人兼任。 没有子团队在 Scrum 的官方文档中，这样说道： Scrum 不认可开发团队中的所谓 “子团队”, 无论是测试还是业务分析的成员都不能划分为 “子团队”。此规则无一例外。 所以我们看到，Scrum 在定义角色的时候，强调开发团队中一个整体，包含把产品发布出来的所有相关的专业技术人员，并且开发团队共同承担开发的责任，只有这样，大家才能形成利益共同体，共同努力把产品做好。 这一点也解释了为什么很多大公司玩不好 Scrum。拿百度举例，百度的一个项目就有很多 “子团队”。在百度，前端开发人员属于前端组，移动端开发人员属于移动端组，测试有专门的 QA 组，PM 也有专门的组。这样的划分，进而造成大家的绩效评估并不是完全由项目执行的好坏来决定，而 PM 也需要花很大精力去推动大家，这样的团队没有共同的利益，是很难做到 “自组织” 的。 强调平等Scrum 中仅定义了 “开发团队” 这个整体的角色，在 “开发团队” 内部，大家都是平等的。因为只有这样，大家才能更加自由的共享信息，共同决策，否则决策权仍然掌握在少部分人手里。在 Scrum 的官方文档中，是这样说的： Scrum 不认可开发团队成员的头衔，无论承担哪种工作他们都叫做开发人员。此规则无一例外。 游戏人数规则开发团队还有一个不能不说的特点，就是他的规模必须足够小，因为他强调信息的透明，如果人数过大，光沟通的成本就大到无法承受了，所以官方文档上推荐的人数是 10 人以内（不包括产品负责人和 Scrum Master，除非他们也参与开发）。 但是在实际执行中，由于业务的增长，团队人数很容易就超过 10 人。比如我们猿题库在创业时只有不到 10 人，现在已经成长到几十人了。这个时候，比较好的做法是进行团队的切分，比如我们试过将猿题库的服务器端和客户端进行拆分，这样保证每个团队还是在 10 人以内。如果以后再增长，可能客户端会再进行拆分成 iOS 团队和 Android 团队。 游戏时间Scrum 对每一轮的迭代时间并没有严格的规定，但它要求是小于一个月。对于每一轮的迭代，Scrum 把它称作 Sprint（冲刺）。 作为创业公司，我们在最近两年都实践着一周一次 Sprint 的方式来工作。一周一次 Sprint 能够保证调整足够快，Sprint 执行中是不鼓励需求改动的。所以一周一次的 Sprint 能够做到，对于比较急迫的需求改动，在下次 Sprint 时（下周）就可以执行。 一周一次的 Sprint 也有不少问题，由于偏离本文主题，所以就不展开介绍了。现在我们的猿题库直播课项目组也在尝试进行 2 周一次的 Sprint。总之，Sprint 多长是由开发团队根据项目的具体特点来决定的，只要不超过一个月即可。 游戏玩法讲了半天，终于讲到核心了，到底怎么玩这个游戏啊！为了更好的理解，我们先看看杀人游戏的玩法，杀人游戏定义了如下几个事件： 天黑请闭眼，这个时候大家都闭上眼睛 杀手睁眼，杀手杀人，杀手闭眼 警察睁眼，警察检查，警察闭眼 天亮了，宣布谁死了，大家讨论并投票谁是杀手，投出的嫌疑人被杀死。如果警察或杀手死了，宣布游戏结束，否则跳到第 1 步。 刚好，Scrum 也定义了 4 个事件，分别是： 计划会议 每日站立会议 评审会议 回顾会议 以下我们来详细介绍一下这 4 个会议到底要具体怎么做。 计划会议计划会议主要通过讨论，完成两件事情：做什么、怎么做。 关于 “做什么”：产品负责人会给出一个产品待办列表，然后由团队成员来根据预计的工作量以及以往的表现，来挑选接下来的 Sprint 需要完成的待办项。这里的特点是：由开发团队成员自己来挑选待办项，而不是由传统意义上的 Tech Leader 或产品负责人来挑选。这样保证了开发任务是由团队成员自己决定的，他更有责任心把事情完成。同时作为产品负责人，有必要非常明确地告诉开发团队每一个待办项的意义和重要性，这样开发团队才能做出有利于产品的挑选工作。 关于 “怎么做”：开发团队从待办列表中挑选完需要完成的待办项之后，就需要对每个要做的待办项进行评估。评估的工作就是讨论具体怎么做，这包括技术架构、实现细节的讨论。只有讨论得非常清楚之后，这项工作的工作量才会比较清楚。 在讨论怎么做之后，一些敏捷公司推荐使用 “出牌” 的方式来评估工作量，我们也采用了这种方式，我们还专门做了一套 Scrum 扑克，用于出牌。如下图所示： 出牌的规则是每个人出一张牌，用牌上的数字表示当前工作的工作量。通常大家还会事先约定好数字 2 代表的工作量，以保证大家的标准相同。为了避免相互影响，大家先把要出的牌扣着，然后同时翻开。之后，出最高分的和出最低分的同学要表达意见，说明为什么自己估计成这样，大家讨论，这样的过程可以保证大家的信息都是透明的，即没有忽略掉的技术实现难度或细节，在信息充分共享的情况下，通常大家第二次出牌时就可以达成一致了。 每日站立会议每日站立会议是进行检视的方法。通常选择固定时间（我们是每天早上 10 点 10 分开），以养成团队工作习惯来避免组织成本。站立会议要尽量的短，通常控制在 15 分钟以内，选择站着开会，也是让大家有更大的预期快速结束。 站立会议主要是为了沟通，以及发现潜在可能的问题，在站立会议上，团队成员每个人要讲 3 句话： 我昨天做了什么 我今天打算做什么 我遇到了什么问题 通过这 3 句话来达到高效沟通的目的，对于会上提到的问题，通常是下来相关人员自行解决。 站立会议通常能够发现项目进展的状态是否顺利，从而尽早采取相应的措施。时间较长的 Sprint 可以配合燃尽图，更方便地审视项目进展速度。 评审会议Sprint 评审会议在 Sprint 结束时举行，用于检查计划中的工作，哪些完成了，哪些没有完成。在我们的实践中，我们会让开发的同事演示自己所做的功能，然后 PM 会看这个功能是否达到了要求。 回顾会议回顾会议是开发团队检视自己，发现团队运转中的问题，并且定制游戏规则的过程。通过对前一个 Sprint 中的人、关系、过程、工具进行检视，团队成员能够总结出做得好的，和做得不好的。进而制定一个改进的方案。 回顾会议是 Scrum 创建 “自组织” 团队的关键，它将团队自我改进变成了一个例行的会议，在这个会议中，讨论的都是大家对该游戏的感受，包括好的和不好的，最终大家为了玩得更爽，就会发扬好的，努力避免不好的，成为一个能够自我进化的集体。 需要注意的是，回顾会议不应该成为吐槽大会，大家应该本着发现问题，解决问题的态度来讨论。例如：如果在回顾会议仅仅是抱怨产品老是改需求，或者抱怨时间不够，而不提出解决方案的话，是非常不好的。 提出问题是容易的，麻烦的是提出解决方案。我们的老大郭常圳提出了一个办法，即我们思考：“如果再来一次，我们能不能做得更好”？如果我们发现，如果再来一次，由于客观原则，我们可能仍然无法避免同样的问题，那么我们就选择坦然接受而不是抱怨。 因为很多时候本来就没有完美的、没有任何问题的解决方案，这就像软件都有 Bug 一样，如果 Bug 不可避免，我们就选择发现的时候尽量修复而不是编码的时候避免。 框架图下图介绍了 Scrum 的整个框架： 一些问题有什么辅助 Scrum 的工具？我们使用的是 Redmine 的 Scrum 插件来开相关的 Scrum 会议。我们 Scrum 的回顾会议总结放在内部的 Wiki 上。也有团队喜欢直接用白板 + 便签来完成 Scrum 的相关会议。像 JIRA 一类的专业项目管理软件，也都支持 Scrum。 游戏超时怎么办？游戏超时通常就意味着游戏结束。在 Scrum 这个游戏中，团队成员不接受 Sprint 延期。所以不管有没有完成所有任务，评审会议和回顾会议都需要按时开，没有完成的任务需要进行仔细讨论，分析其原因到底是什么，从而在下一轮 Sprint 中尽量避免出现同样的问题。 开发团队自己挑任务，会不会造成项目进度很慢？通常情况下不会。如果我们真正把 Scrum 做好，大家能享受到 Scrum 带来的各种好处，例如团队每个人都能参与决策团队做事方式，每个人都能积极的追求效率，而一次次成功的 Scrum，带给大家的成就感也是巨大的。 好的 Scrum 执行还能保证团队不会随意加班，我们已经很久没有周末加班了，平时晚上大部分时间也都能做到按时下班，这对于互联网公司来说，几乎是不可想像的。 不加班只是一个附属品，最重要的是按时发布产品，我们创业 2 年多来从来没有延期发布过产品。这样使得我们的运营推广计划能够非常有序地执行。 需要强调的是，不加班并不是代表我们的工作轻松，通常情况下我们的 Scrum 安排还是比较紧张的，因为我们都想创业时跑得快一些。不加班也不是我们的原则，我们的原则是按时发布产品，所以当有一些特殊情况产生时，我们也会适当的加班。我们只是不把加班当作一个常态的工作方式，因为我们认为工作效率比工作时长更为重要。另一方面我们认为创业是长跑，保持良好的发布节奏已经非常好了，长期加班造成的身体懈怠可能会造成工作效率的损失。 Scrum 适合所有团队吗？首先 Scrum 是非常适合程序员的，因为程序员天生就不喜欢约束。Scrum 的 “自组织” 团队的思想很容易让程序员感觉到自己是团队的主人。另外 Scrum 是非常反会议的，4 个会议都严格地规定了时间长度，所以可以让程序员有充足的时间花在编码上。Scrum 也是比较反需求临时变更的，由于 Sprint 周期短（我们才一周），所以变更可以根据重要程度放到下一个 Sprint 中。 Scrum 非常强调团队作为一个整体来做事情，所以并没有刻意地去评估每个人具体的工作量。这需要团队每个人都比较自觉。当然，由于强调透明和检视，所以团队内如果有人懈怠的话，团队里其他人是很容易发现的。 所以，如果你的团队人数在 10 人左右，又能保证团队是一个整体为项目负责，那就有了尝试 Scrum 的基础。 为什么很多公司用不好 Scrum？Scrum 指南里面也提到，Scrum 是 “易于学习，难于精通的”。所以 Scrum 本来就比较难做好。我感觉到几个比较容易出现的问题是： 团队里面有人不信 Scrum 能比以前的软件开发方式更好。游戏规则使终是游戏规则，如果有人不想玩游戏的话，游戏玩起来就没有那么愉快了。真正想做好 Scrum 就得认真学习 Scrum 指南，然后努力遵守 Scrum 的规则。只有当大家都努力玩这个游戏时，才能享受游戏的乐趣。 随意更改 Scrum 的规则。例如我以前在有道的团队就把 Scrum 的每日站会改成了每周二，周四开一个坐会，开会的方式也变成产品经理询问进度，各个技术人员汇报的方式，会议一次要开半个多小时。这一下子就把每日站会做得变味了。 难以组建团队。之前说过像百度这类大公司，其公司文化不是一朝一夕形成的。Scrum 的工作方式要求大家都为项目完全负责，而很多传统公司按职能来划分团队，例如 PM 团队、客户端团队、前端团队等，这会影响 Scrum 的执行。 Scrum 是终极大招吗Scrum 不是银弹，它并不能解决所有问题，实际上，很多时候它根本不提供解决问题的方法。Scrum 本身只是一个框架，通过这个框架，我们更容易发现项目运行中的问题，通过定期的回顾会议来解决问题。 结束语本文旨在通过介绍 Scrum 的核心思想和基本框架，吸引大家了解 Scrum。要实践 Scrum，还是需要进一步的学习才行。欢迎大家详细阅读 《Scrum 指南》，然后尝试使用 Scrum 来让自己每天的工作变得轻松愉快。 PS：我们的公司猿题库创业两年，做在线教育方向，不久前顺利拿到了 1500 万美元的 C 轮融资。我们现在很缺人，也欢迎大家加入我们，和我们一起玩 Scrum 游戏，感兴趣的可以看：职位介绍。 愿大家玩得开心～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"iOS开发如何提高","slug":"ios-levelup-tips","date":"2014-07-27T09:17:30.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"2014/07/27/ios-levelup-tips/","permalink":"https://blog.devtang.com/2014/07/27/ios-levelup-tips/","excerpt":"","text":"许多人在博客和微信上咨询我 iOS 开发如何提高，经过一番思考之后，我能想到如下一些提高的办法，我个人也是通过这些方法来提高的。 阅读博客在现在这个碎片化阅读流行的年代，博客的风头早已被微博盖过。而我却坚持写作博客，并且大量地阅读同行的 iOS 开发博客。博客的文章长度通常在 3000 字左右，许多 iOS 开发知识都至少需要这样的篇幅才能完整地讲解清楚。并且博客相对于书籍来说，并没有较长的出版发行时间，所以阅读博客对于获取最新的 iOS 开发知识有着非常良好的效果。 我自己精心整理了国内 40 多位 iOS 开发博主的博客地址列表：https://github.com/tangqiaoboy/iOSBlogCN，希望大家都能培养起阅读博客的习惯。 国外也有很多优秀的 iOS 开发博客，他们整体质量比中文的博客更高，以下是一些推荐的博客地址列表： 博客名 博客地址 objc.io http://www.objc.io/ Ray Wenderlich http://www.raywenderlich.com iOS Developer Tips http://iosdevelopertips.com/ iOS Dev Weekly http://iosdevweekly.com/ NSHipster http://nshipster.com/ Bartosz Ciechanowski http://ciechanowski.me Big Nerd Ranch Blog http://blog.bignerdranch.com Nils Hayat http://nilsou.com/ 另外，使用博客 RSS 聚合工具（例如 Feedly：http://www.feedly.com/）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是 Newsify）。合理地使用这些工具也可以将你在地铁上、睡觉前等碎片时间充分利用上。 读书博客的内容通常只能详细讲解一个知识点，而书籍则能成体系地介绍整个知识树。相比国外，中国的书籍售价相当便宜，所以这其实是一个非常划算的提高的方式。建议大家每年至少坚持读完 1 本高质量的 iOS 开发书籍。 去年出版的 《iOS 7 Programming Pushing the Limits》 以及 《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》 都算是不错的进阶方面的读物。顺便打个广告，我自己也在写一本 iOS 进阶方面的图书，年底前应该能上市。 看 WWDC 视频由于 iOS 开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是 WWDC 的视频。 通常情况下，一个 iOS 开发的新知识首先会在 WWDC 上被苹果公开，然后 3 个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过 WWDC 的视频。 现在每年的 WWDC 视频都会在会议过程中逐步放出，重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的 iOS 开发知识，还可以提高英文听力水平。 看苹果的官方文档苹果的官方文档相当详尽，对于不熟悉的 API，阅读官方文档也是最直接有效地方式。 苹果的文档比较海量，适合选一些重点来阅读，比如人机交互指南就是必读的，而其它的内容可以遇到的时候作为重点资源来查阅。 看开源项目的代码大家一定有这样的感受，很多时候用文字讲解半天，还不如写几行代码来得直观。阅读优秀的开源项目代码，不但可以学习到 iOS 开发本身的基本知识，还能学习到设计模式等软件架构上的知识。 如果读者能够参与到开源项目的开发中，则能进一步提高自己的能力。 多写代码，多思考知识的积累离不开实践和总结，我认为 iOS 代码量如果没有超过 10 万行，是不能称得上熟悉 iOS 开发的。某些在校的学生，仅仅做了几个 C++ 的大作业，就在求职简历里面写上 “精通 C++”，则真是让人哭笑不得。 在多写代码的同时，我们也要注意不要 “ 重复造轮子 “，尽量保证每次写的代码都能具有复用性。在代码结构因为业务需求需要变更时，及时重构，在不要留下技术债的同时，我们也要多思考如何设计应用架构，能够保证满足灵活多变的产品需求。 在多次重构和思考的过程中，我们就会慢慢积累出一类问题的 “最佳实践” 方式，成为自己宝贵的经验。 多和同行交流有些时候遇到一些难解的技术问题，和同行的几句交流就可能让你茅塞顿开。。另外常见的技术问题通常都有人以前遇到过，简单指导几句就能让你一下子找到正确的解决方向。 国内开发者之间的交流，可以通过论坛，微博，QQ 群等方式来进行。另外各大公司有时候会办技术沙龙，这也是一个认识同行的好机会。 需要特别提醒的是，和国内开发者之前交流要注意讨论质量，有一些论坛和 QQ 群讨论质量相当低下，提的问题都是能通过简单 Google 获得的，这种社区一定要远离，以提高自己的沟通效率。 除了在国内的技术社区交流，建议读者可以去国外的 stackoverflow：http://www.stackoverflow.com 上提问或回答问题。 分享值得尝试的分享方式有：发起一个开源项目、写技术博客、在技术会议上做报告。这几种方式都比较有挑战，但是如果能大胆尝试，肯定会有巨大的收获。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"WWDC2014，苹果的“软件”发布会","slug":"talk-about-wwdc2014","date":"2014-07-02T14:04:10.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"2014/07/02/talk-about-wwdc2014/","permalink":"https://blog.devtang.com/2014/07/02/talk-about-wwdc2014/","excerpt":"","text":"在今年的 6 月 2 日到 6 日，苹果照例举行了一年一次的全球开发者大会（World Wide Developer Conference，简称 WWDC）。由于去年大会门票在不到 2 分钟之内被抢购一空，今年苹果改成了用抽签的方式来决定 WWDC 现场门票的购买权。在发布会前，大家对今年的发布会充满了各种期待，希望在发布会上见到 iPhone6、iWatch、新一代的耳机（因为苹果收购了耳机厂商 beats）以及新版的 Macbook。但是让人惊讶的是，苹果这次在大会上并没有发布任何新的硬件产品，但展示出其在软件上的各种功能改进和整合上的巨大努力，让我们一起来看看今年苹果的 WWDC 到底带来了哪些改变。 OS X苹果沿用了从去年开始的，以地名来命名操作系统的习惯，新的 OS X 10.10 操作系统的名字为 Yosemite（约塞米蒂国家公园）。Yosemite 吸收了 iOS7 开始的扁平化的设计风格，整个 Finder、Dock 栏及相关应用都重新绘制了新的图标和界面，并且支持偏平化和毛玻璃的半透明效果。另外 Yosemite 还有一些细节改进，例如重新设计的通知中心、更快的 Safari、更好用的邮件客户端等。与去年一样，新版的 Yosemite 操作系统仍然完全免费。 另外我们可以看到，今年苹果在软件上的许多改进都 “借鉴” 了不少其它应用。例如新版的 Spotlight 就和 Mac 下优秀的应用 Alfred 非常相似。而全新的 iCloud Drive 客户端，不但支持所有 Mac 和 iOS 设备，还支持 Windows 平台，这无疑是和 Dropbox 开始了正面的竞争（Dropbox 在两年前拒绝了来自乔布斯 8 亿美元左右的收购请求，现在估值达到了 100 亿美元）。 不过在我看来，以上这些改进比起 handoff 功能来说，都不算什么。handoff 功能显示出苹果对于功能整合的深度思考。苹果提了几个问题： 当我在电脑上工作时，这个时候来了一个电话或短信，为什么我不能直接在电脑上接电话或回复短信呢？ 当我在电脑的浏览器上看到一个电话号码时，我为什么不能直接点击这个电话号码拨打电话呢？ 当我在手机上回复邮件写了一半，这个时候走到电脑前面了，为什么不能方便地在电脑上继续写邮件呢？ 当我在电脑上看到一个小说正入迷，这个时候要出门，为什么不能直接拿起手机继续看呢？ 于是这次，苹果将 Mac 电脑和 iPhone、iPad 的功能进行了深度整合，当你拥有这三个设备时，它们每一个都可以接打电话和收发短信，你在它们任何一个设备上编辑的文档，也可以实时同步到另一个设备上。handoff 并不是苹果的应用独有的功能，苹果将其相关的 API 都开放给了开发者，所以开发者也可以完全开发出支持 handoff 功能的应用。 handoff 功能对于苹果而言意义重大，因为它再次重新定义了硬件生态圈，通过软件的深度整合，拥有多个苹果设备的用户会享受到极大的便利性。每一个设备的功能和信息都和其它苹果设备完美配合，使得单个硬件本身的功能被放大。这将催进拥有一个苹果设备的用户购买更多苹果的其它设备。随着苹果以后推出更多的智能硬件，其构造的硬件生态圈将像 App Store 软件生态圈一样，增加其产品的竞争力。 iOS苹果在这次大会上推出了新的 iOS8 操作系统。在 iOS8 中，iMessage 功能更一步增强，增加了发送语音的功能以及支持多人群聊，很多人都调侃说：“如果加上朋友圈，iMessage 就和微信功能一样了”。但 iMessage 并不支持 Android 平台，所以对微信一类的应用来说完全没有任何威胁。iOS8 中的图片编辑功能也得到了增强，通知中心允许用户进行更多地定制。另外苹果提供了 HealthKit，用于集成用户健康相关的信息。新的 Extension 功能类似于 Android 的 Intent，能够方便应用间相互调用。 相对于 Yosemite 带来的整合方面的改进，新版 iOS8 的改进的重点则是开放。苹果开放了输入法接口，允许第三方提供输入法。苹果也开放了 Touch ID，允许第三方应用获得指纹信息。HomeKit 则为智能硬件开放了不少可以互操作的接口。另外，iOS8 还新增了 4000 个新的 API，开放了大量底层 API 接口供应用调用。所以对于普通用户而言，iOS8 新增的可见功能可能是有限的，但是其开放的大量 API 和新 SDK 释放出了巨大的想象空间，相信会产生更多有趣的应用。 Swift这次的 WWDC 的口号是：“Write the code. Change the world”，Swift 的推出算是很好地诠释了本口号。苹果的 Objective-C 语言发明于与 C++ 同时期的上世纪 80 年代初，虽然苹果对其进行了很多次改进，但这终究像给应用打补丁一样，不是特别舒服。 这次 Swift 的推出，算是苹果大胆的一次尝试，试图用全新的编程语言来提高 OS X 和 iOS 程序员的开发效率，单从语言特性上来看，Swift 吸收了众多现代编程语言的优秀特性，例如类型推断（Type inference）、范型（Generic）、闭包（Closure）、命名空间（namespace），元组（tuple）等，整体语法上也更加简洁。我们也了解到 Swift 是苹果从 4 年前就开始筹划中的事情，可见苹果在长远规划上对于 Swift 语言的重视，相信未来 Swift 会接替更多 Objective-C 原本的地位，所有 iOS 开发者都应该花时间学习这门全新的语言。 苹果这次推出 Swift 也吸引了大量的讨论，其中比较不正确的观点是认为 iOS 开发的门槛因此而降低了。从我和身边的同行对 Swift 的学习和讨论来看，Swift 并不是一门可以简单上手的语言。并且在未来一到两年内，iOS 开发必然会经历同时使用 Objective-C 和 Swift 的过渡阶段。对于 iOS 开发者，除了必须掌握以前的 Objective-C 语言的知识，还需要学习并不简单的 Swift，可见 iOS 开发的门槛不但没有降低，反而提高了不少。 总结总体来说，苹果今年的 WWDC 大会虽然没有推出硬件上的新品，但是其在软件功能整合、开放系统 API 以及改进开发工具上做出了巨大努力，这些都会给苹果产品带来更大的竞争优势。 注：本文已投稿发表到 CSDN，未经允许不得转载。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"那些好用的iOS开发工具","slug":"ios-dev-tools","date":"2014-06-29T05:12:01.000Z","updated":"2024-01-06T14:52:37.918Z","comments":true,"path":"2014/06/29/ios-dev-tools/","permalink":"https://blog.devtang.com/2014/06/29/ios-dev-tools/","excerpt":"","text":"版权说明本文首发于《程序员》杂志 2014 年 6 月刊，未经允许，请勿转载。 前言从苹果发明 iPhone 起，AppStore 上的一个又一个类似 flappy bird 的一夜暴富的故事刺激着大量开发者加入移动开发大军。随着这些开发者出现的，还有大量方便 iOS 开发者的各种工具。这些工具作为整个应用开发生态链的重要一环，极大地方便了广大应用开发者，节省了应用开发的时间。 本文将从应用工具、命令行工具、插件工具 3 个方面，介绍这些优秀的应用。 图形应用工具Charles Charles（http://www.charlesproxy.com）是在 Mac 下常用的截取网络封包的工具，在做 iOS 开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Charles 详细的使用说明，欢迎阅读我的文章：《iOS 开发工具-网络封包分析工具 Charles》 界面调试PonyDebugger（https://github.com/square/PonyDebugger）、Reveal（http://revealapp.com/）、Spark Inspector（http://sparkinspector.com/）是三个常用的界面调试工具，可以在程序运行时动态调试 iOS 应用界面。PonyDebugger 是免费并且开源的，后两者是收费的，不过功能更加强大。 对于动态或复杂的交互界面，手写 UI 的是不可避免的，而 Reveal 一类的工具可以方便我们查看控件的相应属性是否正常，并且可以在程序运行时，动态地修改界面元素。这样就不用反复地修改代码并且重启程序了。 xScopexScope（http://xscopeapp.com/）是一类与界面开发相关的工具集。对于 iOS 开发，比较好用的功能包括它的放大镜取色工具、标尺工具等。其中放大镜取色工具可以将取到的多个色集收集起来，方便后续使用，并且支持直接粘贴成相关的程序颜色代码。 xScope 是收费软件，对于未付费版本，其功能有一些限制。 ImageOptimImageOptim（http://imageoptim.com/）是一个图象压缩的免费工具。iOS 工程默认使用的是 pngcrush 命令来压缩图片，不过其压缩比率其实不高。对于应用中图片资源比较多的读者，可以尝试使用 ImageOptim 来达到最大的图片压缩效果。 如果你从未尝试过 ImageOptim 一类的图片压缩工具，那么第一次给 IPA 文件瘦身的效果应该是比较惊人的。我个人的经验是，初次使用时 ImageOptim 能减少至少 10% 的应用图片资源占用。 ImageOptim 的实现原理是使用各种开源的图像压缩工具，然后取效果最好的那一个。它尝试的工具包括：PNGOUT, Zopfli, Pngcrush, AdvPNG, extended OptiPNG, JpegOptim, jpegrescan, jpegtran 和 Gifsicle。 安装方式是从其官方网站（http://imageoptim.com/）上下载程序文件，拖动到 “应用程序” 目录即可。下图是本篇文章所有的配图，可以看到使用 ImageOptim 达到了 29.5% 的体积缩小。 马克鳗马克鳗（http://www.getmarkman.com/）是国人开发的一款免费标注工具，可以方便地在美术输出的设计稿上标注相应界面元素的大小，颜色，边距，说明等。 命令行工具CocoaPods 每种语言发展到一个阶段，就会出现相应的依赖管理工具或者是中央代码仓库。比如 Java 的 maven，Nodejs 的 npm 等。而 CocoaPods（http://cocoapods.org/）是为 iOS 程序提供依赖管理的工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 在我开发猿题库客户端时，其使用了 24 个第三方开源库。在没有使用 CocoaPods 以前，我需要: 把这些第三方开源库的源代码文件复制到项目中，或者设置成 git 的 submodule。 对于这些开源库通常需要依赖系统的一些 framework，我需要手工地将这些 framework 一一增加到项目依赖中，比如通常情况下，一个网络库就需要增加以下 framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics, zlib。 对于某些开源库，我还需要设置-licucore或者 -fno-objc-arc等编译参数 管理这些依赖包的更新。 这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用 CocoaPods 之后，我只需要将用到的第三方开源库放到一个名为 Podfile 的文件中，然后执行pod install。CocoaPods 就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。 使用 CocoaPods 还需要注意以下几点： 需要使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，你应该把这个文件加入到版本管理中。因为 Podfile.lock 会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样的好处是：当多人协作的时候，可以保证所有人的第三库环境是完全一样的。 详细的使用说明，欢迎阅读我的文章：《用 CocoaPods 做 iOS 程序的依赖管理》 nomadnomad（http://nomad-cli.com/）是一个方便你操作苹果开发者中心（Apple Developer Center）的命令行工具，可以做的事情包括方便地添加测试设备，更新证书文件，增加 App id，验证 IAP 的凭证等。 安装方式： gem install nomad-cli 安装完后，首先执行ios login，你的 Developer 账号密码会被它存储到 Keychain 中，之后就可以用命令行来完成各种后台操作了，例如： 添加测试设备： ios devices:add &quot;TangQiaos iPhone&quot;=&lt;Device Identifier&gt; 更新证书文件: ios profiles:devices:add TangQiao_Profile &quot;TangQiaos iPhone&quot;=&lt;Device Identifier&gt; nomad 还有很多功能，建议大家阅读其官方网站的文档进一步学习。 xctoolxctool（https://github.com/facebook/xctool）是 facebook 开源的一个 iOS 编译和测试的工具。使用它而不是用 Xcode 的 UI 界面是因为它是一个纯命令行工具。比如：我们可以使用 xctool 在命令生下进行编译和单元测试，然后将测试结果集成到 Jenkins 中，这样就实现了自动化的持续集成。虽然苹果也在 OSX Server 上推出了自己的自动化集成工具 BOT，但其配置和使用上现在仍然不太方便。 安装 xctool 可以使用 brew 命令： brew install xctool 使用 xctool 编译项目可以使用如下命令： path/to/xctool.sh \\ -project YourProject.xcodeproj \\ -scheme YourScheme \\ build 使用 xctool 执行单元测试，可以使用如下命令： path/to/xctool.sh \\ -workspace YourWorkspace.xcworkspace \\ -scheme YourScheme \\ test xctool 还有很多功能，建议大家阅读 xctool 官方网站的文档进一步了解更多的功能。 appledocappledoc（https://github.com/tomaz/appledoc）是一个从源码中抽取文档的工具。 对于开发者来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 一类的语言本身就自带 javadoc 命令，可以从源码中抽取文档。而 appledoc 就是一个类似 javadoc 的命令行程序，可以从 iOS 工程的源代码中抽取相应的注释，生成帮助文档。 相对于其它的文档生成工具，appledoc 的优点是： 它默认生成的文档风格和苹果的官方文档是一致的。 appledoc 就是用 objective-c 写的，必要的时候调试和改动也比较方便。 它可以生成 docset，并且集成到 xcode 中。集成之后，在相应的 API 调用处，按住 option 再单击就可以调出相关的帮助文档。 它没有特殊的注释要求，兼容性高。 安装 appledoc 可以直接使用 brew 命令： brew install appledoc 使用时切换到 iOS 工程目录下，执行以下操作即可，appledoc 会扫描当前路径下的所有文件，然后生成好文档放到 doc 目录下。你也可以用 appledoc —help 查看所有可用的参数。 appledoc -o &lt;output_path&gt; \\--project-name &lt;project_name&gt; \\--project-company &lt;project_company&gt; . 详细的使用介绍，欢迎阅读我的文章：《使用 Objective-C 的文档生成工具:appledoc》 Xcode 插件Xcode 是 iOS 的集成开发环境，虽然苹果一直在不断改进 Xcode，但程序员总是有各种新奇的想法和需求，当 Xcode 无法满足他们时，于是他们就会通过插件的方式来为 Xcode 增加新的功能。本节将会给大家介绍一些常用的 Xcode 增强插件。 Xcode 所有的插件都安装在目录~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/下，每个插件为一个子目录，你也可以手工切换到这个目录来增加或删除插件。 Alcatraz Alcatraz（http://alcatraz.io/）是管理 Xcode 所有插件的插件，它可以直接集成到 Xcode 的图形界面中，让你感觉就像在使用 Xcode 自带的功能一样。Alcatraz 不但可以管理 Xcode 的插件，它另外还提供了管理 Xcode 工程模版以及颜色配置的功能。 使用如下的命令行来安装 Alcatraz： mkdir -p ~/Library/Application\\ Support/\\Developer/Shared/Xcode/Plug-ins;curl -L http://git.io/lOQWeA |\\ tar xvz -C ~/Library/Application\\ Support/\\ Developer/Shared/Xcode/Plug-ins 安装成功后重启 Xcode，就可以在 Xcode 的顶部菜单中的 “Window”-&gt;“Package Manager” 中找到 Alcatraz。点击 “Package Manager”，即可启动插件列表页面。你可以在右上角搜索插件，对于想安装的插件，点击其左边的图标，即可下载安装，如下所示，我正在安装 KImageNamed 插件： 安装完成后，再次点击插件左边的图标，可以将该插件删除。 以下所有介绍的插件均可用该方法来安装或删掉，就不另行介绍了。 Alcatraz 详细的使用介绍，欢迎阅读我的文章：《使用 Alcatraz 来管理 Xcode 插件》 KSImageNamedKSImageNamed（https://github.com/ksuther/KSImageNamed-Xcode）是一个帮助你输入 [UIImage imageNamed:] 中的资源名的插件。当你输入[UIImage imageNamed:]时，会自动的弹出上下文菜单，供你选择你需要输入的图片资源名字，另外在选择图片资源时，还可以在左侧预览该资源。如下图所示： XVimXVim（https://github.com/JugglerShu/XVim）是一个 Xcode 的 vim 插件，可以在 Xcode 的编辑窗口中开启 vim 模式。 vim 模式最大的好处是可以全键盘操作，可以方便地移动光标以及复制、粘贴代码。XVim 对于 Xcode 的分栏模式也有很好的支持，与 vim 自带的分栏模式一样，可以用快捷键ctrl + w来切换当前编辑的分栏。 FuzzyAutocompletePluginFuzzyAutocompletePlugin (https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin) 允许使用模糊的方式来进行代码自动补全。 举个例子，如果我们要重载 viewDidAppear:方法，那么我们必须依次建入 view、did、appear 才能得到相应的补全信息，使用 FuzzyAutocompletePlugin 之后，我们可以建入 vda (view、did、appear 三个单词的首字母)，或任意符合 viewDidAppear 整个单词出现顺序的子串 (例如 vdapp, adear 等)，即可匹配到该方法。 XToDoXToDo（https://github.com/trawor/XToDo）是一个查找项目中所有的带有 TODO, FIXME, ???, !!! 标记的注释。 通常我们在项目开发中，由于种种原因，一些事情需要以后处理，这个时候为了防止遗忘，加上TODO或FIXME注释是非常有必要的，但是上线或提交代码前要寻找这些未解决的事项却稍显麻烦。XToDo 可以提供一个汇总的界面，集中显示所有的未完成的TODO和FIXME标记。 BBUDebuggerTuckAwayBBUDebuggerTuckAway（https://github.com/neonichu/BBUDebuggerTuckAway）是一个非常小的工具，可以在你编辑代码的时候自动隐藏底部的调试窗口。因为通常情况下，调试的时候是加断点或监控变量变化，或者在 Console 窗口用po来输出一些调试信息。如果开始编辑代码了，说明已经调试结束了，这个时候隐藏调试窗口，可以给编辑界面更多空间，方便我们修改代码。 SCXcodeSwitchExpanderSCXcodeSwitchExpander（https://github.com/stefanceriu/SCXcodeSwitchExpander）帮助你迅速地在switch语句中填充枚举类型的每种可能的取值。 例如，当你输入switch，然后键入一个NSTableViewAnimationOptions类时，该插件会将其可能的取值补全在每一个case之后，如下图所示： deriveddata-exterminatorderiveddata-exterminator（https://github.com/kattrali/deriveddata-exterminator）是一个清除 Xcode 缓存目录的插件。 有些时候 Xcode 会出各种奇怪的问题，最常见的是在某些复杂操作下（例如同一个项目，来回切换到各种分支版本），会造成 Xcode 显示一些编译的错误或警告，但是最终却又可以编译通过。新手遇到这种问题常常束手无策，而熟悉 Xcode 的人就知道，通常清除 Xcode 缓存就可以解决这类问题。该插件在 Xcode 菜单上增加了一个清除缓存按钮，可以一键方便地清楚缓存内容。 VVDocumenterVVDocumenter（https://github.com/onevcat/VVDocumenter-Xcode）是一个自动生成代码注释的工具，可以方便地将函数的参数名和返回值提取出来，这样结合上一节介绍的appledoc命令，就可以方便地将帮助文档输出。 ClangFormatClangFormat（https://github.com/travisjeffery/ClangFormat-Xcode）是一个自动调整代码风格（Code Style）的工具。Xcode 本身的代码缩进自动调整功能比较弱，特别是对于 JSON 格式，常常产生非常丑陋的默认缩进效果。ClangFormat-Xcode 可以更好地对代码进行重新排版，并且内置了各种排版风格，也支持自定义风格。 ColorSenseColorSense（https://github.com/omz/ColorSense-for-Xcode）是一个UIColor颜色输入辅助工具，可以帮助你在编写UIColor代码时，实时预览相应的颜色，如下图所示： XcodeBoostXcodeBoost（https://github.com/fortinmike/XcodeBoost）包含多个辅助修改代码的小功能，比如： 可以在 .m 文件中复制方法实现，然后将该方法的定义粘贴到对应的 .h 文件中 可以在某一个源文件中直接输入正则表达式查找 可以复制粘贴代码时不启用 Xcode 的自动缩进功能（Xcode 的自动缩进经常出问题，造成已经调整好的代码缩进，因为粘贴时被 Xcode 调整坏了） 总结本文分图形应用工具，命令行工具，Xcode 插件三个部分，介绍了 iOS 开发中好用的工具。其中涉及的图形工具部分是收费的，而命令行工具和 Xcode 插件工具全部是免费并且开源的工具，笔者在此也感谢广大的开源软件作者，是他们让整个软件生态圈更加美好。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"专访《iOS测试指南》作者羋峮","slug":"interview-on-miqun","date":"2014-06-01T09:07:31.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/06/01/interview-on-miqun/","permalink":"https://blog.devtang.com/2014/06/01/interview-on-miqun/","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 前言在 2014 年 QCon 北京 大会上，羋峮进行了他的新书 《iOS 测试指南》 的签售会。在大会中，我代表 InfoQ 与羋峮进行了一次专访，羋峮分享了他在 iOS 平台做自动化测试的一些经验。 羋峮有着多年的测试经验，先后在高德、豆瓣以及豌豆夹从事过测试相关的工作。他在豆瓣工作时，实现并且开源了 iOS 的自动化测试工具 ynm3k，并且刚刚完成了系统介绍 iOS 自动化测试的新书《iOS 测试指南》。 InfoQ：羋峮你好，我想请你先介绍一下你的测试工作经历。 羋峮：我是 03 年毕业的，修了三年地铁以后就转行做软件测试工作了。到现在，做测试有七到八年的时间，我是从豆瓣开始做的移动测试相关的工作，当时移动测试也正好赶上一个起步的阶段，所以还有一点小小的心得。 InfoQ：我想问的第一个主题是关于自动化测试和持续集成的方面的问题。就我所了解的情况，现在大部分的互联网公司关于移动端的测试的工具都还处于比较初级的阶段，很多公司也没有真正应用上那个自动化测试。我昨天跟阿里的 iOS Leader 聊，他们没有用到移动端自动化测试，我之前在网易工作，他们也没有做移动端自动化测试，你觉得是什么原因造成移动端自动化测试还没有流行起来，没有大规模的应用？ 羋峮：测试的投入产出比，尤其是自动化测试的投入产出比一直都没有一个非常简单有效的说明方法。当投入产出比的说不清楚的时候，可能很多人选择观望。tinyfool 在给我写这本书的书序的时候，他也做了一个小调查，基本上就是不测试，或者简单测试的占很大的比重，比较细致的测试非常少。测试做的非常少主要有这么几方面的原因： 1、移动端是一个新生事物，总结出来的方法还没有被普遍的认可。移动端承接了更多 UI 展现方面的工作，其中有很多的和人交互的东西。不但功能复杂，并且还没有唯一的标准。测试的注意力很容易不分散，并且效果非常的不明显。 2、移动端现在更多的是市场行为，需要有产品的占领地盘。还没有到精雕细琢的时代。所以，测试在这个时候明显不如产品或者设计师有话语权。并且现在需要的是 “有”，还没有到 “精” 的程度。 3、国内测试界相对比较浮躁，更多的不是从技术角度去解决问题。所以导致测试需要关注点过于分散，没有真正的定义好自己的工作职责和范围。什么事情都需要关注，最后就是什么事情都没有关注好。 我比较幸运，当时去了豆瓣。豆瓣当时明确的定义了 QA 的工作职责——推荐新技术或者开发新工具，让开发工程师更好的测试。并且设计师在测试阶段也会投入很大的精力去 review 设计稿中各种交互方面的不足。 InfoQ：你在豆瓣开始尝试 iOS 的自动化测试，那我想知道你在这个过程中取得哪些成果？ 羋峮：刚去豆瓣接手工作的时候自己思维还是有局限性的，只是把自己工作定位在去实现一些基于界面操作的自动化的东西，这个其实现在看来可能它是一个切入点，但是可能并不是一个非常好的切入点，其实还有很多工作要做，由于当时自己思维局限所以就做了。 另外一方面，就是因为只想到这一点，所以就是精力比较集中 , 更容易出一些成果。2011 年年底的时候开始做这些工作，自己先后找了有五款自动化测试工具调研。调研的方法是先写一些 demo 的东西，然后再看看工具的源代码。搞清楚工作的架构和底层原理。最后发现，当时的工具都有一些这样那样的问题。然后自己就开始幻想写一个适合自己的这个自动化工具。 当 iOS5 发布以后，苹果的对于 UI Automation 进行了一个改进，增加了performTaskWithPathArgumentsTimeout接口。通过该接口可以实现 UI Automation 和外部程序的简单通信。基于这个改进，自己拉了在豆瓣的一个开发的同事，两个人就用一个半月的时间写了一个自动化测试工具。也是因为有了 performTaskWithPathArgumentsTimeout 接口的发布，所以淘宝也当时利用那个接口写了另外一种实现的 iOS 的测试工具。 在完成 ynm3k 的开发以后，使用它为豆瓣 FM 和豆瓣电影写了一些自动化测试用例。效果还可以。 InfoQ：淘宝那个开源了吗？ 羋峮：淘宝那个开源了，叫 athrun ，我那个也开源了叫 ynm3k，当时是 12 年 7 月份，那个 ADC 的专门都有分享，在网上应该也都有链接 Athrun instrument driver 和 豆瓣 iOS 自动化测试实践和经验 。 InfoQ：当时你们花一个半月开发这个自动化测试工具是用 20% 的工作时间，还是完全的工作时间来做这个事情？因为我觉得你在开发这段时间内肯定也有普通的正常的测试任务要完成，你们公司是怎么平衡这件事情的？ 羋峮：我们应该是业余时间完成的这个框架。主要就是晚上，或者是快下班的时候，自己挤出来一些时间做这个事情。 InfoQ：跟同事的配合也是在那段时间来进行的？ 羋峮：当时就是我俩分工相对来说很明确，一方面需要有更好的遍历控件和定位控件的方法，是由我来现实的；另一方面，需要引入一个 JavaScript 语言的单元测试框架。这部分由我豆瓣的同事 @SeanLionheart 完成，他在正式发布的时候已经去美国上学。 我们两个之间的配合非常顺畅，因为各自的部分是完全解耦的，互补不影响。在交流的时候，还能相互给出自己的想法和意见。 InfoQ：你们做这件事情，豆瓣有从文化上，或者从其他方面对你们这件事情有鼓励或者激励吗？我想知道，是否这个公司的文化对于促进了你们做这件事情？ 羋峮：这个肯定是促进的。首先这个想法是我在一次周会上提出来的。提出来以后，当时我的 Leader 解彦博老师就特别鼓励我们去做这件事情，并且大家都很感兴趣，当时的整个测试团队都给我们提供意见或者交流过想法。 第二，在豆瓣的骨子里，就有很多工程师去愿意去用自己的业余时间去写一些小工具来改进效率，或者是提高效率，或者改进流程，这个在豆瓣都是很流行。自己写的工具，在豆瓣内部得到了广泛的应用，对工程师来说这是很高的荣誉。 InfoQ：当你产品在快速迭代的时候，它的整个页面的组织，界面逻辑都会在快速变化，这个时候自动化测试是否是在这种场景下不太适合？自动化测试是怎么解决产品快速迭代的问题呢？ 羋峮：无法适应变化一直是自动化测试的软肋。首先，有一些变化需要测试做兼容，这个兼容可能需要测试框架本身来支持，也可能需要自动化测试脚本通过一些更加层次化的方法来兼容。举一个例子来说，一个登录按钮，从 NavigationBar 上移到了可能在中间页面的一个 LoginButton 上面，所以这种情况下是应该去兼容的，因为它只是位置发生了变化，它大的业务逻辑没有发生变化，这种是需要测试框架去兼容的。如果是更大一点的变化，需要测试脚本一定量的维护。其次，测试脚本一定要不断的维护。有很多自动化测试最终失败是因为期间放弃过自动化测试脚本的维护。自动化测试脚本不但需要维护，还需要有很好的代码结构。相关测试脚本的代码结构可以参看一些 PageObject 的思想，也可以看看 cucumber 等 BDD 工具，都会帮助你最小改动的维护自动化测试脚本。当然，自动化测试接入工程的时机等因素也很重要。这些都没有固定的模式，需要结合自己团队的特点来开展。自动化测试和持续集成是一对好基友。自动化测试执行和结果展示都需要持续集成的帮助。有了持续集成，自动化测试才会被更多的人认可，可才会有更多的人加入到自动化测试的维护中来。最后，可能需要更新一下对自动化测试的认识。自动化测试不会降低成本，自动化测试不会主动发现 bug。自动化测试可以更标准更快速的重复回归一些功能测试。所以，对自动化测试有一个更加客观的认识，才会帮助你在具体的工程项目中更好的开展自动化测试实践。 InfoQ：刚才你提到你在豆瓣开源的 ynm3k 这个开源测试工具，然后你同时也提到淘宝也开源的 athrun，你有没有比较过你们两者之间工具各自有什么特点？ 羋峮：首先两款工具都同时用到了一个接口，接口的名字是：performTaskWithPathArgumentsTimeout，这个接口可以去运行一个本地的命令行程序。这个接口提供了 UI Automation 和命令行工具的一个交互的可能。 我用那个接口用的非常轻量，需要把运行完的测试结果通过那个接口写文件写出来，写成标准的 XML 以后，通过 Jenkins 或者是 Hudson 这些持续集成的工具，把它展现在持续集成工具的页面里头。 我只是写了文件，淘宝的 athrun 做了一个进程之间的通信，所以他那个工具解决的问题是：用户可以不用 JavaScript 来写 UI Automation 的东西。athrun 自己定义了通信协议，并且通过 performTaskWithPathArgumentsTimeout 接口来完成和 UI Automation 的通信。用户可以使用 Java 语言来做 UI Automation 的自动化测试。 同样类似的国外也有，就像 eBay 的 ios-driver，还有就是最近特别火的 appium，原理上都是通过那个接口实现了两个进程间的通信来驱动 UI Automation 来完成自动化测试的。appium 在驱动 UI Automation 的基础上还兼容了 WebDriver 的 Json Wire protocl 协议。使用者可以使用 Java、Python、Ruby 等语言直接调用 WebDriver 的 API 来完成 iOS 的自动化测试。WebDriver 对很多 Web 端的测试工程师来说都很熟悉。由于 appium 兼容了 Json Wire protocl 协议，使用者还可以使用 Gird 来并发的测试。当然，appium 也支持 Android 的一些自动化测试。 在《iOS 测试指南》书中，大概也进行了一个分类，ynm3k 属于扩展型的，扩展型的工具只是提供了一些 JavaScript 的开发库，用户只需要 import 进来，可能就会有更简化的写法和更强大的功能，然后但是对本身的 UI Automation 的，就基本上没有改变。 但是通过苹果提供performTaskWithPathArgumentsTimeout接口进行进程间通信的这种自动化测试工具，我在书里面把它归类为驱动型的测试工具。使用驱动型的测试工具，用户可以有更多种语言的选择，并且可以拥有动态的调试功能。但是驱动型的测试工具，无法在 instruments 的图形界面下运行，也就失去了，运行自动化测试的时候同时检查内存泄露，统计网络流量等功能。所以，工具对比下来只有适合不适合的说法，并没有绝对意义上的好与坏。 InfoQ：刚才也都是提到你的 UI 测试的书本，我希望你简单介绍一下这本书适合哪些读者，有没有什么你觉得特别值得推荐的书里面的内容可以分享给大家？ 羋峮：我书里前两章写的很短，就说了一些基本的概念；第三章说的是单元测试的一些实践，并且完成一个简单的 app 的单元测试。 第四章就简要的介绍一下 Automation 的基础知识，很多自动化测试工具都是基于 UI Automation 来做的。不管是用哪个工具，从底层了解一些 UI Automation 的 API，都是有帮助。 第五章写的是 iOS 端的 Web 测试的一个方案，介绍了两种工具，其中也提到了 Appium，我也更推荐使用 Appium 来做自动化测试；然后第六章介绍了持续集成方面的事情，就是三到六章应该都是一个综合解决方案中的各个部分的技能的分散介绍。然后第七章介绍了一下，除了功能测试，手机端还需要去做哪些类型的测试，或者借助工具，我们应该怎么样简单的去确认，或者是去更精确的衡量；第八章是基于第三、四、五、六章然后做了一个最后的一个汇总介绍。因为书写的比较慢，在书稿还没有完全完成的时候，苹果就发布了 XCode5 和 OS X 10.9。在这一次更新以后，苹果本身也提供了一个持续集成的解决方案。在 XCode5 中还升级了单元测试框架。所以这一系列的变化就有了第九章的内容。 书的内容本身是想给刚入门 iOS 测试的工程师来看的。最早写书的主要目的也是，为了汇总一些资料。因为相关 iOS 测试的资料实在是太少并且太分散了。但是当书写完以后，才发现原来用到了 3-4 种变成语言。所以，现在看来可能还需要读者有一定的编程功底。所以本书的最适合读者是有编码能力或者测试经验的人需要了解移动端测试的这样一个人群。 InfoQ：你刚才讲到你的工具是开源的，然后你花了业余时间在这个上面，然后你的这本书是你的一个人通过业余时间写作完成的作品，我就想知道你开源和写作大概花费了你多少的业余时间，业余时间里面你是如何安排这些事情的？ 羋峮：做开源的时候还好了，只需要挤出来一定的时间把框架搭完了，慢慢的可以用零散的工作去实现个别功能，或者优化个别功能。写书的话，整个过程中，其实还是需要一些大块的时间去投入，因为自己语文水平比较差，有的时候明白一件事，可能还要去想一想怎么能写明白。对于我而言，往往需要大块的时间去写书，需要写一个小时以后感觉才能进入状态，进入状态之后写作效率还算 OK。一般一次写作的时间会在 4 个小时以上。我自己估了一下，如果一页的内容，代码和截图占到一半以上的话那一页的时间，大概是 1.5 个小时，如果是这一页内容是纯文字的话，那一页的时间大概是两个半小时。所以整个大概写了四百个小时左右。 InfoQ：这确实是一个很大的工作量。感谢你为大家带来的开源工具和作品，谢谢你！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://blog.devtang.com/tags/Interview/"}]},{"title":"深入理解Tagged Pointer","slug":"understand-tagged-pointer","date":"2014-05-30T14:15:29.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/05/30/understand-tagged-pointer/","permalink":"https://blog.devtang.com/2014/05/30/understand-tagged-pointer/","excerpt":"","text":"版权说明本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 【摘要】：为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。本文从Tagged Pointer试图解决的问题入手，带领读者理解Tagged Pointer的实现细节和优势，最后指出了使用时的注意事项。 前言在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。本文从Tagged Pointer试图解决的问题入手，带领读者理解Tagged Pointer的实现细节和优势，最后指出了使用时的注意事项。 问题我们先看看原有的对象为什么会浪费内存。假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。 所以一个普通的 iOS 程序，如果没有Tagged Pointer对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示： 我们再来看看效率上的问题，为了存储和访问一个 NSNumber 对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。 Tagged Pointer为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：2^31&#x3D;2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。 所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了Tagged Pointer对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样： 对此，我们也可以用 Xcode 做实验来验证。我们的实验代码如下： int main(int argc, char * argv[])&#123; @autoreleasepool &#123; NSNumber *number1 = @1; NSNumber *number2 = @2; NSNumber *number3 = @3; NSNumber *numberFFFF = @(0xFFFF); NSLog(@&quot;number1 pointer is %p&quot;, number1); NSLog(@&quot;number2 pointer is %p&quot;, number2); NSLog(@&quot;number3 pointer is %p&quot;, number3); NSLog(@&quot;numberffff pointer is %p&quot;, numberFFFF); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 在该代码中，我们将几个 Number 类型的指针的值直接输出。需要注意的是，我们需要将模拟器切换成 64 位的 CPU 来测试，如下图所示： 运行之后，我们得到的结果如下，可以看到，除去最后的数字最末尾的 2 以及最开头的 0xb，其它数字刚好表示了相应 NSNumber 的值。 number1 pointer is 0xb000000000000012number2 pointer is 0xb000000000000022number3 pointer is 0xb000000000000032numberFFFF pointer is 0xb0000000000ffff2 可见，苹果确实是将值直接存储到了指针本身里面。我们还可以猜测，数字最末尾的 2 以及最开头的 0xb 是否就是苹果对于Tagged Pointer的特殊标记呢？我们尝试放一个 8 字节的长的整数到NSNumber实例中，对于这样的实例，由于Tagged Pointer无法将其按上面的压缩方式来保存，那么应该就会以普通对象的方式来保存，我们的实验代码如下： NSNumber *bigNumber = @(0xEFFFFFFFFFFFFFFF);NSLog(@&quot;bigNumber pointer is %p&quot;, bigNumber); 运行之后，结果如下，验证了我们的猜测，bigNumber的地址更像是一个普通的指针地址，和它本身的值看不出任何关系： bigNumber pointer is 0x10921ecc0 可见，当 8 字节可以承载用于表示的数值时，系统就会以Tagged Pointer的方式生成指针，如果 8 字节承载不了时，则又用以前的方式来生成普通的指针。关于以上关于Tag Pointer的存储细节，我们也可以在 这里 找到相应的讨论，但是其中关于Tagged Pointer的实现细节与我们的实验并不相符，笔者认为可能是苹果更改了具体的实现细节，并且这并不影响Tagged Pointer我们讨论Tagged Pointer本身的优点。 特点我们也可以在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍： Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free。 在内存读取上有着 3 倍的效率，创建时比以前快 106 倍。 由此可见，苹果引入Tagged Pointer，不但减少了 64 位机器下程序的内存占用，还提高了运行效率。完美地解决了小内存对象在存储和访问效率上的问题。 isa 指针Tagged Pointer的引入也带来了问题，即Tagged Pointer因为并不是真正的对象，而是一个伪对象，所以你如果完全把它当成对象来使，可能会让它露马脚。比如我在 《Objective-C 对象模型及应用》 一文中就写道，所有对象都有 isa 指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。因为不是真正的对象，所以如果你直接访问Tagged Pointer的isa成员的话，在编译时将会有如下警告： 对于上面的写法，应该换成相应的方法调用，如 isKindOfClass 和 object_getClass。只要避免在代码中直接访问对象的 isa 变量，即可避免这个问题。 总结苹果将Tagged Pointer引入，给 64 位系统带来了内存的节省和运行效率的提高。Tagged Pointer通过在其最后一个 bit 位设置一个特殊标记，用于将数据直接保存在指针本身中。因为Tagged Pointer并不是真正的对象，我们在使用时需要注意不要直接访问其 isa 变量。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"用CocoaPods做iOS程序的依赖管理","slug":"use-cocoapod-to-manage-ios-lib-dependency","date":"2014-05-25T06:09:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/","permalink":"https://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/","excerpt":"","text":"文档更新说明 2012-12-02 v1.0 初稿 2014-01-08 v1.1 增加设置 ruby 淘宝源相关内容 2014-05-25 v2.0 增加国内 spec 镜像、使用私有 pod、podfile.lock、创建 spec 文件等内容 2015-09-03 v2.1 优化排版，调整一些描述方式，使文章更易读懂。 2015-12-21 v2.2 将淘宝的镜像修改成 https 的。 CocoaPods 简介每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。 CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 我在开发猿题库客户端时，使用了 24 个第三方开源库。在没有使用 CocoaPods 以前，我需要: 把这些第三方开源库的源代码文件复制到项目中，或者设置成 git 的 submodule。 对于这些开源库通常需要依赖系统的一些 framework，我需要手工地将这些 framework 分别增加到项目依赖中，比如通常情况下，一个网络库就需要增加以下 framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics, zlib。 对于某些开源库，我还需要设置-licucore或者 -fno-objc-arc等编译参数 管理这些依赖包的更新。 这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用 CocoaPods 之后，我只需要将用到的第三方开源库放到一个名为 Podfile 的文件中，然后执行pod install。CocoaPods 就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。 CocoaPods 的安装和使用介绍安装安装方式异常简单 , Mac 下都自带 ruby，使用 ruby 的 gem 命令即可下载安装： $ sudo gem install cocoapods$ pod setup 如果你的 gem 太老，可能也会有问题，可以尝试用如下命令升级 gem: sudo gem update --system 另外，ruby 的软件源 https://rubygems.org 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内淘宝的源： gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l 还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。你也可以参考本文接下来的使用 cocoapods 的镜像索引一节的内容来提高下载速度。 使用 CocoaPods 的镜像索引所有的项目的 Podspec 文件都托管在https://github.com/CocoaPods/Specs。第一次执行pod setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢，笔者就更新了将近 1 个小时才完成。 一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像： pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 将以上代码中的 https://gitcafe.com/akuandev/Specs.git 替换成 http://git.oschina.net/akuandev/Specs.git 即可使用 oschina 上的镜像。 使用 CocoaPods使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可 platform :iospod &#x27;JSONKit&#x27;, &#x27;~&gt; 1.4&#x27;pod &#x27;Reachability&#x27;, &#x27;~&gt; 3.0.0&#x27;pod &#x27;ASIHTTPRequest&#x27;pod &#x27;RegexKitLite&#x27; 然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可： cd &quot;your project home&quot;pod install 现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可： 使用 CocoaPods 生成的 *.xcworkspace 文件来打开工程，而不是以前的 *.xcodeproj 文件。 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 查找第三方库你如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么你可以通过 pod search 命令进行查找，以下是我用 pod search json 查找到的所有可用的库： $ pod search json-&gt; AnyJSON (0.0.1) Encode / Decode JSON by any means possible. - Homepage: https://github.com/mattt/AnyJSON - Source: https://github.com/mattt/AnyJSON.git - Versions: 0.0.1 [master repo]-&gt; JSONKit (1.5pre) A Very High Performance Objective-C JSON Library. - Homepage: https://github.com/johnezang/JSONKit - Source: git://github.com/johnezang/JSONKit.git - Versions: 1.5pre, 1.4 [master repo]// ... 以下省略若干行 关于 Podfile.lock当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。 CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出： This file should always be kept under version control. 为自己的项目创建 podspec 文件我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件： pod spec create your_pod_spec_name 该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。 具体步骤可以参考这两篇博文中的相关内容： 《如何编写一个 CocoaPods 的 spec 文件》 《Cocoapods 入门》。 使用私有的 pods我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持 CocoaPods。如下是一个示例： pod &#x27;MyCommon&#x27;, :podspec =&gt; &#x27;https://yuantiku.com/common/myCommon.podspec&#x27; 不更新 podspecCocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用--no-repo-update参数可以禁止其做索引更新操作。如下所示： pod install --no-repo-updatepod update --no-repo-update 生成第三方库的帮助文档如果你想让 CococaPods 帮你生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可： brew install appledoc 关于 appledoc，我在另一篇博客 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 opt 键单击类名或方法名，就可以显示出相应的帮助文档。 原理大概研究了一下 CocoaPods 的原理，它是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。发现的一些技术细节有： Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。 对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。 CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。 愿大家玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"技术人员如何坚持写作","slug":"how-to-persist-writing","date":"2014-05-24T06:00:12.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/05/24/how-to-persist-writing/","permalink":"https://blog.devtang.com/2014/05/24/how-to-persist-writing/","excerpt":"","text":"我和朋友的故事这个月我给 InfoQ 网站、《程序员》 的投稿所获的稿费，加上去人人网分享技术所得到的礼物，一共有将近 3000 块。看到这个数字之后我自己都吓了一跳，不知不觉中，写作和分享竟然给自己带来了这么大的直观收入。 但是相比那些非金钱上的收获，这些直接收入又显得微不足道。我在 《作为码农，我们为什么要写作》 一文中，总结了写作给自己带来的非金钱上的收获，包括：提高自己对知识的掌握层次、提高表达和沟通的能力、错误内容反馈、认识朋友、了解更多相关信息、提高影响力和获得传递知识的乐趣。 由于我自己从写作中获得了巨大的好处，所以我尝试向身边的朋友推荐这个自我提高的方式，但是非常令人惊讶的是，即使知道这里面会有巨大的好处，我身边的很多朋友仍然不能坚持写作。我从他们中收集到的负面反馈包括： 写作太花时间。我的朋友 A 发现，完成一篇给 InfoQ 的投稿需要花费他周末 2 天的时间（包括查找资料和写作，和 InfoQ 编辑的沟通，多次改稿等）。而从稿费得到的直接收入，远远不能弥补他所花费的时间。通常人们都喜欢将自己的月工资除以 22，然后算出来每天自己的时间成本。当发现自己的写作直接收入远远不能匹配工作的收入时，很多人都会选择放弃。 自己不擅长写作。我的朋友 B 对于 Origami 非常精通，我本来打算向他约一篇深入介绍 Origami 的稿件，但是当然得知稿件的稿费只有千字 150 元时，他就放弃了。拿他的话来说，写文章憋出几个字可比写代码费劲多了，为了这篇文章，他可能得花费数周才能完成，最终的稿费收入可能只有几百块。 写作对自己收获不大。我的朋友 C 是一个技术牛人，但是他习惯通过记笔记的方式来整理知识，对于一些知识点，因为是消化过的，所以他就只需要在笔记中将关键的内容记录下来，就可以方便地在后期进行知识的回顾。而如果他要写文章的话，因为文章是面向其他读者，他就需要非常仔细地介绍知识的前因后果，做各种铺垫，还需要做到有条理，表达清晰。这些如果要做好，配图、举例子、提供参考资料等工作是免不了的，所以让我的朋友 C 觉得实在太花时间了，性价比太低。 自己不能坚持。我的朋友 D 完全同意我的观点，认为写作能够带来的巨大好处，但是他就是坚持不下来。这就像有些人不能坚持锻炼身体，有些人不能坚持早睡早起，有些人不能坚持控制饮食一样，对于一些有好处但是需要和自己的潜意识做斗争的事情，很容易被自己打败。 坚持写作的关键他们说得有道理吗？我认为非常有道理。而且我认为，我的 ABCD 四个朋友，都会在各自领域成为大牛，因为他们都热爱编程，喜欢专研，并且有着认真做事情的态度。所以反过来，我认为坚持写作并不是一个人通往成功的必经之路，但是写作是帮助你成功的一个重要的加分项。 那我们为什么坚持写作？我只想到一个理由：爱好。 但是我不同意爱好就等同于擅长的事情。通常情况下某一个人因为在天赋上擅长做某件事情，然后就会在这件事情上持续收获满足感，进而在该件事情上比别人投入更多时间。但是也有那种反过来的，因为爱好一件事情，从而不断地坚持做那件事情，最终因为投入巨大的时间而成功。 我个人坚持写作就属于后者。高中时，我的语文成绩一直在应试教育的阴影之下，由于并不擅长记忆，我的语文成绩一直非常差，高考时语文差一点不及格，满分 150 的考卷最终只有 92 分。但是我内心深处还是喜欢表达的，所以最终工作后还是坚持将自己的学习收获写成文章表达出来，慢慢写多了就有一些感觉了，最终能够熟练地进行技术写作。 我个人对于编程也是这样，由于初高中时对于编程的痴迷，得以花费大量的课余时间学习编程。其实我还是比较笨的，例如高中时为了看懂一个非递归的枚举代码就花了近一个月。那个时候还坚持买《程序员》杂志，虽然大部分看不懂 &#x3D;。&#x3D; ，下图是今年春节回家在家里看到一本 11 年前买的《程序杂》杂志。 所以，你不需要一定擅长写作，只需要有一个喜欢表达和分享的心就可以。 对于爱好，李笑来的 《把时间当作朋友》 一书中的观点更加极端。他在书的第一章 “心智的力量” 中认为：只要人足够强大，能够控制自己的心智，那么就可以无视兴趣的力量，坚持做对自己有收获的事情，然后反而过由于长久坚持而收获成功，得到最终的满足感，最后通过满足感反过来得到兴趣。他的原话是： 只要一件事儿你能做好，并且做到比谁都好，或者至少比大多数人好，你没办法对那件事情没兴趣。 往往并不是有兴趣才能做好，而是做好了才有兴趣。 但是我终究认为人不是机器，我个人更喜欢随性一些，如果做 A 和 B 两件事情都能带来成功，我更倾向于用我个人的兴趣或直觉来选择，而不是 “控制心智”，完全理智地看 A 和 B 哪个收益更大。 本文接下来的部分是写给那些内心爱好写作与分享的朋友，以及那些能够 “控制心智” 的朋友。我们将讨论如何坚持写作。 如何坚持写作在有了兴趣之后，我们来解决上面 ABCD 四个朋友提出的各种问题，看如何能坚持写作。对于 ABCD 提出的各种问题，我们可以尝试以下这些解决办法： 对于不擅长写作的朋友，可以尝试刚开始不要写那么深入的文章，也不要太追求完美而忽略效率。写作能力的提高本来就循序渐进的，刚开始写简单一些，总归比不写要好得多。我刚开始的写作内容，就是尝试把苹果 WWDC 视频中的内容看懂后，用自己的话再讲一遍。慢慢的，就可以写一些原创的深入文章了。 对于觉得写作太花时间的朋友，可以尝试把写作内容变短。例如每天用 200-500 个字总结一些今天在技术上的收获。慢慢坚持，就可以提高自己的表达能力。我个人就喜欢用微博或微信公共帐号来发表简短的原创内容，虽然很多时候就是介绍一个架构或新闻，但是思考怎么用简短的几个字表达清楚，并且能吸引读者转发或阅读，也是能有不少小的提高的。 对于觉得写作收获不大的朋友，如果你把写作当爱好，就不应该计较收获了。另外，我认为写作的收获在早期可能不明显，但是当你的写作积累了一定量的时候，收获就会被成倍地放大，就像我现在这样。我从写作上获得的收入是巨大的。 对于不能坚持的朋友，也可以尝试上面说的方法 2，即每天写少量的内容，这样时间开销会比较少。 最后，学习和模仿别人的写法也是一个不错的提高方式，像 onevcat 和 池建强 的文章就比我写得风趣得多，我也在尝试多一些有趣的表达方式。 推荐最后推荐大家在有一定写作能力后，尝试给 InfoQ 网站 或 《程序员》 杂志投稿，通常他们对于稿件会有更加严格的审核，所以即使稿件被拒，也能让自己找到未来提高的地方。 当你给 InfoQ 的原创文章投稿超过 3 篇被发表后，就可以申请成为兼职编辑，InfoQ 编辑每月有一次集体的 “我是吃货” 聚会，各种海吃海喝之后，还可以和 InfoQ CEO Kevin、男神池建强、张龙老师、交际花显峰等其他编辑当面交流技术，实在是一次难得的机会。 每年 InfoQ 兼职编辑还可以用 3 篇原创稿件换取 5800 元的 QCon 门票，并可以采访 QCon 上来自全国各地的技术高手。比如今年的 QCon 会 上，我就 采访 了 《iOS 测试指南》 的作者羋峮。虽然大家看到了最终的 采访稿件，但是亲自面对面交流的收获很难完全体现在稿件中的，比如有一条羋峮对于测试的看法：“只测试需要测试的逻辑” 这一条，虽然只是采访之后随口所说，但对我的影响还是非常大的，但我很难将其思想体现在稿件中。 希望本文能让那些喜欢写作和分享的人，都能坚持自己的这个爱好，最终从中得到巨大的回报！ 愿大家玩得开心～","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"iOS应用安全开发概述","slug":"ios-security-dev-overview","date":"2014-05-08T13:27:23.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/05/08/ios-security-dev-overview/","permalink":"https://blog.devtang.com/2014/05/08/ios-security-dev-overview/","excerpt":"","text":"【摘要】：iOS 应用由于其直接运行在手机上，相比运行在服务器的后台服务，更有可能被黑客攻击。本文将从网络安全、本地文件和数据安全、源代码安全三个方面，阐述 iOS 应用在安全性上遇到的挑战。 前言在传统互联网领域，安全已经是一个老生常谈的话题。在许多大公司里面，都设置有专门的安全部门，用于检测自己产品的安全性。但即便是这样，业界仍然时常暴出许多安全问题的新闻。就在不久前，乌云 曝光了 携程网在支付过程中，为了调试方便，记录了用户的信用卡卡号和 CVV 码等信息，而调试接口可以被外网访问，这样造成黑客可能通过调试接口读取用户的信用卡信息。虽然最终没有造成实际上的用户损失，但是此次事件再一次给互联网公司敲响了安全的警钟。 除了国内，国外的互联网安全问题同样让人担忧。去年由于曝出 Apache Struts2 的漏洞，苹果公司多次重置开发者的密码，并且最终为了用户数据的安全，将整个开发者后台全部停止服务，花了 2 周多时间将后台有潜在问题的功能重写后，才重新开放服务。而 4 月份刚刚曝光的 OpenSSL 的 heart bleeding 漏洞，则让全球的三分之二的网站受到影响。 在移动互联网快速发展的今天，iOS 应用由于直接运行在用户的手机上，相比运行在服务器的后台服务，更有可能被黑客攻击。本文接下来将从三个方面概述 iOS 移动应用在安全方面所面临的挑战以及应对措施。 一、网络安全安全地传输用户密码大部分的 iOS 应用都需要联网，通过和服务器端进行通讯，获得最新的信息并且将内容展现给用户。由于网络传输过程中有可能经过不安全的中间节点，所以我们应该对敏感数据加密，用于保证用户信息的安全。黑客可以在受害者的手机上设置网络通讯的代理服务器，从而截获所有的网络请求。即使是 Https 的加密通讯，黑客也可以通过 中间人攻击（Man-in-the-middle attack，一种是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制）来截取通讯内容。 黑客可以在 Mac 下使用 Charles 软件（如果在 Windows 下，可以使用 fiddler 软件）来将自己的电脑设置成代理服务器，从而截取应用的网络请求，分析目标应用在通讯协议上是否有安全问题。为了测试，我选取了在国内最大的两家租车公司（神州租车 和 一嗨租车）的 iOS 应用。 从下图可以看到，神州租车和一嗨租车在用户登录时，均采用明文的方式，将密码直接发送给服务器。其中一嗨租车不但采用明文方式发送密码，而且在发送时使用了 Http Get 的方式，而 GET 的 URL 数据一般都会保存在服务器的 access log 中，所以黑客一旦攻破服务器，只需要扫描 acesss log，则可以轻易获得所有用户的明文密码。(注：在本文发表前，一嗨租车已经修改了登录协议，采用了 POST 的方式来登录，但仍然传递的是明文密码) 神州租车登录协议: 一嗨租车登录协议: 如果每一个移动移动都像以上两种应用那样，明文传输用户密码，那么我们可以想象这样一个场景，黑客在咖啡馆或机场等一些公共场所，将自己的电脑设置成该场所一样名字的免费 Wifi，那么受害者只要不小心使用了该 Wifi，则可能泄漏自己的明文密码。对于大多数普通人，都会使用一样的密码登录他的所有的帐号，这就意味着他的其他帐号：例如淘宝或网上银行帐号也有被盗的风险。 正确的做法应该是这样：事先生成一对用于加密的公私钥，客户端在登录时，使用公钥将用户的密码加密后，将密文传输到服务器。服务器使用私钥将密码解密，然后加盐 (Salt：在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符) 之后再多次求 MD5，之后再和服务器原来存储的用同样方法处理过的密码匹配，如果一致，则登录成功。这样的做法，保证黑客即使截获了加密后的密文，由于没有私钥，也无法还原出原始的密码。而服务器即使被黑客攻陷，黑客除了暴力尝试，也无法从加盐和多次 MD5 后的密码中还原出原始的密码。这样就保证了用户密码的安全。 防止通讯协议被轻易破解除了上面提到的明文传输密码的问题外，移动端应用还要面对黑客对于通讯协议的破解的威胁。在成功破解了通讯协议后，黑客可以模拟客户端登录，进而伪造一些用户行为，可能对用户数据造成危害。例如腾讯出品的消除游戏 “天天爱消除”，在淘宝上就有很多售价仅为 1 元的代练服务，如果真正是人工代练，是不可能卖这么便宜的，只有可能是该游戏的通讯协议被破解，黑客制作出了代练的机器人程序。 通讯协议被破解除了对于移动端游戏有严重危害外，对于应用也有很大的危害。例如针对微信，黑客可以制作一些僵尸帐号，通过向微信公共帐号后台发送垃圾广告，达到赢利目的。而 iPhone 设备上的 iMessage 通讯协议据也被破解了，所以很多 iPhone 用户会收到来自 iMessage 的垃圾广告。 对于以上提到的问题，开发者可以选择类似 protobuf (google 提供的一个开源数据交换格式，其最大的特点是基于二进制，因此比传统的 JSON 格式要短小得多) 之类的二进制通讯协议或者自己实现通讯协议，对于传输的内容进行一定程度的加密，以增加黑客破解协议的难度。下图是我截取的淘宝客户端的通讯数据，可以看到其中的值都不能直观地猜出内容，所以这对于通讯协议是有一定的保护作用。 验证应用内支付的凭证iOS 应用内支付 (IAP) 是众多应用赢利的方式，通过先让用户免费试用或试完，然后提供应用内支付来为愿意付费的用户提供更强大的功能，这种模式特别适合不习惯一开始就掏钱的中国用户。但是，由于国内越狱用户的比例比较大，所以我们也需要注意应用内支付环节中的安全问题。 简单来说，越狱后的手机由于没有沙盒作为保护，黑客可以对系统进行任意地修改，所以在支付过程中，苹果返回的已付款成功的凭证可能是伪造的。客户端拿到付款凭证之后，还需要将凭证上传到自己的服务器上，进行二次验证，以保证凭证的真实性。 另外，我们发现越狱用户的手机上，很可能被黑客用中间人攻击技术来劫持支付凭证。这对于黑客有什么好处呢？因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的帐号信息，所以我们的应用和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假的。所以在验证凭证时，哪个帐号发起了验证请求，我们就默认这个凭证是该帐号拥有的。如果黑客将凭证截获，就可以伪装成真实用户来验证凭证或者转手出售获利。 打个比方，这就类似于很多商场的购物卡一样，由于是不记名的，黑客如果将你买的购物卡偷窃然后去刷卡购物，商场是无法简单地区分出来的。 所以，对于应用内支付，开发者除了需要仔细地验证购买凭证外，也需要告知用户在越狱手机上进行支付的风险。 二、本地文件和数据安全程序文件的安全iOS 应用大部分的逻辑都是在编译后的二进制文件中，但是由于今年来混合式（Hybrid）编程方式的兴起，很多应用的部分功能也采用内嵌 Web 浏览器的方式来实现。例如腾讯 QQ iOS 客户端的内部，就有部分逻辑是用 Web 方式实现的。由于 iOS 安装文件其实就是一个 zip 包，所以我们可以通过解压，看到包内的内容。以下是我解开腾讯 QQ 客户端，看到的其 qqapi.js 文件的内容: iOSQQApi = &#123; // ... app: &#123; /** 查询单个应用是否已安装 @param &#123;String&#125; scheme 比如 &#x27;mqq&#x27; @return &#123;Boolean&#125; */ isAppInstalled: function(scheme) &#123; return iOSQQApi._invokeClientMethod( &#x27;app&#x27;, &#x27;isInstalled&#x27;, &#123;&#x27;scheme&#x27;:scheme&#125;); &#125;, /** 批量查询指定应用是否已安装 @param &#123;Array&lt;String&gt;&#125; schemes 比如 [&#x27;mqq&#x27;, &#x27;mqqapi&#x27;] @return &#123;Array&lt;Boolean&gt;&#125; */ isAppInstalledBatch: function(schemes) &#123; return iOSQQApi._invokeClientMethod( &#x27;app&#x27;,&#x27;batchIsInstalled&#x27;, &#123;&#x27;schemes&#x27;:schemes&#125;); &#125; &#125;, // ...&#125; 可以看到，这些文件都有着完整清晰的注释。通过分析这些 javascript 文件，黑客可以比较轻松地知道其调用逻辑。在越狱手机上，还可以修改这些 javascript 代码，达到攻击的目的。 笔者也曾经尝试查看支付宝客户端中的彩票功能，通过分析，也可以找到其完整的、带着清晰注释的 javascript 代码。如下图所示：（注：支付宝现在已经对相应代码进行了加密） 通过将 javascript 源码进行混淆和加密，可以防止黑客轻易地阅读和篡改相关的逻辑，也可以防止自己的 Web 端与 Native 端的通讯协议泄漏。 本地数据安全iOS 应用的数据在本地通常保存在本地文件或本地数据库中。如果对本地的数据不进行加密处理，很可能被黑客篡改。以下是一个名为 LepsWorld3 的游戏，打开它的本地文件，可以很容易地找到，它使用了一个名为 ItempLifes 的变量保存生命数。如下图所示： 于是我们就可以简单修改该值，达到修改游戏参数的目的。而在淘宝上，也可以找到许多以此挣钱的商家，如下图所示： 对于本地的重要数据，我们应该加密存储或者将其保存到 keychain 中，以保证其不被篡改。 三、源代码安全通过 file, class-dump, theos, otool 等工具，黑客可以分析已经编译之后的二进制程序文件，不过相对于这些工具来说，IDA 的威胁最大。 IDA 是一个收费的反汇编工具，对于 Objective-C 代码，它可以常常可以反汇编到可以方便阅读的程度，这对于程序的安全性，也是一个很大的危害。因为通过阅读源码，黑客可以更加方便地分析出应用的通讯协议和数据加密方式。 下图分别示例了一段代码的原始内容，以及通过 IDA 反汇编之后的结果。可以看到，IDA 几乎还原了原本的逻辑，而且可读性也非常高。 原始代码： if ([[VersionAgent sharedInstance] isUpgraded]) &#123; UpdateMigrationAgent *agent = [[UpdateMigrationAgent alloc] init]; [FileUtils clearCacheDirectory]; [[VersionAgent sharedInstance] saveAppVersion];&#125; 反汇编后： v6 = _objc_msgSend(&amp;OBJC_CLASS___VersionAgent, &quot;sharedInstance&quot;);v7 = objc_retainAutoreleasedReturnValue(v6);v41 = _objc_msgSend(v7, &quot;isUpgraded&quot;);objc_release(v7);if ( v41 )&#123; NSLog(CFSTR(&quot;app is upgraded&quot;), v41); _objc_msgSend(&amp;OBJC_CLASS___FileUtils, &quot;clearCacheDirectory&quot;); v8 = _objc_msgSend(&amp;OBJC_CLASS___VersionAgent, &quot;sharedInstance&quot;); v9 = objc_retainAutoreleasedReturnValue(v8); _objc_msgSend(v9, &quot;saveAppVersion&quot;); objc_release(v9);&#125; 反汇编的代码被获得后，由于软件内部逻辑相比汇编代码来说可读性高了很多。黑客可以用来制作软件的注册机，也可以更加方便地破解网络通讯协议，从而制作出机器人（僵尸）帐号。最极端的情况下，黑客可以将反汇编的代码稍加修改，植入木马，然后重新打包发布在一些越狱渠道上，这将对用户产生巨大的危害。 对于 IDA 这类工具，我们的应对措施就比较少了。除了可以用一些宏来简单混淆类名外，我们也可以将关键的逻辑用纯 C 实现。例如微信的 iOS 端的通讯底层，就是用 C 实现的。这样的方式除了能保证通讯协议安全外，也可以在 iOS 和 Android 等多个平台使用同一套底层通讯代码，达到复用的目的。 总结由于移动互联网的快速发展，人们的购物、理财等需求也在移动端出现，这使得移动应用的安全性越来越重要。由于部署在用户终端上，移动应用比服务器应用更容易被攻击，大家也需要在移动应用的网络通讯、本地文件和数据、源代码三方面做好防范，只有这样才能保证应用的安全。 版权说明本文已发表在《程序员》杂志 2014 年 5 月刊上，链接为：http://www.csdn.net/article/2014-04-30/2819573-The-Secret-Of-App-Dev-Security","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"专门针对越狱iOS设备的盗号木马出现","slug":"ios-jailbreak-trojan","date":"2014-04-18T16:27:38.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/04/19/ios-jailbreak-trojan/","permalink":"https://blog.devtang.com/2014/04/19/ios-jailbreak-trojan/","excerpt":"","text":"关于木马今天，国外的 iOS 开发者 @iOn1c 发现一个来自中国的开发者 “WANG XIN” 签名的 iOS 平台的木马插件，该插件是一个名为Unflod.dylib动态链接库，可以将越狱机器上的 Apple ID 用户名和密码盗取，并且发送到指定服务器上。这里 有该恶意插件的反汇编代码。这里 有关于该木马插件的详细分析。 检测与原理检查你的设备是否有该木马的方法：用iFile查看/Library/MobileSubstrate/DynamicLibraries/Unflod.dylib 文件是否存在，如果存在，请立即删除并且重新启动设备。 国外的越狱开发者也分析了一下该插件的工作原理，它通过监听所有的 SSL 协议，来截取用户的帐号和密码。所以理论上，该技术方案其实不光可以监听 Apple ID 帐号，还可以用来监听支付宝、微信等应用的帐号和密码。 感想自从 2010 年 7 月 26 日，美国版权局修改《千禧年数字版权法》中的豁免条款，认可了 iOS 越狱的合法性以后，国外越狱社区就一直在为了自由地使用 iPhone 设备努力。国外的 Cydia 商店不但提供了大量优秀的免费软件，也提供了付费的越狱软件的下载。越狱在国外，是与盗版严格划清界限的，大多数的越狱开发者，也都是为了更好的使用 iPhone 而开发相关软件。 但是在国内，大部分的越狱用户的目的还是停留在使用盗版软件上，这也反映出国人的版权意识薄弱以及法律对于知识产权保护的不力。相关的盗版软件渠道，不但能够堂堂正正的宣传 “海量正版软件游戏，全部免费安装”，而且有些公司还能被大公司以 上亿美金收购。只能说国内的环境实在是太奇葩。 以下是某助手的广告截图，你相信全部苹果游戏应用，本身就是免费的么？ 这次由中国开发者 “WANG XIN” 签名的这个木马插件，实在是让中国人自 “太极” 事件之后再次蒙羞。简单来说，就是坏了规矩。以后来自中国越狱开发者开发的正常越狱软件，将会受到更多潜在的 “歧视” 和 “关照”。而国外的开发者看中国市场，会更加坚定地认为这是一个盗版横行的市场，从而想办法特别 “关照” 中国用户或者直接像很多国外的游戏厂商那样，直接忽视中国市场。 建议最后回说安全这件事，笔者作为一个资深 iOS 开发者，建议一般普通用户，如果是为了用盗版软件就别越狱了，各种国内的越狱渠道都非常不安全的。 如果是开发者们为了研究安全而越狱的，最好也只是在专门研究用的 iTouch 上使用，以避免可能的安全风险。 虽然感觉那一天还比较遥远，但真心希望有一天，国内对于版权的保护能够开展起来，这对于整个中国互联网产业的发展，将会是一个极大的促进。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"从 Facebook 看移动开发的发展","slug":"mobile-development-view-from-facebook","date":"2014-04-16T12:37:59.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/04/16/mobile-development-view-from-facebook/","permalink":"https://blog.devtang.com/2014/04/16/mobile-development-view-from-facebook/","excerpt":"","text":"从 Facebook 谈起Facebook 最近绝对是互联网界的新闻明星。它首先是进行了大手笔的收购：2014 年 2 月，Facebook 以 160 亿美元现金加股票，以及 30 亿美元受限制股票福利的方式 收购移动 IM 应用 WhatsApp，总收购成本 190 亿美元。然后是继续发布了新产品：2014 年 2 月，Facebook 发布了一个新的移动端新闻阅读应用 Paper。最后，Facebook 最近还将自己使用的大量工具开源，包括开源了 Paper 的加载效果 Shimmer，LLDB 的增强工具 chisel，以及 Key-Value Observing 工具 KVOController，如果说这些开源工具让程序员如获至宝的话，那么 Facebook 将 Paper 的交互设计工具 Origami 免费开放，则是对广大设计师的福音，极大地方便了移动交互设计工作的开展。 2014 年对于 Facebook 来说也是一个值得纪念的日子。因为从 2004 年 2 月 4 日 Facebook 产品上线到现在，Facebook 刚刚走过 10 个年头。10 年前，Facebook 的创始人扎克伯格才 19 岁，是哈佛大学的一名学生。转眼间 10 年后，Facebook 已经成长为全球最大的社交网络，月活跃用户达到 12 亿，市值约 1200 亿美元。 业界内大多讨论的话题都围绕在 Facebook 收购 WhatsApp 这件事情上，而作为一个移动开发者，我更加看重 Facebook 发布 Paper 这件事情。因为 Paper 并不是一个简单的应用，它有着非常优秀的交互效果，并且在产品设计和技术上都使用了许多前沿的技术，那就让我们看看，Paper 的开发到底有何不同之处？ 交互设计我们首先从产品设计上看 Paper 的不同之处。Paper 虽然只是一个新闻客户端，但从大家对 Paper 的评价上，我们发现优秀的交互再一次成为大家关注的焦点。回想那些成功的应用，大多都有着令人心动的交互效果，例如：Tweetie 的下拉刷新，现在基本上成为 iPhone 上内容刷新的标准。Path 跳出来的红心让人心动，很多朋友甚至会没事点那个红心，欣赏那流畅的按钮散开效果。还有 Mailbox，用流畅的手势操作，将邮件管理与任务管理完美结合起来。 国外成功的优秀应用也在影响着国内。交互设计不同于平面设计，不能简单地用 Photoshop 展现，而交互设计对于移动应用的成功又异常关键，所以需要花费不少时间来设计，因此产品经理很难兼顾地做交互设计。所以，在国内的一线互联网公司里，交互设计师这个职位慢慢成了移动应用的标配。但是在大部分的非一线互联网公司里面，移动开发的设计仍然停留在由产品经理简单潦草的完成阶段。所以，Facebook 这次 Paper 的成功发布，再一次给移动开发的从业者指出了交互设计的重要性。 回顾中国互联网产业的发展我们可以发现，产品经理（Product Manager）这个职位也是最近五、六年才成为互联网公司的标配的，想必在不远的将来，除着交互设计越来越重要，移动交互设计师也会成为每一个互联网公司重要的必备职位。 另一方面，由于工具的欠缺，大量的交互设计师的工作效率非常低下，他们为了做出一个新颖的效果常常需要花费大量精力。这次 Facebook 免费开放出基于苹果 Quartz Composer 的增强工具集 Origami，使得交互设计工作得到更好的辅助。而且在 Facebook 的带动下，jQC 1.0 也出现了。jQC 是一个与 Facebook 之前开源的 Origami 兼容的工具，提供了 15 个新的 Patch 来提高 Quartz Composer 的功能。 不过另一方面，该工具仍然需要设计师具备一定的基础编码能力，所以对于广大设计师来说，交互设计工具 Origami 对设计师带来的既是机会，同时也是挑战。 移动开发技术随着 iOS 依赖管理工具 Cocoapods 和大量第三方开源库成熟起来，业界积累了大量的优秀开源项目。这次 Facebook 开发 Paper 使用了 将近 100 个第三方开源库，极大地减化了自己的应用开发任务。相信随着移动开发的发展，移动开发的生态圈会越来越成熟，基础的开源组件也将将越来越丰富，广大开发者都将从中受益。 另一方面，Facebook 的工程师在 Quora 上反馈 说 Paper 在 Xcode 下打开需要 40 多秒钟，编译一次需要 30 分钟。这反映出大量的开源库的使用也给 iOS 集成编译环境 Xcode 提出了新的挑战，相信苹果会花大力气解决 Xcode 的性能问题。 总结Facebook 发布的 Paper 让我看到了移动开发领域的快速发展，大量新的工具和开源技术给了设计师和程序员机会和挑战，相信在移动互联网快速发展的浪潮中，会涌现出越来越多优秀的移动应用。谁会是未来移动互联网的霸主？让我们拭目以待。 版权说明本文已发表在《程序员》杂志 2014 年 4 月刊上，链接为：http://www.csdn.net/article/2014-04-16/2819341","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"Mac重装记录","slug":"install-mavericks-note","date":"2014-04-12T09:00:20.000Z","updated":"2024-01-06T14:52:37.917Z","comments":true,"path":"2014/04/12/install-mavericks-note/","permalink":"https://blog.devtang.com/2014/04/12/install-mavericks-note/","excerpt":"","text":"前言上次将我的iMac硬盘换成SSD后，我是通过迁移助理将我的Mac Book Air的环境同步过去的，不知道为什么，半个月前出现了重启后电脑一直处于加转中的状态。尝试过了网上提供的以下方法都没有效果： 启动时按住Shift键进入安全模式（没能进入） 同时按下 Command、Option、P 与 R 键不放（成功执行，但还是无法进入系统） 按住 Command 键及 S 键，进入单用户模式（成功进入，但是把“&#x2F;资源库&#x2F;StartupItems”与“&#x2F;系统&#x2F;资源库&#x2F;StartupItems”都清除，以及清除了com.apple.loginwindow.plist 和com.apple.windowserver.plist后，但还是无法通过正常启动进入系统） 在单用户模式中修复磁盘，没有发现磁盘问题 于是我做了一次覆盖安装，之后可以使用了，但昨天电脑又无法进入系统了。于是我打算格盘后做一次完全的重装，在此记录下自己的重装过程。 备份数据由于我能够通过启动时按Command 键及 S 键，进入单用户模式，所以我首先把自己未提交的工程代码通过U盘备份出来了，具体步骤如下： 按住 Command 键及 S 键不放，以“单一使用者模式”开机。 加载磁盘：mount -uw / 新建一个U盘的加载目的文件夹： mkdir /usb 插入U盘，然后用如下命令加载U盘 mount_msdos /dev/disk1s1 /usb （如果你的U盘不是msdos格式，可以尝试在输入mount_后，按两次tab查看可用的其它格式） 备份资料：cp -r ~/work/iphone /usb 弹出U盘：umount /dev/disk1s1 将U盘资料放到别的电脑上，然后准备用来下一步制作安装盘 制作安装盘 苹果的操作系统其实可以直接通过网络恢复，考虑到恢复时间实在太长，所以最好制作成安装盘，这样安装起来非常快。 准备好一个8G以上的空白U盘，准备好另外一台Mac电脑用来制作安装盘。 新的操作系统Mavericks.app可以在AppStore上直接下载。在另一台电脑上把文件下载好，下载后文件Mavericks.app应该在你的/Applications目录下。 插入U盘，执行：sudo /Applications/Install\\ OS\\ X\\ Mavericks.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ Mavericks.app --nointeraction 以上命令会将U盘先格式化，然后制作成安装盘，整个过程大概需要40分钟左右。 安装系统 插入上一步制作好的U盘 启动时按住 option 键，然后选择通过U盘启动，之后先进入磁盘工具里面把硬盘格式化了（你也可以选择不格式化，这样就是覆盖安装） 安装系统。整个安装过程大概要30分钟的样子。 安装软件 安装好系统后，首先进入AppStore升级系统，把需要的更新补丁都装了。然后通过AppStore的”Purchases”页面，重新安装以前购买过的应用，我主要装的是 qq、evernote、Alfred、MplayerX、Xcode、Dash、Keynote、有道词典。另外通过网页另外下载了QQ的五笔输入法。 接下来的基本上是命令行的安装，Mac下管理命令行工具首先得装homebrew了： ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 安装完之后执行一下brew doctor进行一下自检，看有没有什么异常。没问题就开始安装axel, imagemagick, autojump等命令行工具： brew install wgetbrew install axelbrew install imagemagickbrew install autojump 有些程序(例如老版本的ruby需要使用gcc来编译)，通过以下命令安装老版的gcc： brew tap homebrew/dupes brew install apple-gcc42 使用brew cask来安装应用之前专门写文章介绍过brew cask, 这次打算试试常用软件都用它来装，首先安装brew cask: brew tap phinze/caskbrew install brew-cask 然后设置alfred，把 /opt/homebrew-cask增加到 alfred 的search目录中，然后就可以用alfred来启动安装后的应用了。 接下来用brew cask安装： brew cask install iterm2brew cask install dropboxbrew cask install google-chromebrew cask install sublime-textbrew cask install moubrew cask install xtrafinderbrew cask install charlesbrew cask install revealbrew cask install xscopebrew cask install sparrow 使用zsh然后是使用zsh，下载安装ohmyzsh: curl -L http://install.ohmyz.sh | sh 安装完成之后，vim ~/.zshrc ，除了git插件外，另外增加 osx 和 autojump 插件。然后把以下这行注释启用：export LANG=en_US.UTF-8 ，否则命令行中的中文可能会乱码。 同步数据挂上VPN之后，打开chrome，然后同步自己的所有信息，chrome的同步挺赞的，包括书签，插件，浏览历史记录以及保存的密码都同步过来了。 打开evernote和dropbox，同步数据。由于我的个人文档都存在它们里面，所以同步过来还是挺方便的。 打开QQ，将漫游的聊天记录同步过来。打开dash，恢复购买，然后把snippet从dropbox同步过来。 将自己的ssh key从原来的机器上复制过来。 设置Ruby由于我的博客使用Octopress搭建，所以需要安装Ruby： brew updatebrew install rbenvbrew install ruby-buildrbenv install 1.9.3-p0rbenv local 1.9.3-p0rbenv rehashgem install bundlerrbenv rehashbundle install 结束语一切完成之后，我写下了本文，希望能帮助大家快速地重装系统。简单来说： 通过evernote、dropbox和chrome将个人数据保存在云端后，重装后能快速恢复环境。 通过homebrew和基于homebrew的brew cask，可以方便地帮助你快速安装不在AppStore上销售的软件。 其实正常情况下，Mac使用迁移助理或Time Machine恢复非常方便，如果不是万不得已，大家也不用像我这样重装系统。","categories":[{"name":"mac","slug":"mac","permalink":"https://blog.devtang.com/categories/mac/"}],"tags":[]},{"title":"NSNumber对象缓存以及Tagged Pointer","slug":"weak_object_lifecycle_and_tagged_pointer","date":"2014-03-21T13:09:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"2014/03/21/weak_object_lifecycle_and_tagged_pointer/","permalink":"https://blog.devtang.com/2014/03/21/weak_object_lifecycle_and_tagged_pointer/","excerpt":"","text":"这是一次和 @onevcat 的技术讨论总结。技术点比较散，但是还都比较有意思。涉及的技术细节包括： 系统对象的缓存 Tagged Pointer对象 讨论一：autorelase对象按照苹果的编程约定，由非alloc,copy返回的对象都是autorelease的，所以对于以下代码，虽然变量number是__weak的，但是由于[NSNumber numberWithInt:100]返回的对象是autorelase的，所以仍然能通过NSLog打印出来。 __weak NSNumber *number = [NSNumber numberWithInt:100];NSLog(@&quot;number = %@&quot;, number); 从汇编代码中看，以上代码在创建number变量时，是通过objc_loadWeak方法进行的。而根据 Clang的官方文档，objc_loadWeak方法会retain并autorelease这个对象。所以给一个weak对象赋值，它并不会马上释放，而是会放到autorelease pool中，与autorelease pool一起释放。 如下是objc_loadWeak的代码示例： id objc_loadWeak(id *object) &#123; return objc_autorelease(objc_loadWeakRetained(object));&#125; 为了验证这个回答，我们又做了一个有趣的例子来验证，如下所示： __weak NSNumber *number;@autoreleasepool &#123; number = [NSNumber numberWithInt:100];&#125;NSLog(@&quot;number = %@&quot;, number); 在上面这个例子中，果然如我们所料，number在通过NSLog查看值时，变成了nil。 讨论二：关于NSNumber对象的缓存我们在做以上实验时，发现一个有趣的现象，如果你把100变成了10，则number变成在NSLog时，就能够输出值来，不再是nil了。如下是测试代码： __weak NSNumber *number;@autoreleasepool &#123; number = [NSNumber numberWithInt:10];&#125;NSLog(@&quot;number = %@&quot;, number); 经过 onevcat 的实验，从-1 ～ 12都是可以输出的，而其它值却会变成nil。于是我们猜测是系统对这些常见值的对象做了缓存，于是我们写了如下代码来验证。 结果果然是这样，多次创建值为10的NSNumber对象，其地址都是一样的。而多次创建值为100的NSNumber对象，每次创建获得的对象地址都是不一样的。 NSNumber *number = [NSNumber numberWithInt:10];NSNumber *another = [NSNumber numberWithInt:10];NSLog(@&quot;%p %p&quot;, number, another);number = [NSNumber numberWithInt:100];another = [NSNumber numberWithInt:100];NSLog(@&quot;%p %p&quot;, number, another); 讨论三：64位系统与Tagged Pointer对象讨论本来已经结束了，结果我在写这篇博客的时候，手贱又测试了一下，发现在64位的模拟器下，无论创建多少次，也无论int的值是多少，所有相同int值的NSNumber对象地址都是一样的！ 疑惑了几分钟，我突然想起WWDC中介绍的64位系统引放的Tagged Pointer，恍然大悟。 在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了Tagged Pointer。Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。 在64位系统中，如果我们真正使用一个指针来存储NSNumber实例，那么我们首先需要一个8字节的指针，另外需要一块内存存储NSNumber实例，这通常又是8字节。这样的内存开销是比较大的。苹果对于NSNumber和NSDate对象，改成了用Tagged Pointer来存储，简单来说，Tagged Pointer是一个假的指针，它的值不再是另一个地址，而就是对应变量的值。 Tagged Pointer主要有以下3个特点： Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已！所以，它的内存并不存储在堆中，也不需要malloc和free。 在内存读取上有着3倍的效率（以前是寻址-&gt;发消息-&gt;获取值，现在直接获取值），创建时比以前快106倍。 相关英文文档截图如下： 但Tagged Pointer的引入也带来了问题，即Tagged Pointer因为并不是真正的对象，而是一个伪对象，所以你如果完全把它当成对象来使，可能会让它露马脚。比如我在《Objective-C对象模型及应用》一文中就写道，所有对象都有 isa 指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。 因为不是真正的对象，所以如果你直接访问Tagged Pointer的isa成员的话，在编译时将会有如下警告： 对于上面的写法，应该换成相应的方法调用，如 isKindOfClass 和 object_getClass，如下图所示： 至此，所有疑问都已经解决，开心～ 另外这儿有一篇介绍Tagged Pointer的文章：《64位与Tagged Pointer》，一并推荐给大家。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"使用brew cask来安装Mac应用","slug":"the-introduction-of-homebrew-and-brewcask","date":"2014-02-26T13:38:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"2014/02/26/the-introduction-of-homebrew-and-brewcask/","permalink":"https://blog.devtang.com/2014/02/26/the-introduction-of-homebrew-and-brewcask/","excerpt":"简介brew cask 是一个用命令行管理 Mac 下应用的工具，它是基于 homebrew 的一个增强工具。 homebrew可以管理 Mac 下的命令行工具，例如imagemagick, nodejs，如下所示： brew install imagemagickbrew install node 而使用上brew cask之后，你还可以用它来管理 Mac 下的 Gui 程序，例如qq, chrome, evernote等，如下所示： brew cask install qqbrew cask install google-chromebrew cask install evernote","text":"简介brew cask 是一个用命令行管理 Mac 下应用的工具，它是基于 homebrew 的一个增强工具。 homebrew可以管理 Mac 下的命令行工具，例如imagemagick, nodejs，如下所示： brew install imagemagickbrew install node 而使用上brew cask之后，你还可以用它来管理 Mac 下的 Gui 程序，例如qq, chrome, evernote等，如下所示： brew cask install qqbrew cask install google-chromebrew cask install evernote 安装安装 homebrew用以下一行命令即可安装 homebrew ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 之后执行 brew doctor 命令可以看看homebrew的环境是否正常。通常第一次安装完 brew 之后，还需要安装苹果的Command Line Tools。 安装 cask用如下命令来安装 cask: brew tap phinze/caskbrew install brew-cask LaunchRocket另外再附带推荐一个工具。 LaunchRocket 是一个管理 brew 安装的 service 的工具，安装之后可以看所有的 service 的运行状态，如下图所示： 安装LaunchRocket就要用到我刚刚提的brew cask，用如下命令即可： brew tap jimbojsb/launchrocketbrew cask install launchrocket 之后 LauchRocket 设置页面找到（如下图所示），它的启动项同时也保存在/opt/homebrew-cask/Caskroom/launchrocket目录中。 启动 LauchRocket 有点麻烦，需要切换设置页面去手工启动。我自己想到一个办法，方法是把 /opt/homebrew-cask增加到 alfred 的 search 目录中，然后就可以用 alfred 来启动了，如下所示： 设置 alfred 用 alfred 启动 LauchRocket 大家玩得开心～","categories":[{"name":"mac","slug":"mac","permalink":"https://blog.devtang.com/categories/mac/"}],"tags":[]},{"title":"ReactiveCocoa - iOS开发的新框架","slug":"reactivecocoa-introduction","date":"2014-02-11T10:47:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"2014/02/11/reactivecocoa-introduction/","permalink":"https://blog.devtang.com/2014/02/11/reactivecocoa-introduction/","excerpt":"本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 什么是 ReactiveCocoaReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。 ReactiveCocoa 试图解决什么问题经过一段时间的研究，我认为 ReactiveCocoa 试图解决以下 3 个问题： 传统 iOS 开发过程中，状态以及状态之间依赖过多的问题 传统 MVC 架构的问题：Controller 比较复杂，可测试性差 提供统一的消息传递机制","text":"本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 什么是 ReactiveCocoaReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。 ReactiveCocoa 试图解决什么问题经过一段时间的研究，我认为 ReactiveCocoa 试图解决以下 3 个问题： 传统 iOS 开发过程中，状态以及状态之间依赖过多的问题 传统 MVC 架构的问题：Controller 比较复杂，可测试性差 提供统一的消息传递机制 传统 iOS 开发过程中，状态以及状态之间依赖过多的问题我们在开发 iOS 应用时，一个界面元素的状态很可能受多个其它界面元素或后台状态的影响。 例如，在用户帐户的登录界面，通常会有 2 个输入框（分别输入帐号和密码）和一个登录按钮。如果我们要加入一个限制条件：当用户输入完帐号和密码，并且登录的网络请求还未发出时，确定按钮才可以点击。通常情况下，我们需要监听这两个输入框的状态变化以及登录的网络请求状态，然后修改另一个控件的enabled状态。 传统的写法如下（该示例代码修改自 ReactiveCocoa 官网 ） ： static void *ObservationContext = &amp;ObservationContext;- (void)viewDidLoad &#123; [super viewDidLoad]; [LoginManager.sharedManager addObserver:self forKeyPath:@&quot;loggingIn&quot; options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext]; [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged]; [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];&#125;- (void)updateLogInButton &#123; BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0; BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn; self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if (context == ObservationContext) &#123; [self updateLogInButton]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; RAC 通过引入信号（Signal）的概念，来代替传统 iOS 开发中对于控件状态变化检查的代理（delegate）模式或 target-action 模式。因为 RAC 的信号是可以组合（combine）的，所以可以轻松地构造出另一个新的信号出来，然后将按钮的enabled状态与新的信号绑定。如下所示： RAC(self.logInButton, enabled) = [RACSignal combineLatest:@[ self.usernameTextField.rac_textSignal, self.passwordTextField.rac_textSignal, RACObserve(LoginManager.sharedManager, loggingIn), RACObserve(self, loggedIn) ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) &#123; return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue); &#125;]; 可以看到，在引入 RAC 之后，以前散落在action-target或 KVO 的回调函数中的判断逻辑被统一到了一起，从而使得登录按钮的enabled状态被更加清晰地表达了出来。 除了组合（combine）之外，RAC 的信号还支持链式（chaining）和过滤（filter)，以方便将信号进行进一步处理。 试图解决 MVC 框架的问题对于传统的 Model-View-Controller 的框架，Controller 很容易变得比较庞大和复杂。由于 Controller 承担了 Model 和 View 之间的桥梁作用，所以 Controller 常常与对应的 View 和 Model 的耦合度非常高，这同时也造成对其做单元测试非常不容易，对 iOS 工程的单元测试大多都只在一些工具类或与界面无关的逻辑类中进行。 RAC 的信号机制很容易将某一个 Model 变量的变化与界面关联，所以非常容易应用 Model-View-ViewModel 框架。通过引入 ViewModel 层，然后用 RAC 将 ViewModel 与 View 关联，View 层的变化可以直接响应 ViewModel 层的变化，这使得 Controller 变得更加简单，由于 View 不再与 Model 绑定，也增加了 View 的可重用性。 因为引入了 ViewModel 层，所以单元测试可以在 ViewModel 层进行，iOS 工程的可测试性也大大增强了。InfoQ 也曾撰文介绍过 MVVM：《MVVM 启示录》 。 统一消息传递机制iOS 开发中有着各种消息传递机制，包括 KVO、Notification、delegation、block 以及 target-action 方式。各种消息传递机制使得开发者在做具体选择时感到困惑，例如在 objc.io 上就有 专门撰文（破船的翻译 ），介绍各种消息传递机制之间的差异性。 RAC 将传统的 UI 控件事件进行了封装，使得以上各种消息传递机制都可以用 RAC 来完成。示例代码如下： // KVO[RACObserve(self, username) subscribeNext:^(id x) &#123; NSLog(@&quot; 成员变量 username 被修改成了：%@&quot;, x);&#125;];// target-actionself.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@&quot; 按钮被点击 &quot;); return [RACSignal empty];&#125;];// Notification[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardDidChangeFrameNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@&quot; 键盘 Frame 改变 &quot;); &#125;];// Delegate[[self rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) &#123; debugLog(@&quot;viewWillAppear 方法被调用 %@&quot;, x);&#125;]; RAC 的RACSignal 类也提供了createSignal方法来让用户创建自定义的信号，如下代码创建了一个下载指定网站内容的信号。 -(RACSignal *)urlResults &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSError *error; NSString *result = [NSString stringWithContentsOfURL:[NSURL URLWithString:@&quot;http://www.devtang.com&quot;] encoding:NSUTF8StringEncoding error:&amp;error]; NSLog(@&quot;download&quot;); if (!result) &#123; [subscriber sendError:error]; &#125; else &#123; [subscriber sendNext:result]; [subscriber sendCompleted]; &#125; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot;clean up&quot;); &#125;]; &#125;];&#125; 如何使用 ReactiveCocoaReactiveCocoa 可以在 iOS 和 OS X 的应用开发中使用，对于 iOS 开发者，可以将 RAC 源码 下载编译后，使用编译好的libReactiveCocoa-iOS.a文件。 开发者也可以用 CocoaPods 来设置目标工程对 ReactiveCocoa 的依赖，只需要编辑 Podfile 文件，增加如下内容即可： pod &#x27;ReactiveCocoa&#x27; ReactiveCocoa 的特点RAC 在应用中大量使用了 block，由于 Objective-C 语言的内存管理是基于 引用计数 的，为了避免循环引用问题，在 block 中如果要引用 self，需要使用@weakify(self)和@strongify(self)来避免强引用。另外，在使用时应该注意 block 的嵌套层数，不恰当的滥用多层嵌套 block 可能给程序的可维护性带来灾难。 RAC 的编程方式和传统的 MVC 方式差异巨大，所以需要较长的学习时间。并且，业界内对于 RAC 并没有广泛应用，这造成可供参考的项目和教程比较欠缺。另外，RAC 项目本身也还在快速演进当中，1.x 版本和 2.x 版本 API 改动了许多，3.0 版本也正在快速开发中，对它的使用也需要考虑后期的升级维护问题。 作为一个 iOS 开发领域的新开源框架，ReactiveCocoa 带来了函数式编程和响应式编程的思想，值得大家关注并且学习。 一些学习资源博客 &amp; 教程 http://spin.atomicobject.com/2014/02/03/objective-c-delegate-pattern/ http://blog.bignerdranch.com/4549-data-driven-ios-development-reactivecocoa/ http://en.wikipedia.org/wiki/Functional_reactive_programming http://www.teehanlax.com/blog/reactivecocoa/ http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/ http://nshipster.com/reactivecocoa/ http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/ https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013 http://msdn.microsoft.com/en-us/library/hh848246.aspx http://www.itiger.me/?p=38 http://blog.leezhong.com/ios/2013/12/27/reactivecocoa-2.html https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md http://www.haskell.org/haskellwiki/Functional_Reactive_Programming http://blog.zhaojie.me/2009/09/functional-reactive-programming-for-csharp.html 代码 https://github.com/Machx/MVVM-IOS-Example https://github.com/ReactiveCocoa/RACiOSDemo 书籍 https://leanpub.com/iosfrp 视频 http://vimeo.com/65637501","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"自己动手给iMac换SSD","slug":"add-ssd-to-old-imac","date":"2014-01-26T14:06:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"2014/01/26/add-ssd-to-old-imac/","permalink":"https://blog.devtang.com/2014/01/26/add-ssd-to-old-imac/","excerpt":"公司的 iMac 是 2011 年款的，经过 2 年的使用，现在已经变得比较慢了，用htop看了一下，其实 cpu 占用率一直不高，主要是磁盘 IO 比较慢，所以考虑自己动手给 iMac 换一个 SSD。在此将整个过程分享给大家。","text":"公司的 iMac 是 2011 年款的，经过 2 年的使用，现在已经变得比较慢了，用htop看了一下，其实 cpu 占用率一直不高，主要是磁盘 IO 比较慢，所以考虑自己动手给 iMac 换一个 SSD。在此将整个过程分享给大家。 如果你需要备份系统，可以拿一个移动硬盘，使用Time Machine功能将需要的内容备份到移动硬盘上。 另外你还需要准备一些工具，我是借同事的 老 A 苹果拆机工具组合，这个工具箱可以拆苹果的各种设备，上次还用它拆了一次 iPhone4s。 硬件更换步骤换 SSD 的步骤主要参考自：ifixit 上的教程。感兴趣的朋友可以一试。其实步骤相当简单，简单说一下： 把 iMac 平放，用吸盘吸开屏幕盖。 取下屏幕左右各 4 个螺丝，然后轻轻抬起屏幕（注意不要抬太高，因为后面连着线）。 把屏幕与主版连接的 4 根线拆下来，之后将屏幕移除。 取下硬盘上的 2 个螺丝，然后将硬盘的数据线和电源线拔掉，将硬盘轻轻取出来。 将 SSD 接上数据线和电源线。 做步骤 3 的逆向过程，把屏幕接上 4 根线，然后将屏幕左右各 4 个螺丝拧上。 盖上屏幕盖，这个磁力很强，要小心手不要被夹住。 换好之后，接通电源听到正常的启动声音的话，就表示硬件自检没问题了。 安装操作系统SSD 上没有带 Mac 系统，所以要先把系统装上去。将苹果最新的系统刻录在 U 盘或 SD 卡上，然后接到 iMac 上。启动时按住Option键，等一段时间，就可以选择启动磁盘，我们选择从 U 盘启动。 U 盘启动之后，先进入Disk Utility，将刚刚装上的 SSD 分区格式化成Mac OS 扩展（日志式）。然后返回，选择安装 Mac 操作系统。 这个比较坑的一点是系统显示的估计安装时间只有大约 15 分钟，但是进行到最后 1 分钟时，却大概要再等 15 分钟才能结束，这个时候不要太心急。安装完成之后会进入第一次重启，然后再次显示正在安装，这个时候大概又需要等 20 分钟，不过不用任何操作，只用看着就行了。20 分钟后会第二次重启，重启之后就进入到欢迎界面了。 进入欢迎界面后，先简单设置一下进入系统，安装 2 个小软件： SSD fan control Trim Enabler 这主要是因为 iMac 的温度感应模块在原有的硬盘上，换下来之后，风扇就会狂转，只能用第三方软件来控制其转速。另一个工具是朋友推荐我安装的，没有仔细研究用处。 迁移数据之后，你可以用Time machine或迁移助理，将这台电脑的数据从备份中恢复。我是使用的迁移助理，将我另一台 Macbook Air 的系统恢复过去的。 其它 我换的是 21.5 寸的 iMac，如果是 27 寸的 iMac，因为内部空间足够，所以可以尝试将 SSD 和原有的硬盘都保留，这样就可以自己组fusion drive。不过更换方式就要相对麻烦一些，感觉兴趣的可以自己在 ifixit 上找相关的教程。 显示屏上的连接线都很脆弱，更换的时候要小心，我在尝试能否象 27 寸 iMac 一样同时将原有硬盘和 SSD 保留的时候，就不小心压坏了显示屏上的连接线的一根针角。于是花了 80 块钱在 淘宝 上重新买了一根线才安好。所以大家一定别着急，换的时候小心一些。附一张损坏的连接线照片。 总之，自动动手换 SSD 不是那么复杂，胆大心细一些就可以轻松搞定。","categories":[{"name":"mac","slug":"mac","permalink":"https://blog.devtang.com/categories/mac/"}],"tags":[]},{"title":"非换行空格在CoreText排版上的问题","slug":"the-issue-of-non-breaking-space-in-coretext","date":"2014-01-23T09:36:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"2014/01/23/the-issue-of-non-breaking-space-in-coretext/","permalink":"https://blog.devtang.com/2014/01/23/the-issue-of-non-breaking-space-in-coretext/","excerpt":"分享一个在使用 Core Text 时遇到的问题。 问题描述我们的猿题库界面因为有图片、公式需要混排，所以用的是 Core Text 实现的排版。 在使用中，发现一些英文题目的换行方式不对，我们设置的是按单词换行，但是总是有些题目的换行并不是按单词的，造成显示上比较错乱，如下图所示。图中 unchangeable, study, falls 三个单词都被生生截断了，造成阅读上的不适。","text":"分享一个在使用 Core Text 时遇到的问题。 问题描述我们的猿题库界面因为有图片、公式需要混排，所以用的是 Core Text 实现的排版。 在使用中，发现一些英文题目的换行方式不对，我们设置的是按单词换行，但是总是有些题目的换行并不是按单词的，造成显示上比较错乱，如下图所示。图中 unchangeable, study, falls 三个单词都被生生截断了，造成阅读上的不适。 解决方案经过我们的分析，我们最终发现这是由于题目内容中有 非换行空格（non-breaking-space）造成的。根据 wikipedia 上的介绍，该字符的 ASCII 码为 160，主要做用如下： Text-processing software typically assumes that an automatic line break may be inserted anywhere a space character occurs; a non-breaking space prevents this from happening (provided the software recognizes the character). For example, if the text “100 km” will not quite fit at the end of a line, the software may insert a line break between “100” and “km”. To avoid this undesirable behaviour, the editor may choose to use a non-breaking space between “100” and “km”. This guarantees that the text “100 km” will not be broken: if it does not fit at the end of a line it is moved in its entirety to the next line. 于是我们大概知道整个原因了：编辑在后台录入题目时，是在网页做的富文本编辑器里面，里面的空格输入的是 &amp;nbsp;，然后这个空格转存到数据库中会转成 非换行空格（non-breaking-space），也就是 ASCII 为 160 的空格。最后传到 iPhone 这边，用 Core Text 排版时，Core Text 认为遇到这个空白符不应该换行，于是就一直不换行，直到显示不了了才强制换行，就造成了单词被截断。 解决办法是在客户端上用以下代码将这种空格替换成普通的空格，普通的空格 ASCII 码为 32。（附：ASCII 码表）： // 因为显示效果原因，从直观上看不出 2 个空格在编码上的差异，不过代码复制到 Xcode 中能看出来。NSString *content = ...content = [content stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot; &quot;]; 最终改好的效果如下所示： 其它感谢 @onevcat 提供信息，让我找到问题的根源。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"作为码农，我们为什么要写作","slug":"why-we-need-write","date":"2014-01-08T13:51:00.000Z","updated":"2024-01-06T14:52:37.916Z","comments":true,"path":"2014/01/08/why-we-need-write/","permalink":"https://blog.devtang.com/2014/01/08/why-we-need-write/","excerpt":"在程序员这个行业，坚持做技术写作的人一直比较少。我和身边的朋友沟通后，发现他们除了借口没有时间外，大多没有意识到写作带来的收益。在他们看来，将自己学到的知识简单记录下来就足够自己需要的时候回顾了。而技术写作通常需要花更多时间，因为需要将技术的细节以及来龙去脉讲清楚。 不得不承认，这的确是一个事实，通常情况下，把一个知识讲清楚比理解它更难。那我们为什么要花时间写作呢？我想写作至少有以下好处。","text":"在程序员这个行业，坚持做技术写作的人一直比较少。我和身边的朋友沟通后，发现他们除了借口没有时间外，大多没有意识到写作带来的收益。在他们看来，将自己学到的知识简单记录下来就足够自己需要的时候回顾了。而技术写作通常需要花更多时间，因为需要将技术的细节以及来龙去脉讲清楚。 不得不承认，这的确是一个事实，通常情况下，把一个知识讲清楚比理解它更难。那我们为什么要花时间写作呢？我想写作至少有以下好处。 提高自己对知识的掌握层次美国教育心理学家 Bloom 将知识认知分为了两个维度，其中认知历程维度又分为 6 个层次，分别为：记忆、理解、应用、分析、评鉴、创造。如下图所示，层次越高，表示对知识的掌握程度越深。 对于写作者来说，在写作过程中，因为需要对知识进行精确地表述，常常要对知识的细节再次的探索。在这个过程中，写作者可能会发现自己的观点不清晰的地方，通过二次学习，使自己的理解更加完善。写作者也可能会发现自己观点中的错误，从而改正自己的曲解。在经历过这段过程后，通常对于自己所写的知识的掌握程度，都上升了一个层次。 我自己的每次技术写作都经历了这样的提高过程。所以，我更多时候是把写作当成学习的一种方式。这种学习方式比普通的学习方式更加深入，效果更好。当然，花费的时间也更多。 提高表达和沟通的能力作为一个程序员，日常的工作大部分时间都是面对电脑。许多人周末也喜欢当一个技术宅，待在家里上网、看电影或者玩游戏来消遣。长时间的面对机器，使得我们的语言表达能力极度衰退。而写作是一个很好的机会，让我们练习自己的表达能力。 长时间写作之后，你会更加注意平时沟通的语言。你的用词更加精准，表达更加生动。在表达能力提高的同时，你的沟通效率也得到提高。 接受读者的沟通和反馈当你的文章通过博客或者 InfoQ 网站发表出来后，你就会接着获得写作的第三个好处：来自读者的沟通和反馈。一篇好的文章通常会吸引一些读者回复，通过和读者的交流，你可以收获以下好处： 错误内容反馈：尽管文章在写作时经历过二次学习，但是人难免会犯错。写作将你的思想完全暴露出来，有水平的读者可以指出你文章中的错误，从而使你对知识的理解更加准确。我的很多博客文章都有一些细微错误，通过读者的找反馈，我很快就将错误内容改正过来了，自己的水平也得到了提高。 认识朋友：一个乐于分享的人总会比沉默寡言的人更招人喜欢。所以通过写作，你可以结交很多和你一样，乐于分享的朋友。 了解更多相关信息：一些读者会回复说：” 某某框架也用了这个技术方案 “，或者是：” 你的这个实现方案没有另一个某某开源方案好 “。这些信息，作为你当前文章知识点的补充，使你能够了解更多相关的资料，再一次完善自己所学的知识。 影响力当你持续的写作，坚持一年以上，你就会慢慢收获影响力。这个时候，你也会收到技术大会的分享邀请，出版社的约稿邀请，著名互联网公司的工作邀请，甚至是创业项目的合伙人邀请。你相比那些不分享的人，获得了更多的机会。当然你的技术观点也会被更多人接受，你也会收获到传递知识的乐趣。 #结束语 在写作过程中，你将收获提高自己对知识的掌握层次和提高表达和沟通的能力的好处。 在写作结束后，你将收获错误内容反馈、认识朋友和了解更多相关信息的好处。 在坚持写作一段时间，你将收获影响力和传递知识的乐趣。 另外，《暗时间》 的作者刘未鹏在 他的文章，也总结了很多写作的好处，大家也可以看看。 看了写作的这么多好处，你是否心动？那赶快创建一个博客，开始你的技术写作之旅吧！","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://blog.devtang.com/tags/writing/"}]},{"title":"2013年个人总结","slug":"2013-summary","date":"2014-01-01T11:04:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2014/01/01/2013-summary/","permalink":"https://blog.devtang.com/2014/01/01/2013-summary/","excerpt":"2013这一年值得总结的有两方面的事情：一是技术分享和收获，二是创业感悟。 技术分享我这一年在技术分享上投入了更多的时间，也得到了非常大的收获。 我主要的技术分享渠道包括： 个人博客。今年一共完成了24篇原创博客。相比于去年的36篇，少了很多。主要是因为很多精力分散到微信公共帐号上去了。不过今年文章的质量相比去年更高了，写了包括《Objective-C对象模型及应用》和《谈Objective-C Block的实现》这类比较深入的文章。 InfoQ网站 。今年一共完成了7篇发表在InfoQ 上的稿件 , 其中原创技术文章4篇，翻译技术新闻1篇，采访稿2篇。","text":"2013这一年值得总结的有两方面的事情：一是技术分享和收获，二是创业感悟。 技术分享我这一年在技术分享上投入了更多的时间，也得到了非常大的收获。 我主要的技术分享渠道包括： 个人博客。今年一共完成了24篇原创博客。相比于去年的36篇，少了很多。主要是因为很多精力分散到微信公共帐号上去了。不过今年文章的质量相比去年更高了，写了包括《Objective-C对象模型及应用》和《谈Objective-C Block的实现》这类比较深入的文章。 InfoQ网站 。今年一共完成了7篇发表在InfoQ 上的稿件 , 其中原创技术文章4篇，翻译技术新闻1篇，采访稿2篇。 我的微信公共帐号：iOSDevTips，从2013年2月21日起，我坚持在这个微博公共帐号中发表iOS开发相关的技巧和文章。有时候是发送自己的文章，但大多数时候，都是一些别处看到的不错的分享转发给大家。坚持到现在快一年了，该公共帐号积累了5600名粉丝。我个人通过该公众帐号推送了140条iOS开发相关的文章。如果你做iOS开发，欢迎扫描下面的二维码关注我的公共帐号。 我的微博@唐巧_boy ，基本保证了不谈别的，只谈iOS开发。粉丝虽然没怎么涨（现在4400多粉），但是现在我的微博常常可以转发上百。2013年发了996条微博，总共被转发10120次，平均每条微博被转10次。这让我有一种莫名的感觉：我这个算是大号么？ 技术分享会。主要做了3次： 5月25日，在CocoaChina举办的线下聚会，分享了粉笔网的架构。 11月23日，在阿里技术沙龙 分享了 《iOS程序的逆向与安全》，这里有 视频录像 和 PDF版讲稿。 11月30日，在DIFF论坛分享了《如何将微信公众账号运营到5000粉丝》。 我主要的收获包括： 认识了大量的iOS开发同行，从他们身上我学到了很多知识。我再也没有刚刚创业时一个人做iOS开发的孤独感了。遇到问题时，除了google和stackoverflow外，实在不行也可以找小伙伴们求助。 因为向InfoQ投稿的原因，我有幸成为了InfoQ的兼职编辑，也认识了包括池建强、张龙等喜欢写作的大牛，交际圈子一下子扩大了不少。InfoQ时不时组织的编辑聚会也让我获得了一个了解大家不同声音和意见的渠道。对于一些行业信息，这种聚会中的小道消息总是比官方新闻要真实和靠谱得多。 InfoQ为编辑和讲师专门做了一次演讲培训，让我关注到自己从未注意到的领域，也珍惜起每次演讲的机会，努力提高自己的演讲技能。 因为写博客的关系，今年还持续收到来自出版社的约稿邀请，其实我一直想写一本iOS进阶开发方面的书，也一直在通过博客积累书稿的素材，所以最终水到渠成。我选择了和电子工业出版社签约。出版社的张老师永恒的侠少 也特别的开明，使我几乎没有写稿的压力，能够平衡好工作和写作的时间。希望在2014年，这本书能够和读者见面。 影响力变大了。以前我发一条微博，没有人转，现在随便就超过10次转发。有了影响力之后，大家有什么iOS开发的消息都会主动@我来求转发，使得我可以获得第一手的iOS开发相关的推荐。另外，当我说错什么话或者犯傻的时候，马上就有人来纠正我，使得我能够很快进步。 创业创业流水帐 2013年我们改变了方向，慢慢关停了粉笔网，然后专注地做猿题库相关的开发和运营。作为一个创业者，我一开始就有创业不顺利的预期，所以这次调整还是挺能接受的。不但能接受，我还非常佩服CEO李勇的果断，我们在粉笔网上几乎没有耗费什么过多的精力，就全力投到新项目猿题库上面了。 因为猿题库这个方向被证明还可行，所以2013是忙碌的一年，找到目标之后就是赶紧开发，我们在2013年春节上线了猿题库行测后，又花2个月上线了猿题库司考，之后花1个半月上线了通用课程平台。通用课程在7月1日上线，我们通过通用课程平台发布了猿题库考研政治、证券从业、初级会计、法律顾问、一级建造师5门课程。 之后我们又花了1个月完成了猿题库iPad版的开发。我们选择了将App做成Universal的形式来发布，使其能同时支持iPhone和iPad。 9月份我们发布了猿题库高考，之后我们将之前单独定制的猿题库行测和猿题库司考客户端融入到通用课程的项目中，使我们最终只用维护一套代码。 再之后，我们进入了功能改进阶段。其中比较大的事情包括增加夜间模式，字体调节，搜索功能，离线下载，数据缓存逻辑。 我们还将之前花大力气做的扫描答题卡功能去掉了，因为我们认为用户如果有精力在纸上填涂答题卡的话，还不如直接在手机上录入答案更为方便一些。虽然我之前在这个功能上耗费了大量精力，但我还是挺支持这个决定的。 最后，我们在年底前顺利拿到了B轮融资。 工作效率与身体我感觉通过番茄工作法和Rescue Time软件等软件，我已经将个人效率提高到极致了。我常常可以保持在电脑前面连续coding几个小时不分神，有些时候眼睛都发酸了，才想起要休息。另外，由于长期运动较少，我的肩膀问题比较多，动起来都会响。所以我不打算再提高效率了，再提高的话可能也不能提多少效率，而且会伤害身体。 我们团队也尽量保证晚上不加班的文化，所以身体还算吃得消，就是锻炼太少了。圣诞节的时候朋友回国，帮我带了一个Fitbit Force，希望通过它提醒我每天坚持运动。 个人能力的提高随着自己在iOS开发上的积累，在开发上的提高越来越慢，大部分的开发工作对我来说都不太有挑战了。而开发任务排得相当满，几乎没有留给我充电和学习的时间。我还是一个喜欢让自己一直处在学习状态的人，所以基本上就只有利用晚上和周末的时候来学习和积累了。 写作和分享是一个很好的激励方式，促进我通过发表文章的方式完成新知识的学习。不过这其实挺不能长久的，我还是希望是在工作中学习和进步，因为每天分配给工作的时间是最多的，业余时间毕竟相对较少。 我想对于创业的各种苦来说，这算是一个吧。对于这种苦，最好的解决方法就是努力让公司做大做强，只有公司做大了，你才有机会招更多人，同时做更多更有技术含量的事情。 拆分scrum团队随着团队人数的扩张，我们尝试了一次全体参加的计划会议，结果发现效率很低，于是我们将原来的srcum团队拆分成了2个团队，一个客户端团队，一个服务器端团队。团队拆分保证了每个团队都在10人以内的规模，沟通和讨论的效率都高了很多。强烈建议有同样困扰的朋友们尝试一下拆分团队，确实能使得会议更加高效。 优化发布速度我们从产品进入优化迭代期开始，尝试进行每周发布一个Beta版本的发布。Beta版本通过我们的论坛发布，越狱的iPhone用户以及Android用户可以通过论坛下载到最新的Beta版本。每完成4个Beta版，我们会将功能提交到AppStore审核。 每周一个Beta版本发布有利于保证质量，因为相比以前一个月一个版本的提测速度，测试可以尽早介入到新功能的测试中，有助于提早发现和修复bug。 但是每周一个Beta版本其实是压缩了开发时间，因为需要留时间给测试同事测试以及修复bug，以及最终要和服务器端配合上线。每周真正的开发时间通常只有3天半。 大部分时候，我们都会由于时间紧迫造成提测时间较晚，最终又造成修复bug时间不够，于是每周都会有一两天工作到很晚，上线Beta版那天，常常会到晚上10点以后，把实在没精力修复的Bug Later掉，才能完成上线。这样的状态非常伤身体，这段时间也是我比较难受的时期。 每周一个Beta版还有一个问题是无法保证那种大功能的开发，例如我们做离线下载功能，3天半根本无法完成，于是只能将这个功能在两周后的Beta版中提交。这又会涉及多分支的开发和管理，分支间来回切换，又会降低一些开发效率。 整体来说，每周一个Beta版的发布有利于保证产品质量，但是会造成整体的开发进度稍慢于每2周或每月一个版本的发布。如果又要保证开发进度一样，每周的Beta版发布将带来更多的加班工作。 控制自己的情绪，找准自己的定位我有一段时间过于有责任感了，感觉什么事情都应该关心，特别是项目进度。那段时间，我长期处于无法保证按时上线的焦虑状态，并且对产品和美术的调整异常敏感，因为他们的一句话，就表示我又要加班了。 我花了很长时间去转变自己对于项目按时上线的态度，现在，我更加关注自己做为开发者的身份，而不再过多考虑项目在进度上的问题。 当我发现我不再关注进度时，我的开发效率反而提高了，因为心情不再过多地受到进度或需求调整地影响了。这件事情也让我想清楚了要找到自己的位置，不应该为自己不能负责的事情而焦虑。专注于自己能改变和努力的地方，其它事情就应该相信对应的负责人，让他们来操心。 创业对于人心智的磨练还是挺大的，我相信我以后会更加容易控制自己的情绪和行为。 其它读书今年读的主要是iOS方面的书籍，包括如下这些，其中重点推荐《iOS 7 Programming Pushing the Limits》 《iOS 7 Programming Pushing the Limits》 《OpenCV 2 Computer Vision Application Programming Cookbook》 《Cocoa设计模式》 《黑客攻防技术宝典·iOS实战篇》 《Web之困：现代Web应用安全指南》 《Objective-C高级编程：iOS与OS X多线程和内存管理》 《七周七语言》 《不抱怨的世界》 感谢2013年有很多贵人帮助，自己才能快速成长，在此感谢2013年陪我一起走过的家人和朋友，和我一起努力的公司同事。 特别要感谢的是：体贴的老婆和岳母大人，宽容细致的老大郭常圳，iOS开发群里的小伙伴（特别是Lexrus)，InfoQ的老大Kevin和编辑杨Sai、水哥，MacTalk作者@池建强，小道消息作者@Fenng，@永恒的侠少，@gaosboy，@neat爷，张兰。谢谢你们～ 个人Milestone 开始写iOS开发的书 创业得到了B轮融资","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"如何写面向互联网公司的求职简历","slug":"how-to-write-resume-for-it-company","date":"2013-12-22T12:04:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/12/22/how-to-write-resume-for-it-company/","permalink":"https://blog.devtang.com/2013/12/22/how-to-write-resume-for-it-company/","excerpt":"前言我在 IT 公司工作了六年，有着三年面试官的经历。在面试中，我发现很多人都不能写好一份求职简历，所以今天不谈 iOS 开发，谈谈如何写一份针对互联网公司的求职简历。 我主要想分享的内容包括： 简历的页数不要超过两页（最好一页） 删掉不必要的信息 如果你实在太牛逼，最多写 2 页 重要的信息写在最前面 你的联系方式 你最重要的工作经历 不要简单罗列工作经历 列出你的工作中有价值的细节（有哪些技术上的困难等） 不要写任何虚假或夸大的信息 类似精通 java，精通 C&#x2F;C++ 等 不要附加任何可能带来负面印象的信息 不要加照片 不要写政治面貌 不要写奇怪的爱好（打游戏，喝酒，抽烟） 不要写参加过某某培训公司的 iOS 培训 尽量用专业邮箱 用 PDF 格式","text":"前言我在 IT 公司工作了六年，有着三年面试官的经历。在面试中，我发现很多人都不能写好一份求职简历，所以今天不谈 iOS 开发，谈谈如何写一份针对互联网公司的求职简历。 我主要想分享的内容包括： 简历的页数不要超过两页（最好一页） 删掉不必要的信息 如果你实在太牛逼，最多写 2 页 重要的信息写在最前面 你的联系方式 你最重要的工作经历 不要简单罗列工作经历 列出你的工作中有价值的细节（有哪些技术上的困难等） 不要写任何虚假或夸大的信息 类似精通 java，精通 C&#x2F;C++ 等 不要附加任何可能带来负面印象的信息 不要加照片 不要写政治面貌 不要写奇怪的爱好（打游戏，喝酒，抽烟） 不要写参加过某某培训公司的 iOS 培训 尽量用专业邮箱 用 PDF 格式 简历不要超过两页（最好一页）互联网公司和传统企业有着很大的区别，通常情况下，创新和效率是互联网公司比较追求的公司文化，所以体现在简历上，就是超过一页的简历通常会被认为不够专业。 更麻烦的是，多数这种简历很可能在 HR 手中就被过滤掉了，因为 HR 每天会收到大量的简历，一般情况下每份简历在手中的停留时间也就 10 秒钟左右。而超过一页的简历会需要更多的时间去寻找简历中的有价值部分，对于 HR 来说，她更倾向于认为这种人通常是不靠谱的，因为写个简历都不懂行规，为什么还要给他面试机会呢 ? 那么我们应该如何精简简历呢 ? 简单说来就是一个字：删！ 删掉不必要的自我介绍信息，很多求职者会将自己在学校所学的课程罗列上去，例如：C 语言，数据结构，数学分析。。。好家伙，一写就是几十门，还放在简历的最上面，就怕面试官看不见。对于这类信息，一个字：删！面试官不 Care 你上了哪些课程，而且在全中国，大家上的课程也都大同小异，所以没必要写出来。 删除不必要的工作或实习、实践经历。如果你找一份程序员的工作，那么你参加了奥运会的志愿者活动，并且拿到了奖励或者你参加学校的辩论队，获得了最佳辩手这些经历通常是不相关的。诸如此类的还有你帮导师代课，讲了和工作不相关的某某专业课，或者你在学生会工作等等。删除不相关的工作、实习或实践内容可以保证你的简历干净。当然，如果你实在没得可写，比如你是应届生，一点实习经历都没有，那可以适当写一两条，保证你能写够一页的简历，但是那两条也要注意是强调你的团队合作能力或者执行力之类的技能，因为这些才是面试官感兴趣的。 删除不必要的证书：最多写个 4、6 级的证书，什么教师资格证，中高级程序员证，还有国内的各种什么认证，都是没有人 Care 的。 删除不必要的细节，作为 iOS 开发的面试官，很多求职者在介绍自己的 iOS 项目经历的时候，介绍了这个工程用的工作环境是 Mac OS，使用的机器是 Mac Mini，编译器是 XCode4.x，能够运行在 iOS4.3 以上环境，还有一些人，把这个项目用到的开源库都写上啦，什么 ASI, AFNetworking, Cocoapods 啥的。这些其实都不是重点，请删掉。后面我会讲，你应该如何介绍你的 iOS 项目经历。 自我评价，这个部分是应届生最喜欢写的，各种有没有的优点都写上，例如： 性格开朗、稳重、有活力，待人热情、真诚；工作认真负责，积极主动，能吃苦耐劳，用于承受压力，勇于创新；有很强的组织能力和团队协作精神，具有较强的适应能力；纪律性强，工作积极配合；意志坚强，具有较强的无私奉献精神。对待工作认真负责，善于沟通、协调有较强的组织能力与团队精神；活泼开朗、乐观上进、有爱心并善于施教并行；上进心强、勤于学习能不断提高自身的能力与综合素质。 这些内容在面试的时候不太好考查，都可以删掉。通常如果有 HR 面的话，HR 自然会考查一些你的沟通，抗压，性格等软实力。 我相信，不管你是刚毕业的学生，还是工作十年的老手，你都可以把你的简历精简到一页 A4 纸上。 重要的信息写在最前面将你觉得最吸引人的地方写在最前面。如果你有牛逼公司的实习，那就把实习经历写在最前面，如果你在一个牛逼的实验室里面做科研，就把研究成果和论文写出来，如果你有获得过比较牛逼的比赛名次（例如 google code, ACM 比赛之类），写上绝对吸引眼球。 所以，每个人的简历的介绍顺序应该都是不一样的，不要在网上下载一个模板，然后就一项一项地填：教育经历，实习经历，得奖经历，个人爱好，这样的简历毫无吸引力，也无法突出你的特点。 除了你的个人特点是重要信息外，你的手机号，邮箱，毕业院校，专业以及毕业时间这些也都是非常重要的，一定要写在简历最上面。 不要简单地罗列工作经历不要简单地说你开发了某某 iOS 客户端。这样简单的罗列你的作品集并不能让面试官很好地了解你的能力，当然，真正在面试时面试官可能会仔细询问，但是一份好的简历，应该省去一些面试官额外询问你的工作细节的时间。 具体的做法是：详细的描述你对于某某 iOS 客户端的贡献。主要包括：你参与了多少比例功能的开发 ? 你解决了哪些开发中的有挑战的问题 ? 你是不是技术负责人 ? 而且，通过你反思这些贡献，你也可以达到自我审视，如果你发现这个项目你根本什么有价值的贡献都没做，就打了打酱油，那你最好不要写在简历上，否则当面试官在面试时问起时，你会很难回答，最终让他发现你的这个项目经历根本一文不值时，肯定会给一个负面的印象。 不要写任何虚假或夸大的信息刚刚毕业的学生都喜欢写精通 Java，精通 C&#x2F;C++，其实代码可能写了不到 1 万行，我觉得你要精通某个语言，至少得写 50 万行这个语言的代码才行，而且要对语言的各种内部机制和原理有了解。那些宣称精通 Java 的同学，连 Java 如何做内存回收，如何做范型支持，如何做自动 boxing 和 unboxing 的都不知道，真不知道为什么要写精通 2 字。 任何夸大或虚假的信息，在面试时被发现，会造成极差的面试印象，所以你如果对某个知识一知半解，要么就写 “使用过” 某某，要么就干脆不写。如果你简历实在太单薄，没办法写上了一些自己打酱油的项目，被问起来怎么办 ? 请看看下面的故事： 我面试过一个同学，他的面试时非常诚实，问他一些简历上的东西，他如果不会，就会老实说，这个我只是使用了一下，确实不清楚细节。对于一些没有技术含量的项目，他也会老实说，这个项目他做的工作比较少，主要是别人在做。最后他还会补充说，“我自认为自己数据结构和算法还不错，要不你问我这方面的知识吧。” 这倒是一个不错的办法，对于一个没有项目经验，但是聪明并且数据结构和算法基础知识扎实的应届生，其实我们是非常愿意培养的。很多人以为公司面试是看经验，希望招进来就能干活，其实不是的，至少我们现在以及我以前在网易招人，面试的是对方的潜力，没有项目经验根本关系不大。 总之，不要写任何虚假或夸大的信息，即使你最终骗得过面试官，进了某公司，如果能力不够，在最初的试用期内，也很可能因为能力不足而被开掉。 不要附加任何可能带来负面印象的信息任何与招聘工作无关的东西，尽量不要提。有些信息提了可能有加分，也可能有减分，取决于具体的面试官。而有些信息大部分情况下都是减分的，我罗列一下我认为是减分的信息。 不要在简历中附加个人照片。个人长相属于与工作能力不相关的信息，也许你觉得你长得很帅，那你怎么知道你的样子不和面试官的情敌长得一样 ? 也许你长得很漂亮，那么你怎么知道 HR 是否被你长得一样的小三把男朋友抢了 ? 我说得有点极端，那人们对于长相的评价标准确实千差万别，萝卜青菜各有所爱，加上可能有一些潜在的极端情况，所以没必要附加这部分信息。这属于加了可能有加分，也可能有减分的情况。 不要写你的政治面貌。你以为现在互联网公司还看重你是否是 D 员吗 ? 就算看重，你怎么知道他们认为这是加分还是减分 ? 我知道有一家公司，只要是 D 员的都直接拒掉。所以，除非你是面试的国企，在互联网公司，这一条最好不要写，写了有可能是平分，也有可能是减分，加分的可能性极小。 不要写各种奇怪的爱好。喜欢打 Dota，喝酒，这类可能带来负面印象的爱好最好不要写。的确有些公司会有这种一起联机玩游戏或者喝酒的文化，不过除非你明确清楚对于目标公司，写上会是加分项，否则还是不写为妙。（顺便说一句，据我了解，阿里的朋友特别喜欢喝酒，面试阿里写上这个可能是加分的，但如果你要是遇到阿里里面正好不喝酒的 Team 或面试官，不要怪我。） 不要使用 word 格式的简历，使用 PDF 的格式。我在招 iOS 程序员时，好多人的简历都是 Word 格式的，mac 下的 office 那么难用，公司好多人机器上都没有 mac office。我真怀疑这些人真是的想投简历么 ? PDF 格式的简历通常能展现出简历的专业性。 不要使用 QQ 号开头的 QQ 邮箱，例如 &#x31;&#50;&#x33;&#52;&#53;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d; ，邮箱的事情我之前简单说过，有些人很在乎这个，有些人觉得无所谓，我个人对用数字开头的 QQ 邮箱的求职者不会有加分，但是对使用 gmail 邮箱的求职者有加分。因为这涉及到个人的工作效率，使用 gmail 的人通常会使用邮件组，过滤器，IMAP 协议，标签，这些都有助于提高工作效率。如果你非要使用 QQ 邮箱，也应该申请一个有意义的邮箱名，例如 &#x74;&#x61;&#x6e;&#x67;&#113;&#105;&#97;&#x6f;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#109; 。相关的讨论可以参见知乎上的讨论：《用人单位拒绝聘用使用 QQ 邮箱发应聘邮件的求职者，这一行为是否合理？》 不要写参加过某某培训公司的 iOS 培训，特别是那种一、两个月的速成培训。这对于我和身边很多面试官来说，绝对是负分。面试当中，经验是一个考查点，但是学习能力比经验重要多了，如果你是参加培训学习的 iOS 开发，很可能说明你没有自学能力。这一点似乎很多人都没有搞清楚，大家可以看看 @老赵 在他的个人博客上发表的 《为什么我要反对北大青鸟》。 我在 2 年前也写过一篇博客 《我们必须自学》，详细解释了我的看法。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"Xcode Debugger中的Icon符号的意义","slug":"the-secret-of-xcode-debugger-icon","date":"2013-12-22T11:23:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/12/22/the-secret-of-xcode-debugger-icon/","permalink":"https://blog.devtang.com/2013/12/22/the-secret-of-xcode-debugger-icon/","excerpt":"你注意到了吗？在 Xcode 中，当你点击查看调用栈的时候，调用栈的每个方法前面都有一个 Icon，而且还有好几种不同的样子，如下图所示，你知道它们代表什么意思吗？","text":"你注意到了吗？在 Xcode 中，当你点击查看调用栈的时候，调用栈的每个方法前面都有一个 Icon，而且还有好几种不同的样子，如下图所示，你知道它们代表什么意思吗？ 其实它们代表的意义如下： Person icon is User Mug icon is AppKit (or UIKit) Briefcase icon is Frameworks Gear icon is System Morse code icon is Foundation Spider web looking icon is Web 另外，Debuger 中的图标（如下图所示）也是有意义： 具体意义如下： L &#x3D; Local variable A &#x3D; Argument S &#x3D; Static variable V &#x3D; global Variable R &#x3D; register i &#x3D; Instance variable E &#x3D; Expression 或许你觉得以上内容没什么实用价值，那再分享一个实用的。 在 XCode5 中，点击一个小眼睛图标，就直接预览 UIImage 的内容，如下图所示： 这个有用吧，祝大家玩得开心～","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"iOS开发工具-网络封包分析工具Charles","slug":"network-tool-charles-intr","date":"2013-12-11T06:03:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/12/11/network-tool-charles-intr/","permalink":"https://blog.devtang.com/2013/12/11/network-tool-charles-intr/","excerpt":"更新本部分的内容写于2013年12月，2015年11月有更新，更新版的文章见：《Charles 从入门到精通》 简介 本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 Charles 是在 Mac 下常用的截取网络封包的工具，在做 iOS 开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。 因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 支持 SSL 代理。可以截取分析 SSL 的请求。 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。 支持 AJAX 调试。可以自动将 json 或 xml 数据格式化，方便查看。 支持 AMF 调试。可以将 Flash Remoting 或 Flex Remoting 信息格式化，方便查看。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 检查 HTML，CSS 和 RSS 内容是否符合 W3C 标准。","text":"更新本部分的内容写于2013年12月，2015年11月有更新，更新版的文章见：《Charles 从入门到精通》 简介 本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 Charles 是在 Mac 下常用的截取网络封包的工具，在做 iOS 开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。 因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 支持 SSL 代理。可以截取分析 SSL 的请求。 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。 支持 AJAX 调试。可以自动将 json 或 xml 数据格式化，方便查看。 支持 AMF 调试。可以将 Flash Remoting 或 Flex Remoting 信息格式化，方便查看。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 检查 HTML，CSS 和 RSS 内容是否符合 W3C 标准。 安装 Charles去 Charles 的官方网站（http://www.charlesproxy.com）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录 下即完成安装。 安装 SSL 证书如果你需要截取分析 SSL 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下： 去 http://www.charlesproxy.com/ssl.zip 下载 CA 证书文件。 解压该 zip 文件后，双击其中的 .crt 文件，这时候在弹出的菜单中选择 “总是信任”，如下所示： 从钥匙串访问中即可看到添加成功的证书。如下所示： 将 Charles 设置成系统代理之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。 启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。 Charles 主界面介绍 Charles 主要提供 2 种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 Structure 视图将网络请求按访问的域名分类。 Sequence 视图将网络请求按访问的时间排序。 大家可以根据具体的需要在这两种视图之前来回切换。 对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。 过滤网络请求通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，我们有 2 种办法。 在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuantiku.com , 那么只需要在 Filter 栏中填入 yuantiku 即可。 在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示： 通常情况下，我们使用方法 1 做一些临时性的封包过滤，使用方法 2 做一些经常性的封包过滤。 截取 iPhone 上的网络封包Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。 Charles 上的设置要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示: iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，打开 Terminal，输入ifconfig en0, 即可获得该电脑的 IP，如下图所示： 在 iPhone 的 “设置”-&gt;“无线局域网 “中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有 “HTTP 代理” 一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示： 设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。 截取 SSL 信息Charles 默认并不截取 SSL 的信息，如果你想对截取某个网站上的所有 SSL 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示： 这样，对于该 Host 的所有 SSL 请求可以被截取到了。 模拟慢速网络在做 iPhone 开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示： 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示： 我们可以修改该请求的任何信息，包括 url 地址，端口，参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便。 总结通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。 参考链接 Charles 主要的功能列表 Charles 官网","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"使用Flurry来统计和分析用户行为","slug":"use-flurry-to-analyse-data","date":"2013-11-14T05:51:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/11/14/use-flurry-to-analyse-data/","permalink":"https://blog.devtang.com/2013/11/14/use-flurry-to-analyse-data/","excerpt":"2015年11月更新由于 Flurry 的后台在中国访问实在太慢，另外 Flurry 对中国区的 IP 类型判断不太准确（3G和Wifi无法准确区分），所以我现在不再推荐大家使用 Flurry 了。 不用 Flurry 之后，我们现在使用的是腾讯的 MTA 来做统计。 简介 本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 Flurry是一家专门为移动应用提供数据统计和分析的公司。他们的数据统计分析SDK支持的平台包括iPhone, iPad, Android, Windows Phone, Java ME和BlackBerry。使用Flurry服务的公司包括eBay、Yahoo、Hulu和Skype等超过11万家公司，涉及的应用超过36万个。 利用Flurry提供的分析平台，我们可以很容易地自动统计出应用的使用情况，例如： 每天（每周或每月）登录用户数，应用使用次数 每天（每周或每月）新用户数，活跃用户数 用户的所在地、年龄、性别的分布情况 Flurry也可以自动统计出移动设备的分类情况，例如： 使用3G，Wifi的会话比例 使用iOS系统各版本(例如iOS6.0, iOS7.0等)的比例 使用iOS各种设备（例如iPhone4, iPhone5等)的比例 除了上面介绍的自动统计项目，Flurry SDK也提供了统计用的相关API，便于我们针对自己产品的特点，做针对性的统计。例如统计应用中某个按钮的按下次数，或者网络请求的平均响应时间等。","text":"2015年11月更新由于 Flurry 的后台在中国访问实在太慢，另外 Flurry 对中国区的 IP 类型判断不太准确（3G和Wifi无法准确区分），所以我现在不再推荐大家使用 Flurry 了。 不用 Flurry 之后，我们现在使用的是腾讯的 MTA 来做统计。 简介 本文为 InfoQ 中文站特供稿件，首发地址为：文章链接。如需转载，请与 InfoQ 中文站联系。 Flurry是一家专门为移动应用提供数据统计和分析的公司。他们的数据统计分析SDK支持的平台包括iPhone, iPad, Android, Windows Phone, Java ME和BlackBerry。使用Flurry服务的公司包括eBay、Yahoo、Hulu和Skype等超过11万家公司，涉及的应用超过36万个。 利用Flurry提供的分析平台，我们可以很容易地自动统计出应用的使用情况，例如： 每天（每周或每月）登录用户数，应用使用次数 每天（每周或每月）新用户数，活跃用户数 用户的所在地、年龄、性别的分布情况 Flurry也可以自动统计出移动设备的分类情况，例如： 使用3G，Wifi的会话比例 使用iOS系统各版本(例如iOS6.0, iOS7.0等)的比例 使用iOS各种设备（例如iPhone4, iPhone5等)的比例 除了上面介绍的自动统计项目，Flurry SDK也提供了统计用的相关API，便于我们针对自己产品的特点，做针对性的统计。例如统计应用中某个按钮的按下次数，或者网络请求的平均响应时间等。 Flurry的基本使用注册和下载对应SDK使用Flurry前，需要先到官方网站http://www.flurry.com/注册账号。然后登录到Flurry后台，依次选择 &quot;Applications&quot; -&gt; “Add a New Application&quot; ，增加一个需要统计分析的应用。如下图所示： 然后，在接下来的界面之后根据你的应用类型，选择iPhone或iPad应用。如下图所示： 接着，填入应用的名字和分类（名字仅用作在Flurry后台和自己的其它应用区分，不需要和应用的真实名字相同），之后点击”Create App”，如下所示： 到此，我们就成功在后台创建了一个新的应用统计和分析项目。点击下图中的”Download”，可以下载需要集成在应用中的SDK。而下图中的提示2中的Key：X28BBKTNZ9H3VYTBDBG3则是我们在集成时用于标识自己应用的ID。 集成SDK我们将下载后的SDK解压，可以看到文件列表如下。列表中对我们最重要的文件是Flurry目录下的flurry.h文件和libFlurry_4.3.0.a文件。这2个文件需要复制到Xcode的工程中去。 而ProjectApiKey.txt文件中记录了我们之前创建的应用ID，在在代码中调用SDK初使化时需要使用。 接着我们打开Xcode工程，将之前下载解压的Flurry目录拖动添加到工程中，同时在工程的.pch文件中加上 #import &quot;Flurry.h&quot;，如下图所示： 接着我们在Link Binary With Libraries中加入如下2个依赖的framework: Security.framework SystemConfiguration.framework。 接着我们打开 AppDelegate.m，在- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中，加入代码[Flurry startSession:@&quot;X28BBKTNZ9H3VYTBDBG3&quot;];，如下图所示： 这样，就完成了Flurry最简单的集成。通过以上短短几步，Flurry就可以帮我们完成应用的基本使用数据的统计和分析。 自定义统计项Flurry提供了logEvent函数，用于实现自定义的统计项。默认情况下，该函数接受一个参数，用于表示当前统计项的名字。 例如我们的界面中有2个按钮，我们想统计它们各自被用户的点击次数，则可以如下代码实现。在该代码中，我们定义了2个自定义的统计项，名字分别为First Button Pressed和Second Button Pressed。 - (IBAction)firstButtonPressed:(id)sender &#123; [Flurry logEvent:@&quot;First Button Pressed&quot;];&#125;- (IBAction)secondButtonPressed:(id)sender &#123; [Flurry logEvent:@&quot;Second Button Pressed&quot;];&#125; logEvent函数也支持添加各种参数，用于做更加精细的统计，例如，我们想在统计用户在同一个页面，点击时不同按钮的次数分布，看哪些按钮更加常用，则统计代码可以如下实现： - (IBAction)firstButtonPressed:(id)sender &#123; [Flurry logEvent:@&quot;Button Pressed&quot; withParameters:@&#123;@&quot;target&quot;: @&quot;first&quot;&#125;];&#125;- (IBAction)secondButtonPressed:(id)sender &#123; [Flurry logEvent:@&quot;Button Pressed&quot; withParameters:@&#123;@&quot;target&quot;: @&quot;second&quot;&#125;];&#125; logEvent函数也支持统计时间，常常用来统计某个复杂的网络操作的耗时或者用户对于某些界面的响应时间。例如，我们想统计用户停留在某个提示界面的时间，则可以用如下代码完成： //// FirstViewController.m// FlurryUsageSample//// Created by TangQiao on 13-10-25.// Copyright (c) 2013年 TangQiao. All rights reserved.//#import &quot;FirstViewController.h&quot;#define FLURRY_EVENT_KEY @&quot;First View Controller&quot;@implementation FirstViewController- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; // 开始统计时间 [Flurry logEvent:FLURRY_EVENT_KEY timed:YES];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; // 结束统计时间 [Flurry endTimedEvent:FLURRY_EVENT_KEY withParameters:nil];&#125;@end 查看统计结果完成上面的自定义统计的代码后，待应用发布后，我们就可以从后台的Events栏中看到相应的统计结果了。如下图所示： 统计CrashlogFlurry从4.2.3开始，支持应用的Crashlog统计。只需要在AppDelegate.m文件中，在调用startSession方法之前，调用setCrashReportingEnabled:YES即可： [Flurry setCrashReportingEnabled:YES];[Flurry startSession:@&quot;YOUR_API_KEY&quot;]; 这里注意，一定要在startSession之前调用setCrashReportingEnabled，否则将无法记录Crashlog信息！切记！！ 之后你就可以从后台管理界面的Errors项中，获得应用的Crashlog信息。 和其它统计分析平台的对比和著名的统计工具Google Analytics相比，Flurry的优点是： Flurry专门针对移动端做了许多优化，例如统计流量就小很多。 Flurry没有被墙的问题。 Flurry缺点是: Google Analytics的统计功能相对更强大一些。 Google Analytics可以和网页版的统计数据做整合。 和国内的分析平台友盟相比，Flurry的优点是： 使用Flurry的应用相对更多。根据Flurry和友盟的官方数据，有超过36万应用使用Flurry1 ，有超过18万应用使用友盟2。 Flurry是国外的公司，保持独立和专注，数据安全性更高；友盟现在已经被阿里收购，当用户的应用涉及领域和阿里有类似或重合的时候，那么该统计数据有潜在的安全性问题。 Flurry的缺点是： 友盟因为是中国公司，所以对国内开发者非常友善，相关的文档或界面都是中文的。而Flurry并不提供中文的后台管理界面或相关文档。 Flurry的服务器在国外，在响应速度上应该相对比友盟慢一些。但在测试中，Flurry服务器都保证了500ms左右的响应时间，还是比较好的。 总结本文介绍了Flurry的基本功能以及如何做自定义的统计，最后与业界其它同类工具做了对比。我也将相关示例代码整理到github上，地址是：https://github.com/tangqiaoboy/FlurryUsageSample，愿本文能帮助你更加方便地做应用的统计和分析工作。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"猿题库iOS客户端的技术细节（三）：基于CoreText的排版引擎","slug":"the-tech-detail-of-ape-client-3","date":"2013-10-21T08:15:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/10/21/the-tech-detail-of-ape-client-3/","permalink":"https://blog.devtang.com/2013/10/21/the-tech-detail-of-ape-client-3/","excerpt":"前言本人今年主要在负责猿题库 iOS 客户端的开发，本文旨在通过分享猿题库 iOS 客户端开发过程中的技术细节，达到总结和交流的目的。 这是本技术分享系列文章的第三篇。本文涉及的技术细节是：基于 CoreText 的排版引擎。","text":"前言本人今年主要在负责猿题库 iOS 客户端的开发，本文旨在通过分享猿题库 iOS 客户端开发过程中的技术细节，达到总结和交流的目的。 这是本技术分享系列文章的第三篇。本文涉及的技术细节是：基于 CoreText 的排版引擎。 CoreText 概述因为猿题库的做题和解析界面需要复杂的排版，所以我们基于 CoreText 实现了自己的富文本排版引擎。我们的排版引擎对公式、图片和链接有着良好支持，并且支持各种字体效果混排。对于内容中的图片，支持点击查看大图功能，对于内容中的链接，支持点击操作。 下图是我们应用的一个截图，可以看到公式，图片与文字混排良好。 对于富文本排版，除了可以用 CoreText 实现外，还可以用 UIWebView 实现。我以前写过一篇介绍如何用 UIWebView 进行复杂内容显示和交互的文章 《关于 UIWebView 和 PhoneGap 的总结》，里面介绍了使用 UIWebView 如何处理参数传递，同步与异步等问题，感兴趣的同学也可以翻看。 基于 CoreText 来实现和基于 UIWebView 来实现相比，前者有以下好处： CoreText 占用的内存更少，UIWebView 占用的内存更多。 CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取） CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。 基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。 当然基于 CoreText 的方案也有一些劣势： CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。 基于 CoreText 来排版，需要自己处理图片排版相关的逻辑，也需要自己处理链接点击操作的支持。 我们最初的猿题库行测第一版采用了基于 UIWebView 来实现，但是做出来发现一些小的交互细节无法做到精致。所以后来的第二版我们就全部转成用 CoreText 实现，虽然实现成本上增加了不少，但是应用的交互效果好多了。 使用 CoreText 也为我们后来的 iPad 版提供了技术积累，因为 iPad 版的页面排版更加复杂，用 UIWebView 是完全无法完成相应的交互和排版需求的。 关于如何基于 CoreText 来做一个排版引擎，我主要参考的是这篇教程：《Core Text Tutorial for iOS: Making a Magazine App》 以及 Nimbus 中的 NIAttributeLabel.m 的实现，在这里我就不重复教程中的内容了，我主要讲一些实现细节。 实现细节服务端接口我们在后台实现了一个基于 UBB 的富文本编译器。使用 UBB 的原因是： UBB 相对于 HTML 来说，虽然功能较简单，但是能完全满足我们对于富文本排版的需求。 做一个 UBB 的语法解析器比较简单，便于我们将 UBB 渲染到各个平台上。 为了简化 iOS 端的实现，我们将 UBB 的语法解析在服务器端完成。服务器端提供了接口，可以直接获得将 UBB 解析成类似 HTML 的 文件对象模型 (DOM) 的树型数据结构。有了这个树型数据结构，iOS 端渲染就简单多了，无非就是递归遍历树型节点，将相关的内容转换成 NSAttributeString 即可，之后将 NSAttrubiteString 转成 CoreText 的 CTFrame 即可用于界面的绘制。 支持图文混排支持图文混排在教程：《Core Text Tutorial for iOS: Making a Magazine App》 中有介绍，我们在解析 DOM 树遇到图片节点时，则将该内容转成一个空格，随后设置该空格在绘制时，需要我们自己指定宽高相关信息，而宽高信息在图片节点中都有提供。这样，CoreText 引擎在绘制时，就会把相关的图片位置留空，之后我们将图片异步下来下来后，使用 CoreGraph 相关的 API 将图片再画在界面上，就实现了图文混排功能。 下面的相关的示例代码： /* Callbacks */static void deallocCallback( void* ref )&#123; [(id)ref release];&#125;static CGFloat ascentCallback( void *ref )&#123; CGFloat height = [(NSString*)[(NSDictionary*)ref objectForKey:@&quot;height&quot;] floatValue]; return height/2 + [FrameParserConfig sharedInstance].baselineFromMid;&#125;static CGFloat descentCallback( void *ref )&#123; CGFloat height = [(NSString*)[(NSDictionary*)ref objectForKey:@&quot;height&quot;] floatValue]; return height/2 - [FrameParserConfig sharedInstance].baselineFromMid;&#125;static CGFloat widthCallback( void* ref )&#123; return [(NSString*)[(NSDictionary*)ref objectForKey:@&quot;width&quot;] floatValue];&#125;+ (void)appendDelegateData:(NSDictionary *)delegateData ToString:(NSMutableAttributedString*)contentString &#123; //render empty space for drawing the image in the text //1 CTRunDelegateCallbacks callbacks; callbacks.version = kCTRunDelegateCurrentVersion; callbacks.getAscent = ascentCallback; callbacks.getDescent = descentCallback; callbacks.getWidth = widthCallback; callbacks.dealloc = deallocCallback; CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callbacks, delegateData); [delegateData retain]; // Character to use as recommended by kCTRunDelegateAttributeName documentation. // use &quot; &quot; will lead to wrong width in CTFramesetterSuggestFrameSizeWithConstraints unichar objectReplacementChar = 0xFFFC; NSString * objectReplacementString = [NSString stringWithCharacters:&amp;objectReplacementChar length:1]; NSDictionary * attributes = [self getAttributesWithStyleArray:nil]; //try to apply linespacing attributes to this placeholder NSMutableAttributedString * space = [[NSMutableAttributedString alloc] initWithString:objectReplacementString attributes:attributes]; CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); CFRelease(delegate); [contentString appendAttributedString:space]; [space release];&#125; 这里需要注意的是，用来代替图片的占位符使用空格会带来排版上的异常，具体原因未知，我们猜测是 CoreText 的 bug，参考 Nimbus 的实现后，我们使用 0xFFFC作为占位符，就没有遇到问题了。 支持链接支持链接点击的主要实现的方式是： 在解析 DOM 树的时候，记录下链接串在整个富文本中的位置信息（包括 offset 和 length)。 在 CoreText 渲染到的 view 上，监听用户操作事件，使用 CTLineGetStringIndexForPosition函数来获得用户点击的位置对应 NSAttributedString 字符串上的位置信息（index) 判断第 2 步得到的 index 是否在第一步记录的各个链接的区间范围内，如果在范围内，则表示用户点击了某一个链接。 这段逻辑的关键代码如下： // test touch point is on link or not+ (LinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CTTableViewCellData *)data &#123; CTFrameRef textFrame = data.ctFrame; CFArrayRef lines = CTFrameGetLines(textFrame); if (!lines) return nil; CFIndex count = CFArrayGetCount(lines); LinkData *foundLink = nil; CGPoint origins[count]; CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins); // CoreText context coordinates are the opposite to UIKit so we flip the bounds CGAffineTransform transform = CGAffineTransformScale(CGAffineTransformMakeTranslation(0, view.bounds.size.height), 1.f, -1.f); for (int i = 0; i &lt; count; i++) &#123; CGPoint linePoint = origins[i]; CTLineRef line = CFArrayGetValueAtIndex(lines, i); CGRect flippedRect = [self getLineBounds:line point:linePoint]; CGRect rect = CGRectApplyAffineTransform(flippedRect, transform); if (CGRectContainsPoint(rect, point)) &#123; CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect), point.y-CGRectGetMinY(rect)); CFIndex idx = CTLineGetStringIndexForPosition(line, relativePoint); foundLink = [self linkAtIndex:idx linkArray:data.linkArray]; return foundLink; &#125; &#125; return nil;&#125; 基于 CoreText 的内容省略我们在使用 CoreText 时，还遇到一个具体排版上的问题。正常情况下，在生成 CTFrame 之后，只需要调用：CTFrameDraw(self.data.ctFrame, context);即可完成界面的绘制。但是产品提出了一个需求，对于某些界面，当显示不下的时候，需要将多余内容用...来表示。这让我们的绘制逻辑需要特别处理，以下是具体的实现： static NSString* const kEllipsesCharacter = @&quot;\\u2026&quot;;CGPathRef path = CTFrameGetPath(_data.ctFrame);CGRect rect = CGPathGetBoundingBox(path);CFArrayRef lines = CTFrameGetLines(_data.ctFrame);CFIndex lineCount = CFArrayGetCount(lines);NSInteger numberOfLines = MIN(_numberOfLines, lineCount);CGPoint lineOrigins[numberOfLines];CTFrameGetLineOrigins(_data.ctFrame, CFRangeMake(0, numberOfLines), lineOrigins);NSAttributedString *attributedString = _data.attributedString;for (CFIndex lineIndex = 0; lineIndex &lt; numberOfLines; lineIndex++) &#123; CGPoint lineOrigin = lineOrigins[lineIndex]; lineOrigin.y = self.frame.size.height + (lineOrigin.y - rect.size.height); CGContextSetTextPosition(context, lineOrigin.x, lineOrigin.y); CTLineRef line = CFArrayGetValueAtIndex(lines, lineIndex); BOOL shouldDrawLine = YES; if (lineIndex == numberOfLines - 1) &#123; CFRange lastLineRange = CTLineGetStringRange(line); if (lastLineRange.location + lastLineRange.length &lt; (CFIndex)attributedString.length) &#123; CTLineTruncationType truncationType = kCTLineTruncationEnd; NSUInteger truncationAttributePosition = lastLineRange.location + lastLineRange.length - 1; NSDictionary *tokenAttributes = [attributedString attributesAtIndex:truncationAttributePosition effectiveRange:NULL]; NSAttributedString *tokenString = [[NSAttributedString alloc] initWithString:kEllipsesCharacter attributes:tokenAttributes]; CTLineRef truncationToken = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)tokenString); NSMutableAttributedString *truncationString = [[attributedString attributedSubstringFromRange:NSMakeRange(lastLineRange.location, lastLineRange.length)] mutableCopy]; if (lastLineRange.length &gt; 0) &#123; // Remove any whitespace at the end of the line. unichar lastCharacter = [[truncationString string] characterAtIndex:lastLineRange.length - 1]; if ([[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:lastCharacter]) &#123; [truncationString deleteCharactersInRange:NSMakeRange(lastLineRange.length - 1, 1)]; &#125; &#125; [truncationString appendAttributedString:tokenString]; CTLineRef truncationLine = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)truncationString); CTLineRef truncatedLine = CTLineCreateTruncatedLine(truncationLine, self.size.width, truncationType, truncationToken); if (!truncatedLine) &#123; // If the line is not as wide as the truncationToken, truncatedLine is NULL truncatedLine = CFRetain(truncationToken); &#125; CFRelease(truncationLine); CFRelease(truncationToken); CTLineDraw(truncatedLine, context); CFRelease(truncatedLine); shouldDrawLine = NO; &#125; &#125; if (shouldDrawLine) &#123; CTLineDraw(line, context); &#125;&#125; 后记以上源码很多都参考了 Nimbus 的实现，在此再一次表达一下对开源社区的感谢。 在大约 2 年前，CoreText 还是一个新玩意。那时候微博的界面都还是用控件组合得到的。慢慢的，大家都开始接受 CoreText，很多应用都广泛地将 CoreText 应用于自己的界面中，做出来了更加复杂的排版、交互效果。在 iOS7 之后，苹果推出了更加易于使用的 TextKit，使得富文本排版更加容易，相信以后的 iOS 应用界面会更加美观，交互更加绚丽。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"猿题库iOS客户端的技术细节（二）：答题卡扫描算法","slug":"the-tech-detail-of-ape-client-2","date":"2013-10-19T03:10:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/10/19/the-tech-detail-of-ape-client-2/","permalink":"https://blog.devtang.com/2013/10/19/the-tech-detail-of-ape-client-2/","excerpt":"前言本人今年主要在负责猿题库 iOS 客户端的开发，本文旨在通过分享猿题库 iOS 客户端开发过程中的技术细节，达到总结和交流的目的。 这是本技术分享系列文章的第二篇。本文涉及的技术细节是：答题卡扫描算法。","text":"前言本人今年主要在负责猿题库 iOS 客户端的开发，本文旨在通过分享猿题库 iOS 客户端开发过程中的技术细节，达到总结和交流的目的。 这是本技术分享系列文章的第二篇。本文涉及的技术细节是：答题卡扫描算法。 问题描述我们在调研用户需求的时候，发现有些用户很喜欢我们的猿题库产品，因为我们会根据用户对当前课程的知识点掌握情况，智能地给他出题。但是部分用户还是习惯在纸上做题，所以我们提供了试卷打印功能。 但是，用户如果在纸上答题，无法方便地将答案上传到我们的服务器上。如果我们没有了用户做题数据，就无法根据他的成绩，做针对性的推荐和分析。所以，我们想到一种办法： 用户像传统考试那样，将答题结果填涂在答题卡上，然后我们提供一种用手机摄像头采集填涂结果的答题卡扫描算法，方便用户上传答题数据。 上图是一个我们试验用的答题卡，通过手机摄像头获取，从中可以看到，该答题卡有以下问题： 由于手机摄像头无法完全正对答题卡，拍照角度有偏曲，答题卡在拍照后并不是完全的矩形。 用户填涂区域可能并不饱满和完整。 答题纸边缘可能有用户的草稿或其它干扰识别的信息。 技术解决方案我们尝试了多种识别方案，最终采用的方案如下： 图象预处理，压缩图像大小，转彩色图像为灰度图像 识别答题卡区域 图象纠偏 答案区域识别 该方案及相关算法细节我们还在申请专利，由于专利还在申请过程中，所以我们这次仅展示上述主要步骤的示例图片。等专利完全申请结束后，我会在此将算法细节公开。 上述主要步骤的示例图如下： 原始图 识别答题卡区域 图象纠偏 答案区域识别答案已标注在图片每个题号的右边位置： 算法质量算法正确率和召回率我们用收集来的 1000 套样本数据对算法进行评测，最终结果是：扫描题目准确率达到 99.67%，召回率达到 99.14%。主要识别失败的样本是：页面严重扭曲弯折的答题卡。我们也在一直改进算法，希望能够给用户提供更加精准的扫描结果。 算法执行时间我们觉得让用户直接对着答题卡用拍摄的方式动态识别，比先拍一张照片再识别的方式更加方便。所以我们对答题卡识别算法的执行时间进行了一系列优化，最终保证每次识别时间小于 0.1 秒，这样的识别时间非常快，基本上用户把手机摄像头对准答题卡，扫描结果就出来了。 算法的调试和移植由于我们整个技术团队都使用 Mac 电脑进行开发，所以我们对于算法的调试都是在 Mac 平台上完成的，我使用了开源的图象处理库 OpenCV，在搭建 OpenCV 环境时遇到一些问题，最终完成环境搭建后，我将相关的经验总结在博文 《在 MacOS 和 iOS 系统中使用 OpenCV》 中。 由于算法需要同时应用在 iOS 和 Android 平台，所以我主要用 C++ 语言实现算法。Xcode 可以很好地支持 Objective-C 语言和 C++ 语言混编，只需要将相关的源文件扩展名从 .m 改为 .mm 即可。而 Android 平台所采用的 Java 语言，也支持通过 JNI 的方式来调用 C++ 的代码。这样就可以方便地将识别算法移植到手机中了。 总结本文介绍了猿题库 iOS 客户端采用的答题卡扫描算法的大致步骤，以及算法的质量和移植方案。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App","slug":"the-tech-detail-of-ape-client-1","date":"2013-10-16T16:43:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/10/17/the-tech-detail-of-ape-client-1/","permalink":"https://blog.devtang.com/2013/10/17/the-tech-detail-of-ape-client-1/","excerpt":"前言本人今年主要在负责猿题库 iOS 客户端的开发，本文旨在通过分享猿题库 iOS 客户端开发过程中的技术细节，达到总结和交流的目的。 这是本技术分享系列文章的第一篇。本文涉及的技术细节是：采用多 Target 编译方案来实现多个相似 App 的开发，以保证我们能够快速地推出多个相似课程的客户端。","text":"前言本人今年主要在负责猿题库 iOS 客户端的开发，本文旨在通过分享猿题库 iOS 客户端开发过程中的技术细节，达到总结和交流的目的。 这是本技术分享系列文章的第一篇。本文涉及的技术细节是：采用多 Target 编译方案来实现多个相似 App 的开发，以保证我们能够快速地推出多个相似课程的客户端。 问题描述今年春节后，我们对外发布了应用 “猿题库-公务员考试行测”，接着我们就开始一个个发布猿题库系列课程应用。到现在半年多过去了，我们一共对外发布了 8 款应用（如下图所示）。 这些课程，随了 “ 猿题库-公务员考试申论 “ 和其它课程不一样之外，另外 7 个课程都有着相似，但是又不完全相同的功能和界面。 这些应用的相同点包括： 基本相同的注册和登录以及首页逻辑和界面（只是背景图片不一样而已）。 相同的做题逻辑和界面。 基本相同的答题报告显示界面。 基本相同的能力评估报告界面。 不同点主要包括： 应用图标，启动画面，应用启动后的首页都不一样。 有些课程（例如公务员考试和高考）是有目标考试的概念，不同的目标考试大纲是不一样的。拿高考来举例，北京的高考和上海的高考，就有着完全不一样的考试大纲。高考的文科和理科，又有着完全不同的考试科目。 有些课程会有一些自定义的界面，例如高考的应用可以设置昵称，有些课程的真题练习中是有推荐真题模块的，而有些课程又没有。 有些课程有扫描答题卡功能，有些课程有考前冲刺功能，有些课程有大题专项查看功能，而有些课程又没有上述功能。另外还有一些微小细节，但是解决方法和类似，所以就不一一展开说明。 技术解决方案我们的技术解决方案主要说来分 4 步： 通过抽取子项目，构建可复用的大模块。 通过多 Target 编译的方式，不同课程的在编译时，采用不同的资源文件和源文件。 在第 2 步的基础上，在项目中创建配置用的 Config 类，然后在不同 Target 各自的配置文件中设置不同的 Config 值。实现课程的差异化界面。 从不同的 xib 中加载界面。 抽取子项目我们首先做的是抽取子项目，从 “猿题库司法考试客户端 “ 开始，我们将可以重用的模块一一抽取出来，以 git submodule 的形式组织到项目中。这个抽取过程在开发完猿题库司法考试客户端之后，基本成型了。我们抽取的 submodule 主要分为 4 部分： UI Common，涉及可复用的登录界面，注册界面，付费界面，NPS 界面，意见反馈界面，关于界面，扫描答题卡界面。另外，我们将一些可复用的 UI 风格控件也抽取成了相应的静态工厂方法，用于生成统一风格的按钮、背景以及状态栏等。 Core Common，涉及可复用的底层模块。包括网络请求模块，自己封装的 Core Text 渲染引擎，缓存模块，一些静态 util 方法等。 Lib Common，所有第三方的开源库依赖，有部分代码根据我们的需求做了修改和定制。 Scan Common, 答题卡扫描识别算法模块，实现核心的扫描算法。 以上只是粗粒度划分，这些模块化的子项目可能在以后被重用，例如 Core Common 完全就可以复用在任何其它项目中。 构造多个编译 Target抽取完子项目以后，我们采用多 target 的方式，将不同课程中的同名资源文件打包进各自的 Target 中，最后所有课程在一个工程项目中，如下图所示： 先简单介绍一下 Xcode 中 target 的概念，苹果在文档中写道： Targets that define the products to build. A target organizes the files and instructions needed to build a product into a sequence of build actions that can be taken.” 在 Xcode 的一个项目中，可以允许建立多个编译的 target，每个 target 代表着最终编译出来的一个 App 文件，在每个 target 中，可以添加不同的编译源文件和资源文件。最终，通过我们在不同 target 之间，修改其 Copy Bundle Resources 和 Compile Sources 配置，使课程之间的差异性得到实现。我们具体的配置方案如下： 我们的每个课程的资源文件都具有相同的文件名，例如首页背景都叫 HomeBackgroundBg.png ，由于每个课程背景不一样，所以我们在工程中，每一个课程 target 下，通过修改Copy Bundle Resources，使其都配置有不同的（但是同名） HomeBackgroundBg.png 。这样的好处是，在代码逻辑层面，我们可以完全不用处理课程间资源文件的差异性问题。资源文件的差异性都是通过配置文件来保证的。 对于文案一类的差别，我们通过修改Compile Sources，使不同的课程有着不同的文案定义文件。通过这样，我们使不同课程有了不同的文案。另外包括后台网络接口的差异性问题，统计项的差异性问题，也都是这样处理的。 Config 类最后，我们使用 Config 类来完成交互和页面 UI 组件差异性问题。拿能力评估报告页面来说，不同的课程的页面都有一些差异。我们在公共层的代码中将这些逻辑全部实现，具体的 UI 在呈现时，通过读取相关的 Config 类来决定具体如何展示。这样，我们只需要在第 2 步提供的各个课程的差异性源文件中，完成 Config 类的配置即可。 从不同的 xib 中加载界面有些时候，我们仅仅需要的是 UI 界面排列方式不一样，其它交互逻辑完全一样。对于这种需求，我们尝试同一个 view 对应有多个 xib，然后通过上一步的 Config 类的信息，来加载不同的 xib 界面。这样所有的差异性都在不同的 xib 中解决了，对 controller 层可以完全透明。 下图是我们报告页面的 xib 界面，分为：高考课程、有目标考试的课程、没有目标考试的课程三种。由于这 3 个界面的后台逻辑和交互逻辑都一样，我们通过 3 个 xib 来实现它们之间差异性的部分。 以下是 view 加载对应的 xib 的代码逻辑： + (IPadAbilityReportHeaderView *)loadFromNib:(IPadAbilityReportHeaderViewType)type &#123; NSString *nibFileName; switch (type) &#123; case IPadAbilityReportHeaderViewTypeWithQuiz: nibFileName = @&quot;IPadAbilityReportHeaderViewWithQuiz&quot;; break; case IPadAbilityReportHeaderViewTypeWithoutQuiz: nibFileName = @&quot;IPadAbilityReportHeaderViewWithoutQuiz&quot;; break; case IPadAbilityReportHeaderViewTypeGaokao: nibFileName = @&quot;IPadAbilityReportHeaderViewInGaokao&quot;; break; default: break; &#125; NSArray *nibArray = [[NSBundle mainBundle] loadNibNamed:nibFileName owner:nil options:nil]; if (nibArray.count &gt; 0) &#123; return [nibArray lastObject]; &#125; else &#123; return nil; &#125;&#125; 总结通过多 target 编译方案，我们可以很方便的实现多个相似 App 的开发，以保证我们能够快速地推出多个相似课程的客户端。同时，由于在一个工程中，我们也可以方便地测试新的代码逻辑在各个课程下是否正常。 该方案可以用来解决 “维护大量逻辑相似但是又有细微不同的应用” 的需求，希望本文能给业界同行一些帮助。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"Objective-C对象模型及应用","slug":"objective-c-object-model","date":"2013-10-15T12:31:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/10/15/objective-c-object-model/","permalink":"https://blog.devtang.com/2013/10/15/objective-c-object-model/","excerpt":"前言原创文章，转载请注明出自 唐巧的技术博客。 本文主要介绍 Objective-C 对象模型的实现细节，以及 Objective-C 语言对象模型中对isa swizzling和method swizzling的支持。希望本文能加深你对 Objective-C 对象的理解。 ISA 指针Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。 在 XCode 中按Shift + Command + O, 然后输入 NSObject.h 和 objc.h，可以打开 NSObject 的定义头文件，通过头文件我们可以看到，NSObject 就是一个包含 isa 指针的结构体，如下图所示：","text":"前言原创文章，转载请注明出自 唐巧的技术博客。 本文主要介绍 Objective-C 对象模型的实现细节，以及 Objective-C 语言对象模型中对isa swizzling和method swizzling的支持。希望本文能加深你对 Objective-C 对象的理解。 ISA 指针Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。 在 XCode 中按Shift + Command + O, 然后输入 NSObject.h 和 objc.h，可以打开 NSObject 的定义头文件，通过头文件我们可以看到，NSObject 就是一个包含 isa 指针的结构体，如下图所示： 按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 isa 的指针。每一个类也可以接受消息，例如[NSObject alloc]，就是向 NSObject 这个类发送名为alloc消息。 在 XCode 中按Shift + Command + O, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 isa 指针的结构体，如下图所示。（图中除了 isa 外还有其它成员变量，但那是为了兼容非 2.0 版的 Objective-C 的遗留逻辑，大家可以忽略它。） 因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类 (metaclass)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。 元类 (metaclass) 也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有的元类的 isa 指针都会指向一个根元类 (root metaclass)。根元类 (root metaclass) 本身的 isa 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 isa 指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有 isa 指针。 我们再来看看继承关系，由于类方法的定义是保存在元类 (metaclass) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。 我很想把关系说清楚一些，但是这块儿确实有点绕，下面这张图或许能够让大家对 isa 和继承的关系清楚一些（该图片来自 这里） 该图中，最让人困惑的莫过于 Root Class 了。在实现中，Root Class 是指 NSObject，我们可以从图中看出： NSObject 类包括它的对象实例方法。 NSObject 的元类包括它的类方法，例如 alloc 方法。 NSObject 的元类继承自 NSObject 类。 一个 NSObject 的类中的方法同时也会被 NSObject 的子类在查找方法时找到。 类的成员变量如果把类的实例看成一个 C 语言的结构体（struct），上面说的 isa 指针就是这个结构体的第一个成员变量，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示（图片来自《iOS 6 Programming Pushing the Limits》）： 为了验证该说法，我们在 XCode 中新建一个工程，在 main.m 中运行如下代码： #import &lt;UIKit/UIKit.h&gt;@interface Father : NSObject &#123; int _father;&#125;@end@implementation Father@end@interface Child : Father &#123; int _child;&#125;@end@implementation Child@endint main(int argc, char * argv[])&#123; Child * child = [[Child alloc] init]; @autoreleasepool &#123; // ... &#125;&#125; 我们将断点下在 @autoreleasepool 处，然后在 Console 中输入p *child, 则可以看到 Xcode 输出如下内容，这与我们上面的说法一致。 (lldb) p *child(Child) $0 = &#123; (Father) Father = &#123; (NSObject) NSObject = &#123; (Class) isa = Child &#125; (int) _father = 0 &#125; (int) _child = 0&#125; 可变与不可变因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。 相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0 并未在头文件中将实现暴露出来，但在 Objective-C 1.0 中，我们可以看到方法的定义列表是一个名为 methodLists的指针的指针（如下图所示）。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是Category实现的原理。同时也说明了为什么Category只可为对象增加成员方法，却不能增加成员变量。 需要特别说明一下，通过objc_setAssociatedObject 和 objc_getAssociatedObject方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。 除了对象的方法可以动态修改，因为 isa 本身也只是一个指针，所以我们也可以在运行时动态地修改 isa 指针的值，达到替换对象整个行为的目的。不过该应用场景较少。 系统相关 API 及应用isa swizzling 的应用系统提供的 KVO 的实现，就利用了动态地修改 isa 指针的值的技术。在 苹果的文档 中可以看到如下描述： Key-Value Observing Implementation Details Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data. When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance. You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 类似的，使用 isa swizzling 的技术的还有系统提供的 Key-Value Coding（KVC）。 (谢谢大家指出错误，KVC 并没有使用到 isa swizzling) Method Swizzling API 说明Objective-C 提供了以下 API 来动态替换类方法或实例方法的实现： class_replaceMethod 替换类方法的定义 method_exchangeImplementations 交换 2 个方法的实现 method_setImplementation 设置 1 个方法的实现 这 3 个方法有一些细微的差别，给大家介绍如下： class_replaceMethod在苹果的文档（如下图所示）中能看到，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用class_addMethod来为该类增加一个新方法，也因为如此，class_replaceMethod在调用时需要传入types参数，而method_exchangeImplementations和method_setImplementation却不需要。 method_exchangeImplementations 的内部实现相当于调用了 2 次method_setImplementation方法，从苹果的文档中能清晰地了解到（如下图所示） 从以上的区别我们可以总结出这 3 个 API 的使用场景: class_replaceMethod, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。 method_exchangeImplementations，当需要交换 2 个方法的实现时使用。 method_setImplementation 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。 以上 3 个方法的源码在 这里，感兴趣的同学可以读一读。 使用示例我们在开发 猿题库 客户端的笔记功能时，需要使用系统的UIImagePickerController。但是，我们发现，在 iOS6.0.2 系统下，系统提供的UIImagePickerController在 iPad 横屏下有转屏的 Bug，造成其方向错误。具体的 Bug 详情可以见 这里。 为了修复该 Bug，我们需要替换UIImagePickerController的如下 2 个方法 - (BOOL)shouldAutorotate;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation; 我们先实现了一个名为ImagePickerReplaceMethodsHolder的类，用于定义替换后的方法和实现。如下所示： // ImagePickerReplaceMethodsHolder.h@interface ImagePickerReplaceMethodsHolder : NSObject- (BOOL)shouldAutorotate;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;@end// ImagePickerReplaceMethodsHolder.m@implementation ImagePickerReplaceMethodsHolder- (BOOL)shouldAutorotate &#123; return NO;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123; return UIInterfaceOrientationPortrait;&#125;@end 然后，我们在调用处，判断当前的 iOS 版本，对于 [iOS6.0, iOS6.1) 之间的版本，我们将UIImagePickerController的有问题的方法替换。具体代码如下： #define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self hackForImagePicker]; &#125;);&#125;+ (void)hackForImagePicker &#123; // fix bug of image picker under iOS 6.0 // http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0 if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;6.0&quot;) &amp;&amp; SYSTEM_VERSION_LESS_THAN(@&quot;6.1&quot;)) &#123; Method oldMethod1 = class_getInstanceMethod([UIImagePickerController class], @selector(shouldAutorotate)); Method newMethod1 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(shouldAutorotate)); method_setImplementation(oldMethod1, method_getImplementation(newMethod1)); Method oldMethod2 = class_getInstanceMethod([UIImagePickerController class], @selector(preferredInterfaceOrientationForPresentation)); Method newMethod2 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(preferredInterfaceOrientationForPresentation)); method_setImplementation(oldMethod2, method_getImplementation(newMethod2)); &#125;&#125; 通过如上代码，我们就针对 iOS 特定版本的有问题的系统库函数打了 Patch，使问题得到解决。 开源界的使用有少量不明真相的同学以为苹果在审核时会拒绝 App 使用以上 API，这其实是对苹果的误解。使用如上 API 是安全的。另外，开源界也对以上方法都适当的使用。例如： 著名的网络库 AFNetworking。AFNetworking 网络库 (v1.x 版本) 使用了 class_replaceMethod 方法（AFHTTPRequestOperation.m 文件第 105 行） Nimbus。Nimbus 是著名的工具类库，它在其 core 模块中提供了NIRuntimeClassModifications.h文件，用于提供上述 API 的封装。 国内的大众点评 iOS 客户端。该客户端使用了他们自己开发的基于 Wax 修改而来的 WaxPatch，WaxPatch 可以实现通过服务器更新来动态修改客户端的逻辑。而 WaxPatch 主要是修改了 wax 中的 wax_instance.m 文件，在其中加入了 class_replaceMethod 来替换原始实现，从而实现修改客户端的原有行为。 总结通过本文，我们了解到了 Objective-C 语言的对象模型，以及 Objective-C 语言对象模型中对isa swizzling和method swizzling的支持。本文也通过具体的实例代码和开源项目，让我们对该对象模型提供的动态性有了更加深刻的认识。 后记文章发表后，一些同行指出在 ARM64 的 CPU 下，isa 的内部结构有变化。这点我是知道的，不过希望以后再撰文讨论。感兴趣的同学可以查看苹果今年 WWDC2013 的视频：《Session 404 Advanced in Objective-C》。 参考链接 https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html http://www.devalot.com/articles/2011/11/objc-object-model.html http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html gunstep 的实现源码 http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf http://opensource.apple.com/source/objc4/objc4-532/runtime/ https://github.com/AFNetworking/AFNetworking https://github.com/jverkoey/nimbus https://github.com/mmin18/WaxPatch","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"动态下载苹果提供的多种中文字体","slug":"ios-asian-font-download-introduction","date":"2013-08-11T08:00:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/08/11/ios-asian-font-download-introduction/","permalink":"https://blog.devtang.com/2013/08/11/ios-asian-font-download-introduction/","excerpt":"引言在今年 WWDC 的内容公开之前，大家都以为 iOS 系统里面只有一种中文字体。为了达到更好的字体效果，有些应用在自己的应用资源包中加入了字体文件。但自己打包字体文件比较麻烦，原因在于： 1、字体文件通常比较大，10M - 20M 是一个常见的字体库的大小。大部分的非游戏的 app 体积都集中在 10M 以内，因为字体文件的加入而造成应用体积翻倍让人感觉有些不值。如果只是很少量的按钮字体需要设置，可以用一些工具把使用到的汉字字体编码从字体库中抽取出来，以节省体积。但如果是一些变化的内容需要自定义的字体，那就只有打包整个字体库了。 2、中文的字体通常都是有版权的。在应用中加入特殊中文字体还需要处理相应的版权问题。对于一些小公司或个人开发者来说，这是一笔不小的开销。 以上两点造成 App Store 里面使用特殊中文字库的 iOS 应用较少。现在通常只有阅读类的应用才会使用特殊中文字库。 但其实从 iOS6 开始，苹果就支持动态下载中文字体到系统中。只是苹果一直没有公开相应的 API。最终，相应的 API 在今年的 WWDC 大会上公开，接下来就让我们来一起了解这个功能。","text":"引言在今年 WWDC 的内容公开之前，大家都以为 iOS 系统里面只有一种中文字体。为了达到更好的字体效果，有些应用在自己的应用资源包中加入了字体文件。但自己打包字体文件比较麻烦，原因在于： 1、字体文件通常比较大，10M - 20M 是一个常见的字体库的大小。大部分的非游戏的 app 体积都集中在 10M 以内，因为字体文件的加入而造成应用体积翻倍让人感觉有些不值。如果只是很少量的按钮字体需要设置，可以用一些工具把使用到的汉字字体编码从字体库中抽取出来，以节省体积。但如果是一些变化的内容需要自定义的字体，那就只有打包整个字体库了。 2、中文的字体通常都是有版权的。在应用中加入特殊中文字体还需要处理相应的版权问题。对于一些小公司或个人开发者来说，这是一笔不小的开销。 以上两点造成 App Store 里面使用特殊中文字库的 iOS 应用较少。现在通常只有阅读类的应用才会使用特殊中文字库。 但其实从 iOS6 开始，苹果就支持动态下载中文字体到系统中。只是苹果一直没有公开相应的 API。最终，相应的 API 在今年的 WWDC 大会上公开，接下来就让我们来一起了解这个功能。 功能介绍使用动态下载中文字体的 API 可以动态地向 iOS 系统中添加字体文件，这些字体文件都是下载到系统的目录中（目录是/private/var/mobile/Library/Assets/com_apple_MobileAsset_Font/），所以并不会造成应用体积的增加。并且，由于字体文件是 iOS 系统提供的，也免去了字体使用版权的问题。虽然第一次下载相关的中文字体需要一些网络开销和下载时间，但是这些字体文件下载后可以在所有应用间共享，所以可以遇见到，随着该 API 使用的普及，大部分应用都不需要提示用户下载字体，因为很可能这些字体在之前就被其它应用下载下来了。 字体列表在 这个链接 中，苹果列出了提供动态下载和使用中文字体文件列表。不过，由于下载的时候需要使用的名字是 PostScript 名称，所以如果你真正要动态下载相应的字体的话，还需要使用 Mac 内自带的应用 “字体册 “来获得相应字体的 PostScript 名称。如下显示了从” 字体册 “中获取《兰亭黑-简 特黑》字体的 PostScript 名称的截图： API 介绍苹果提供的动态下载代码的 Demo 工程 链接在这里。将此 Demo 工程下载下来，即可学习相应 API 的使用。下面我对该工程中相应 API 做简单的介绍。 假如我们现在要下载娃娃体字体，它的 PostScript 名称为DFWaWaSC-W5。具体的步骤如下： 1、我们先判断该字体是否已经被下载下来了，代码如下： - (BOOL)isFontDownloaded:(NSString *)fontName &#123; UIFont* aFont = [UIFont fontWithName:fontName size:12.0]; if (aFont &amp;&amp; ([aFont.fontName compare:fontName] == NSOrderedSame || [aFont.familyName compare:fontName] == NSOrderedSame)) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 2、如果该字体下载过了，则可以直接使用。否则我们需要先准备下载字体 API 需要的一些参数，如下所示： // 用字体的 PostScript 名字创建一个 DictionaryNSMutableDictionary *attrs = [NSMutableDictionary dictionaryWithObjectsAndKeys:fontName, kCTFontNameAttribute, nil];// 创建一个字体描述对象 CTFontDescriptorRefCTFontDescriptorRef desc = CTFontDescriptorCreateWithAttributes((__bridge CFDictionaryRef)attrs);// 将字体描述对象放到一个 NSMutableArray 中NSMutableArray *descs = [NSMutableArray arrayWithCapacity:0];[descs addObject:(__bridge id)desc];CFRelease(desc); 3、准备好上面的descs变量后，则可以进行字体的下载了，代码如下： __block BOOL errorDuringDownload = NO;CTFontDescriptorMatchFontDescriptorsWithProgressHandler( (__bridge CFArrayRef)descs, NULL, ^(CTFontDescriptorMatchingState state, CFDictionaryRef progressParameter) &#123; double progressValue = [[(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingPercentage] doubleValue]; if (state == kCTFontDescriptorMatchingDidBegin) &#123; NSLog(@&quot; 字体已经匹配 &quot;); &#125; else if (state == kCTFontDescriptorMatchingDidFinish) &#123; if (!errorDuringDownload) &#123; NSLog(@&quot; 字体 %@ 下载完成 &quot;, fontName); &#125; &#125; else if (state == kCTFontDescriptorMatchingWillBeginDownloading) &#123; NSLog(@&quot; 字体开始下载 &quot;); &#125; else if (state == kCTFontDescriptorMatchingDidFinishDownloading) &#123; NSLog(@&quot; 字体下载完成 &quot;); dispatch_async( dispatch_get_main_queue(), ^ &#123; // 可以在这里修改 UI 控件的字体 &#125;); &#125; else if (state == kCTFontDescriptorMatchingDownloading) &#123; NSLog(@&quot; 下载进度 %.0f%% &quot;, progressValue); &#125; else if (state == kCTFontDescriptorMatchingDidFailWithError) &#123; NSError *error = [(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingError]; if (error != nil) &#123; _errorMessage = [error description]; &#125; else &#123; _errorMessage = @&quot;ERROR MESSAGE IS NOT AVAILABLE!&quot;; &#125; // 设置标志 errorDuringDownload = YES; NSLog(@&quot; 下载错误: %@&quot;, _errorMessage); &#125; return (BOOL)YES;&#125;); 通常需要在下载完字体后开始使用字体，一般是将相应代码放到 kCTFontDescriptorMatchingDidFinish 那个条件中做，可以象苹果官网的示例代码上那样，用 GCD 来改 UI 的逻辑，也可以发 Notification 来通知相应的 Controller。 以下是通过以上示例代码下载下来的娃娃体字体截图： iOS 版本限制以上代码只能运行在 iOS6 以上的系统，但当前还有不少用户是 iOS5 的系统。不过，随着苹果在 WWDC2013 中推出 iOS7 的 beta 版，很多人都期待着使用 iOS7。从历史数据上看，苹果 iOS 新版本推出后，通常 3 个月内就可以达到 50% 以上的使用比例。所以，可以遇见到在今年年底，iOS5 的用户将所剩无几。如果我们打算在年底只支持 iOS6 以上的系统，那么就可以通过上面介绍的方法使用大量中文字体来美化你的应用。 愿新的 API 能让大家的应用更加美观，have fun!","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"谈Objective-C block的实现","slug":"a-look-inside-blocks","date":"2013-07-28T02:42:00.000Z","updated":"2024-01-06T14:52:37.915Z","comments":true,"path":"2013/07/28/a-look-inside-blocks/","permalink":"https://blog.devtang.com/2013/07/28/a-look-inside-blocks/","excerpt":"前言这里 有关于 block 的 5 道测试题，建议你阅读本文之前先做一下测试。 先介绍一下什么是闭包。在 wikipedia 上，闭包的定义 是: In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function. 翻译过来，闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。 block 实际上就是 Objective-C 语言对于闭包的实现。block 配合上 dispatch_queue，可以方便地实现简单的多线程编程和异步编程，关于这个，我之前写过一篇文章介绍：《使用 GCD》。 本文主要介绍 Objective-C 语言的 block 在编译器中的实现方式。主要包括： block 的内部实现数据结构介绍 block 的三种类型及其相关的内存管理方式 block 如何通过 capture 变量来达到访问函数外的变量","text":"前言这里 有关于 block 的 5 道测试题，建议你阅读本文之前先做一下测试。 先介绍一下什么是闭包。在 wikipedia 上，闭包的定义 是: In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function. 翻译过来，闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。 block 实际上就是 Objective-C 语言对于闭包的实现。block 配合上 dispatch_queue，可以方便地实现简单的多线程编程和异步编程，关于这个，我之前写过一篇文章介绍：《使用 GCD》。 本文主要介绍 Objective-C 语言的 block 在编译器中的实现方式。主要包括： block 的内部实现数据结构介绍 block 的三种类型及其相关的内存管理方式 block 如何通过 capture 变量来达到访问函数外的变量 实现方式数据结构定义block 的数据结构定义如下（图片来自 这里)： 对应的结构体定义如下： struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;;struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */&#125;; 通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成： isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。 该数据结构和后面的 clang 分析出来的结构实际是一样的，不过仅是结构体的嵌套方式不一样。但这一点我一开始没有想明白，所以也给大家解释一下，如下 2 个结构体 SampleA 和 SampleB 在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息。 struct SampleA &#123; int a; int b; int c;&#125;;struct SampleB &#123; int a; struct Part1 &#123; int b; &#125;; struct Part2 &#123; int c; &#125;;&#125;; 在 Objective-C 语言中，一共有 3 种类型的 block： _NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。 _NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。 _NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。 我们在下面会分别来查看它们各自的实现方式上的差别。 研究工具：clang为了研究编译器是如何实现 block 的，我们需要使用 clang。clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 block 具体的源码实现方式。该命令是 clang -rewrite-objc block.c NSConcreteGlobalBlock 类型的 block 的实现我们先新建一个名为 block1.c 的源文件： #include &lt;stdio.h&gt;int main()&#123; ^&#123; printf(&quot;Hello, World!\\n&quot;); &#125; (); return 0;&#125; 然后在命令行中输入clang -rewrite-objc block1.c即可在目录中看到 clang 输出了一个名为 block1.cpp 的文件。该文件就是 block 在 c 语言实现，我将 block1.cpp 中一些无关的代码去掉，将关键代码引用如下： struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(&quot;Hello, World!\\n&quot;);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;int main()&#123; (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA) (); return 0;&#125; 下面我们就具体看一下是如何实现的。__main_block_impl_0 就是该 block 的实现，从中我们可以看出： 一个 block 实际是一个对象，它主要由一个 isa 和 一个 impl 和 一个 descriptor 组成。 在本例中，isa 指向 _NSConcreteGlobalBlock， 主要是为了实现对象的所有特性，在此我们就不展开讨论了。 由于 clang 改写的具体实现方式和 LLVM 不太一样，并且这里没有开启 ARC。所以这里我们看到 isa 指向的还是_NSConcreteStackBlock。但在 LLVM 的实现中，开启 ARC 时，block 应该是 _NSConcreteGlobalBlock 类型，具体可以看 《objective-c-blocks-quiz》 第二题的解释。 impl 是实际的函数指针，本例中，它指向 __main_block_func_0。这里的 impl 相当于之前提到的 invoke 变量，只是 clang 编译器对变量的命名不一样而已。 descriptor 是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。在该例子中我们还看不到相关 capture 的代码，后面将会看到。 NSConcreteStackBlock 类型的 block 的实现我们另外新建一个名为 block2.c 的文件，输入以下内容： #include &lt;stdio.h&gt;int main() &#123; int a = 100; void (^block2)(void) = ^&#123; printf(&quot;%d\\n&quot;, a); &#125;; block2(); return 0;&#125; 用之前提到的 clang 工具，转换后的关键代码如下： struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy printf(&quot;%d\\n&quot;, a);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int a = 100; void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2); return 0;&#125; 在本例中，我们可以看到： 本例中，isa 指向 _NSConcreteStackBlock，说明这是一个分配在栈上的实例。 __main_block_impl_0 中增加了一个变量 a，在 block 中引用的变量 a 实际是在申明 block 时，被复制到 __main_block_impl_0 结构体中的那个变量 a。因为这样，我们就能理解，在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a。 __main_block_impl_0 中由于增加了一个变量 a，所以结构体的大小变大了，该结构体大小被写在了 __main_block_desc_0 中。 我们修改上面的源码，在变量前面增加 __block 关键字： #include &lt;stdio.h&gt;int main()&#123; __block int i = 1024; void (^block1)(void) = ^&#123; printf(&quot;%d\\n&quot;, i); i = 1023; &#125;; block1(); return 0;&#125; 生成的关键代码如下，可以看到，差异相当大： struct __Block_byref_i_0 &#123; void *__isa; __Block_byref_i_0 *__forwarding; int __flags; int __size; int i;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_i_0 *i; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref printf(&quot;%d\\n&quot;, (i-&gt;__forwarding-&gt;i)); (i-&gt;__forwarding-&gt;i) = 1023;&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main()&#123; __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;; void (*block1)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344); ((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1); return 0;&#125; 从代码中我们可以看到： 源码中增加一个名为 __Block_byref_i_0 的结构体，用来保存我们要 capture 并且修改的变量 i。 __main_block_impl_0 中引用的是 __Block_byref_i_0 的结构体指针，这样就可以达到修改外部变量的作用。 __Block_byref_i_0 结构体中带有 isa，说明它也是一个对象。 我们需要负责 __Block_byref_i_0 结构体相关的内存管理，所以 __main_block_desc_0 中增加了 copy 和 dispose 函数指针，对于在调用前后修改相应变量的引用计数。 NSConcreteMallocBlock 类型的 block 的实现NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。以下是一个 block 被 copy 时的示例代码 (来自 这里)，可以看到，在第 8 步，目标的 block 类型被修改为 _NSConcreteMallocBlock。 static void *_Block_copy_internal(const void *arg, const int flags) &#123; struct Block_layout *aBlock; const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE; // 1 if (!arg) return NULL; // 2 aBlock = (struct Block_layout *)arg; // 3 if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123; // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock; &#125; // 4 else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123; return aBlock; &#125; // 5 struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return (void *)0; // 6 memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first // 7 result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 1; // 8 result-&gt;isa = _NSConcreteMallocBlock; // 9 if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123; (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup &#125; return result;&#125; 变量的复制对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的，如下图所示（图片来自 这里）： 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的，如下图所示（图片来自 这里）： LLVM 源码在 LLVM 开源的关于 block 的实现源码，其内容也和我们用 clang 改写得到的内容相似，印证了我们对于 block 内部数据结构的推测。 ARC 对 block 类型的影响在 ARC 开启的情况下，将只会有 NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 block。 原本的 NSConcreteStackBlock 的 block 会被 NSConcreteMallocBlock 类型的 block 替代。证明方式是以下代码在 XCode 中，会输出 &lt;__NSMallocBlock__: 0x100109960&gt;。在苹果的 官方文档 中也提到，当把栈中的 block 返回时，不需要调用 copy 方法了。 #import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; int i = 1024; void (^block1)(void) = ^&#123; printf(&quot;%d\\n&quot;, i); &#125;; block1(); NSLog(@&quot;%@&quot;, block1); &#125; return 0;&#125; 我个人认为这么做的原因是，由于 ARC 已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。 参考链接希望本文能加深你对于 block 的理解。我在学习中，查阅了以下文章，一并分享给大家。祝大家玩得开心～ A look inside blocks: Episode 1 A look inside blocks: Episode 2 A look inside blocks: Episode 3 对 Objective-C 中 Block 的追探 LLVM 中 block 实现源码 objective-c-blocks-quiz Blocks","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"分析支付宝客户端的插件机制","slug":"alipay-plugin-mechanism","date":"2013-06-23T04:39:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/06/23/alipay-plugin-mechanism/","permalink":"https://blog.devtang.com/2013/06/23/alipay-plugin-mechanism/","excerpt":"前言因为开了 iOSDevTips 的微信公共账号，老收到各种 iOS 开发的问题，前两天收到一个问题的内容是： 请问像支付宝钱包那样可以在应用里安装自己的应用，是已经在应用里写了逻辑，还是可以向应用里发送代码 ? 我觉得这个问题挺有意思的，估计大家都感兴趣，所以今天就抽空研究了一下，将支付宝客户端的插件机制具体实现方式介绍给大家。 先介绍一下该插件机制，如上图所示，支付宝客户端在安装后，对于像 “彩票”、“爱心捐赠” 这类功能，需要再点击安装一次，然后才可以使用。有些时候该插件功能进行了升级，需要点击升级才可以继续使用。插件的方式有利于软件动态增加新的功能或升级功能，而不用再一次向 AppStore 提交审核。另外，由于用户不需要的插件可以不用安装，也缩小了应用本身的体积大小，节省了下载流量。","text":"前言因为开了 iOSDevTips 的微信公共账号，老收到各种 iOS 开发的问题，前两天收到一个问题的内容是： 请问像支付宝钱包那样可以在应用里安装自己的应用，是已经在应用里写了逻辑，还是可以向应用里发送代码 ? 我觉得这个问题挺有意思的，估计大家都感兴趣，所以今天就抽空研究了一下，将支付宝客户端的插件机制具体实现方式介绍给大家。 先介绍一下该插件机制，如上图所示，支付宝客户端在安装后，对于像 “彩票”、“爱心捐赠” 这类功能，需要再点击安装一次，然后才可以使用。有些时候该插件功能进行了升级，需要点击升级才可以继续使用。插件的方式有利于软件动态增加新的功能或升级功能，而不用再一次向 AppStore 提交审核。另外，由于用户不需要的插件可以不用安装，也缩小了应用本身的体积大小，节省了下载流量。 分析过程截取网络请求分析第一步，截取网络请求。截取网络请求可以查看当用户点击 “彩票” 进行安装的时候，客户端到底做了什么事情。使用 Charles 的代理设置功能，启动一个 http 代理，然后在 iPhone 上设置连接此代理，则可以看到，当点击 “彩票” 插件时，客户端下载了一个名为 10000011.amr 的文件。如下图所示： 下载插件文件尝试用 wget 将文件下载下来，发现其没有验证 cookie，下载成功，命令如下： wget http://download.alipay.com/mobilecsprod/alipay.mobile/20130601021432806/xlarge/10000011.amr amr 本意表示是一个音频文件，明显不对，尝试将其后缀名改成 zip，成功将其解压。用 itools 连接上支付宝的客户端，同样能看到客户端将其下载后，也是解压到 document 目录下的。解压后的内容与应用内新增加的内容一致，如图所示： 分析文件内容大概浏览了一下解压后的文件，主要包括 html、css 和 js 文件。可见支付宝的插件机器是通过 UIWebView 来展示内容的方式来实现的，那为什么要先下载安装这些内容而不通过 UIWebView 实时下载 html 呢？这主要应该是为了节省相应的流量。我看了一下，10000011.amr 文件整个有将近 1M 大小，如果不通过插件机制预先下载，则只能依赖系统对于 UIWebView 的缓存来节省流量，这相对来说没有前者靠谱。 另外，使用基于 UIWebView 的方式来展示插件，也有利于代码的复用。因为这些逻辑都是用 js 来写的，可以同样应用于 Android 平台，在 Config.js 文件中，明显可以看到对于各类平台的判断逻辑。如下图所示： 另外，&#x2F;www&#x2F;demo&#x2F;index-alipay-native.html 文件即该插件的首页，用浏览器打开就可以看到和手机端一样的内容。如下载图所示（左半边是手机上的应用截图，右半边是浏览器打开该 html 文件的截图）： 插件的网络通讯接下来感兴趣的是该插件是如何完成和支付宝后台的网络通讯的。可以想到有两种可能的方式： 直接和支付宝后台通讯 和 Native 端通讯，然后 Native 端和服务器通讯。 要验证这个需要读该插件的 js 源代码，整个 js 源码逻辑还是比较干净的，主要用了玉伯写的 seajs 做模块化加载，backbone.js 是一个前端的 MVC 框架，zepto.js 是一个更适合于移动端使用的 “JQuery”。 大概扫了一下，感觉更可能是用的方法一：直接和支付宝后台通讯 , 因为 Config.js 中都明确将网络通讯的地址写下来了。另一个证据是，利用下面的脚本扫描整个 js 源码，只能在 backbone 中搜到对于 iframe 的使用。而在 iOS 开发中，如果 js 端和 native 端要通讯，是需要用到 iframe 的，详细原理可以参见我的另一篇文章 《关于 UIWebView 和 PhoneGap 的总结》。不过我不能完全确认，因为我还没有找到相应控制页面切换和跳转的 js 代码，如果你找到了，麻烦告诉我。 find . -type f -name &quot;*.js&quot; | xargs grep &quot;iframe&quot; 交易的安全用 Charles 可以截取到，当有网络交易时，应用会另外启动一个 https 的安全链接，完成整个交易过程的加密。如下图所示： 总结支付宝的插件机制整体上就是通过 html 和 javascript 方式实现的，主要的好处是： 跨平台 (可以同时用在 iOS 和 Android 客户端） 省流量（不需要的插件不用下载，插件本地缓存长期存在不会过期，自己管理插件更新逻辑） 更新方便（不用每次提交 AppStore 审核） 坏处如果非要说有的话，就是用 javascript 写 iOS 界面，无法提供非常炫的 UI 交互以及利用到 iOS 的所有平台特性。不过象支付宝这种工具类应用，也不需要很复杂的 UI 交互效果。 另外教大家一个小技巧，如果你不确定某个页面是不是 UIWebView 做的，直接在那个页面长按，如果弹出 “ 拷贝，定义，学习 “ 这种菜单，那就是确定无疑是 UIWebView 的界面了。如下图所示： 相关工具欢迎关注我的技术微博 @ 唐巧 _boy 和微信公共账号 iOSDevTips ，每天收获一些关于 iOS 开发的学习资料和技巧心得。 我在研究时使用了 Charles 来截获支付宝客户端的网络请求，用 iTools 来查看支付宝客户端的本地内容。如果你想自行验证本文内容，请先下载上述工具。在此就不额外介绍它们的使用了。 后记（2013-7-7） 在完成上文后，Allen 在他的博客上先后分享了两篇更深入分析的文章 《浅析支付宝钱包插件》 和 《再谈支付宝钱包插件和说好的 Demo》。 这两篇文章都比本文深入得多，值得大家阅读。 写完上文，居然收到了来自支付宝卫朴（花名）的工作邀请。不过我现在创业正在努力当中，所以我拒绝了邀请。看来这也是一种找工作的办法啊，比投简历管用，呵呵。 从一些朋友那儿了解到，支付宝因为本文而会在以后的版本中加强安全性，至少不会像现在这样，所有逻辑都在写在 javascript 中，并且还带有注释，这也是我希望看到的结果。愿支付宝越做越好。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"写在创业一周年","slug":"startup-anniversary-note","date":"2013-06-17T12:56:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/06/17/startup-anniversary-note/","permalink":"https://blog.devtang.com/2013/06/17/startup-anniversary-note/","excerpt":"前言大约在去年这个时候，我离开网易有道，开始了自己的创业不归路。一年过去了，总是在忙碌，在最忙的时候，我连博客都没有时间更新了。但是这一年的经历对我的成长重大，还是挺值得写下来的，在此将我的故事分享给那些一同走在创业路上的朋友。","text":"前言大约在去年这个时候，我离开网易有道，开始了自己的创业不归路。一年过去了，总是在忙碌，在最忙的时候，我连博客都没有时间更新了。但是这一年的经历对我的成长重大，还是挺值得写下来的，在此将我的故事分享给那些一同走在创业路上的朋友。 当初的选择这次的创业其实并不算是真正意义上的创业，因为我并不是创业合伙人，也没有股权，对于公司的发展，我更多是执行者，很少有参与讨论的机会。但与此同时，我的薪水并没有大幅度减少，期权所画出的大饼也确实有些吸引力，另外，我可以独立负责 iOS 开发，对我来说是一个不小的挑战，作为一个早期加入的核心员工，我可以享受到公司成长带来的好处，也可以和公司一起成长，承担更多责任，学习和体会创业的过程。 所以，如果我这次创业失败，对我的影响相当小，我不用担心交不起房租，更不用担心找不到工作。不管创业成功与否，我都将收获在 iOS 开发领域快速的成长，也可以感受和学习创业公司的工作方式。现在一年过去了，创业发展顺利，我还可以进一步感受和思考公司规模扩大所带来的各种问题，以及一起参与解决这些问题。 某种程度上说，这符合我对于第一次创业的期望方式：有挑战，有收获，风险小，潜在收益也不错。因为我工作才 3 年，在各方面还很嫩，选择加入一个创业团队比直接自己当创业合伙人要安全得多。 技术成长由于我不是合伙人，所以我可以继续专注于 iOS 开发，不用管市场，运营以及产品的事情。以前在前公司，我只是负责某 iOS 产品的 UI 部分，我甚至都没有机会了解将 App 发布到 AppStore 的过程。在这次创业中，整个 iOS 端的开发都是由我一人负责，我学习和接触了很多以前没有机会了解的东西。 在项目开发中学习是最好的学习方式，这次创业我也不止做了一个 App，每做一个 App，我就会尝试一些新的技术方案和挑战。 在做粉笔网客户端时，我尝试了完全使用 ARC，也尝试用 UIWebView 写了很多 javascript。 在做猿题库行测时，我尝试了使用 AVFoundation 来自定义扫描界面，尝试用 OpenCV 来实现答题卡识别算法，尝试用 CoreText 做部分界面的渲染。 在做猿题库申论时，我尝试用 Storyboard 和 cocoapod 来做包管理。 在做猿题库司法考试时，考虑到团队可能扩大，我尝试用全手写界面的方式来开发。并且用 Git Submodule 来管理猿题库公用模块。 在即将上线的猿题库新课程中，我尝试了结合多 target 编译和 Submodule 来管理多个猿题库之间的差别，力求将新课程的开发成本减少到只需一些配置文件即可。 如果不是因为创业，我可能都无法决定使用这些技术方案，更别说负责整个 iOS 端了。 眼界变宽以前在网易，公司里有很多做 iOS 开发的同事，偶尔有一些技术交流，现在创业只有我一个人做 iOS 开发，我最担心的是我自己由于交流太少而眼界变窄。于是我想只有通过网络和同行进行更多的交流了。于是我就建了一个 QQ 群，然后把以前的同事都拉到群里面，但是大家还是交流还是比较少，我想了想，主要是因为这些同事都不太喜欢交流和分享，强行把他们拉到 QQ 群里面，并不能促使他们交流，于是我就开始在网上寻找一些喜欢交流的同行，邀请他们加到群里面一起聊技术。这样慢慢地，群里面就有自发的讨论出现了。 有一段时间，我发现讨论的内容还挺有价值的，于是就觉得 QQ 群不能将讨论内容沉淀下来太可惜了，当时正好微信公共账号比较火，我就想试试把有价值的内容通过微信公共账号发出去。刚开始很难，原因一方面是整理信息的成本很高，写成微信很花时间。另一方面，我也没有那么多时间来写微信。不过我坚持了一段时间后，渐渐发现有一些牛人会被吸引到我们的 QQ 群里面，这样就行成了一个良性循环。QQ 群不断有牛人加入贡献高质量的讨论，讨论内容通过微信发出去后，又吸引更多牛人要求加入。由于申请加入的人太多，我提高了申请加群的要求，因为群里人数一旦过多，就会影响平时的工作了。所以现在 QQ 群的人数基本稳定了。群里面的人员组成主要分以下几类： 比较大的 IT 公司的 iOS 开发者，包括腾讯、百度、新浪、搜狐、网易、阿里、人人等 比较小的 IT 公司的 iOS 开发者，包括豆瓣、美团、知乎、拓词、花瓣、Clover、流利说等 自由职业者或自己在创业中的 iOS 开发者 海外的 iOS 开发者 如果说有什么特点，就是他们都是喜欢分享的人，大部分人都维护着自己的原创博客，这保证了群里面讨论内容的活跃。同时他们都还很忙，这保证了群里面不会很水，有问题讨论问题，没问题的时候就很安静。这是我非常喜欢的。因为这样的讨论组一方面保证了讨论的即时性，另一方面又不至于太吵而干扰平时的工作。 如果不是因为创业，我可能也不会被迫组建并维护这么一个高质量的 QQ 群，进而也不会有这么好的交流圈子了。 我的微信公众账号是 iOSDevTips, 现在关注人数有 3000 人。6 月 6 日，微信公共账号同时得到了 @Fenng 和 @ 池建强 在各自的微信公共账号上的 推荐，关注人数也暴涨。很高兴自己最终坚持下来了。如果你是 iOS 开发者，欢迎关注我的微信公共账号，只发干货。用微信扫描下面的二维码即可关注： 工作上的反思和改进虽然我在创业中专注于 iOS 开发，但是我还是会参与一些产品讨论，也会负责面试招人，也会反思现有工作方式的各种问题。这种反思的过程持续地在每一天进行。这种反思和改进包括如下几个方面。 执行力变强似乎什么事情都可以归结到对资源和时间的合理分配和控制。对于创业公司来说，对于产品开发进度的控制是尤其重要的，我们很高兴地看到，我们的创业团队在过去的一年，不但保证了所有开发项目不延期，并且还保证了很快的开发进度。在过去一年，我们花 4 个月完成了粉笔网的开发，3 个月完成了猿题库行测的开发，2 个月完成了猿题库司法考试的开发，7 天完成了猿题库申论的开发，这些项目的开发进度和我们之前计划的完全一样，没有任何延期。在软件开发领域，项目延期对于很多公司来说从来都是常态，我们通过团队的努力以及一些合理的进度管理方法来让按期交付变成了常态。 首先说说团队的努力，团队的努力主要在于团队每个人都努力工作，提高效率。就我个人来说，我会更加关注自己每天花在写代码上面的时间和沟通的时间，以及工作间隙刷微博的时间。我有些时候状态好，可以一连写好几个小时代码，有些时候状态不好，写一会儿代码就会分神干别的，这个时候我会把所有干扰工作的 QQ, 邮箱都关掉，然后戴上耳机，给自己设置一个 45 分钟的番茄钟（不知道这个是什么的，可以搜一下番茄工作法），然后每个番茄钟到了再休息一下，一般连续做过 3 个番茄钟之后，精力就又容易集中了，之后就不用设置番茄钟又可以连续写上好几个小时。当然，适当活动也是必要的，我有时候会注意每一个小时动一下，公司里面也有哑铃可以举几个。另外，我还安装了 rescue time 软件 ，可以方便自己回顾每天的工作效率变化情况。 然后说说我们的进度管理方法，我们使用 scrum 来进行进度管理，但是根据我们创业团队的情况，我们做了不少改变，我们对于 scrum 的主要改变是： scrum 中每个 sprint 的周期变为 1 周。下面会展开阐述理由。 scrum 会议中的回顾会议和计划会议一起开。主要是为了减少会议的次数。 1 周的 sprint 相比传统的 2 周或 4 周 sprint 最大的优点是，可以对进度有较强的控制，因为迭代周期减小为一周，所以可以更早地发现开发中可以出现的问题，进而进行微调。微调的粒度变小，就保证了整体进度的可控。我们对开发进度的微调包括： 通过每周的 sprint，尽早发现开发进度上的风险，合理加班或者减少部分需求开发。 通过每周的 sprint，尽早地将产品功能的改变融入到新的 sprint 中，使得产品能够尽快应对来自市场需求或产品需求的变化。 1 周的 sprint 也有一定的缺点，首先是它的时间非常紧，除去开回顾会议和计划会议的时间，通常只剩下 4 天半。4 天半时间通常会排满开发进度，常常会造成留给测试同事的时间比较少。对于要上线的 sprint，sprint 结束日那天的上线工作也会占据不少时间，因为上线通常会涉及很多系统运维相关的操作。另一个缺点是，它无法安排一些长期并且重要的事情，例如技术分享和讨论，新技术调研等。 但整体说来，对于创业公司来说，活下去才是最重要的，1 周的 sprint 可以带来产品按时交付的巨大优势。所以我们直到现在还是坚持 1 周的 sprint。或许以后公司大了，时间不是最最紧迫的资源时，我们可能会考虑 2 周的 sprint。 对 scrum 有了更深认识scrum 很容易被误解，也容易被错误地实践。 对于高压型的 Leader, scrum 很容易成为他压榨程序员的工具，因为程序员通常在估计工作量时很乐观，但是执行时就会出现各种问题，scrum 将任务拆分到每天做什么的时候，很容易造成程序员为了完成当天的工作而加班。如果管理者在回顾会议不能很好的处理这个问题，程序员就会认为这是一种管理者控制进度的工具，然后在以后的计划会议中故意将时间估长。 对于温和的 Leader, scrum 中的 sprint 很可能成为一句空话，每个 sprint 都会出现完不成的情况，每次当然都会有合理的理由：例如功能开发量估计不足，需求没有讨论清楚，遇到的技术难点等等。当大家对于 sprint 的按时完成没有压力的时候，scrum 本身就成了一个可有可无的东西了。 执行了一年多 scrum，我感觉 scrum 最核心的思想就是强调团队的自我反思和进步，而这一点要求 scrum 团队成员有较强的能力和素质。所以很多公司没有把 scrum 执行好，就是简单地执行了 scrum 中的各种流程和方法，而忽视了其中最重要的基础：团队成员的能力。如果团队成员本身能力不行，也不能为整个团队着想，为公司着想，搞 scrum 就是一句空话。只有大家真正相互欣赏，相互理解和配合，团队的作用才能发挥起来。我们通过一年多对 scrum 的实践和改进，最终形成了我们自己的团队工作方式和团队文化，这一点是非常棒的。 如果不是因为创业，我可能至今还以为 scrum 只是管理者为了压榨程序员的劳动力而建立的工具，也无法体会到 scrum 的好处。 更注意沟通效率上面也说过，时间是创业公司最大的敌人。而对于我来说，除了写代码的时间外，最大的时间开销就是沟通了。我们想了很多办法来提高沟通的效率。比如重要的信息，我们都会记录在 wiki 上，比如每次 scrum 的回顾会议的总结，我们就会放到 wiki 上，服务器端的接口信息，我们也会整理到 wiki 上。wiki 对于新来的同事特别有用，因为他可以通过 wiki 了解到整个团队工作的历史，进而方便他熟悉和融入团队。对于一些相互依赖的接口信息，放到 wiki 上也省去了我们为了弄清楚接口而打断别人的工作，提高了大家的工作效率。 为了提高沟通效率，我们也把所有能省去的会议都省去了，我们没有产品评审会议，没有美术评审会议，我们也不会评审测试用例，以上这些会议，如果我们觉得有必要进行沟通的，就私下沟通，一切从简。 我们尽量减少打断别人工作的行为，如果我觉得有一件事情需要让所有人知道，我就会发一封邮件出来，如果该事情值得记录下来，我可能会同时把内容整理到 wiki 上。如果我在开发上的一些任务依赖后台相应的功能，我就会给相关人员报一个 Bug，让他抽时间处理这个 Bug 即可。小的产品文案的改动也是以报 Bug 的形式来沟通。如果有些事情急需要让大家知道，比如服务器正在重启，测试和开发暂时不可连接服务器，我们就会在 QQ 群里面说一声。只有当我的工作被严重 block 的时候，例如需要服务器同事的确认才能进一步开发，例如需要产品的确认才能进一步开发的时候，我才会去打断别人的工作当面询问。尽量保证别人的工作可以不被打断，其实也是提高了大家工作的效率。 回想起以前在大公司，所有的沟通大多是在 QQ 一类的聊天工具中完成，打字交流，效率极低。开组会的时候，很多人无所事事，玩手机开小差，效率低下。创业让我感受到了效率至上的工作态度，让自己每天的工作高效是非常快乐的事情。由于我们不鼓励加班，所以我们自然也享受到了高效工作的回报：自己有更多时间做自己的事情。我每天都比同屋的另一个在美团工作的朋友下班早，晚上下班回到家，有时候我会看看书，有时候看看电影，有时候也会研究一些新的技术，创业的生活不再变得苦逼了。 如果不是因为创业，我根本无法体会到创业带来的高效地工作环境，每天自己的时间都在做具体的事情上，而不是大量的沟通上。 总结如果不是因为创业，我无法在 iOS 开发上负责更多事情并且快速成长，无法扩大眼界认识很多 iOS 同行并和他们组建高质量讨论圈子，无法成功地连续一年执行 scrum 并且保证所有项目不延期，也无法享受高效工作不加班的生活。有这么多收获，创业本身能不能成功反倒不是最重要的事情了，每天能够开心，认真，充实地工作本身就是一种享受。 身边有不少朋友都在创业，有失败的，也有发展顺利的，和他们聊天常常会谈到，创业是一条不归路，因为创业的过程就象是打开了潘多拉的盒子，你见识到了外面世界的精彩，就再也不能忍受在大公司的平庸生活了。愿所有在创业路上奔跑的人们，找到属于自己的精彩。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"}]},{"title":"iOS开发工具篇-AppStore统计工具","slug":"ios-dev-tool-app-store-tool","date":"2013-06-16T04:26:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/06/16/ios-dev-tool-app-store-tool/","permalink":"https://blog.devtang.com/2013/06/16/ios-dev-tool-app-store-tool/","excerpt":"本文首发于 InfoQ，本文版权归 InfoQ 所有，转载请保留 原文链接。 前言随着 iOS 开发的流行，针对 iOS 开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics 等), App Store 销售分析工具（例如 App annie)， App crash 收集工具（例如 Crashlytics)，App 测试发布工具（Test Flight）, App Push 服务等。 这些解决方案或工具节省了 iOS 开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以我希望，将我自己使用和调研的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。 今天介绍 AppStore 统计工具：App Annie 和苹果的命令行统计工具。","text":"本文首发于 InfoQ，本文版权归 InfoQ 所有，转载请保留 原文链接。 前言随着 iOS 开发的流行，针对 iOS 开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics 等), App Store 销售分析工具（例如 App annie)， App crash 收集工具（例如 Crashlytics)，App 测试发布工具（Test Flight）, App Push 服务等。 这些解决方案或工具节省了 iOS 开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以我希望，将我自己使用和调研的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。 今天介绍 AppStore 统计工具：App Annie 和苹果的命令行统计工具。 App Annie 介绍 苹果官方的 iTunes Connect 提供的销售数据统计功能比较弱，例如只能保存最近 30 天的详细销售数据，界面丑陋，无法查看 App 的排名历史变化情况等。 AppAnnie 是一个专门为开发者提供的，针对 AppStore 相关数据的统计分析工具。该工具可以统计 App 在 AppStore 的下载量，排名变化，销售收入情况以及用户评价等信息。 原理AppAnnie 实现的原理是：通过你配置的管理账号，向 itunes connect 请求获得你的 App 的相关数据，包括每日下载量，用户的评分数据，以及销售数据。 注册 Sales 类型的账号使用 AppAnnie，首先需要在苹果官方的 itunes connect 中配置一个 Sales 类型的账号。因为默认的开发者账号是 Admin 级的权限，该权限是非常高的，可以修改 App 的价格或者直接下架商品。如果将这个账号直接配置在 AppAnnie 中，虽然不影响其获得相关数据，但是有一定的账号安全风险。 配置该账号的详细步骤如下： 1、登录 itunes connect，选择 Manager Users 2、选择 iTunes Connect User 3、点击 Add new User 4、填写新用户的相关信息 5、勾选用户类型为 Sales 6、选择 Notifications 为 All Notifications。点击图中所指的位置即可全选。 7、之后，邮箱中会收到 iTunes Connect 发来的激活邮件。点击邮件中的激活链接，即可进入到账号注册界面，之后注册账号即可激活。如果该邮箱已经注册过 Apple Id，则会进入到登录界面，登录后即可激活。 注册 App Annie 账号及配置打开 App Annie 的官方网站:http://www.appannie.com/，注册步骤和一般网站的步骤一样，我就不介绍了，注册完成之后的配置步骤如下： 1、在设置页面中增加 iTunes Connect 账号 2、填写你的之前在 iTunes Connect 中增加的 Sales 类型的账号及密码 3、在 User Setting 中勾选上接收每日 Report 4、这样，每天就可以收到 AppAnnie 发来的相关统计邮件了。如下是一封粉笔网的销售报告邮件截图： 官方的命令行工具如果你觉得将自己的销售数据交给第三方统计服务商，有一些不太安全。可以考虑使用苹果官方提供的 Autoingestion.class 工具来获得每天的销售数据，然后存到本地的数据库中。 该工具的下载地址是 这里，苹果对于该用户的帮助文档在 这里。 下面介绍一下这个工具的使用，将 Autoingestion.class 下载下来后，切换到 class 文件所在目录，执行如下命令，即可获得对应的统计数据： java Autoingestion &lt;帐号名&gt; &lt;密码&gt; &lt;vendorId&gt; &lt;报告类型&gt; &lt;时间类型&gt; &lt;报告子类型&gt; &lt;时间&gt; 其中 vendor Id 在 iTunes Connect 的如下图所示位置获得，是一个数字 8 开头的序列。 &lt;报告类型&gt; 可选的值是：Sales 或 Newsstand &lt;时间类型&gt; 可选的值是：Daily, Weekly, Monthly 或 Yearly &lt;报告子类型&gt; 可选的值是：Summary, Detailed 或 Opt-In &lt;时间&gt; 以如下的格式给出：YYYYMMDD 以下是一个示例，它将获得 2013 年 5 月 8 日的日销售摘要数据。 java Autoingestion username@fenbi.com password 85587619 Sales Daily Summary 20130508 我试用了一下该工具，觉得还是太糙了一些，仅仅能够将销售数据备份下来，如果要做 AppAnnie 那样的统计报表，还需要写不少代码。而且，该工具并不象 App Annie 那样，还提供应用在 App Store 的排名变化情况。虽然可以自己再做抓取，但也是需要工作量的。 其它类似 App Annie 的服务类似 App Annie 这样的服务还有：AppFigures。我试用过之后，发现它不如 App Annie 功能强大。不过作为一个替代方案，也一并介绍给大家。 在 Github 上也有一些开源的 统计工具，感兴趣的朋友也可以尝试一下。这些工具基本上也就是对苹果的命令行工具的增强，例如增加了将数据导入到数据库中等功能。 功能对比App Annie 和苹果本身提供的命令行工具虽然都能统计 App Store 的数据，但是二者功能相差悬殊。苹果的命令行工具仅仅能提供销售数据的按日、周、月、年等方式的统计和备份。而 App Annie 除了以更加良好的界面和交互提供这些功能外，还能跟踪 App 的排名变化，以及 App 在苹果的各种榜单中所处位置的情况。 建议大家都可以尝试使用 App Annie 或 AppFigures 这类统计工具，帮助你方便地查看 App 的销售和排名情况。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"Git submodule的坑","slug":"git-submodule-issues","date":"2013-05-08T13:44:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/05/08/git-submodule-issues/","permalink":"https://blog.devtang.com/2013/05/08/git-submodule-issues/","excerpt":"前言随着近几年的发展，Git 已经成为开源界的标准的版本控制工具。开源界的重量级项目，如 Linux, Android, Eclipse, Gnome, KDE, Qt, ROR, Debian，无一例外的都是使用 git 来进行版本控制。如果你还不会 Git，那么恕我直言，你已经 out 了，赶紧抽空充充电吧。本文并不打算做 Git 入门级介绍，想学习 git 的同学，推荐国内作者蒋鑫写的 《Git 权威指南》。 对于一些比较大的工程，为了便于复用，常常需要抽取子项目。例如我开发的猿题库客户端现在包括 3 门考试，客户端涉及的公共 UI、公共底层逻辑、公共的第三方库、以及公共的答题卡扫描算法就被我分别抽取成了子项目。这些子项目都以 git submodule 的形式，增加到工程中。 在使用了 git submodule 一段时间后，我发现了一些 submodule 的问题，在此分享给大家。","text":"前言随着近几年的发展，Git 已经成为开源界的标准的版本控制工具。开源界的重量级项目，如 Linux, Android, Eclipse, Gnome, KDE, Qt, ROR, Debian，无一例外的都是使用 git 来进行版本控制。如果你还不会 Git，那么恕我直言，你已经 out 了，赶紧抽空充充电吧。本文并不打算做 Git 入门级介绍，想学习 git 的同学，推荐国内作者蒋鑫写的 《Git 权威指南》。 对于一些比较大的工程，为了便于复用，常常需要抽取子项目。例如我开发的猿题库客户端现在包括 3 门考试，客户端涉及的公共 UI、公共底层逻辑、公共的第三方库、以及公共的答题卡扫描算法就被我分别抽取成了子项目。这些子项目都以 git submodule 的形式，增加到工程中。 在使用了 git submodule 一段时间后，我发现了一些 submodule 的问题，在此分享给大家。 更新 submodule 的坑submodule 项目和它的父项目本质上是 2 个独立的 git 仓库。只是父项目存储了它依赖的 submodule 项目的版本号信息而已。如果你的同事更新了 submodule，然后更新了父项目中依赖的版本号。你需要在 git pull 之后，调用 git submodule update 来更新 submodule 信息。 这儿的坑在于，如果你 git pull 之后，忘记了调用 git submodule update，那么你极有可能再次把旧的 submodule 依赖信息提交上去。对于那些习惯使用 git commit -a 的人来说，这种危险会更大一些。所以建议大家: git pull 之后，立即执行 git status, 如果发现 submodule 有修改，立即执行 git submodule update 尽量不要使用 git commit -a， git add 命令存在的意义就是让你对加入暂存区的文件做二次确认，而 git commit -a 相当于跳过了这个确认过程。 更复杂一些，如果你的 submodule 又依赖了 submodule，那么很可能你需要在 git pull 和 git submodule update 之后，再分别到每个 submodule 中再执行一次 git submodule update，这里可以使用 git submodule foreach 命令来实现： git submodule foreach git submodule update 修改 submodule 的坑有些时候你需要对 submodule 做一些修改，很常见的做法就是切到 submodule 的目录，然后做修改，然后 commit 和 push。 这里的坑在于，默认 git submodule update 并不会将 submodule 切到任何 branch，所以，默认下 submodule 的 HEAD 是处于游离状态的 (‘detached HEAD’ state)。所以在修改前，记得一定要用 git checkout master 将当前的 submodule 分支切换到 master，然后才能做修改和提交。 如果你不慎忘记切换到 master 分支，又做了提交，可以用 cherry-pick 命令挽救。具体做法如下： 用 git checkout master 将 HEAD 从游离状态切换到 master 分支 , 这时候，git 会报 Warning 说有一个提交没有在 branch 上，记住这个提交的 change-id（假如 change-id 为 aaaa) 用 git cherry-pick aaaa 来将刚刚的提交作用在 master 分支上 用 git push 将更新提交到远程版本库中 以下是相关命令的操作示范和命令行输出结果： ➜ ui_common git:(df697f9) git checkout masterWarning: you are leaving 1 commit behind, not connected toany of your branches: df697f9 forget to check out masterIf you want to keep them by creating a new branch, this may be a good timeto do so with: git branch new_branch_name df697f911e5a0f09d883f8f360977e470c53d81eSwitched to branch &#x27;master&#x27;➜ ui_common git:(master) git cherry-pick df697f9 使用第三方工具对于 submodule 的重度使用者，有几个工具可作推荐： Repo Google 用于管理 Android 项目的工具。 Gitslave Git Subtree 以上工具，我都没有实际用过，所以无法提供更多信息。 Tips由于常常使用 submodule 的相关命令，可以在 ~&#x2F;.gitconfig 文件中将其设置别名，方便操作，我设置的所有相关别名如下： [alias] st = status -s ci = commit l = log --oneline --decorate -12 --color ll = log --oneline --decorate --color lc = log --graph --color co = checkout br = branch rb = rebase dci = dcommit sbi = submodule init sbu = submodule update sbp = submodule foreach git pull sbc = submodule foreach git co master 参考链接 《why-your-company-shouldnt-use-git-submodules》 (需翻墙) 《Git_submodule_tutorial》","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"}]},{"title":"历史上的WWDC门票售空图片","slug":"the-history-of-wwdc","date":"2013-04-30T14:40:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/04/30/the-history-of-wwdc/","permalink":"https://blog.devtang.com/2013/04/30/the-history-of-wwdc/","excerpt":"","text":"2008年62天售空。介绍了iPhone 3G。 2009年33天售空。介绍了iPhone 3GS。 2010年8天售空。介绍了iPhone 4。 2011年12小时售空。介绍了iOS5, ARC, Storyboard, iCloud, Mac OS X Lion。 从这一年开始，iPhone新品都没能赶上在WWDC中介绍。 2012年2小时售空。介绍了iOS6。 2013年2分钟售空。期待。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"那些被遗漏的Objective-C保留字","slug":"the-missing-objc-keywords","date":"2013-04-29T12:22:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/04/29/the-missing-objc-keywords/","permalink":"https://blog.devtang.com/2013/04/29/the-missing-objc-keywords/","excerpt":"今天翻到很久以前自己在网易博客上写的 这篇文章，惊奇地发现自己都忘记了里面的一些内容。所以我又重新学习了一下，然后改了改内容，挪到这里。 前言Steffen Itterheim 是 《Learn Iphone and Ipad Cocos2d Game Development》 作者。cocos2d 和 cocos2d-x 现在已成为著名的游戏开发引擎。在 AppStore 上有超过 100 个游戏是基于 Cocos2D。 Steffen Itterheim 在 他的博客 中总结了 Objective-C 2.0 所有的编译器保留字，并且对这些保留字做了介绍和使用示例。这些保留字如下： @class @defs @protocol @required @optional @end @interface @public @package @protected @private @property @end @implementation @synthesize @dynamic @end @throw @try @catch @finally @synchronized @autoreleasepool @selector @encode @compatibility_alias @”string” 我把这些保留字过了一遍，发现很少用到的有 @dynamic @defs @encode @compatibility_alis，所以就给大家介绍一下这几个关键字吧。","text":"今天翻到很久以前自己在网易博客上写的 这篇文章，惊奇地发现自己都忘记了里面的一些内容。所以我又重新学习了一下，然后改了改内容，挪到这里。 前言Steffen Itterheim 是 《Learn Iphone and Ipad Cocos2d Game Development》 作者。cocos2d 和 cocos2d-x 现在已成为著名的游戏开发引擎。在 AppStore 上有超过 100 个游戏是基于 Cocos2D。 Steffen Itterheim 在 他的博客 中总结了 Objective-C 2.0 所有的编译器保留字，并且对这些保留字做了介绍和使用示例。这些保留字如下： @class @defs @protocol @required @optional @end @interface @public @package @protected @private @property @end @implementation @synthesize @dynamic @end @throw @try @catch @finally @synchronized @autoreleasepool @selector @encode @compatibility_alias @”string” 我把这些保留字过了一遍，发现很少用到的有 @dynamic @defs @encode @compatibility_alis，所以就给大家介绍一下这几个关键字吧。 @dynamic@dynamic 是相对于 @synthesize 的，它们用样用于修饰 @property，用于生成对应的的 getter 和 setter 方法。但是 @ dynamic 表示这个成员变量的 getter 和 setter 方法并不是直接由编译器生成，而是手工生成或者运行时生成。 示例如下： @implementation ClassName@synthesize aProperty, bProperty;@synthesize cProperty=instanceVariableName;@dynamic anotherProperty;// method implementations@end @defs@defs 用于返回一个 Objective-C 类的 struct 结构，这个 struct 与原 Objective-C 类具有相同的内存布局。就象你所知的那样，Objective-C 类可以理解成由基本的 C struct 加上额外的方法构成。 示例代码如下： struct &#123; @defs( NSObject) &#125; 你可能会想，什么情况下才会需要使用这个关键字。答案是涉及非常底层的操作或优化的时候才会用到。像如这篇讨论 Objective-C 如何做缓存优化 的文章中，就用到了该关键字。 @encode@encode 是用于表示一个类型的字符串，对此，苹果有专门的 介绍文档 示例如下： -(void) aMethod&#123; char *enc1 = @encode(int); // enc1 = &quot;i&quot; char *enc2 = @encode(id); // enc2 = &quot;@&quot; char *enc3 = @encode(@selector(aMethod)); // enc3 = &quot;:&quot; // practical example: CGRect rect = CGRectMake(0, 0, 100, 100); NSValue *v = [NSValue value:&amp;rect withObjCType:@encode(CGRect)];&#125; @compatibility_alis@compatibility_alis 是用于给一个类设置一个别名。这样就不用重构以前的类文件就可以用新的名字来替代原有名字。 示例如下： @compatibility_alias AliasClassName ExistingClassName @autoreleasepool@autoreleasepool 是用于 ARC 下代替 NSAutoreleasePool 的保留字，我把它写在这里，是想告诉那些以为 ARC 慢的同学，在苹果的 这篇官方文档 中有提到， @autoreleasepool 比 NSAutoreleasePool 快 6 倍。当然，文档中也提到，ARC 下不止 Autorelease Pool 的实现变快了，retain 和 release 也快很多。如果你还没有在工程中使用 ARC，推荐看看我的 《是否应该使用 ARC》。 Cheat Sheet有一个热心者根据他的博文，制作了一张 《Objective-C 2.0 保留字速查表》，对于新手来说，把这张速查表打印出来，对于熟悉现在的保留字还是很有用的，它的下载地址是：http://maniacdev.com/cheatsheetobjccd.pdf 五一节到了，祝大家节日快乐！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"iOS应用内支付(IAP)的那些坑","slug":"tricks-in-iap","date":"2013-04-07T12:14:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/04/07/tricks-in-iap/","permalink":"https://blog.devtang.com/2013/04/07/tricks-in-iap/","excerpt":"前言udacity 中的在线课程 《How to build a startup》 中提到，所谓创业，就是尝试寻找新的赢利模式。正因为这是一种尝试，所以不可避免地需要调整产品方向，寻找市场中还未被发现的用户需求，给用户创造价值，进而获得收入。最近很火的 精益创业 的观点，则是强调将这种尝试成本降到最小，使得自己可以根据市场反馈迅速调整产品。 我们在今年春节后上线了新的在线智能题库：猿题库。这应该是我们在互联网教育这个创业领域尝试的第二个方向。 猿题库现在推出了公务员考试行测和申论 2 个产品，均包括 web, iOS 和 Android 三个平台。这次我们尝试做一个收费的产品，所以在 iOS 端集成了应用内支付（IAP）功能。在开发过程中和上线后，我们遇到了 IAP 中的一些坑，在此分享给各位。","text":"前言udacity 中的在线课程 《How to build a startup》 中提到，所谓创业，就是尝试寻找新的赢利模式。正因为这是一种尝试，所以不可避免地需要调整产品方向，寻找市场中还未被发现的用户需求，给用户创造价值，进而获得收入。最近很火的 精益创业 的观点，则是强调将这种尝试成本降到最小，使得自己可以根据市场反馈迅速调整产品。 我们在今年春节后上线了新的在线智能题库：猿题库。这应该是我们在互联网教育这个创业领域尝试的第二个方向。 猿题库现在推出了公务员考试行测和申论 2 个产品，均包括 web, iOS 和 Android 三个平台。这次我们尝试做一个收费的产品，所以在 iOS 端集成了应用内支付（IAP）功能。在开发过程中和上线后，我们遇到了 IAP 中的一些坑，在此分享给各位。 IAP 审核相关的坑IAP 开发的详细步骤我写在 另一篇博客 中了。在此主要介绍审核时遇到的问题。 IAP 类型错误由于我们是按月付费的产品，所以在设置 IAP 类型时，我没有经验，只是简单设置成了可重复消费 (Consumable) 的 IAP 项目。但是我不知道，苹果对于这种按时间收费的产品，应该使用不可更新的定阅（Non-Renewing Subscription）类型。这个类型设置错误造成了我们 app 的一次审核被拒。 IAP 验证逻辑由于苹果在 iOS5.0 以下有 IAP 的 bug，使得攻击者可以伪造支付成功的凭证。而 iOS6.0 的系统在越狱后同样可以伪造凭证，所以我们对于应用内支付，增加了服务器端的验证。服务器端会将支付凭证发给苹果的服务器进行二次验证，以保证凭证是真实有效的。 在我们公司的测试服务器中，我们会连接苹果的测试服务器（ https://sandbox.itunes.apple.com/verifyReceipt ）验证。 在我们部署在线上的正式服务器中，我们会连接苹果的正式服务器（ https://buy.itunes.apple.com/verifyReceipt ）验证。 我们提交给苹果审核的是正式版，我们以为苹果审核时，我们应该连接苹果的线上验证服务器来验证购买凭证。结果我理解错了，苹果在审核 App 时，只会在 sandbox 环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器。但是审核的 app 又是连接的我们的线上服务器。所以我们这边的服务器无法验证通过 IAP 购买，造成我们 app 的又一次审核被拒。 解决方法是判断苹果正式验证服务器的返回 code，如果是 21007，则再一次连接测试服务器进行验证即可。苹果的 这一篇文档 上有对返回的 code 的详细说明。 IAP 上线后的遇到的情况我们在服务器端增加了验证 IAP 是否有效的逻辑。在产品上线后，如我们所料，我们收到了大量的欺骗性购买，这些都被我们的服务器识别出来了，但是我们也遇到了以下这次没有想到的情况: 1、由于国内越狱用户的比例比较大 (2012 年底国内越狱比例是 42%), 所以虽然我们服务器会验证购买凭证，但是每天有超过 50% 以上的凭证都是伪造的。同时由于苹果的验证服务器在美国，凭证验证请求响应的时间比较慢，大量的伪造凭证发给苹果服务器，不知道会不会被苹果认为我们是在恶意进行 DDOS。至少我们发现有些时候，验证请求会超时。 2、由于国内有许多小白用户，他们的手机从购买时就被渠道商帮忙越狱过了并且安装了 IAP free 插件。所以对于这类用户，他们即使想付费购买，由于系统原有的 IAP 支付功能已经被破坏，所以他们是无法正常付费的。麻烦的是，他们会以为这是我们的 app 的问题，转而给我们的客服打电话投诉。这让我们非常郁闷。 3、苹果的验证服务器有时候会出问题，我们发现本来约定好返回的 JSON 数据在有几次返回的居然是一个 XML 格式的文件。造成我们将正常的付费 IAP 凭证验证失败。所以，在服务器记录下所有的验证凭证非常有必要，一来可以防止黑客多次提交同一个成功凭证的重放攻击，二来在需要时可以手工进行再验证。 越狱手机可能被黑客窃取购买凭证！！我们发现有一部分用户反馈说已经收到苹果的扣费账单，但是我们从服务器的验证记录看，他上传的凭证却是虚假的。由于这些用户不太多，我们一开始以为是用户在恶意欺骗我们，后来我们让他将苹果的付费账单邮件转发给我们，以及将 itunes 的购买记录截图转发给我们，随着讨论的深入，我们越来越怀疑这里面有一个黑色的产业链。越狱手机的正常购买凭证可能被黑客的恶意程序截获，具体的攻击方式我们讨论了一下，其实就是被 中间人攻击，详细的过程如下: 越狱手机的在被破解后，可能从一些破解渠道安装了黑客的恶意程序。 黑客将越狱手机所有 https 请求都经过他的中间服务器。 当有支付请求时，黑客先将请求发给苹果服务器，待苹果将成功的凭证返回后，黑客将这个凭证替换成假的凭证，完全支付凭证的偷取。 或许有人会问，这个凭证拿来有什么用呢 ? 很简单 ，因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的 apple id 信息，所以我们的 app 和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假的。于是黑客就可以用这个凭证，在另外的账号中通知我们完成了购买，而发来的验证凭证又是真实的，所以我们的服务器就会误认为是黑客的账号完成了购买，继而把会员期算在黑客的账号上。 再举一个简单的例子，你拿 500 块钱买了顺风优选的 500 元购物券，由于这个购物券是不记名的，所以顺风优选无法知道是谁买的。如果这个购物券在发放过程中被人掉包，那么偷购物券的人就可以拿这个偷来的真购物券来购物，而顺风优选的卡因为是不记名的，所以也无法查证这件事情。在这个例子中，购物券的不记名和苹果的支付凭证无账号信息是同一个道理。 鉴于以上情况，考虑到越狱手机不但不能成功支付，还会有安全问题，所以我们在新版中取消了越狱手机中的 IAP 支付功能。 所以，请大家还是不要越狱自己的手机，iPhone 手机越狱后风险相当大。实在不值得为了免费玩几个游戏就丢掉安全性。 后记中间人攻击的演示iOS 独立开发者 王轲 _IndieBros 在他的博客文章 《使用 mitmproxy 获取 iTunes 11 的 Raw HTTPs Response》 中演示了如何使用中间人攻击来修改 Game Center 游戏数据。王轲还把我的例子白话翻译了一下（可见我还是说得太绕了，囧）： 坏人在购买过程中插了一腿，换走了用户的无记名发票（购物小票形象些），然后手持无记名小票伪装成真实顾客或者转手出售获利。 关于越狱与盗版不少细心的同学评论纠正我，指出越狱并不等同于使用盗版。确实，如果说严格的定义，越狱只是让 iPhone 获得 root 权限，进而可以做任何事情。如果越狱的同学在越狱后不安装 IAP free 插件，不使用 app sync 插件，不使用任何国内的和非 bigboss 的 cydia 源，不使用任何盗版软件，所有应用都是从 app store 官方网站上下载的话，被黑客攻击的可能性会降低一些。 即使这样，由于手机已经被 root 了，苹果的沙盒安全机制失效，所以风险还是很大的。 关于越狱用户的比例有同学提出我文章中写的越狱手机比例太高了，想询问数据来源。这个比例主要来自我们自己的 app 的统计信息，以及结合国内的统计工具友盟的 越狱手机比例统计，去年底国内的越狱比例是 42%。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"是否应该使用ARC?","slug":"should-we-use-arc","date":"2013-03-27T13:23:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/03/27/should-we-use-arc/","permalink":"https://blog.devtang.com/2013/03/27/should-we-use-arc/","excerpt":"我和身边做 iOS 开发的同事组建了一个 QQ 群，每隔一段时间，大家就会讨论是否应该使用 ARC。所以我觉得有必要将这些讨论分享出来，让大家消除对于 ARC 的疑虑。","text":"我和身边做 iOS 开发的同事组建了一个 QQ 群，每隔一段时间，大家就会讨论是否应该使用 ARC。所以我觉得有必要将这些讨论分享出来，让大家消除对于 ARC 的疑虑。 关于 ARC 的介绍文章网上已经很多，苹果的官方文档也不少。担心使用 ARC 会带来问题的同学主要的理由有以下 5 点: 担心这个技术方案不靠谱。苹果大多数时候的技术方案都是比较靠谱的，但也有一些技术方案有很多坑，例如 storyboard。关于 storyboard 的问题可以参看我的 这篇文章。 原有的项目在非 ARC 环境下运行良好，担心迁移成本或引入新的问题。 苹果以前手工管理内存需要非常小心，稍微不注意应用程序就崩溃了。有过这段经历的 iOS 开发老手，心里上还是觉得自己手工管理内存更踏实一些。 使用 ARC 需要了解 ARC 的一些细节，还需要引入 _bridge 等新的关键字，学习成本还是有的。 以为 ARC 只能支持 iOS5.0 以上（这是非常大的误解）。 对于上面提到 5 点问题，我认为相应的回答如下: ARC 是 WWDC2011 大会时提出的技术，离现在已经快 2 年了，而且苹果现在将 MacOS 上的垃圾回收机制废弃 (Deprecated)，采用 ARC 替代，无疑证明了 ARC 是成熟的了。 确实有一些迁移成本，但苹果在 Xcode 中专门集成了迁移工具，成本已经非常小了。如下图就是 Xcode 集成的将非 ARC 工程转换成 ARC 工程的工具。另外，为了兼容第三方的非 ARC 开源库，你也可以在工程中随意使用编译参数：-fno-objc-arc , 这个参数允许对部分文件关闭 ARC。 手工管理内存虽然踏实，但是泄露很容易发生。常常开发完成后，需要使用 Instruments 来检测泄露。但用了 ARC 后，基本不会出现泄露了，我在开发粉笔网 iPhone 客户端时，由于使用了 ARC，花三个月开发完的应用，用 instruments 检测后，没有发现任何内存泄漏问题。这在没有使用 ARC 的工程中是不可想象的。 确实有学习成本。但是非常值得学习，能省不少开发精力。 虽然 ARC 是与 iOS5 一同推出，但是由于 ARC 的实现机制是在编译期完成，所以使用 ARC 之后 App 仍然可以支持 iOS4.3。稍微需要注意的是，如果要在 ARC 开启的情况下支持 iOS4.3，需要将 weak 关键字换成 __unsafe_unretained，另外还有一些细节需要处理，在这里我就不展开说了。 所以，希望大家都能在项目中使用 ARC，一旦你感受到它带来的好处，你就离不开它了。它也能让你从繁琐的内存管理代码中解放出来，将精力更多关注于代码结构、设计模式而不是底层的内存管理。 关于 ARC 的教程，除了苹果的官方文档外，推荐易飞杨写的 ARC 相关的文章（注：链接需要翻墙才能打开）。易飞杨的博客中关于 iPhone 开发的文章都写得很深入，值得好好阅读。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"设置应用内的系统控件语言","slug":"set-ios-system-ui-language","date":"2013-01-23T13:05:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/01/23/set-ios-system-ui-language/","permalink":"https://blog.devtang.com/2013/01/23/set-ios-system-ui-language/","excerpt":"在iOS应用中，有时候会需要调用系统的一些UI控件，例如： 在UIWebView中长按会弹出系统的上下文菜单 在UIImagePickerController中会使用系统的照相机界面 在编译状态下的UITableViewCell，处于待删除时，会有一个系统的删除按钮。 以上这些UI控件中，其显示的语言并不是和你当前手机的系统语言一致的。而是根据你的App内部的语言设置来显示。结果就是，如果你没有设置恰当的话，你的中文App可能会出现一些英文的控件文字。","text":"在iOS应用中，有时候会需要调用系统的一些UI控件，例如： 在UIWebView中长按会弹出系统的上下文菜单 在UIImagePickerController中会使用系统的照相机界面 在编译状态下的UITableViewCell，处于待删除时，会有一个系统的删除按钮。 以上这些UI控件中，其显示的语言并不是和你当前手机的系统语言一致的。而是根据你的App内部的语言设置来显示。结果就是，如果你没有设置恰当的话，你的中文App可能会出现一些英文的控件文字。 例如下图中，一个名为“百思不得姐”的应用，其在AppStore免费总榜中排名前100，图书类分类榜排名第一的应用，就闹出了系统控件显示成了英文的笑话，在其软件界面中长按，就会出如下的菜单，可以看到，这个菜单的文字全是英文的： 而正常的菜单应该是中文的，如下是新浪微博的正文长按之后的效果： 如何解决这个问题呢？方法如下: 用vim直接打开工程的Info.plist文件，在文件中增加如下内容即可： &lt;key&gt;CFBundleLocalizations&lt;/key&gt; &lt;array&gt; &lt;string&gt;zh_CN&lt;/string&gt; &lt;string&gt;en&lt;/string&gt;&lt;/array&gt; TO: 百思不得姐的开发者，不用谢：）你们应用的内容挺有意思的。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"谈ObjC对象的两段构造模式","slug":"two-stage-creation-on-cocoa","date":"2013-01-13T02:15:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/01/13/two-stage-creation-on-cocoa/","permalink":"https://blog.devtang.com/2013/01/13/two-stage-creation-on-cocoa/","excerpt":"前言Objective-c 语言在申请对象的时，需要使用两段构造 (Two Stage Creation) 的模式。一个对象的创建，需要先调用 alloc 方法或 allocWithZone 方法，再调用 init 方法或 initWithSomething 方法。如下是一个 NSString 对象的创建示例： NSString * str = [[NSString alloc] initWithString:@&quot;http://blog.devtang.com&quot;]; 由于该语言的对象创建方法和大多数其它语言（如 C、C++、Java、JavaScript）都不一样，所以引起了我的好奇。是什么原因促使 Objective-C 做了这种设计，而又是什么原因促使大多数其它语言都采用 “new” 方法来一次性创建对象呢？ 在看了 《Cocoa Design Patterns》 一书（顺便吐槽一下该书中文版翻译质量不高，建议看英文版），并且做了一些调研之后，我将总结分享给大家，欢迎大家讨论。","text":"前言Objective-c 语言在申请对象的时，需要使用两段构造 (Two Stage Creation) 的模式。一个对象的创建，需要先调用 alloc 方法或 allocWithZone 方法，再调用 init 方法或 initWithSomething 方法。如下是一个 NSString 对象的创建示例： NSString * str = [[NSString alloc] initWithString:@&quot;http://blog.devtang.com&quot;]; 由于该语言的对象创建方法和大多数其它语言（如 C、C++、Java、JavaScript）都不一样，所以引起了我的好奇。是什么原因促使 Objective-C 做了这种设计，而又是什么原因促使大多数其它语言都采用 “new” 方法来一次性创建对象呢？ 在看了 《Cocoa Design Patterns》 一书（顺便吐槽一下该书中文版翻译质量不高，建议看英文版），并且做了一些调研之后，我将总结分享给大家，欢迎大家讨论。 对象的创建我们先来看看在对象的创建过程中，alloc 和 init 到底做了哪些事情。 alloc 方法根据苹果的 官方文档。当对象创建时，cocoa 会从应用程序的虚拟地址空间上为该对象分配足够的内存。cocoa 会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存。 当我们通过 alloc 或 allocWithZone 方法创建对象时，cocoa 会返回一个未” 初使化 “过的对象。在这个过程中，cocoa 除了上面提到的申请了一块足够大的内存外，还做了以下 3 件事： 将该新对象的引用计数 (Retain Count) 设置成 1。 将该新对象的 isa 成员变量指向它的类对象。 将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型，零有可能是指 nil 或 Nil 或 0.0） isa 成员变量是在 NSObject 中定义的，所以保证 Cocoa 的所有对象都带有此成员变量。借助该变量可以实现 Cocoa 对象在运行时的自省 (Introspection) 功能。 init 方法大部分情况下，我们都不希望所有成员变量都是零，所以 init 方法会做真正的初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。例如，NSMutableString 可能就会额外再申请一块字符数组，用于动态修改字符串。 init 还有一个需要注意的问题。某些情况下，init 会造成 alloc 的原本空间不够用，而第二次分配内存空间。所以下面的写法是错的： NSString * s = [NSString alloc];[s init]; // 这儿 init 返回的地址可能会变。s 原本的指针地址可能是无效的地址。 为此，苹果引入了一个编程规范，让大家写的时候将 alloc 和 init 写在一行。所以上面的代码正确的写法是 NSString * s = [[NSString alloc] init]; new在后来，苹果也引入了类方法：new。但是由于历史原因，init 方法是实例方法而非类方法，所以作为类方法的 new，只能简单地等价于 alloc + init，不能指定 init 的参数，所以用处不大。苹果在设计上也禁止多次调用 init 方法，例如如下代码会抛出 NSInvalidArgumentException。 NSString * str = [NSString new];str = [str initWithString:@&quot;Bar&quot;]; 为什么这么设计说回来文章开始时提出来问题，为什么苹果要这么设计而其它语言不这么设计？ 上面提到，alloc 其实不只干了申请内存的事情，还做了： 内存管理的事情，设置 Retain Count。 运行时自省的功能，设置 isa 变量。 非逻辑性的初使化功能，设置所有成员变量为零。 简单看来，根据设计模式的 Single Responsibility 的设计原则，苹果觉得 alloc 和 init 是做的 2 件不同的事情，把这两件事情分开放在 2 个函数中，对于程序员更加清楚明了。更详细查阅文档后，我觉得这是由于历史原因，让苹果觉得 alloc 方法过于复杂，在历史上，alloc 不仅仅是分配内存，还可以详细的指定该内存所在的内存分区（用 NSZone 表示）。这就是下面要提到的 allocWithZone 方法。 在 《Cocoa Design Patterns》 一书也提到，早期苹果是建议程序员使用 allocWithZone 来管理内存分配的，每个 NSZone 表示一块内存分区，allowWithZone 方法可以允许对象从指定分区分配内存。了解到这段历史后，也不难理解苹果这么设计的原因了。因为在这种情况下，alloc 要处理的情况复杂，和 init 放到一起不合适。 而对于大多数出生在 90 年代的语言来说 (例如 Java,JavaScript,C#)，由于内存具体的分配方案都不需要程序员操心了，所以就不需要单独为内存分配实现一个 alloc 方法了。 后记allocWithZone 被废弃自从 Mac OS X 10.5 上引入了垃圾回收机制后，苹果就不建议程序员使用 allocWithZone 了，事实上，cocoa 框架也会忽略 allocWithZone 指定的分区。苹果在文档中也 提到，allocWithZone 仅仅是一个历史遗留设计了。下图是苹果的文档截图： Objective-C 的历史Objective-C 是一门非常老的语言。如果你查阅文档，你会发现它和 C++ 出生在同一时代（两种语言的发行年份都是 1983 年），都是作为 C 语言的面向对象的接班人被推出。当然，最终 C++ 胜出。由于历史久远，Objective-C 也无法有太多优秀的语言做参考，所以，有很多历史遗留的设计。在 2007 年苹果公司发布了 Obj-C 2.0, 对其进行了大量改进。 在最近几年的 WWDC 大会上，每年苹果都会对 Objective-C 和其对应的 LLVM 编译器进行改进，例如 WWDC2011 推出的 ARC，WWDC2012 推出的 Object Literals 等。所以现在使用 Objective-C 做开发已经非常舒服了。期待苹果给开发者带来更多惊喜。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"2012年个人总结","slug":"2012-summary","date":"2013-01-01T06:31:00.000Z","updated":"2024-01-06T14:52:37.914Z","comments":true,"path":"2013/01/01/2012-summary/","permalink":"https://blog.devtang.com/2013/01/01/2012-summary/","excerpt":"和 去年 一样，记录一下今年的成长和收获。","text":"和 去年 一样，记录一下今年的成长和收获。 主要工作自己这一年主要的工作是： 2012 年 1-4 月份，有道云笔记 iOS 端开发 2012 年 4-9 月份，粉笔网 iPhone 端开发 2012 年 11 月份-2013 年 1 月，猿题库-公务员考试行测、猿题库-公务员考试申论 iPhone 端的开发 有道云笔记开发 1-4 月份，我继续开发了有道云笔记 iOS 端的新功能。做得最费劲的功能是和 perfectworks 一起做 iPad 版的图文混排编缉器。本来想 iOS 的 UIWebView 是基于 webkit 内核的，把 PC 版的编辑器代码移植一下就行了。可真正做的时候，遇到很多问题。 首先是我们发现 UIWebView 有一些平台特有的 javascript 兼容性 Bug。当时苹果官方的用 Safari 直接连接模拟器进行调试的工具还没有推出，我们只能用 weinre 这个第三方工具来调试 js，但是 weinre 有时候会出 Bug，这个时候就只能用 Alert 来把调试信息打出来了，真是比 IE6 还苦。 然后是在 iOS 平台上，native 端调 js 是同步的，但 js 调 native 调是异步的。所以原有的 js 代码需要做很多重构。关于这里面的技术细节，我总结在 这里。 最后是联调，因为 js 和 ios 两边同时开发，我们需要大量的联调工作。所以我每天抱着笔记本跑到前端组和 perfectworks 坐到一起。另外，我们还相互之间互相暴露了 git 的地址，然后相互 pull 各自调试代码，待各自都调试完成了，再把代码 rebase 整理一下，push 到服务器上。最后，我们将这种实践整理成文 《用 Git 进行协同开发》。 另外，在 2-3 月份，我还和 c4pt0r 一起，通过有道的个人项目时间，开发了有道云笔记的 Mac 版。不过这个版本由于是非正式项目，所以应该还有很多需要完善的 Feature。最终 c4pt0r 将其取名为 NotEver，发布到了 github 上。 粉笔网开发在粉笔网我花了 3 个多月时间，独立完成了粉笔网 iPhone 客户端开发工作。整个代码量除去第三方库，有 3 万多行。那段时间非常辛苦，每周 6 天，每天 11 个小时，最终产品如期上线。在产品上线后，我写了 一篇博客 来专门讲述这中间的感悟。那篇文章发出后，在微博上得到了大量的转发，最终引起了 CSDN 的 炫姐姐 的关注。在她的邀请下，我们进行了一次技术和项目管理的 分享。 猿题库开发猿题库算是我们创业的第二个产品尝试。这是一个收费产品，同样开发时间很紧张，最终我们延续了粉笔网之前快速开发的经验，用 3 个月时间再次推出了一个全平台（Web,iOS,Android) 产品。 这次在猿题库中，我还花时间调研并实现了扫描答题卡算法。也算是对我多年搞 ACM 的积累的一点算法的使用，否则都快忘完了。扫描答题卡使用了 OpenCV 库和 ZXing 库，所以我撰写了相关的经验文章发表在博客上。 猿题库在春节后上线。希望它能给我们一个惊喜。 创业5 月 12 日，我离职加入了由前网易同事创立的一家创业公司：粉笔网。离职前纠结了相当长时间，主要是有道是一家非常棒的公司，在有道的工作非常开心，而且我们的产品有道云笔记一直在国内占据着云笔记类用户量第一的位置。不过最终我还是选择了离职，主要的原因是： 想接受更大的挑战。在粉笔网我会独立负责整个 iOS 端的开发工作，会辛苦很多，但是成长也会快很多。 想有更大的潜在经济回报。在大公司拿死工资总还是无法摆脱财务自由，创业虽然成功率很低，但至少有希望，并且希望把握在自己手中。 想和大家一起打造一个小而精的技术团队。 现在回过头来看，创业确实比较辛苦，但我也确实成长了很多。并且由于我们团队成员大多已经结婚，所以我们努力打造着一个不加班的创业公司文化。我们从 9 月份产品上线后，就一直坚持正常的上下班时间。 但是另一方面，我们的工作并不轻松。我们每周一个 Scrum，每天的工作量很大，所以我们会尽量高效地沟通，做好自己的时间管理。这里面 Scrum 和番茄钟帮了我很大的忙。我现在每天除去沟通的时间，常常能花 4-5 小时专注地写代码，而这在以前，常常只有 3 小时左右。 有一些朋友很关心我，问我：“如果创业失败了怎么办？”。其实失败了能怎么样呢？失败无非就是损失掉了短期的利益。但长远来看，我比以前更加专业了，我们团队更加牛逼了，不管我们是继续另一份创业或者去大公司找工作，我相信都有这个实力。 技术成长这一年专心于 iOS 开发的积累，已经能够非常熟练地进行 iOS 日常的开发。 另外在这一年，我注意在工作的时候记下一些总结，然后在周末有空的时候，就会花时间把这些整理成文章。回顾 2012 年，我一共写了 36 篇博客文章，平均每月 3 篇。写博客有助于我梳理自己的知识，同时也结交了不少 iOS 开发的同行。 个人 Milestone 2012-5-10 离职创业","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"StoryBoard--看上去很美","slug":"do-not-use-storyboard","date":"2012-12-15T02:21:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/12/15/do-not-use-storyboard/","permalink":"https://blog.devtang.com/2012/12/15/do-not-use-storyboard/","excerpt":"介绍StoryBoard 是苹果在 2011 年的 WWDC Session 309《Introducing Interface Builder Storyboarding》中介绍的 Interface Builder 的新功能。其基本想法是将原本的 xib 进行升级，引入一个容器用于管理多个 xib 文件，并且这个容器可以通过拖拽设置 xib 之间的界面跳转。而这个容器就是被苹果称做的 StoryBoard。下图是一个 Storyboard 的截图。","text":"介绍StoryBoard 是苹果在 2011 年的 WWDC Session 309《Introducing Interface Builder Storyboarding》中介绍的 Interface Builder 的新功能。其基本想法是将原本的 xib 进行升级，引入一个容器用于管理多个 xib 文件，并且这个容器可以通过拖拽设置 xib 之间的界面跳转。而这个容器就是被苹果称做的 StoryBoard。下图是一个 Storyboard 的截图。 优点总体上来说，Storyboard 有以下好处： 你可以从 storyboard 中很方便地梳理出所有 View Controller 的界面间的调用关系。这一点对于新加入项目组的开发同事来说，比较友好。 使用 Storyboard 可以使用 Table View Controller 的 Static Cell 功能。对于开发一些 Cell 不多，但每个 Cell 都不一样的列表类设置界面会比较方便。 通过实现 - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 方法，每个 View Controller 的跳转逻辑都聚集在一处，这方便我们统一管理界面跳转和传递数据。 Storyboard 可以方便将一些常用功能模块化和复用。例如 WWDC2011 年介绍 Storyboard 的视频就将微博分享功能模块化成一个单独的 Storyboard。我在开发 App 时，也将例如通过第三方注册登录模块做成一个单独的 Storyboard，便于以后复用。 缺点我在新项目使用 Storyboard 时，却发现它只是看上去很美，真正用起来，却有很多问题，我发现的问题有： 首先它和 xib 一样，对版本管理是灾难。因为是它实际上的多个 xib 的集合，所以更容易让多人编辑产生冲突。苹果对 storyboard 的设计也不好，基本上你只要打开，什么都不做，这个文件就会被更改，所以冲突几乎是不可避免的—除非你不打开，实在不小心打开看了，需要在提交前回退成服务器上的版本。 Storyboard 提供的 Static cell 特性只适合于 UITableViewController 的子类。我很多时候的用法是一个 TableView 嵌套在另一个 UIView 中，static cell 就不能用了。 segue 的概念对于开发来说并不省事，如果是用程序内部 trigger 一个 segue，那么需要在另一个回调的地方设置 dest view controller 的参数信息。 总结我仔细比较权衡了一下优缺点，最主要的问题是我的版本管理在多人协作开发时将陷入灾难，而这是完全不能接受的。而最主要的好处就是，你可以在一个类似白板的地方 “一揽众山小 “一样了解所有界面之间的切换关系，但这个有那么重要吗？我自已其实很清楚跳转逻辑，这个只是对新同事了解项目代码时有帮助，那我花一点时间直接给他讲讲画画不就搞定的吗？为了这点好处而让版本管理无法使用，是完全不能接受的。 所以最终我决定放弃使用 StoryBoard 了，这个 “看上去很美” 的功能有着不可接受的缺陷。现在看来，它仅适用于做一些 Demo 的开发。苹果一直没有处理好这类可视化界面设计功能的版本管理，象 xib 文件，虽然是 xml 格式的，但如果多人编辑了，合并起来也会很麻烦。所以业界好多同行都不用 xib, 直接用纯代码来写界面，虽然稍慢一点儿，但是工程很干净，也基本没有了多人协作的版本冲突问题。 2013-10-6 更新苹果在 WWDC2013 之后发布了 Xcode5，storyboard 和 xib 的内部实现进行了大量修改，使得其格式更加简单和易读，最终的效果是在版本冲突时，合并冲突变得可能。所以，现在我对于 storyboard 和 xib 不再象以前那么排斥了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"关于IAP的破解","slug":"iap-crack-issue","date":"2012-12-09T07:06:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/12/09/iap-crack-issue/","permalink":"https://blog.devtang.com/2012/12/09/iap-crack-issue/","excerpt":"介绍大概在今年7月份，有俄罗斯黑客破解了苹果的应用内付费（In-App Purchases），设备在不越狱的情况下就可以免费获得来自苹果官网App Store里应用的收费道具。受影响的产品众多，包括著名的Angry Birds，切水果，Mega Jump, Pandora等。这里有一份受影响的著名的游戏应用列表。 正常的越狱行为还是比较复杂的，需要下载破解软件，并且操作进入DFU模式，所以大部分人并不能够方便地越狱。但该方案不需要越狱就可以破解应用内付费，给用户实施该行为提供了方便。","text":"介绍大概在今年7月份，有俄罗斯黑客破解了苹果的应用内付费（In-App Purchases），设备在不越狱的情况下就可以免费获得来自苹果官网App Store里应用的收费道具。受影响的产品众多，包括著名的Angry Birds，切水果，Mega Jump, Pandora等。这里有一份受影响的著名的游戏应用列表。 正常的越狱行为还是比较复杂的，需要下载破解软件，并且操作进入DFU模式，所以大部分人并不能够方便地越狱。但该方案不需要越狱就可以破解应用内付费，给用户实施该行为提供了方便。 为了验证破解的有效性，我今天试了一下，确实能够直接绕开苹果的应用内付费就直接完成购买操作。而苹果也在它的官方文档上特别注明了该漏洞的存在，截图如下： 从该文档中我们可以知道，iOS6以下的所有设备（包括越狱或非越狱设备），都会受到该漏洞的影响。 攻击原理我们知道通常的IAP购买行为，从逻辑上就是设备向App Store发起一个购买操作，App Store在验证过用户的密码确认身份后，扣费并返回购买成功的凭证，整个网络操作是通过SSL加密的。 该IAP破解方法，是让设备误以为另一个网站就是AppStore，而向它通讯，而这个假AppStore返回一个假的购买成功的凭证，这样就欺骗设备完成了购买。整个欺骗使用的手段包括： 用户给自己添加一个受信任的证书以完成SSL通讯的证书校验 设置一个伪DNS（域名解析服务）地址，把AppStore的域名指向假的地址。 应对措施现在看来，暂时有效的应对方法是，将该交易凭证上传到我们自己的服务器上，然后让我们自己的服务器与AppStore进行验证，以确认该凭证是否是伪造的，然后将验证结果返回给设备。苹果的官方网站上也是这么介绍的。这样做麻烦的地方是，对于那些游戏和工具类应用，增加了服务器开发和维护的开销。 但是就象苹果自己也意识到的那样（如下图），既然破解者可以欺骗设备来和AppStore通讯，那么同样破解者从原理上，也可以欺骗设备同我们自己的服务器通讯，到头来，设备本身无论如何是无法知道自己的信息的真实性的。 对于这件事，我们只能期望于：因为我们的应用用户量不大，验证协议又不是通用的，所以破解者需要专门针对我们的通讯协议进行破解，这需要他本身有动力做这个事情，并且要花费他一些时间。所以可能他觉得做这个事情没什么挑战和意义，就不破解我们了。在这件事情上，“希望他不要破解”，好象也是我们唯一能做的事情。 乐观一点讲，AppStore上有上百万的应用，如果所有应用都采用服务器验证购买凭证，黑客一一针对破解，确实也太不可能了，所以这件事情还是很有必要的。另外随着iOS6的普及，该漏洞也将被修补掉，所以大家也不用过于悲观。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"iOS应用内付费(IAP)开发步骤列表","slug":"in-app-purchase-check-list","date":"2012-12-09T04:55:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/12/09/in-app-purchase-check-list/","permalink":"https://blog.devtang.com/2012/12/09/in-app-purchase-check-list/","excerpt":"前两天和服务端同事一起，完成了应用内付费（以下简称IAP, In app purchase）的开发工作。步骤繁多，在此把开发步骤列表整理如下。因为只是步骤列表，所以并不含详细的说明教程，需要看教程的新手，可以看我附在最后的一些参考链接。","text":"前两天和服务端同事一起，完成了应用内付费（以下简称IAP, In app purchase）的开发工作。步骤繁多，在此把开发步骤列表整理如下。因为只是步骤列表，所以并不含详细的说明教程，需要看教程的新手，可以看我附在最后的一些参考链接。 配置Developer.apple.com登录到Developer.apple.com，然后进行以下步骤： 为应用建立建立一个不带通配符的App ID 用该App ID生成和安装相应的Provisioning Profile文件。 配置iTunes Connect登录到iTunes Connet，然后进行以下步骤： 用该App ID创建一个新的应用。 在该应用中，创建应用内付费项目，选择付费类型，通常可选的是可重复消费(Consumable)的或是永久有效(Non-Consumable)的2种，然后设置好价格和Product ID以及购买介绍和截图即可，这里的Product ID是需要记住的，后面开发的时候需要。如下图所示： 添加一个用于在sandbox付费的测试用户，如下图所示。注意苹果对该测试用户的密码要求和正式账号一样，必须是至少8位，并且同时包含数字和大小写字母： 填写相关的税务，银行，联系人信息。如下图所示： ###开发工作(ios端) 1、 在工程中引入 storekit.framework 和 #import &lt;StoreKit&#x2F;StoreKit.h&gt; 2、 获得所有的付费Product ID列表。这个可以用常量存储在本地，也可以由自己的服务器返回。 3、 制作一个界面，展示所有的应用内付费项目。这些应用内付费项目的价格和介绍信息可以是自己的服务器返回。但如果是不带服务器的单机游戏应用或工具类应用，则可以通过向App Store查询获得。我在测试时发现，向App Store查询速度非常慢，通常需要2-3秒钟，所以不建议这么做，最好还是搞个自己的服务器吧。 4、当用户点击了一个IAP项目，我们先查询用户是否允许应用内付费，如果不允许则不用进行以下步骤了。代码如下： if ([SKPaymentQueue canMakePayments]) &#123; // 执行下面提到的第5步： [self getProductInfo];&#125; else &#123; NSLog(@&quot;失败，用户禁止应用内付费购买.&quot;);&#125; 5、 我们先通过该IAP的ProductID向AppStore查询，获得SKPayment实例，然后通过SKPaymentQueue的 addPayment方法发起一个购买的操作。 // 下面的ProductId应该是事先在itunesConnect中添加好的，已存在的付费项目。否则查询会失败。- (void)getProductInfo &#123; NSSet * set = [NSSet setWithArray:@[@&quot;ProductId&quot;]]; SKProductsRequest * request = [[SKProductsRequest alloc] initWithProductIdentifiers:set]; request.delegate = self; [request start];&#125;// 以上查询的回调函数- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response &#123; NSArray *myProduct = response.products; if (myProduct.count == 0) &#123; NSLog(@&quot;无法获取产品信息，购买失败。&quot;); return; &#125; SKPayment * payment = [SKPayment paymentWithProduct:myProduct[0]]; [[SKPaymentQueue defaultQueue] addPayment:payment];&#125; 6、 在viewDidLoad方法中，将购买页面设置成购买的Observer。 - (void)viewDidLoad &#123; [super viewDidLoad]; // 监听购买结果 [[SKPaymentQueue defaultQueue] addTransactionObserver:self];&#125;- (void)viewDidUnload &#123; [super viewDidUnload]; [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];&#125; 7、 当用户购买的操作有结果时，就会触发下面的回调函数，相应进行处理即可。 - (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions &#123; for (SKPaymentTransaction *transaction in transactions) &#123; switch (transaction.transactionState) &#123; case SKPaymentTransactionStatePurchased://交易完成 NSLog(@&quot;transactionIdentifier = %@&quot;, transaction.transactionIdentifier); [self completeTransaction:transaction]; break; case SKPaymentTransactionStateFailed://交易失败 [self failedTransaction:transaction]; break; case SKPaymentTransactionStateRestored://已经购买过该商品 [self restoreTransaction:transaction]; break; case SKPaymentTransactionStatePurchasing: //商品添加进列表 NSLog(@&quot;商品添加进列表&quot;); break; default: break; &#125; &#125;&#125;- (void)completeTransaction:(SKPaymentTransaction *)transaction &#123; // Your application should implement these two methods. NSString * productIdentifier = transaction.payment.productIdentifier; NSString * receipt = [transaction.transactionReceipt base64EncodedString]; if ([productIdentifier length] &gt; 0) &#123; // 向自己的服务器验证购买凭证 &#125; // Remove the transaction from the payment queue. [[SKPaymentQueue defaultQueue] finishTransaction: transaction];&#125;- (void)failedTransaction:(SKPaymentTransaction *)transaction &#123; if(transaction.error.code != SKErrorPaymentCancelled) &#123; NSLog(@&quot;购买失败&quot;); &#125; else &#123; NSLog(@&quot;用户取消交易&quot;); &#125; [[SKPaymentQueue defaultQueue] finishTransaction: transaction];&#125;- (void)restoreTransaction:(SKPaymentTransaction *)transaction &#123; // 对于已购商品，处理恢复购买的逻辑 [[SKPaymentQueue defaultQueue] finishTransaction: transaction];&#125; 8、服务器验证凭证(Optional)。如果购买成功，我们需要将凭证发送到服务器上进行验证。考虑到网络异常情况，iOS端的发送凭证操作应该进行持久化，如果程序退出，崩溃或网络异常，可以恢复重试。 ###开发工作(服务端) 服务端的工作比较简单，分4步： 接收ios端发过来的购买凭证。 判断凭证是否已经存在或验证过，然后存储该凭证。 将该凭证发送到苹果的服务器验证，并将验证结果返回给客户端。 如果需要，修改用户相应的会员权限。 考虑到网络异常情况，服务器的验证应该是一个可恢复的队列，如果网络失败了，应该进行重试。 与苹果的验证接口文档在这里。简单来说就是将该购买凭证用Base64编码，然后POST给苹果的验证服务器，苹果将验证结果以JSON形式返回。 苹果AppStore线上的购买凭证验证地址是https://buy.itunes.apple.com/verifyReceipt ，测试的验证地址是：https://sandbox.itunes.apple.com/verifyReceipt 参考链接以下参考链接详细说明了完成应用内付费开发的步骤： https://developer.apple.com/appstore/in-app-purchase/index.html http://www.himigame.com/iphone-cocos2d/550.html http://www.cocoachina.com/iphonedev/sdk/2011/1028/3435.html http://www.cocoachina.com/newbie/basic/2012/0214/3976.html","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"让Xcode的 stack trace信息可读","slug":"make-stack-trace-more-readable","date":"2012-11-14T12:19:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/11/14/make-stack-trace-more-readable/","permalink":"https://blog.devtang.com/2012/11/14/make-stack-trace-more-readable/","excerpt":"昨天在写 iOS 代码的时候，调试的时候模拟器崩溃了。异常停在了如下整个 main 函数的入口处： int main(int argc, char *argv[])&#123; @autoreleasepool &#123; // 异常停在了下面这行，毫无提示作用 return UIApplicationMain(argc, argv, nil, NSStringFromClass([MyClass class])); &#125;&#125;","text":"昨天在写 iOS 代码的时候，调试的时候模拟器崩溃了。异常停在了如下整个 main 函数的入口处： int main(int argc, char *argv[])&#123; @autoreleasepool &#123; // 异常停在了下面这行，毫无提示作用 return UIApplicationMain(argc, argv, nil, NSStringFromClass([MyClass class])); &#125;&#125; Xcode 的 Console 界面报出了一些出错信息 , 如下图所示： 我根据 Console 里面的文字提示信息，猜出应该是出现了空指针 nil 的操作。但是具体出错在哪一行，却不知道。最终虽然找到了 bug，但是 debug 的过程确实费了些时间。考虑到这个 stace trace 信息应该对我挺有帮助才对的，所以我就查了一下如何让这原本一堆 16 进制的调用栈信息更可读。于是在 stackoverflow 上找到了 2 个比较好的解决办法，在这里分享给大家。 方法一该 方法 的步骤是，首先在你的 AppDelegate 中定义一个方法 , 用于处理异常： void uncaughtExceptionHandler(NSException *exception) &#123; NSLog(@&quot;CRASH: %@&quot;, exception); NSLog(@&quot;Stack Trace: %@&quot;, [exception callStackSymbols]); // Internal error reporting&#125; 然后在应用启动时，设置这个方法作为自己的自定义异常回调： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSSetUncaughtExceptionHandler(&amp;uncaughtExceptionHandler); // Normal launch stuff&#125; 完成之后，当对于上面的异常，在定义了这个回调之后，Log 信息变成如下所示，出错行一目了然，根据下面的可读的 stack trace，我一下就可以找到是 QuestionParser 这个类的第 378 行导致的异常，进而可以跳到出错行分析原因，很容易就把 bug 修复了。 Ape[2711:11303] CRASH: *** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[2]Ape[2711:11303] Stack Trace: ( 0 CoreFoundation 0x0209402e __exceptionPreprocess + 206 1 libobjc.A.dylib 0x01a71e7e objc_exception_throw + 44 2 CoreFoundation 0x0205aa95 -[__NSPlaceholderDictionary initWithObjects:forKeys:count:] + 165 3 CoreFoundation 0x020874e9 +[NSDictionary dictionaryWithObjects:forKeys:count:] + 73 4 Ape 0x00096a0a +[QuestionParser parseToDictionary:] + 378 5 Ape 0x00096434 -[QuestionStore putQuestion:] + 308 6 Ape 0x00089ddf -[QuestionViewController requestFinished:] + 303 7 Ape 0x000869dd -[NetworkAgent requestFinished:] + 653 8 Ape 0x00085d33 __27-[NetworkAgent addRequest:]_block_invoke_0 + 131 9 libdispatch.dylib 0x01cf153f _dispatch_call_block_and_release + 15 10 libdispatch.dylib 0x01d03014 _dispatch_client_callout + 14 11 libdispatch.dylib 0x01cf2fd6 _dispatch_after_timer_callback + 28 12 libdispatch.dylib 0x01d03014 _dispatch_client_callout + 14 13 libdispatch.dylib 0x01cfa8b7 _dispatch_source_latch_and_call + 219 14 libdispatch.dylib 0x01cf6405 _dispatch_source_invoke + 322 15 libdispatch.dylib 0x01cf3768 _dispatch_main_queue_callback_4CF + 187 16 CoreFoundation 0x0203aaf5 __CFRunLoopRun + 1925 17 CoreFoundation 0x02039f44 CFRunLoopRunSpecific + 276 18 CoreFoundation 0x02039e1b CFRunLoopRunInMode + 123 19 GraphicsServices 0x0282b7e3 GSEventRunModal + 88 20 GraphicsServices 0x0282b668 GSEventRun + 104 21 UIKit 0x00be265c UIApplicationMain + 1211 22 Ape 0x00016c5d main + 141 23 Ape 0x00002b05 start + 53 24 ??? 0x00000001 0x0 + 1) 方法二方法二相比方法一更加简单，具体做法是在 Xcode 界面中按 cmd + 6 跳到 Breakpoint 的 tab，然后点击左下角的 + 号，增加一个 Exception 的断点，如下图所示。这样，当异常出现时，会自动停在异常处，而不会抛出到 UIApplicationMain。拿我的有 bug 的程序来说，代码会自动断在 QuestionParser 这个类的第 378 行。 总结其实以前 Xcode 是能显示出可读的 stack trace 信息的，似乎到了 Xcode4.2 以后就出问题了。所以上面提到的 2 个办法相当于 walk around 解决了 Xcode4.2 以后出现的 bug。如果该文章对你有用，希望你能帮我点击下面的分享按钮，分享给更多朋友，同时也帮我宣传一下博客，这将有助于我分享更多的心得给大家，Have fun!","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"改进iOS客户端的升级提醒功能","slug":"how-to-design-upgrade-notice","date":"2012-11-10T10:42:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/11/10/how-to-design-upgrade-notice/","permalink":"https://blog.devtang.com/2012/11/10/how-to-design-upgrade-notice/","excerpt":"功能设计先申明一下，我是码农，不是一个产品经理，但我觉得现有市面上的很多 App，设计的 “升级提示功能” 都不太友好。在此分享一下我的想法，欢迎大家讨论。 这些 App 包括：新浪微博、网易微博、网易新闻客户端以及大部分带有升级提示功能的 App，所以我觉得这个问题还是挺普遍的。对于该问题，一句话描述起来就是：“这些 App 都会在用户刚刚使用它的时候，提示有新版本，让用户去 AppStore 上下载最新的版本”。下面是某个应用的升级提示截图： 为什么我认为这是一个糟糕的设计呢？因为用户刚刚打开你的 App，明显就是想使用你的功能。例如刚刚打开新浪微博，可能就是想看一下最新的消息或回复。刚刚打开网易新闻客户端，可能就是想看看最新的新闻。这个时候，你告诉用户有新版本，是想让用户暂时放弃使用该 App 吗？我不知道有多少用户会去点 “升级” 这个按钮，反正我每次看到这个提示都很郁闷，因为我如果点了，我就暂时不能使用该应用了（升级时原版本的 App 是无法使用的）。所以我在想，这个提示升级的时间能不能做得更友好一些？","text":"功能设计先申明一下，我是码农，不是一个产品经理，但我觉得现有市面上的很多 App，设计的 “升级提示功能” 都不太友好。在此分享一下我的想法，欢迎大家讨论。 这些 App 包括：新浪微博、网易微博、网易新闻客户端以及大部分带有升级提示功能的 App，所以我觉得这个问题还是挺普遍的。对于该问题，一句话描述起来就是：“这些 App 都会在用户刚刚使用它的时候，提示有新版本，让用户去 AppStore 上下载最新的版本”。下面是某个应用的升级提示截图： 为什么我认为这是一个糟糕的设计呢？因为用户刚刚打开你的 App，明显就是想使用你的功能。例如刚刚打开新浪微博，可能就是想看一下最新的消息或回复。刚刚打开网易新闻客户端，可能就是想看看最新的新闻。这个时候，你告诉用户有新版本，是想让用户暂时放弃使用该 App 吗？我不知道有多少用户会去点 “升级” 这个按钮，反正我每次看到这个提示都很郁闷，因为我如果点了，我就暂时不能使用该应用了（升级时原版本的 App 是无法使用的）。所以我在想，这个提示升级的时间能不能做得更友好一些？ 有一次在地铁上我想到了一个好办法，就是让升级提示不是出现在软件刚刚打开的时候，而是用户刚刚退出 App 的时候，我们可以在用户刚刚退出 App 的时候，向 iOS 设备发一个本地的通知 (Local Notification)，在本地通知上显示升级提示。当用户点击这个升级提示时，我们的 App 在启动后跳转到 AppStore，这样就达到的提示升级的效果。 这样做相比以前的好处有以下几点： 用户退出 App 的时刻，是一个访问这个 App 活动的结束。在这个时候提示，用户更有理由接受升级。 即便用户当前不接受升级，但这个升级提示都会存在用户的通知中心中，用户想升级时，点击这个通知，就可以方便地一键跳到 AppStore 的下载页面。而之前的方法在用户取消后，用户就不方便取获下载地址了。 另外，本地通知的使用只需要 iOS4.0 以上版本即可，而在中国，iOS4.0 以上比例 达到了 99%。本地通知也不需要向用户申请发送通知的 DeviceToken，所以该方案很少被用户禁止（用户只能专门去通知中心将该应用的所有通知关闭）。当然，这个升级提示也不应该每次都出现，以免对用户产生太多打挠，象我在粉笔网客户端上设置的策略是最多半个月出现一次。 在我在粉笔网 iPhone 端实现该方案后，有一次我发现支付宝的 iOS 客户端也采用通知的方式来提示用户升级，看来大家都想到一块儿了。不过从通知的发送时间来看，他们应该不是使用的本地通知，而是通过服务器发送 Push 通知的方式。这种方式的好处是即使用户安装后一次也没有使用你的 App，你还是可以通过通知来唤醒他，可能的坏处是： 可能用户已经升完级了，你还把升级通知的信息发给用户了。象我就是，支付宝都升完级了，还发通知提示我有新版可以使用。 用户如果禁止了应用的 Push 通知，你就没办法发送升级提醒了。 技术实现再简单说一下技术实现，我写了一个 VersionAgent 类，每 24 小时最多向服务器请求一次最新的 App 版本。然后在每次 App 启动 5 秒后，检查一下是否过了 24 小时一次的请求阈值，如下所示： - (void)applicationDidBecomeActive:(UIApplication *)application&#123; double delayInSeconds = 5.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC); dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; [[VersionAgent sharedInstance] checkVersion]; &#125;);&#125; 如果版本有更新，则在 AppDelegate 的 applicationDidEnterBackgroundl 回调中，发送一个本地通知，示例代码如下： - (void)applicationDidEnterBackground:(UIApplication *)application&#123; if ([[VersionAgent sharedInstance] shouldShowLocalNotification]) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; UILocalNotification * localNotification = [[UILocalNotification alloc] init]; if (localNotification) &#123; localNotification.fireDate= [[[NSDate alloc] init] dateByAddingTimeInterval:3]; localNotification.timeZone=[NSTimeZone defaultTimeZone]; localNotification.alertBody = @&quot; 粉笔网客户端有新的版本，点击到 App Store 升级。&quot;; localNotification.alertAction = @&quot; 升级 &quot;; localNotification.soundName = @&quot;&quot;; [application scheduleLocalNotification:localNotification]; &#125; &#125;); &#125;&#125; 然后通过 AppDelegate 的回调函数，判断 App 的启动方式是否是通过用户点击通知中心的升级提示来启动，如果是，则跳转到 AppStore，示例代码如下： - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123; // open app store link NSString * url = [NSString stringWithFormat:@&quot;itms-apps://itunes.apple.com/app/id%@&quot;, APP_STORE_ID]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];&#125; 题外话 最新微博上有一个 新闻 很火，一个技术男，给女友发弹窗通知求爱。有些人回复说这样做太麻烦，需要在服务器上记 DeviceToken，否则所有用户都发的话，会让很多不相关的人收到。 其实这完全可以用本地通知来做，完全不需要服务器配合，相当简单。具体做法是：你自己写一个发本地求爱通知的小应用，然后记下女友手机的 UDID，将女友的手机设置成开发者设备，然后抓住一次机会在其手机上安装好开发者证书和你写的这个小 App 即可。可以把这个 App 隐藏在某个文件夹下面，然后打开一次，设置好本地通知的发出时间即可。 我的很多文章最后结尾都是 Have fun，不过最近很难高兴起来啊。因为 0x12 Big，今天 google 的全线产品都无法访问了。想起我每天的工作都是用 google 搜技术贴，用 gmail 收邮件，用 gtalk 聊天，我的联系人信息，备忘录也是同步在 google contact 上，我真的无法 fun 起来了。本博客是架设在 github 上的，我也很担心该博客可能也会因为是境外 IP 而被禁止访问。 有时候，我很气愤，而有时候，我会乐观地想，这些都是负能量的积累，黎明前的黑暗。不管怎么样，谁也无法阻止大家对自由的向往，希望有朝一日，所有人都能自由地获取信息。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"在MacOS和iOS系统中使用OpenCV","slug":"use-opencv-in-ios","date":"2012-10-27T12:43:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/10/27/use-opencv-in-ios/","permalink":"https://blog.devtang.com/2012/10/27/use-opencv-in-ios/","excerpt":"前言 OpenCV 是一个开源的跨平台计算机视觉库，实现了图像处理和计算机视觉方面的很多通用算法。 最近试着在 MacOS 和 iOS 上使用 OpenCV，发现网上关于在 MacOS 和 iOS 上搭建 OpenCV 的资料很少。好不容易搜到些资料，却发现由于 OpenCV 和 Xcode 的版本更新，变得不再有用了。有些问题费了我很多时间，在此总结分享给大家，希望后来人少走些弯路。 可以预见到，随着 Xcode 和 OpenCV 的版本更新，本文可能不再有效了。 所以特此注明，文本介绍的搭建方法仅针对于 Xcode4.5.1 和 OpenCV 2.4.2 版本。 （2013-6-22）更新: 我在 Xcode4.6.2 和 OpenCV 2.4.5 版本的时候重新进行了一次环境搭建，以下内容做了相应调整，应该也是有效的。","text":"前言 OpenCV 是一个开源的跨平台计算机视觉库，实现了图像处理和计算机视觉方面的很多通用算法。 最近试着在 MacOS 和 iOS 上使用 OpenCV，发现网上关于在 MacOS 和 iOS 上搭建 OpenCV 的资料很少。好不容易搜到些资料，却发现由于 OpenCV 和 Xcode 的版本更新，变得不再有用了。有些问题费了我很多时间，在此总结分享给大家，希望后来人少走些弯路。 可以预见到，随着 Xcode 和 OpenCV 的版本更新，本文可能不再有效了。 所以特此注明，文本介绍的搭建方法仅针对于 Xcode4.5.1 和 OpenCV 2.4.2 版本。 （2013-6-22）更新: 我在 Xcode4.6.2 和 OpenCV 2.4.5 版本的时候重新进行了一次环境搭建，以下内容做了相应调整，应该也是有效的。 MacOS 系统中使用 OpenCV在 Mac OS Lion 中安装 OpenCV相信大部分 Mac 用户都安装了 brew 或 port，如果你没有装，那么首先安装一下 brew 吧。使用如下命令安装 brew: ruby -e &quot;$(curl -fsSkL raw.github.com/mxcl/homebrew/go)&quot; 在安装好 brew 后，只需要一条命令就可以安装 OpenCV 了： brew install opencv 通常情况下这样做就应该会安装成功，但我在公司和家里面的电脑尝试的时候，brew 都会报一些错误，我遇到的都是一些小问题，按照 brew 的提示信息，解决掉相应的问题即可。 安装成功后，你应该可以在 “&#x2F;usr&#x2F;local&#x2F;include” 目录下找到名为 opencv 和 opencv2 的目录，这里面是 OpenCV 相关的头文件。你也可以在 “&#x2F;usr&#x2F;local&#x2F;lib” 目录下找到许多以 libopencv_ 开头的 .dylib 文件，这些是 OpenCV 的链接库文件。 在 Mac OS Mountain Lion 中安装 OpenCV按照 该教程，先用 brew 安装 cmake. 去 OpenCV 官网 下载 Linux&#x2F;Mac 版的源码，将源码解压后，在控制台中切换到源码目录，执行如下操作： # make a separate directory for buildingmkdir buildcd buildcmake -G &quot;Unix Makefiles&quot; ..# Now, we can make OpenCV. Type the following in:make -j8sudo make install 上面的命令在执行时要注意，整个源码目录的路径不能带空格。否则编译会报错找不到一些文件。 安装成功后，你应该可以在 “&#x2F;usr&#x2F;local&#x2F;include” 目录下找到名为 opencv 和 opencv2 的目录，这里面是 OpenCV 相关的头文件。你也可以在 “&#x2F;usr&#x2F;local&#x2F;lib” 目录下找到许多以 libopencv_ 开头的 .dylib 文件，这些是 OpenCV 的链接库文件。 在 MacOS 系统中使用 OpenCV接着我们可以试着在 Xcode 工程中使用 OpenCV。 新建一个 Cocoa Application 的工程。工程建好后，选中工程的 Target，在 Build Settings 一样，找到 “Header Search Paths” 这一个选项，将它的值改为 “&#x2F;usr&#x2F;local&#x2F;include”。 同样还需要设置的还有 “Lib Search Paths” 这一项，将它的值改为 “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;**”, 如下所示： 接着切换到 Build Phases 这个 tab，在 “Link Binary With Libraries” 中，选项 + 号，然后将弹出的文件选择对话框目录切换到 “&#x2F;usr&#x2F;local&#x2F;lib” 目录下，选择你需要使用的 OpenCV 链接库（通常情况下，你至少会需要 core、highgui 和 imgproc 库)，如下图所示（截图中的 OpenCV 版本号可能和你的有差别，但应该不影响）： 这里有一个技巧，因为 &#x2F;usr 目录在对话框中默认不是可见的，可以按快捷键 command + shift + G，在弹出的 “前往文件夹 “ 对话框中输入 &#x2F;usr&#x2F;local&#x2F;lib ，即可跳转到目标文件夹。如下图所示： 下一步是我自己试出来的，对于 Lion 操作系统，你需要在 Build Settings 中，将 “C++ Language Dialect” 设置成 C++11，将 “C++ Standard Library” 设置成 libstdc++ ，如下图所示。个人感觉是由于 Xcode 默认设置的 GNU++11、libc++ 与 OpenCV 库有一些兼容性问题，我在更改该设置前老是出现编译错误。后续版本在 Montain Lion 系统中解决了这个问题，不用进行这一步了。 把上面的设置都做好后，就可以在需要的使用 OpenCV 库的地方，加上 opencv 的头文件引用即可： #import &quot;opencv2/opencv.hpp&quot; 注意，如果你的源文件扩展名是 .m 的，你还需要改成 .mm，这样编译器才知道你将会在该文件混合使用 C++ 语言和 Objective-C 语言。 OpenCV 处理图象需要的格式是 cv::Mat 类，而 MacOS 的图象格式默认是 NSImage，所以你需要知道如何在 cv::Mat 与 NSImage 之前相互转换。如下是一个 NSImage 的 Addition，你肯定会需要它的。该代码来自 stackoverflow 上的 这个贴子。 NSImage+OpenCV.h 文件： //// NSImage+OpenCV.h//// Created by TangQiao on 12-10-26.//#import &lt;Foundation/Foundation.h&gt;#import &quot;opencv2/opencv.hpp&quot;@interface NSImage (OpenCV)+(NSImage*)imageWithCVMat:(const cv::Mat&amp;)cvMat;-(id)initWithCVMat:(const cv::Mat&amp;)cvMat;@property(nonatomic, readonly) cv::Mat CVMat;@property(nonatomic, readonly) cv::Mat CVGrayscaleMat;@end NSImage+OpenCV.mm 文件： //// NSImage+OpenCV.mm//// Created by TangQiao on 12-10-26.//#import &quot;NSImage+OpenCV.h&quot;static void ProviderReleaseDataNOP(void *info, const void *data, size_t size)&#123; return;&#125;@implementation NSImage (OpenCV)-(CGImageRef)CGImage&#123; CGContextRef bitmapCtx = CGBitmapContextCreate(NULL/*data - pass NULL to let CG allocate the memory*/, [self size].width, [self size].height, 8 /*bitsPerComponent*/, 0 /*bytesPerRow - CG will calculate it for you if it&#x27;s allocating the data. This might get padded out a bit for better alignment*/, [[NSColorSpace genericRGBColorSpace] CGColorSpace], kCGBitmapByteOrder32Host|kCGImageAlphaPremultipliedFirst); [NSGraphicsContext saveGraphicsState]; [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:bitmapCtx flipped:NO]]; [self drawInRect:NSMakeRect(0,0, [self size].width, [self size].height) fromRect:NSZeroRect operation:NSCompositeCopy fraction:1.0]; [NSGraphicsContext restoreGraphicsState]; CGImageRef cgImage = CGBitmapContextCreateImage(bitmapCtx); CGContextRelease(bitmapCtx); return cgImage;&#125;-(cv::Mat)CVMat&#123; CGImageRef imageRef = [self CGImage]; CGColorSpaceRef colorSpace = CGImageGetColorSpace(imageRef); CGFloat cols = self.size.width; CGFloat rows = self.size.height; cv::Mat cvMat(rows, cols, CV_8UC4); // 8 bits per component, 4 channels CGContextRef contextRef = CGBitmapContextCreate(cvMat.data, // Pointer to backing data cols, // Width of bitmap rows, // Height of bitmap 8, // Bits per component cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNoneSkipLast | kCGBitmapByteOrderDefault); // Bitmap info flags CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), imageRef); CGContextRelease(contextRef); CGImageRelease(imageRef); return cvMat;&#125;-(cv::Mat)CVGrayscaleMat&#123; CGImageRef imageRef = [self CGImage]; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); CGFloat cols = self.size.width; CGFloat rows = self.size.height; cv::Mat cvMat = cv::Mat(rows, cols, CV_8UC1); // 8 bits per component, 1 channel CGContextRef contextRef = CGBitmapContextCreate(cvMat.data, // Pointer to backing data cols, // Width of bitmap rows, // Height of bitmap 8, // Bits per component cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNone | kCGBitmapByteOrderDefault); // Bitmap info flags CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), imageRef); CGContextRelease(contextRef); CGColorSpaceRelease(colorSpace); CGImageRelease(imageRef); return cvMat;&#125;+ (NSImage *)imageWithCVMat:(const cv::Mat&amp;)cvMat&#123; return [[[NSImage alloc] initWithCVMat:cvMat] autorelease];&#125;- (id)initWithCVMat:(const cv::Mat&amp;)cvMat&#123; NSData *data = [NSData dataWithBytes:cvMat.data length:cvMat.elemSize() * cvMat.total()]; CGColorSpaceRef colorSpace; if (cvMat.elemSize() == 1) &#123; colorSpace = CGColorSpaceCreateDeviceGray(); &#125; else &#123; colorSpace = CGColorSpaceCreateDeviceRGB(); &#125; CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)data); CGImageRef imageRef = CGImageCreate(cvMat.cols, // Width cvMat.rows, // Height 8, // Bits per component 8 * cvMat.elemSize(), // Bits per pixel cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNone | kCGBitmapByteOrderDefault, // Bitmap info flags provider, // CGDataProviderRef NULL, // Decode false, // Should interpolate kCGRenderingIntentDefault); // Intent NSBitmapImageRep *bitmapRep = [[NSBitmapImageRep alloc] initWithCGImage:imageRef]; NSImage *image = [[NSImage alloc] init]; [image addRepresentation:bitmapRep]; CGImageRelease(imageRef); CGDataProviderRelease(provider); CGColorSpaceRelease(colorSpace); return image;&#125;@end 完成以上步骤后，恭喜你，你可以在源代码中自由地调用 OpenCV 的函数了。 在 iOS 系统中使用 OpenCV下载或编译 opencv2.framework接下来介绍如何在 iOS 程序中使用 OpenCV。在 iOS 上使用最新的 OpenCV 库比较简单，进入 opencv 的官网，下载 build 好的名为 opencv2.framework 即可（下载地址）。 如果你比较喜欢折腾，也可以自行下载 opencv 的源码，在本地编译 opencv2.framework。这里 有官方网站的教程，步骤非常简单，不过我照着它的教程尝试了一下失败了。感觉还是 Xcode 编译器与 OpenCV 代码的兼容性问题，所以就没有继续研究了。 在 iOS 程序中使用 OpenCV新建一个 iOS 工程，将 opencv2.framework 直接拖动到工程中。然后，你需要在 Build Settings 中，将 “C++ Standard Library” 设置成 libstdc++。 因为 opencv 中的 MIN 宏和 UIKit 的 MIN 宏有冲突。所以需要在 .pch 文件中，先定义 opencv 的头文件，否则会有编译错误。将工程的 .pch 文件内容修改成如下所示： #import &lt;Availability.h&gt;#ifdef __cplusplus #import &lt;opencv2/opencv.hpp&gt;#endif#ifdef __OBJC__ #import &lt;UIKit/UIKit.h&gt; #import &lt;Foundation/Foundation.h&gt;#endif 把上面的设置都做好后，就可以在需要的使用 OpenCV 库的地方，加上 opencv 的头文件引用即可： #import &quot;opencv2/opencv.hpp&quot; 还是那句话，如果你的源文件扩展名是 .m 的，你还需要改成 .mm，这样编译器才知道你将会在该文件中混合使用 C++ 语言和 Objective-C 语言。 同样，iOS 程序内部通常用 UIImage 表示图片，而 OpenCV 处理图象需要的格式是 cv::Mat，你会需要下面这个 Addition 来在 cv::Mat 和 UIImage 格式之间相互转换。该代码来自 aptogo 的开源代码，他的版权信息在源码头文件中。 UIImage+OpenCV.h 文件： //// UIImage+OpenCV.h// OpenCVClient//// Created by Robin Summerhill on 02/09/2011.// Copyright 2011 Aptogo Limited. All rights reserved.//// Permission is given to use this source code file without charge in any// project, commercial or otherwise, entirely at your risk, with the condition// that any redistribution (in part or whole) of source code must retain// this copyright and permission notice. Attribution in compiled projects is// appreciated but not required.//#import &lt;UIKit/UIKit.h&gt;@interface UIImage (UIImage_OpenCV)+(UIImage *)imageWithCVMat:(const cv::Mat&amp;)cvMat;-(id)initWithCVMat:(const cv::Mat&amp;)cvMat;@property(nonatomic, readonly) cv::Mat CVMat;@property(nonatomic, readonly) cv::Mat CVGrayscaleMat;@end UIImage+OpenCV.mm 文件： //// UIImage+OpenCV.mm// OpenCVClient//// Created by Robin Summerhill on 02/09/2011.// Copyright 2011 Aptogo Limited. All rights reserved.//// Permission is given to use this source code file without charge in any// project, commercial or otherwise, entirely at your risk, with the condition// that any redistribution (in part or whole) of source code must retain// this copyright and permission notice. Attribution in compiled projects is// appreciated but not required.//#import &quot;UIImage+OpenCV.h&quot;static void ProviderReleaseDataNOP(void *info, const void *data, size_t size)&#123; // Do not release memory return;&#125;@implementation UIImage (UIImage_OpenCV)-(cv::Mat)CVMat&#123; CGColorSpaceRef colorSpace = CGImageGetColorSpace(self.CGImage); CGFloat cols = self.size.width; CGFloat rows = self.size.height; cv::Mat cvMat(rows, cols, CV_8UC4); // 8 bits per component, 4 channels CGContextRef contextRef = CGBitmapContextCreate(cvMat.data, // Pointer to backing data cols, // Width of bitmap rows, // Height of bitmap 8, // Bits per component cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNoneSkipLast | kCGBitmapByteOrderDefault); // Bitmap info flags CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), self.CGImage); CGContextRelease(contextRef); return cvMat;&#125;-(cv::Mat)CVGrayscaleMat&#123; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); CGFloat cols = self.size.width; CGFloat rows = self.size.height; cv::Mat cvMat = cv::Mat(rows, cols, CV_8UC1); // 8 bits per component, 1 channel CGContextRef contextRef = CGBitmapContextCreate(cvMat.data, // Pointer to backing data cols, // Width of bitmap rows, // Height of bitmap 8, // Bits per component cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNone | kCGBitmapByteOrderDefault); // Bitmap info flags CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), self.CGImage); CGContextRelease(contextRef); CGColorSpaceRelease(colorSpace); return cvMat;&#125;+ (UIImage *)imageWithCVMat:(const cv::Mat&amp;)cvMat&#123; return [[[UIImage alloc] initWithCVMat:cvMat] autorelease];&#125;- (id)initWithCVMat:(const cv::Mat&amp;)cvMat&#123; NSData *data = [NSData dataWithBytes:cvMat.data length:cvMat.elemSize() * cvMat.total()]; CGColorSpaceRef colorSpace; if (cvMat.elemSize() == 1) &#123; colorSpace = CGColorSpaceCreateDeviceGray(); &#125; else &#123; colorSpace = CGColorSpaceCreateDeviceRGB(); &#125; CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)data); CGImageRef imageRef = CGImageCreate(cvMat.cols, // Width cvMat.rows, // Height 8, // Bits per component 8 * cvMat.elemSize(), // Bits per pixel cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNone | kCGBitmapByteOrderDefault, // Bitmap info flags provider, // CGDataProviderRef NULL, // Decode false, // Should interpolate kCGRenderingIntentDefault); // Intent self = [self initWithCGImage:imageRef]; CGImageRelease(imageRef); CGDataProviderRelease(provider); CGColorSpaceRelease(colorSpace); return self;&#125;@end 总结上面 2 个环境搭建好后，你就可以在 MacOS 上试验各种图象处理算法，然后很方便地移值到 iOS 上。 一直觉得，图象和声音是移动设备上的特点和优势。因为移动设备没有了可以快速输入的键盘，屏幕也不大，在移动设备上，声音，图象和视频应该是相比文字更方便让人输入的东西。移动端 APP 应该利用好这些特点，才能设计出更加体贴的功能。 而且，通常情况下做图象处理都比较好玩，记得以前在学校做了一个在 QQ 游戏大厅自动下中国象棋的程序，其后台使用了网上下载的一个带命令行接口的象棋 AI，然后我的代码主要做的事情就是识别象棋棋盘，然后将棋盘数据传给那个象棋 AI，接着获得它返回的策略后，模拟鼠标点击来移动棋子。当时不懂什么图象算法，直接把棋子先截取下来保存，然后识别的时候做完全匹配，非常弱的办法，但是效果非常好，做出来也很好玩。嗯，所以文章最后，我想说的是：have fun!","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"粉笔网的架构和项目管理","slug":"scrum-and-architecture-in-fenbi","date":"2012-10-15T02:56:00.000Z","updated":"2024-01-06T14:52:37.913Z","comments":true,"path":"2012/10/15/scrum-and-architecture-in-fenbi/","permalink":"https://blog.devtang.com/2012/10/15/scrum-and-architecture-in-fenbi/","excerpt":"","text":"10 月 10 日，在 CMDN 炫姐姐 的邀请下，我们粉笔网团队通过 CSDN 的 CMDN Club, 对外进行了第一次 技术分享。分享的内容主要包括 2 部分: 第一部分是关于粉笔网使用 Scrum 进行快速开发的故事。我们分享了如何在 3 个多月完成了全平台的开发的经验分享，其中也包括我们对 Scrum 的具体使用方式和其中遇到的各种问题。CSDN 整理出来的报道文章在 这里。 第二部分是关于粉笔网的技术架构方案。粉笔网在技术上还是一个微博类的 UGC 信息聚合系统。一方面，我们的团队之前做过 网易微博 和 爱转角 这 2 个微博类系统，积累了很多经验。另一方面，我们作为创业团队，没有在大公司里可以使用的内部开发的成熟的分布式存储系统，所以，我们只有借助于开源社区。最终，我们比较了现在各种方案的优缺点后，提出了我们自己的能够支持千万级用户的系统架构方案。这个方案最终通过了我们自己的压力测试，并且在上线后运行良好。CSDN 整理出来的报道文章在 这里。 我们将演示的 PDF 文件在此分享给大家。下载链接： 第一部分 , 第二部分 。 2016.02.27 更新原粉笔网已关闭，相关演示的 PDF 文件不再可下载。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"谈谈我的创业感受","slug":"talk-about-my-startup-exp","date":"2012-09-15T05:50:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/09/15/talk-about-my-startup-exp/","permalink":"https://blog.devtang.com/2012/09/15/talk-about-my-startup-exp/","excerpt":"5 个程序员，3 个多月时间，30 多万行代码，1000 个 bug，只为打造卓越产品。 开发历程先简单介绍一下产品。我们的产品叫 “粉笔网”，这是一个新颖的学习社区。我们公司的创始人是前网易高管 李勇。我们团队从 4 月份开始筹备，5 月份开始工作，整个开发历经 3 个多月，其中网站于 8 月 28 号顺利上线，iPhone 客户端 和 Android 客户端 于 9 月 8 日顺利通过审核上线。","text":"5 个程序员，3 个多月时间，30 多万行代码，1000 个 bug，只为打造卓越产品。 开发历程先简单介绍一下产品。我们的产品叫 “粉笔网”，这是一个新颖的学习社区。我们公司的创始人是前网易高管 李勇。我们团队从 4 月份开始筹备，5 月份开始工作，整个开发历经 3 个多月，其中网站于 8 月 28 号顺利上线，iPhone 客户端 和 Android 客户端 于 9 月 8 日顺利通过审核上线。 对于互联网行业的功能开发，项目延期是很常见的，但是我们的程序员虽然只有 5 个人（后台 2 人，Web 前端 1 人，iPhone 端 1 人，Android 端 1 人），但整个项目（包括 Web 网站，iPhone 端和 Android 端）都顺利地在 3 个多月完成了开发和上线。我觉得这里面主要得益于团队成员之前默契的配合，以及用 scrum 让我们的整个工作安全紧张有序，但是又不慌乱。 在这三个多月里，我们制定了紧张的时间安排。我们一开始就知道任务很重，所以，我们定制了合理的加班计划。简单来说，就是 6 乘 11，即工作 6 天，每天 11 个小时（早上 10 点到晚上 9 点），每个月的最后一个周末，我们可以双休。在工作时间上，我们每周的工作时间是 66 个小时，比正常的每周 40 个小时的工作时间，多了 50%，这基本上达到我们的精力极限了。 但加班并不是我们期望的长期的工作方式，所以在 8 月 28 号产品正式上线后，我们即恢复了早 10 晚 7 的正常每天 8 小时的工作时间。 以下是我们整个项目的进展图，我们每周一个 sprint，每 3 周一个 Milestone，需求在中间经历过一些变动，但都是在对项目进度的影响在可控的范围内。 代码总结回顾我们团队这 3 个多月的代码贡献，可以用惊人来形容。除去第三方的开源库依赖，后台写了将近 10 万行代码，前端 8 万行代码，iPhone 端 7 万行，android 端 7 万行。一共 30 多万行代码。 以下是用 gitstat 软件 统计出来的代码增长图，首先是 web 前端和后台，它们在一个项目里面： 然后是 iPhone 端： 创业感受我在经历了 2 年大公司实习，2 年半大公司工作后，现在在这样一个创业期的小公司工作。我感觉到最明显的差别是工作效率上的。我们的团队很小，所以我们的交流沟通很多时候都只需要扭头喊一嗓子就行了，对于一些架构设计的讨论，很多时候都是在饭桌上以及午饭后晒太阳时进行的。我们没有各种设计评审会议，接受合理的需求变动和改进，最大限度地保证产品按期完成而不是延期。 在 8 月 28 号 Web 版 (http://fenbi.com) 上线后，我们保持了每周一个迭代更新的速度。每周一个 scrum 相当刺激，除去开 scrum meeting 和上线的时间，留给我们的开发和测试改 bug 的时间只有 4 天左右。大家每天都非常有活力地工作，但是，我们却保证了严格的 code review 制度，所有提交都会汇集到 gerrit 上进行 code review，通过之后再由 gerrit 自动 merge 到工作分支上。 很多人说，创业公司每个人都是多面手，但我们的团队更强调每个人都能精通一方面，成为某一方面的专家。所以，我们会抽时间去一起阅读 redis 代码，读 amazon 关于 dynamo 的论文。我们希望我们的技术成长能够跟上公司的成长速度，在各方面都积累。只有这样，当有一天，由于用户大量增长带来服务器访问压力时，我们能够从容地提出解决方案，不至于象京东那样搞个活动就把系统搞挂了。 我们也把大公司的好习惯带进了创业公司，比如我们强调 wiki 的撰写。wiki 相比文档来说要敏捷很多，我们只写别人需要看的和重要的信息。比如我们对于系统的所有接口设计，代码规范，美术设计流程，上线流程，部署方案，每次 scrum 的总结等。这样一个新人进来之后，他很容易从 wiki 上找到他需要的信息而不是靠我们口口相传。又比如我们会做 code review 和持续集成测试，客户端会做 daily build，这些都是非常规范的。 总结回想这几个月的经历，感觉最大的收获是能够和一帮志趣相投的人一起快乐的工作。我想，创业的风险是相当大的，如果我们最后成功了，我们将摆脱基本的财务压力，追求更高的理想，但即使这个创业项目最终失败了，我相信我们的团队也能够凝聚起来，迎接下一份挑战。 题外话–招聘嗯，是的，这部分就是一个广告。我们希望有更多的产品、技术同事加入我们。 我们能提供的由于有风险投资，我们的创业一点也不苦逼。我们的工作地点远离码农离散地中关村和五道口，座落在高富帅云集的 CBD 朝外 SOHO，我最大的体会是即使是上下班高峰期，这里的 10 号线也常常也很宽松，不会象五道口那样使劲挤还挤不上去。我们的技术配 27 寸的 iMac（也可选择 21.5 的 iMac 加双显），我们有食品间提供免费的可乐、加多宝，茶叶，水果。我们也有每周一次的羽毛球俱乐部。中午吃完饭觉得困，我们有 4 个沙发加一个躺椅可供休息。 我们的公司才刚刚成立不到半年，产品上线后反馈很好，我们也不缺资金。这个时候加入我们，你可以得到不输于一线互联网公司的待遇，加上一个在回报上无限可能的期权。我们的初始技术团队都有过多年大公司的工作经验，所以在这里你可以学到大公司的好的一面（包括规范的 scrum 开发，code review，wiki, 代码规范和追求代码质量），又可以享受创业公司的灵活（几乎没有会议，高效地沟通）。 我们的要求由于我们整个团队有极强的代码洁癖和编码热情，我们也希望找到符合团队气质的人。我们不希望招那种把编程仅仅当做一份工作的人，因为我们认为，兴趣是最好的老师，对编程没有兴趣的人，是不可能把工作做到卓越的。 所以，如果你和我们一样，对编程这件事情上抱有热情的话，希望你能邮件联系我们的 Tech Leader 郭常圳: gcz(at)fenbi.com 。如果你能附上一段你放在 github 上的开源代码，会让我们更加充分了解你，当然如果没有也没关系。我们相信，社区代码是价值，商业代码也是价值。 我个人主要负责粉笔网 iPhone 端的开发，我非常希望能够找到一个 iOS 开发的同事能够相互交流和学习。我不期望你是一个 iOS 大牛，甚至你现在完全不会 iOS 开发也没关系，但是希望我们能够一起成长为 iOS 开发的专家。 另外，我们对于 Linux 系统管理都不太懂，特别希望能找到一个系统管理高手加入我们团队，我们乐意向你学习。同时，如果你对学习开发有兴趣，那就太好不过了，我们的目标是 DevOps。 我们也欢迎实习生申请加入，但要求每周至少全职实习 4 天。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"用脚本来简化iOS美术同学的工作","slug":"use-script-to-power-up-ui-work","date":"2012-08-26T12:34:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/08/26/use-script-to-power-up-ui-work/","permalink":"https://blog.devtang.com/2012/08/26/use-script-to-power-up-ui-work/","excerpt":"问题我们知道，在 iOS 开发中，为了使我们的 app 能够同时支持 iPhone 的 Retina 屏幕和普通屏幕，美术同学需要对 UI 设计稿中的每个元素进行 2 次切图。苹果要求对图片元素的命名分别为 name.png 和 &#x6e;&#x61;&#109;&#101;&#64;&#x32;&#x78;&#x2e;&#x70;&#110;&#x67;，带 @2x 的表示是 Retina 屏幕的贴图，不带 @2x 的同名文件为普通屏幕的贴图。 我在开发的时候发现很难要求美术同学按照开发的要求来对图片命名。她们通常对于切图的命名是例如 * 登录按钮大 .png* ，* 登录按钮小 .png*, * 登录按钮按下大 .png* * 登录按钮按下小 .png* 这样的形式。于是，对这些文件按照苹果的要求进行重命名就成了我这个码农的一个体力活。","text":"问题我们知道，在 iOS 开发中，为了使我们的 app 能够同时支持 iPhone 的 Retina 屏幕和普通屏幕，美术同学需要对 UI 设计稿中的每个元素进行 2 次切图。苹果要求对图片元素的命名分别为 name.png 和 &#x6e;&#x61;&#109;&#101;&#64;&#x32;&#x78;&#x2e;&#x70;&#110;&#x67;，带 @2x 的表示是 Retina 屏幕的贴图，不带 @2x 的同名文件为普通屏幕的贴图。 我在开发的时候发现很难要求美术同学按照开发的要求来对图片命名。她们通常对于切图的命名是例如 * 登录按钮大 .png* ，* 登录按钮小 .png*, * 登录按钮按下大 .png* * 登录按钮按下小 .png* 这样的形式。于是，对这些文件按照苹果的要求进行重命名就成了我这个码农的一个体力活。 解决方案有什么方法能减少开发和美术的体力活呢？想到因为 &#x6e;&#97;&#x6d;&#101;&#64;&#x32;&#x78;&#x2e;&#112;&#x6e;&#x67; 的图片是 name.png 图片的 2 整倍，所以，我们完全可以让美术只切 @2x 的大图，而我们使用脚本来生成小图。于是我写了下面这样的一个脚本，我只需要将所有的大图按照类似 &#x6e;&#97;&#x6d;&#x65;&#45;&#x31;&#x40;&#x32;&#x78;&#46;&#112;&#x6e;&#x67; , &#x6e;&#x61;&#109;&#x65;&#45;&#x32;&#x40;&#x32;&#120;&#46;&#112;&#x6e;&#103; 方式命名，然后脚本就会自动帮我生成对应的名为 name-1.png 和 name-2.png 的小图。 #! /bin/bash# File name : convertImage.sh# Author: Tang Qiao# # print usageusage() &#123; cat &lt;&lt; EOF Usage: convertImage.sh &lt;src directory&gt; &lt;dest directory&gt;EOF&#125;if [ $# -ne 2 ]; then usage exit 1fiSRC_DIR=$1DEST_DIR=$2# check src dirif [ ! -d $SRC_DIR ]; then echo &quot;src directory not exist: $SRC_DIR&quot; exit 1fi# check dest dirif [ ! -d $DEST_DIR ]; then mkdir -p $DEST_DIRfifor src_file in $SRC_DIR/*.* ; do echo &quot;process file name: $src_file&quot; # 获得去掉文件名的纯路径 src_path=`dirname $src_file` # 获得去掉路径的纯文件名 filename=`basename $src_file` # 获得文件名字 (不包括扩展名) name=`echo &quot;$filename&quot; | cut -d&#x27;.&#x27; -f1` # remove @2x in filename if there is name=`echo &quot;$name&quot; | cut -d&quot;@&quot; -f1` # 获得文件扩展名 extension=`echo &quot;$filename&quot; | cut -d&#x27;.&#x27; -f2` dest_file=&quot;$DEST_DIR/$&#123;name&#125;.$&#123;extension&#125;&quot; convert $src_file -resize 50% $dest_filedone 脚本使用方法：将以上代码另存为 convertImage.sh，然后用以下方式调用此脚本，即可将源文件夹中所有以 @2x 结尾的图片文件转成一半大小的、去掉 @2x 的小图片。 convertImage.sh 源文件夹 目标文件夹 使用以上脚本后，美术只用切一半的图了。因为给我的切图少了，所以我可以更加方便地找到对应的切图了。另外，我也减少了一半对切图进行重命名的工作。 Tipsimagemagick如果你运行以上脚本失败，请先用 brew 或 port 安装 imagemagick。imagemagick 是一个相当强大的图象处理库。 brew install imagemagick 检查图片在使用该脚本一段时间后，我发现美术同学给我的大图的长宽常常不是偶数，这样造成缩小的图就不是原图的整倍数了。为了方便我检查美术给我的图片是否宽高都是偶数，我写了如下检查的脚本，这样就可以检查图片的宽高是否符合要求了。 #! /bin/bash# File name : checkImageSize.sh# Author: Tang Qiao# usage() &#123; cat &lt;&lt;EOF Usage: checkImageSize.sh &lt;directory&gt;EOF&#125;if [ $# -ne 1 ]; then usage exit 1fiSRC_DIR=$1# check src dirif [ ! -d $SRC_DIR ]; then echo &quot;src directory not exist: $SRC_DIR&quot; exit 1fifor src_file in $SRC_DIR/*.png ; do echo &quot;process file name: $src_file&quot; width=`identify -format &quot;%[fx:w]&quot; $src_file` height=`identify -format &quot;%[fx:h]&quot; $src_file` # check width modValue=`awk -v a=$width &#x27;BEGIN&#123;printf &quot;%d&quot;, a % 2&#125;&#x27;` if [ &quot;$modValue&quot; == &quot;1&quot; ]; then echo &quot;[Error], the file $src_file width is $width&quot; fi # check height modValue=`awk -v a=$height &#x27;BEGIN&#123;printf &quot;%d&quot;, a % 2&#125;&#x27;` if [ &quot;$modValue&quot; == &quot;1&quot; ]; then echo &quot;[Error], the file $src_file height is $height&quot; fidone 问题我在使用以上方法时，发现由于 imagemagick 压缩比太高，生成的图片如果象素太小，它就会生成索引图片，而不知道何故，少量索引图片在 iPhone 3GS 上会显示出一条黑线在图片底部。对于这些图片，用 photoshop 将其模式改成 RGB 颜色即可。如下所示： 用脚本代替体力活是一件很 happy 的事情，因为你可以用省下来的时间多做一些有意思的事情了。 Have fun ! 后记在发表完这篇文章后，得到了很多反馈。 其中 李祎 同学提到了一个 iOS 独立开发者的解决思路：http://kevincao.com/2011/08/prepare-png-for-iphone-app/ ，我感觉该博客中提到的方法，或许更加适合美术同学，因为整个操作都是图形化的。所以附在这里，希望对大家有用。 另外，网易杭研院的 施强 同学推荐了一个用于缩图的软件:http://www.xnconvert.com/ ，据说也能很好的解决以上问题。一并在此推荐给大家作为参考。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"Objective-C的新特性","slug":"use-modern-objective-c","date":"2012-08-05T13:50:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/08/05/use-modern-objective-c/","permalink":"https://blog.devtang.com/2012/08/05/use-modern-objective-c/","excerpt":"苹果在今年的 WWDC2012 大会上介绍了大量 Objective-C 的新特性，能够帮助 iOS 程序员更加高效地编写代码。在不久前更新的 Xcode4.4 版本中，这些新特性已经可以使用了。让我们看看这些新特性有哪些：","text":"苹果在今年的 WWDC2012 大会上介绍了大量 Objective-C 的新特性，能够帮助 iOS 程序员更加高效地编写代码。在不久前更新的 Xcode4.4 版本中，这些新特性已经可以使用了。让我们看看这些新特性有哪些： Object Literals这个是我认为最赞的一个改进。Object Literals 允许你方便地定义数字、数组和字典对象。这个功能类似于 java5 提供的 auto boxing 功能。这虽然是一个语法糖，但我认为对提高写代码效率帮助很大。让我们先来看看以前定义数字、数组和字典对象的方法： NSNumber * number = [NSNumber numberWithInt:1];NSArray * array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, nil];NSDictionary * dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;, @&quot;key1&quot;, @&quot;value2&quot;, @&quot;key2&quot;, nil]; 是不是很恶心？现在以上代码可以简化成以下形式，注意到没有，不用再在参数的最后加恶心的 nil 了，字典的 key 和 value 也不再是倒着先写 value, 再写 key 了： NSNumber * number = @1;NSArray * array = @[@&quot;one&quot;, @&quot;two&quot;];NSDictionary * dict = @&#123;@&quot;key1&quot;:@&quot;value1&quot;, @&quot;key2&quot;:@&quot;value2&quot;&#125;; 更多的示例如下： // 整数NSNumber *fortyTwo = @42; // 等价于 [NSNumber numberWithInt:42]NSNumber *fortyTwoUnsigned = @42U; // 等价于 [NSNumber numberWithUnsignedInt:42U]NSNumber *fortyTwoLong = @42L; // 等价于 [NSNumber numberWithLong:42L]NSNumber *fortyTwoLongLong = @42LL; // 等价于 [NSNumber numberWithLongLong:42LL]// 浮点数NSNumber *piFloat = @3.141592654F; // 等价于 [NSNumber numberWithFloat:3.141592654F]NSNumber *piDouble = @3.1415926535; // 等价于 [NSNumber numberWithDouble:3.1415926535]// 布尔值NSNumber *yesNumber = @YES; // 等价于 [NSNumber numberWithBool:YES]NSNumber *noNumber = @NO; // 等价于 [NSNumber numberWithBool:NO]// 空数组NSArray * array = @[]; // 等价于 [NSArray array]// 空的字典NSDictionary * dict = @&#123;&#125;; // 等价于 [NSDictionary dictionary] 怎么样？是不是简单多了？而且，为了方便你的旧代码迁移到新的写法，xcode 专门还提供了转换工具，在 xcode4.4 中，选择 Edit -&gt; Refactor -&gt; Convert to Modern Objective-C Syntax 即可。如下所示： 局部的函数调用不用前向申明这虽然是一个挺小的改进，但是很贴心。假如我们在一个源文件中有 2 个函数：分别名为 foo 和 bar，其中 foo 的定义在 bar 前面。那如果在 foo 函数内部直接调用 bar，编译器会报警告说找不到函数 bar。 而现在，我们可以随意地在源文件中放置函数 bar 的位置。编译器在找不到 bar 时，会再源码后面找，如果找到了 bar，就不会报错了。 带有类型的 enum现在我们可以定义 enum 是无符号整数还是整数，这样编译器会更加智能的做类型检查。如下所示： typedef enum TableViewCellType : NSInteger &#123; TableViewCellTypeQueue, TableViewCellTypeNewFans, TableViewCellTypeUserInfo, TableViewCellTypeOrganization, TableViewCellTypeFeedback, TableViewCellTypeRateApp, TableViewCellTypeRecommendation, TableViewCellTypeLogout&#125;TableViewCellType; 默认生成 @synthesize 代码以前写完一个诸如 @property (nonatomic, strong) NSString * username; 变量定义后，马上得转到 .m 文件中去增加相应的 @synthesize username &#x3D; _username; 代码。 现在，编辑器发现你没有写 @synthesize 时，会自动帮你加上这一行。这同时在另一方面，起到了鼓励大家使用以下划线开头的变量名作为成员变量名的作用。 当然，为了向下兼容，如果你的程序里面已经有了 @property 变量对应的 @synthesize 代码时，编辑器就不会自动帮你增加这个代码了。 另外有 2 种特殊情况下，即使你没有写 @synthesize ，编辑器也不会自动帮你加上，这 2 种情况是： 你同时提供了该 property 的 setter 和 getter 方法。 你的这个 property 是 readonly 的，并且你提供了其 getter 方法。 遍历元素你是如何遍历数组的元素的？通常我们有 2 种做法，一种是用 for in，另一种是用一个变量来循环数组下标。如下： NSArray * lines = ...for (NSString * line in lines) &#123; // ...&#125;for (int i = 0; i &lt; lines.count; ++i) &#123; NSString * s = [lines objectAtIndex:i]; ...&#125; 如果是字典，遍历的代码就要稍微复杂一点了： NSDictionary * dict = …NSArray * keys = [dict allKeys];for (NSString * key in keys) &#123; NSString * value = [dict objectForKey:key]; &#125; 现在，xcode 对于 iOS4.0 以上的系统，支持用 block 来遍历元素了。用 block 来遍历字典可以简化代码的编写，建议大家都使用上这个新特性。 [lines enumerateObjectsUsingBlock:^(NSString * obj, NSUInteger idx, BOOL *stop) &#123; &#125;];[_urlArguments enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;&#125;]; Subscripting Methods这个新特性在 WWDC2012 的视频中提到了，但是在 Xcode4.4 中没有实现（在 Xcode4.5 中实现了）。也是一个很体贴的语法糖，它允许你用中括号来代替原本的方法来获取和设置数组元素。 简单来说，以前的 [array objectAtIndex:idx] 和 [array replaceObjectAtIndex:idx withObject:obj]，可以直接写作 array[idx] 和 array[idx] &#x3D; obj 了。其实这个特性在很多高级语言中都实现了，只是 Objective-C 生于 80 年代，一直没改进这个。 以下是一些示例代码： NSArray * array = @[ @&quot;111&quot;, @&quot;222&quot;, @&quot;333&quot;];for (int i = 0; i &lt; 3; ++i) &#123; NSLog(@&quot;array[i] = %@&quot;, array[i]);&#125;NSMutableDictionary * dict =[@&#123; @1: @&quot;value1&quot;, @2: @&quot;value2&quot;, @3: @&quot;value3&quot; &#125; mutableCopy];for (int i = 0; i &lt; 3; ++i) &#123; NSLog(@&quot;dict[%d] = %@&quot;, i, dict[@(i+1)]); dict[@(i+1)] = [NSString stringWithFormat:@&quot;new %@&quot;, dict[@(i+1)]];&#125;[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSLog(@&quot;dict[%@] = %@&quot;, key, dict[key]);&#125;]; 这个改进同样对 NSDictionary 有效。甚至，你也可以给你自己的类提供中括号操作符对应的方法。具体做法是实现如下两个方法： - (id)objectAtIndexedSubscript:(NSUInterger)idx;- (void)setObject:(id)value atIndexedSubscript:(NSUInteger)idx; Tips上面提到了不用写 @synthesize 了，那原本写的那么多 @synthesize 怎么办呢？作为有代码洁癖的我很想把它们删掉，但怎么删呢？一个文件一个文件打开，然后行一行删掉吗？放心，苹果已经帮我们想了解决方案。在 WWDC2012 Session 400 Developer Tools Kickoff 中，苹果介绍了具体做法。步骤如下： 首先使用区域查找，因为一般项目都会依赖第三方的开源库，我们可不想更改别人的库，所以我们只查找我们库中的文件，如下图所示： 接着我们用正则匹配，找到以 @synthesize 开头，后面接着是 var &#x3D; _var; 格式的行。插入正则表达式很简单，直接点击查找输入框左边的放大镜，选择 “insert pattern”，苹果就会把常见的正则表达式都列出来，你直接选择就可以了，非常方便。如下图所示： 在插入好合适的正则表达式后，我们按回车，就可以搜索到结果。 我们点击搜索界面的 preview 按钮，查看替换效果，可以看到，对于我们测试代码，Xcode 生成的预览图已经正确地当对应代码删掉了。然后我们就可以点击替换，去掉所有的 @synthesize 代码了。 在下载完 Xcode4.4 后，我就把我们的工程代码都转换成了新特性的语法。在转换后，我发现原本 25000 行的代码少了将近 1000 行。心里还是很开心的，因为又可以少写一些体力活类型的代码了。 还是那句话，希望这些新特性能够让大家玩得开心。 参考资料 LLVM 官方网站比较全面地介绍了 Object Literal： http://clang.llvm.org/docs/ObjectiveCLiterals.html WWDC2012 Session 400 Developer Tools Kickoff WWDC2012 Session 405 Modern Objective-C WWDC2012 Session 413 Migrating to Modern Objective-C","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"封装同步的UIActionSheet","slug":"enhance-uiactionsheet","date":"2012-06-24T13:51:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/06/24/enhance-uiactionsheet/","permalink":"https://blog.devtang.com/2012/06/24/enhance-uiactionsheet/","excerpt":"问题做 iOS 开发的同学想必都用过 UIActionSheet。UIActionSheet 可以弹出一个选择列表，让用户选择列表中的某一项操作。使用 UIActionSheet 非常简单，以下是一个简单的示例代码： - (void)someButtonClicked &#123; UIActionSheet * sheet = [[UIActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@&quot;ddd&quot; destructiveButtonTitle:@&quot;aaa&quot; otherButtonTitles:@&quot;bbb&quot;, @&quot;ccc&quot;, @&quot;ddd&quot;, nil]; sheet.destructiveButtonIndex = 1; [sheet showInView:self.view];&#125;- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex &#123; int result = buttonIndex; NSLog(@&quot;result = %d&quot;, result);&#125; 但我个人在使用时，感觉 UIActionSheet 有以下 2 个问题：","text":"问题做 iOS 开发的同学想必都用过 UIActionSheet。UIActionSheet 可以弹出一个选择列表，让用户选择列表中的某一项操作。使用 UIActionSheet 非常简单，以下是一个简单的示例代码： - (void)someButtonClicked &#123; UIActionSheet * sheet = [[UIActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@&quot;ddd&quot; destructiveButtonTitle:@&quot;aaa&quot; otherButtonTitles:@&quot;bbb&quot;, @&quot;ccc&quot;, @&quot;ddd&quot;, nil]; sheet.destructiveButtonIndex = 1; [sheet showInView:self.view];&#125;- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex &#123; int result = buttonIndex; NSLog(@&quot;result = %d&quot;, result);&#125; 但我个人在使用时，感觉 UIActionSheet 有以下 2 个问题： UIActionSheet 是一个异步的调用，需要设置 delegate 来获得用户选择的结果。这么小粒度的选择界面，把调用显示和回调方法分开写在 2 个方法中，使得原本简单的逻辑复杂了。虽然也不会复杂到哪儿去，但是每次调用 UIActionSheet 就需要另外写一个 delegate 回调方法，让我觉得这是一个过度的设计。如果 UIActionSheet 在弹出界面时，是一个同步调用，在调用完 showInView 方法后，就能获得用户的点击结果，那该多方便。 UIActionSheet 默认的 init 方法比较恶心。cancel Button 其实默认是在最底部的，但是在 init 方法中是放在第一个参数。destructive 默认是列表的第一个。如果你需要的界面不是将 destructive button 放在第一个，就需要再指定一次 destructiveButtonIndex，而这个 index 的下标，是忽略 cancel button 来数的，虽说也不是很麻烦，但是心里感觉比较恶心。 改造 UIActionSheet基于上面 2 个原因，我想把 UIActionSheet 改造成一个同步的调用。这样，在我调用它的 showInView 方法后，我希望它直接同步地返回用户的选择项，而不是通过一个 Delegate 方法来回调我。另外，我也不希望 init 方法有那么多麻烦的参数，我只希望 init 的时候，指定一个数组能够设置每个 button 的 title 就行了。 于是我写了一个 SynchronizedUIActionSheet 类，这个类将 UIActionSheet 简单封装了一下，利用 CFRunLoopRun 和 CFRunLoopStop 方法来将 UIActionSheet 改造成同步的调用。整个代码如下所示： SynchronizedUIActionSheet.h 文件： // SynchronizedUIActionSheet.h#import &lt;Foundation/Foundation.h&gt;@interface SynchronizedUIActionSheet : NSObject&lt;UIActionSheetDelegate&gt;@property (nonatomic, strong) NSArray * titles;@property (nonatomic, assign) NSInteger destructiveButtonIndex;@property (nonatomic, assign) NSInteger cancelButtonIndex;- (id)initWithTitles:(NSArray *)titles;- (NSInteger)showInView:(UIView *)view;@end SynchronizedUIActionSheet.m 文件： #import &quot;SynchronizedUIActionSheet.h&quot;@implementation SynchronizedUIActionSheet &#123; UIActionSheet * _actionSheet; NSInteger _selectedIndex;&#125;@synthesize titles = _titles;@synthesize destructiveButtonIndex = _destructiveButtonIndex;@synthesize cancelButtonIndex = _cancelButtonIndex;- (id)initWithTitles:(NSArray *)titles &#123; self = [super init]; if (self) &#123; _titles = titles; _destructiveButtonIndex = 0; _cancelButtonIndex = titles.count - 1; &#125; return self;&#125;- (void)setTitles:(NSArray *)titles &#123; _titles = titles; _cancelButtonIndex = titles.count - 1; &#125;- (NSInteger)showInView:(UIView *)view &#123; _actionSheet = [[UIActionSheet alloc] init]; for (NSString * title in _titles) &#123; [_actionSheet addButtonWithTitle:title]; &#125; if (_destructiveButtonIndex != -1) &#123; _actionSheet.destructiveButtonIndex = _destructiveButtonIndex; &#125; if (_cancelButtonIndex != -1) &#123; _actionSheet.cancelButtonIndex = _cancelButtonIndex; &#125; [_actionSheet showInView:view]; CFRunLoopRun(); return _selectedIndex;&#125;- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex &#123; _selectedIndex = buttonIndex; _actionSheet = nil; CFRunLoopStop(CFRunLoopGetCurrent());&#125;@end 在改造后，调用 ActionSheet 的示例代码如下，是不是感觉逻辑清爽了一些？ - (IBAction)testButtonPressed:(id)sender &#123; SynchronizedUIActionSheet * synActionSheet = [[SynchronizedUIActionSheet alloc] init]; synActionSheet.titles = [NSArray arrayWithObjects:@&quot;aaa&quot;, @&quot;bbb&quot;, @&quot;ccc&quot;, @&quot;ddd&quot;, nil]; synActionSheet.destructiveButtonIndex = 1; NSUInteger result = [synActionSheet showInView:self.view]; NSLog(@&quot;result = %d&quot;, result);&#125; 总结利用 NSRunLoop 来将原本的异步方法改成同步，可以使我们在某些情形下，方便地将异步方法变成同步方法来执行。 例如以前我们在做有道云笔记 iPad 版的时候，采用的图片多选控件需要用户允许我们获得地理位置信息，如果用户没有选择允许，那个这个图片多选控件就会执行失败。为了不让这个控件挂掉，我们想在用户禁止访问地理位置时，不使用该控件，而使用系统自带的图片单选的 UIImagePickerController 控件来选择图片。对于这个需求，我们明显就希望将获得地理位置信息这个系统确认框做成同步的，使得我们可以根据用户的选择再决定用哪种图片选择方式。最终，我们也用类似上面的方法，用 NSRunLoop 来使我们的异步方法调用暂停在某一行，直到获得用户的反馈后，再往下执行，示例代码如下： - (id)someCheck &#123; BOOL isOver = NO; // do the async check method, after the method return, set isOver to YES while (!isOver) &#123; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125; return value;&#125; 以上 Demo 代码我放到 github 上了 , 地址是 这里，请随意取用。祝端午节快乐。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"在iOS开发中使用FMDB","slug":"use-fmdb","date":"2012-04-22T06:11:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/04/22/use-fmdb/","permalink":"https://blog.devtang.com/2012/04/22/use-fmdb/","excerpt":"前言SQLite (http://www.sqlite.org/docs.html) 是一个轻量级的关系数据库。iOS SDK 很早就支持了 SQLite，在使用时，只需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。但是，原生的 SQLite API 在使用上相当不友好，在使用时，非常不便。于是，开源社区中就出现了一系列将 SQLite API 进行封装的库，而 FMDB (https://github.com/ccgus/fmdb) 则是开源社区中的优秀者。","text":"前言SQLite (http://www.sqlite.org/docs.html) 是一个轻量级的关系数据库。iOS SDK 很早就支持了 SQLite，在使用时，只需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。但是，原生的 SQLite API 在使用上相当不友好，在使用时，非常不便。于是，开源社区中就出现了一系列将 SQLite API 进行封装的库，而 FMDB (https://github.com/ccgus/fmdb) 则是开源社区中的优秀者。 FMDB 在使用上相当方便。以下是一个简单的例子： NSString* docsdir = [NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSString* dbpath = [docsdir stringByAppendingPathComponent:@&quot;user.sqlite&quot;]; FMDatabase* db = [FMDatabase databaseWithPath:dbpath];[db open];FMResultSet *rs = [db executeQuery:@&quot;select * from people&quot;];while ([rs next]) &#123; NSLog(@&quot;%@ %@&quot;, [rs stringForColumn:@&quot;firstname&quot;], [rs stringForColumn:@&quot;lastname&quot;]);&#125;[db close]; 可以看到，使用 FMDB 后的数据库代码清晰明了，比原生的 API 优雅多了。另外，FMDB 同时兼容 ARC 和非 ARC 工程，会自动根据工程配置来调整相关的内存管理代码。 使用说明该使用说明主要翻译自 fmdb 的 github 项目说明文档: https://github.com/ccgus/fmdb 引入相关文件首先将 FMDB 从 github 上 clone 下来，然后将以下文件 copy 到你的工程中： FMDatabase.hFMDatabase.mFMDatabaseAdditions.hFMDatabaseAdditions.mFMDatabasePool.hFMDatabasePool.mFMDatabaseQueue.hFMDatabaseQueue.mFMResultSet.hFMResultSet.m 建立数据库建立数据库只需要如下一行即可 , 当该文件不存在时，fmdb 会自己创建一个。如果你传入的参数是空串：@”” ，则 fmdb 会在临时文件目录下创建这个数据库，如果你传入的参数是 NULL，则它会建立一个在内存中的数据库。 FMDatabase *db = [FMDatabase databaseWithPath:@&quot;/tmp/tmp.db&quot;]; 打开数据库使用如下语句，如果打开失败，可能是权限不足或者资源不足。通常打开完操作操作后，需要调用 close 方法来关闭数据库。 if (![db open]) &#123; // error return;&#125;// some operation// ...[db close]; 执行更新操作除了 Select 操作之外，其它的都是更新操作。更新操作使用如下方法，如果有错误，可以用 error 参数中获得。 -[FMDatabase executeUpdate:error:withArgumentsInArray:orVAList:] 执行查询操作查询操作示例如下。注意：即使操作结果只有一行，也需要先调用 FMResultSet 的 next 方法。 FMResultSet *s = [db executeQuery:@&quot;SELECT * FROM myTable&quot;];while ([s next]) &#123; //retrieve values for each record&#125;FMResultSet *s = [db executeQuery:@&quot;SELECT COUNT(*) FROM myTable&quot;];if ([s next]) &#123; int totalCount = [s intForColumnIndex:0];&#125; FMDB 提供如下多个方法来获取不同类型的数据： intForColumn:longForColumn:longLongIntForColumn:boolForColumn:doubleForColumn:stringForColumn:dateForColumn:dataForColumn:dataNoCopyForColumn:UTF8StringForColumnIndex:objectForColumn: 通常情况下，你并不需要关闭 FMResultSet，因为相关的数据库关闭时，FMResultSet 也会被自动关闭。 数据参数通常情况下，你可以按照标准的 SQL 语句，用 ? 表示执行语句的参数，如： INSERT INTO myTable VALUES (?, ?, ?) 然后，可以我们可以调用 executeUpdate 方法来将 ? 所指代的具体参数传入，通常是用变长参数来传递进去的，如下： NSString *sql = @&quot;insert into User (name, password) values (?, ?)&quot;;[db executeUpdate:sql, user.name, user.password]; 这里需要注意的是，参数必须是 NSObject 的子类，所以象 int,double,bool 这种基本类型，需要封装成对应的包装类才行，如下所示： // 错误，42 不能作为参数[db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, 42];// 正确，将 42 封装成 NSNumber 类[db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:42]]; 线程安全如果我们的 app 需要多线程操作数据库，那么就需要使用 FMDatabaseQueue 来保证线程安全了。切记不能在多个线程中共同一个 FMDatabase 对象并且在多个线程中同时使用，这个类本身不是线程安全的，这样使用会造成数据混乱等问题。 使用 FMDatabaseQueue 很简单，首先用一个数据库文件地址来初使化 FMDatabaseQueue，然后就可以将一个闭包 (block) 传入 inDatabase 方法中。在闭包中操作数据库，而不直接参与 FMDatabase 的管理。 // 创建，最好放在一个单例的类中FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];// 使用[queue inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;]; while ([rs next]) &#123; // … &#125;&#125;];// 如果要支持事务[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; if (whoopsSomethingWrongHappened) &#123; *rollback = YES; return; &#125; // etc… [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:4]];&#125;]; 工具为了查看 Sqlite 中的数据，一个好的图形化界面的数据库管理程序是必不可少的。mysql 有 phpMyAdmin，那么 sqlite 呢？ 我主要使用的是 Firefox 的一个名为 SQLite Manager 的插件，安装此插件后，可以直接打开后缀名为 sqlite 的数据库文件。SQLite Manager 提供一个图形化的界面来执行数据查询或更改操作。如下图所示： 总结FMDB 将 SQLite API 进行了很友好的封装，使用上非常方便，对于那些使用纯 Sqlite API 来进行数据库操作的 app，可以考虑将其迁移到基于 FMDB 上，这对于以后数据库相关功能的开发维护，可以提高不少效率。 我在学习 fmdb 的时候做了一个小工程用于练习，我把它放到 github 上了。感兴趣的可以自行下载：https://github.com/tangqiaoboy/FmdbSample 祝大家玩得开心。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"关于UIWebView的总结","slug":"talk-about-uiwebview-and-phonegap","date":"2012-03-24T12:19:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/03/24/talk-about-uiwebview-and-phonegap/","permalink":"https://blog.devtang.com/2012/03/24/talk-about-uiwebview-and-phonegap/","excerpt":"前言今天参加了 Adobe 和 CSDN 组织的一个关于 PhoneGap 的开发讲座 ，而 PhoneGap 在 iOS 设备上的实现就是通过 UIWebView 控件来展示 html 内容，并且与 native 代码进行交互的。 正好我们在做有道云笔记的 iPad 版，因为我们也是使用 UIWebView 来展示笔记内容，所以也需要做 js 与 native 代码相互调用的事情。所以在这儿顺便总结一下 UIWebView 在使用上的细节，以及谈谈我对 PhoneGap 的看法。","text":"前言今天参加了 Adobe 和 CSDN 组织的一个关于 PhoneGap 的开发讲座 ，而 PhoneGap 在 iOS 设备上的实现就是通过 UIWebView 控件来展示 html 内容，并且与 native 代码进行交互的。 正好我们在做有道云笔记的 iPad 版，因为我们也是使用 UIWebView 来展示笔记内容，所以也需要做 js 与 native 代码相互调用的事情。所以在这儿顺便总结一下 UIWebView 在使用上的细节，以及谈谈我对 PhoneGap 的看法。 机制首先我们需要让 UIWebView 加载本地 HTML。使用如下代码完成： NSString * path = [[NSBundle mainBundle] bundlePath];NSURL * baseURL = [NSURL fileURLWithPath:path];NSString * htmlFile = [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot;];NSString * htmlString = [NSString stringWithContentsOfFile:htmlFile encoding:(NSUTF8StringEncoding) error:nil];[self.webView loadHTMLString:htmlString baseURL:baseURL]; 接着，我们需要让 js 能够调用 native 端。iOS SDK 并没有原生提供 js 调用 native 代码的 API。但是 UIWebView 的一个 delegate 方法使我们可以做到让 js 需要调用时，通知 native。在 native 执行完相应调用后，可以用 stringByEvaluatingJavaScriptFromString 方法，将执行结果返回给 js。这样，就实现了 js 与 native 代码的相互调用。 以下是 PhoneGap 相关调用的示例代码： // Objective-C 语言- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; NSURL * url = [request URL]; if ([[url scheme] isEqualToString:@&quot;gap&quot;]) &#123; // 在这里做 js 调 native 的事情 // .... // 做完之后用如下方法调回 js [webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&#x27;done&#x27;)&quot;]; return NO; &#125; return YES;&#125; 具体让 js 通知 native 的方法是让 js 发起一次特殊的网络请求。这里，我们和 PhoneGap 都是使用加载一个隐藏的 iframe 来实现的，通过将 iframe 的 src 指定为一个特殊的 URL，实现在 delegate 方法中截获这次请求。 以下是 PhoneGap 相关调用的示例代码： // Javascript 语言// 通知 iPhone UIWebView 加载 url 对应的资源// url 的格式为: gap:somethingfunction loadURL(url) &#123; var iFrame; iFrame = document.createElement(&quot;iframe&quot;); iFrame.setAttribute(&quot;src&quot;, url); iFrame.setAttribute(&quot;style&quot;, &quot;display:none;&quot;); iFrame.setAttribute(&quot;height&quot;, &quot;0px&quot;); iFrame.setAttribute(&quot;width&quot;, &quot;0px&quot;); iFrame.setAttribute(&quot;frameborder&quot;, &quot;0&quot;); document.body.appendChild(iFrame); // 发起请求后这个 iFrame 就没用了，所以把它从 dom 上移除掉 iFrame.parentNode.removeChild(iFrame); iFrame = null;&#125; 在这里，可能有些人说，通过改 document.location 也可以达到相同的效果。关于这个，我和 zyc 专门试过，一般情况下，改 document.location 是可以，但是改 document.location 有一个很严重的问题，就是如果我们连续 2 个 js 调 native，连续 2 次改 document.location 的话，在 native 的 delegate 方法中，只能截获后面那次请求，前一次请求由于很快被替换掉，所以被忽略掉了。 我也专门去 Github 上查找相关的开源代码，它们都是用过 iframe 来实现调用的，例如这个：https://github.com/marcuswestin/WebViewJavascriptBridge 关于这个，我也做了一个 Demo 来简单示例，地址如下：https://github.com/tangqiaoboy/UIWebViewSample 参数的传递以上的示例代码为了讲清楚机制，所以只是示例了最简单的相互调用。但实际上 js 和 native 相互调用时，常常需要传递参数。 例如，有道云笔记 iPad 版用 UIWebView 显示笔记的内容，当用户点击了笔记中的附件，这个时候，js 需要通知 native 到后台下载这个笔记附件，同时通知 js 当前的下载进度。对于这个需求，js 层获得用户点击事件后，就需要把当前点击的附件的 ID 传递给 native，这样 native 才能知道下载哪个附件。 参数传递最简单的方式是将参数作为 url 的一部分，放到 iFrame 的 src 里面。这样 UIWebView 通过截取分析 url 后面的内容即可获得参数。但是这样的问题是，该方法只能传递简单的参数信息，如果参数是一个很复杂的对象，那么这个 url 的编解码将会很复杂。对此，我们的有道云笔记和 PhoneGap 采用了不同的技术方案。 我们的技术方案是将参数以 JSON 的形式传递，但是因为要附加在 url 之后，所以我们将 JSON 进行了 Base64 编码，以保证 url 中不会出现一些非法的字符。 PhoneGap 的技术方案是，也是用 JSON 传递参数，但是将 JSON 放在 UIWebView 中的一个全局数组中，UIWebView 当需要读取参数时，通过读取这个全局数组来获得相应的参数。 相比之下，应该说 PhoneGap 的方案更加全面，适用于多种场景。而我们的方案简洁高效，满足了我们自己产品的需求。 同步和异步因为 iOS SDK 没有天生支持 js 和 native 相互调用，大家的技术方案都是自己实现的一套调用机制，所以这里面有同步异步的问题。细心的同学就能发现，js 调用 native 是通过插入一个 iframe，这个 iframe 插入完了就完了，执行的结果需要 native 另外用 stringByEvaluatingJavaScriptFromString 方法通知 js，所以这是一个异步的调用。 而 stringByEvaluatingJavaScriptFromString 方法本身会直接返回一个 NSString 类型的执行结果，所以这显然是一个同步调用。 所以 js call native 是异步，native call js 是同步。在处理一些逻辑的时候，不可避免需要考虑这个特点。 这里顺便说一个 android，其实在 android 开发中，js 调 native 是同步的，但是 PhoneGap 为了将自己做成一个跨平台的框架，所以在 android 的 js call native 的 native 端，用 new Thread 新建了一个执行线程，这样把 android 的 js call native 也变成了异步调用。 UIWebView 的问题线程阻塞问题我们在开发中发现，当在 native 层调用 stringByEvaluatingJavaScriptFromString 方法时，可能由于 javascript 是单线程的原因，会阻塞原有 js 代码的执行。这里我们的解决办法是在 js 端用 defer 将 iframe 的插入延后执行。 主线程的问题UIWebView 的 stringByEvaluatingJavaScriptFromString 方法必须是主线程中执行，而主线程的执行时间过长就会 block UI 的更新。所以我们应该尽量让 stringByEvaluatingJavaScriptFromString 方法执行的时间短。 有道云笔记在保存的时候，需要调用 js 获得笔记的完整 html 内容，这个时候如果笔记内容很复杂，就会执行很长一段时间，而因为这个操作必须是主线程执行，所以我们显示 “正在保存” 的 UIAlertView 完全无法正常显示，整个 UI 界面完全卡住了。在新的编辑器里，我们更新了获得 html 内容的代码，才将这个问题解决。 键盘控制做 iOS 开发的都知道，当我们需要键盘显示在某个控件上时，可以调用 [obj becomeFirstResponder] 方法来让键盘出来，并且光标输入焦点出现在该控件上。 但是这个方法对于 UIWebView 并不可用。也就是说，我们无法通过程序控制让光标输入焦点出现在 UIWebView 上。关于这个问题，我在 stackoverflow 上专门 问了一下，还是没有得到很好的解决办法。 CommonJS 规范commonJS 是一个模块块加载的规范。而 AMD 是该规范的一个草案，CommonJS AMD 规范描述了模块化的定义，依赖关系，引用关系以及加载机制，其规范原文在 这里 。它被 requireJS，NodeJs，Dojo，jQuery 等开源框架广泛使用。这里 还有一篇不错的中文介绍文章。 AMD 规范需要用目录层级当作包层次，这一点就象 java 一样。之前我以为 iOS 打包后的 ipa 资源文件中不能有资源目录层级关系，今天在会上问了一下，原来是我自己弄错了。如果需要将目录层级带入 ipa 资源文件中，只需要将该目录拖入工程中，然后选择 “Create groups for any added folders”。如下图所示，这样目录层级能够打包到 ipa 文件中。 调试在 iOS 设备中调试 javascript 是一件相当苦逼的事情，拿 pw 的话来说：“一下子回到了 ie6 时代”。当然，业界也有一些调试工具可以用的。 我们在开发时主要采用的是 weinre 这个框架。用这个框架，可以做一些基本的调试工作，但是它现在功能还没有象 pc 上的 js 调试器那么强大，例如它不能下断点，另外如果有 js 执行错误，它也无法正确的将错误信息报出。它还有一些 bug，例如在 mac 机下，如果你同时连接了有线网和无线网，那么 weinre 将无法正确地连接到调试页面。 但终究，它是现在业界现存的唯一相对可用的调试工具了。本次的 PhoneGap 讲座的第一位演讲者董龙飞有一篇博客很好地介绍了 weinre 的使用，地址是 这里，推荐感兴趣的同学看看。即使不用 PhoneGap，weinre 也能给你在移动设备上设计网页带来方便。 （2013 年 10 月 22 日更新）：关于调试这一块儿，从 WWDC2012 开始，苹果已经支持用 safari 来连接 iPhone 模拟器里面的 UIWebView 进行调试了，所以调试上已经方便了很多。详细的教程可以查看: WWDC2012 Session 600《Debuging UIWebViews and Websites on iOS》 我对 PhoneGap 的看法今天的大会上，2 位演讲者把 PhoneGap 吹得相当牛。但是其实真正用过的人才能知道，PhoneGap 还是有相当多的问题的。至少我知道在网易就有一个使用 PhoneGap 而失败的项目，所以我认为 PhoneGap 还是有它相当大的局限性的。 我认为 PhoneGap 有以下 3 大问题： 首先，PhoneGap 的编程语言其实是 javascript，这对于非前端工作者来说，其实学习起来和学习原生的 objective-C 或 Java 编程语言难度差不多，而且由于历史原因，javascript 语言本身的问题比其它语言都多。要想精通 javascript，相当不易。 然后，PhoneGap 的目标是方便地创建跨平台的应用。但是其实苹果和 google 都发布了自己的人机交互指南。有些情况下，苹果的程序和 android 程序有着不同的交互原则的。象有道云笔记的 iPhone 版 和 android 版，就有着完全不同的界面和交互。使用 PhoneGap 就意味着你的程序在 UI 和交互上，既不象原生的 iphone 程序，又不象原生的 android 程序。 最后，性能问题。Javascript 终究无法和原生的程序比运行效率，这一点在当你要做一些动画效果的时候，就能显现得很明显。 当然，PhoneGap 的优势也很明显，如果你是做图书类，查询类，小工具类应用的话，这些应用 UI 交互不复杂，也不占用很高的 cpu 资源，PhoneGap 将很好地发挥出它的优势。对于这类应用： 你只需要编写一次，则可以同时完成 iOS, android, windows phone 等版本的开发。 如果改动不大，只是内容升级，那它升级时只需要更新相应的 js 文件，而不需要提交审核，而一般正常提交苹果的 app store 审核的话，常常需要一周时间。 所以 PhoneGap 不是万能的，但也不是没有用，它有它擅长的领域，一切都看你是否合理地使用它。 最后，推荐 PhoneGap 中国网站 ，在这里，你可以找到为数不多的中文资料。 对 js 的感想现在前端工程师相当牛逼啊。前端工程师不但可以写前端网页，还可以用 Flex 写桌面端程序，可以用 nodejs 写 server 端程序，可以用 PhoneGap 写移动端程序，这一切，都是基于 javascript 语言的，还有最新出的 windows 8，原生支持用 js 来写 Metro 程序，世界已经无法阻止前端工程师了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"Xcode4 使用技巧","slug":"xcode4-tips","date":"2012-03-10T12:42:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/03/10/xcode4-tips/","permalink":"https://blog.devtang.com/2012/03/10/xcode4-tips/","excerpt":"使用 xcode4 也有一段时间了，今天整理了一下 xcode4 的一些使用技巧，在这里分享给大家。","text":"使用 xcode4 也有一段时间了，今天整理了一下 xcode4 的一些使用技巧，在这里分享给大家。 设置作者这里所指的作者就是每个源文件头部注释中的 “Created by xxx” 中的作者名。我很长一段时间不知道应该在哪里设置它。后来终于找到了。 原来这个作者名是来自 地址薄 这个程序中 我 的姓名。在 sportlight 中输入” 地 “即可找到这个程序。如下图所示： 设置公司（组织）这里所指的公司也是指源文件头部注释中的”Copyright (c) xxx” 中的公司名字。这个相对好找一些。点击工程，在右边的工具栏中就可以找到 “Organization” 这一项。 模拟器iOS 模拟器也算是 xcode 的一部分。在刚开始使用时，不知道如何把照片导入到模拟器中。后来在网上搜到了方法：将照片拖到 iOS 模拟器中，iOS 模拟器会用 safari 打开该图片，然后在 safari 中长按该图，就会弹出菜单，选择 “保存到相册” 即可。 另外，模拟器也有一些快捷键，我常用的是 cmd + 左 &#x2F; 右 来调整 Orientation。另外，如果是 iPad 模拟器，可以按 cmd + 1 使其变成 100% 的大小。还有 cmd + s 可以将模拟器截图。 获得模拟器中的程序数据其实模拟器中的程序存储在：/yourHome/Library/Application Support/iPhone Simulator/5.0/Applications 目录下，你可以直接进去找。 另外，如果要删除所安装的程序，也可以直接将 Applications 目录下的文件夹删掉，这比在模拟器中删更方便。 安装旧版本的模拟器在 xcode 中，只会带最新版的模拟器，虽然有些模拟器可以在设置里面下载，但是更老的版本就无法在 xcode 的设置页下载了。 这个问题的解决办法是把以前的 xcode 和对应的模拟器装上，然后将模拟器复制或链接到最新的 xcode 目录下，代码如下： cd /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKssudo ln -s /Developer-3.2.5/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.0.sdk .sudo ln -s /Developer-3.2.5/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.1.sdk . 以前的 xcode 可以从 以下地址 下载到 (需要开发者账号), 建议大家每次安装新 xcode 的时候，把模拟器都备份一下，安装完再恢复回来，这样就不用这么每次折腾了。 BehaviorsBehaviors 是设置页面里的一栏，通过 cmd + 逗号可以调出设置页面看到。在 Behaviors 里可以设置各种行为发生时，界面应该做何改变。 例如，如果我们要每次运行结束后，就关闭 Console 界面，可以在 Behaviors 下面的 “Run completes” 一栏的右边，选中 “Hide debugger” 一项即可（如下图红色标识所示)。 另外，我们也可以点击左下角的 “+” 来增加一些自定义的行为，例如我就增加了 2 个行为，分别用于把导航栏和工具栏同时隐藏和显示（如下图蓝色标识所示）。Behavior 的扩展性很强，你甚至可以定义执行一些脚本，所以可以做的事情很多。 快捷键如果能慢慢熟悉一些快捷键，对于提高工作效率是有很大帮助的。虽然设置页面有所有的快键键列表，但是估计没人能全部记住并且用上，我个人总结出来常用的快键键如下： cmd + 1 切换成 Project Navigator (cmd + 2~7 也可以做相应切换，不过不常用）cmd + ctrl + 上 在 .h 和 .m 文件之间切换cmd + enter 切换成 standard editorcmd + opt + enter 切换成 assistant editorcmd + shift + y 切换 Console View 的显示或隐藏cmd + 0 隐藏左边的导航 (Navigator) 区cmd + opt + 0 隐藏右边的工具 (Utility) 区ctrl + 6 列出当前文件中所有的方法，可以输入关键词来过滤。这个相当赞，可以快速定位到想编辑的方法。 我直接把这个快键盘改成了 ctrl+o，这样按起来更顺手。cmd + ctrl + 左 / 右 到上 / 下一次编辑的位置，在 2 个编辑位置跳转的时候很方便。cmd + opt + j 跳转到文件过滤区cmd + shift + f 在工程中查找cmd + r 运行，如果选上直接 kill 掉上次进程的话，每次直接一按就可以重新运行了cmd + b 编译工程cmd + shift + k 清空编译好的文件cmd + . 结束本次调试ESC 调出代码补全cmd + 单击 查看该方法的实现opt + 单击 查看该方法的文档cmd + t 新建一个 tab 栏cmd + shift + [ 在 tab 栏之间切换 Snippets代码片段 (Snippets) 是 xcode4 新增的功能。用于管理一些常用的代码段，在需要时通过代码补全自动生成出来，可以提高工作效率。 关于这个，可以参见我的另一篇文章：&lt;&#x2F;2012&#x2F;02&#x2F;04&#x2F;use-git-to-manage-code-snippets&#x2F;&gt; 下载 xcode从 Xcode4.3 开始，苹果将 Xcode 的下载放到了 Lion 的 mac app store 中。郁闷的是，中国区连接 app store 下载的速度相当慢，在试了一些方法（例如设置 hosts, 设置 dns）之后，我发现最好的办法如下： 用开发者账号登陆：https://developer.apple.com/downloads/index.action，然后点击下载获得下载地址，然后将地址复制到 mac 版迅雷中，用迅雷下载，速度可以达到 200K 左右。 希望这些技巧能提高你的工作效率，祝玩得开心:)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"用Git进行协同开发","slug":"collaboration-with-git","date":"2012-02-29T11:08:00.000Z","updated":"2024-01-06T14:52:37.912Z","comments":true,"path":"2012/02/29/collaboration-with-git/","permalink":"https://blog.devtang.com/2012/02/29/collaboration-with-git/","excerpt":"问题场景描述常常会遇到这样的协同场景：后台的同事和前端的同事需要共同开发一个新功能，而他们的代码相互依赖，所以需要不停地更新各自的代码进行联调。 对于这种场景，最简单的方式就是，这 2 个同事坐到一起，然后把 svn 当作一个共享代码的中转站来共享开发中的代码。 在这种方式下，大家各自写自己的代码，提交到 svn 上，然后用 svn up 获得对方的代码。在调试问题的时候，大家可能不停地更新代码，然后让对方用 svn up 来更新。最终，虽然开发能够顺利进行，但是 svn 上会积累大量调试中的代码历史。所以，这样把 svn 当作代码中转站是一个很山寨的行为。 在开发 有道云笔记 新的 iPad 版 时，我和前端同事 zyc 尝试用 git 进行了协同开发。在这里把具体方案分享给大家，欢迎大家讨论。","text":"问题场景描述常常会遇到这样的协同场景：后台的同事和前端的同事需要共同开发一个新功能，而他们的代码相互依赖，所以需要不停地更新各自的代码进行联调。 对于这种场景，最简单的方式就是，这 2 个同事坐到一起，然后把 svn 当作一个共享代码的中转站来共享开发中的代码。 在这种方式下，大家各自写自己的代码，提交到 svn 上，然后用 svn up 获得对方的代码。在调试问题的时候，大家可能不停地更新代码，然后让对方用 svn up 来更新。最终，虽然开发能够顺利进行，但是 svn 上会积累大量调试中的代码历史。所以，这样把 svn 当作代码中转站是一个很山寨的行为。 在开发 有道云笔记 新的 iPad 版 时，我和前端同事 zyc 尝试用 git 进行了协同开发。在这里把具体方案分享给大家，欢迎大家讨论。 Git 相关协议介绍Git 对于你本机的代码\u001b项目，允许用很方便的方式进行非授权的只读访问 ,相关介绍链接。简单来说，就是可以用 Git 自带的 Git daemon 命令在本机的 9418 端口启动一个守护进程，然后其它机器就可以以只读方式访问你开放出来的项目代码。 具体步骤如下： 在你的 Git 工程下新建一个名为 git-daemon-export-ok 的文件放到 .git 目录下，表明该工程允许非授权访问。示例代码如下： cd /path/to/project.gittouch git-daemon-export-ok 执行 git daemon 命令，设置你要 Export 出的项目目录的父目录，例如工程的代码地址是：&#x2F;opt&#x2F;git&#x2F;project 的话，则示例代码如下： git daemon --reuseaddr --base-path=/opt/git/ /opt/git/ 告知对方你的机器的 IP，然后在对方的机器，用下列命令即可检出你的代码： git checkout git://your_ip_address/project 如果对方有更新，只需要 git pull 一下。 协作对于这种基于 Git 的协作，我们可以在本地随意的提交代码，让对方用 git pull 更新。当开发完成，需要 push 到公共仓库的时候，再用 git rebase -i 将本地的提交进行清理即可。并且由于大家都是在机器间互拷，不依赖 svn 公共服务器，更新代码的速度也要快得多。","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"}]},{"title":"使用GCD","slug":"use-gcd","date":"2012-02-22T12:44:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/22/use-gcd/","permalink":"https://blog.devtang.com/2012/02/22/use-gcd/","excerpt":"什么是 GCDGrand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如 NSThread, NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。 GCD 和 block 的配合使用，可以方便地进行多线程编程。","text":"什么是 GCDGrand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如 NSThread, NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。 GCD 和 block 的配合使用，可以方便地进行多线程编程。 应用举例让我们来看一个编程场景。我们要在 iPhone 上做一个下载网页的功能，该功能非常简单，就是在 iPhone 上放置一个按钮，点击该按钮时，显示一个转动的圆圈，表示正在进行下载，下载完成之后，将内容加载到界面上的一个文本控件中。 不用 GCD 前虽然功能简单，但是我们必须把下载过程放到后台线程中，否则会阻塞 UI 线程显示。所以，如果不用 GCD, 我们需要写如下 3 个方法： someClick 方法是点击按钮后的代码，可以看到我们用 NSInvocationOperation 建了一个后台线程，并且放到 NSOperationQueue 中。后台线程执行 download 方法。 download 方法处理下载网页的逻辑。下载完成后用 performSelectorOnMainThread 执行 download_completed 方法。 download_completed 进行 clear up 的工作，并把下载的内容显示到文本控件中。 这 3 个方法的代码如下。可以看到，虽然 开始下载 -&gt; 下载中 -&gt; 下载完成 这 3 个步骤是整个功能的三步。但是它们却被切分成了 3 块。他们之间因为是 3 个方法，所以还需要传递数据参数。如果是复杂的应用，数据参数很可能就不象本例子中的 NSString 那么简单了，另外，下载可能放到 Model 的类中来做，而界面的控制放到 View Controller 层来做，这使得本来就分开的代码变得更加散落。代码的可读性大大降低。 static NSOperationQueue * queue;- (IBAction)someClick:(id)sender &#123; self.indicator.hidden = NO; [self.indicator startAnimating]; queue = [[NSOperationQueue alloc] init]; NSInvocationOperation * op = [[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download) object:nil] autorelease]; [queue addOperation:op];&#125;- (void)download &#123; NSURL * url = [NSURL URLWithString:@&quot;http://www.youdao.com&quot;]; NSError * error; NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if (data != nil) &#123; [self performSelectorOnMainThread:@selector(download_completed:) withObject:data waitUntilDone:NO]; &#125; else &#123; NSLog(@&quot;error when download:%@&quot;, error); [queue release]; &#125;&#125;- (void) download_completed:(NSString *) data &#123; NSLog(@&quot;call back&quot;); [self.indicator stopAnimating]; self.indicator.hidden = YES; self.content.text = data; [queue release];&#125; 使用 GCD 后如果使用 GCD，以上 3 个方法都可以放到一起，如下所示： // 原代码块一self.indicator.hidden = NO;[self.indicator startAnimating];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 原代码块二 NSURL * url = [NSURL URLWithString:@&quot;http://www.youdao.com&quot;]; NSError * error; NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if (data != nil) &#123; // 原代码块三 dispatch_async(dispatch_get_main_queue(), ^&#123; [self.indicator stopAnimating]; self.indicator.hidden = YES; self.content.text = data; &#125;); &#125; else &#123; NSLog(@&quot;error when download:%@&quot;, error); &#125;&#125;); 首先我们可以看到，代码变短了。因为少了原来 3 个方法的定义，也少了相互之间需要传递的变量的封装。 另外，代码变清楚了，虽然是异步的代码，但是它们被 GCD 合理的整合在一起，逻辑非常清晰。如果应用上 MVC 模式，我们也可以将 View Controller 层的回调函数用 GCD 的方式传递给 Modal 层，这相比以前用 @selector 的方式，代码的逻辑关系会更加清楚。 block 的定义block 的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示： // 申明变量 (void) (^loggerBlock)(void); // 定义 loggerBlock = ^&#123; NSLog(@&quot;Hello world&quot;); &#125;; // 调用 loggerBlock(); 但是大多数时候，我们通常使用内联的方式来定义 block，即将它的程序块写在调用的函数里面，例如这样： dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // something&#125;); 从上面大家可以看出，block 有如下特点： 程序块可以在代码中以内联的方式来定义。 程序块可以访问在创建它的范围内的可用的变量。 系统提供的 dispatch 方法为了方便地使用 GCD，苹果提供了一些方法方便我们将 block 放在主线程 或 后台线程执行，或者延后执行。使用的例子如下： // 后台执行：dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // something&#125;);// 主线程执行：dispatch_async(dispatch_get_main_queue(), ^&#123; // something&#125;);// 一次性执行：static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // code to be executed once&#125;);// 延迟 2 秒执行：double delayInSeconds = 2.0;dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; // code to be executed on the main queue after delay&#125;); dispatch_queue_t 也可以自己定义，如要要自定义 queue，可以用 dispatch_queue_create 方法，示例如下： dispatch_queue_t urls_queue = dispatch_queue_create(&quot;blog.devtang.com&quot;, NULL);dispatch_async(urls_queue, ^&#123; // your code&#125;);dispatch_release(urls_queue); 另外，GCD 还有一些高级用法，例如让后台 2 个线程并行执行，然后等 2 个线程都结束后，再汇总执行结果。这个可以用 dispatch_group, dispatch_group_async 和 dispatch_group_notify 来实现，示例如下： dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; // 并行执行的线程一&#125;);dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; // 并行执行的线程二&#125;);dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^&#123; // 汇总结果&#125;); 修改 block 之外的变量默认情况下，在程序块中访问的外部变量是复制过去的，即写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下： __block int a = 0;void (^foo)(void) = ^&#123; a = 1;&#125;foo();// 这里，a 的值被修改为 1 后台运行使用 block 的另一个用处是可以让程序在后台较长久的运行。在以前，当 app 被按 home 键退出后，app 仅有最多 5 秒钟的时候做一些保存或清理资源的工作。但是应用可以调用 UIApplication 的beginBackgroundTaskWithExpirationHandler方法，让 app 最多有 10 分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。 让程序在后台长久运行的示例代码如下： // AppDelegate.h 文件@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;// AppDelegate.m 文件- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [self beingBackgroundUpdateTask]; // 在这里加上你需要长久运行的代码 [self endBackgroundUpdateTask];&#125;- (void)beingBackgroundUpdateTask&#123; self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123; [self endBackgroundUpdateTask]; &#125;];&#125;- (void)endBackgroundUpdateTask&#123; [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask]; self.backgroundUpdateTask = UIBackgroundTaskInvalid;&#125; 总结总体来说，GCD 能够极大地方便开发者进行多线程编程。大家应该尽量使用 GCD 来处理后台线程和 UI 线程的交互。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"给iOS工程增加Daily Build","slug":"apply-daily-build-in-ios-project","date":"2012-02-16T11:27:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/16/apply-daily-build-in-ios-project/","permalink":"https://blog.devtang.com/2012/02/16/apply-daily-build-in-ios-project/","excerpt":"前言Daily Build 是一件非常有意义的事情，也是敏捷开发中关于 “持续集成” 的一个实践。Daily Build 对于开发来说有如下好处： 保证了每次 check in 的代码可用，不会造成整个工程编译失败。 进度跟进。产品经理可以每天看到最新的开发进度，并且试用产品，调整一些细节。很多时候，一个新功能，你真正用了一下才能有体会好或不好，所以 daily build 也给产品经理更多时间来调理他的设计。 需求确认。产品经理可以确认开发的功能细节是他的预期。因为我们的开发比较紧凑，所以都没有传统的需求说明文档，所以 daily build 也给产品经理用于尽早确认开发的功能细节是他的预期，我就遇到一次产品经理发现开发出的一个功能细节和他的预期不一致，但是因为有 daily build，使得我可以尽早做修改，把修改的代价减小了。 测试跟进。如果功能点是独立的话，测试同事完全可以根据 daily build 来进行一些早期的测试。越早的 Bug 反馈可以使得修改 bug 所需的时间越短。","text":"前言Daily Build 是一件非常有意义的事情，也是敏捷开发中关于 “持续集成” 的一个实践。Daily Build 对于开发来说有如下好处： 保证了每次 check in 的代码可用，不会造成整个工程编译失败。 进度跟进。产品经理可以每天看到最新的开发进度，并且试用产品，调整一些细节。很多时候，一个新功能，你真正用了一下才能有体会好或不好，所以 daily build 也给产品经理更多时间来调理他的设计。 需求确认。产品经理可以确认开发的功能细节是他的预期。因为我们的开发比较紧凑，所以都没有传统的需求说明文档，所以 daily build 也给产品经理用于尽早确认开发的功能细节是他的预期，我就遇到一次产品经理发现开发出的一个功能细节和他的预期不一致，但是因为有 daily build，使得我可以尽早做修改，把修改的代价减小了。 测试跟进。如果功能点是独立的话，测试同事完全可以根据 daily build 来进行一些早期的测试。越早的 Bug 反馈可以使得修改 bug 所需的时间越短。 步骤xcodebuild 命令如何做 daily build 呢？其实 Xcode 就提供了命令行 build 的命令，这个命令是 xcodebuild，用 xcodebuild -usage可以查看到所有的可用参数，如下所示： [tangqiao ~]$xcodebuild -usageUsage: xcodebuild [-project &lt;projectname&gt;] [[-target &lt;targetname&gt;]...|-alltargets] [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]... xcodebuild [-project &lt;projectname&gt;] -scheme &lt;schemeName&gt; [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]... xcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]... xcodebuild -version [-sdk [&lt;sdkfullpath&gt;|&lt;sdkname&gt;] [&lt;infoitem&gt;] ] xcodebuild -list [[-project &lt;projectname&gt;]|[-workspace &lt;workspacename&gt;]] xcodebuild -showsdks 一般情况下的命令使用如下: xcodebuild -configuration Release -target &quot;YourProduct&quot; 但在 daily build 中，用 Release 用为 configuration 其实不是特别好。因为 Release 的证书可能会被经常修改。我们可以基于 Release 的 Configuation，建一个专门用于 daily build 的 configuration。方法是：在工程详细页面中，选择 Info 一栏，在 Configurations 一栏的下方点击 “+” 号，然后选择 “Duplicate Release Configuration”, 新建名为 “DailyBuild” 的 Configuration, 如下图所示： 之后就可以用如下命令来做 daily build 了 xcodebuild -configuration DailyBuild -target &quot;YourProduct&quot; 执行完命令后，会在当前工程下的 build&#x2F;DailyBuild-iphoneos&#x2F; 目录下生成一个名为： YourProduct.app 的文件。这个就是我们 Build 成功之后的程序文件。 生成 ipa 文件接下来我们需要生成 ipa 文件，在生成 ipa 文件这件事情上，xcode 似乎没有提供什么工具，不过这个没什么影响，因为 ipa 文件实际上就是一个 zip 文件，我们使用系统的 zip 命令来生成 ipa 文件即可。需要注意的是，ipa 文件并不是简单地将编辑好的 app 文件打成 zip 文件，它需要将 app 文件放在一个名为 Payload 的文件夹下，然后将整个 Payload 目录打包成为 .ipa 文件，命令如下： cd $BUILD_PATHmkdir -p ipa/Payloadcp -r ./DailyBuild-iphoneos/$PRODUCT_NAME ./ipa/Payload/cd ipazip -r $FILE_NAME * 生成安装文件苹果允许用 itms-services 协议来直接在 iphone&#x2F;ipad 上安装应用程序，我们可以直接生成该协议需要的相关文件，这样产品经理和测试同学都可以直接在设备上安装新版的应用了。相关的参考资料可以见：这里 和 这里 具体来说，就是需要生成一个带 itms-services 协议的链接的 html 文件，以及一个 plist 文件。 生成 html 的示例代码如下： cat &lt;&lt; EOF &gt; install.html&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt; 安装此软件 &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; 安装此软件:&lt;a href=&quot;itms-services://?action=download-manifest&amp;url=http%3A%2F%2Fwww.yourdomain.com%2Fynote.plist&quot;&gt;$FILE_NAME&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;EOF 生成 plist 文件的代码如下，注意，需要将下面的涉及 www.yourdomain.com 的地方换成你线上服务器的地址，将 ProductName 换成你的 app 安装后的名字。 cat &lt;&lt; EOF &gt; ynote.plist&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://www.yourdomain.com/$FILE_NAME&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://www.yourdomain.com/icon.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://www.yourdomain.com/icon.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.yourdomain.productname&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;ProductName&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;ProductName&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;EOF 定时运行这一点非常简单，使用 crontab -e 命令即可。大家可以随意 google 一下 crontab 命令，可以找到很多相关文档。假如我们要每周 1-5 的早上 9 点钟执行 daily build，则 crontab 的配置如下： 0 9 * * * 1-5 /Users/tangqiao/dailybuild.sh &gt;&gt; /Users/tangqiao/dailybuild.log 2&gt;&amp;1 失败报警在 daily build 脚本运行失败时，最好能发报警邮件或者短信，以便能够尽早发现。发邮件可以用 python 的 smtplib 来写，示例如下： import smtplibsender = &#x27;sender@devtang.com&#x27;receivers = [&#x27;receiver@devtang.com&#x27;]message = &quot;&quot;&quot;From: Alert &lt;sender@devtang.com&gt;To: Some one &lt;receiver@devtang.com&gt;Subject: SMTP email sampleHope you can get it.&quot;&quot;&quot;try: obj = smtplib.SMTP(&#x27;server.mail.devtang.com&#x27;) obj.sendmail(sender, receivers, message) print &#x27;OK: send mail succeed&#x27;except Exception: print &#x27;Error: unable to send mail&#x27; 上传daily build 编译出来如果需要单独上传到另外一台 web 机器上，可以用 ftp 或者 scp 协议。如果 web 机器悲剧的是 windows 机器的话，可以在 windows 机器上开一个共享，然后用 mount -t smbfs 来将这个共享 mount 到本地，相关的示例代码如下： mkdir uploadmount -t smbfs //$SMB_USERNAME:$SMB_PASSWORD@$SMB_TARGET ./uploadif [ &quot;$?&quot; -ne 0 ]; then echo &quot;Failed to mount smb directory&quot; exit 1fimkdir ./upload/$FOLDERcp $FILE_NAME ./upload/$FOLDER/if [ &quot;$?&quot; -eq 0 ]; then echo &quot;[OK] $FILE_NAME is uploaded to $SMB_TARGET&quot; else echo &quot;[ERROR] $FILE_NAME is FAILED to uploaded to $SMB_TARGET&quot; fiumount ./upload 遇到的问题本来我写的自动化脚本在 Mac OS X 10.6 下运行得很好。但是升级到 lion 后，脚本在手动执行时很正常，但是在用 crontab 启动时就会出现找不到开发者证书的错误。在网上搜了很久也没有找到解决办法。最后我试了一下在 “钥匙串访问” 中把开发者证书从 “登录” 那栏拖动到 “系统” 那栏，居然就解决了，如下图所示： 另外我搜到 2 个类似的问题的解决方案，虽然对我这个没起作用，也一并放在这儿，或许对遇到类似问题的人有帮助： http://stackoverflow.com/questions/7635143/cannot-build-xcode-project-from-command-line-but-can-from-xcode http://shappy1978.iteye.com/blog/765842 总结将以上各点结合起来，就可以用 bash 写出一个 daily build 脚本了。每天这一切都会自动完成，心情相当好。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"给NSString增加Java风格的方法","slug":"nsstring-java-like-wrapper","date":"2012-02-14T09:17:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/14/nsstring-java-like-wrapper/","permalink":"https://blog.devtang.com/2012/02/14/nsstring-java-like-wrapper/","excerpt":"我实在受不了 NSString 冗长的方法调用了，每次写之前都要查文档。特别是那个去掉前后多余的空格的方法，长得离谱。与之对应的别的语言，拿 java 来说，对应的方法名叫 trim。拿 python 来说，对应的方法名叫 strip。但是 Objective-C 呢？是下面这段： [self stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];","text":"我实在受不了 NSString 冗长的方法调用了，每次写之前都要查文档。特别是那个去掉前后多余的空格的方法，长得离谱。与之对应的别的语言，拿 java 来说，对应的方法名叫 trim。拿 python 来说，对应的方法名叫 strip。但是 Objective-C 呢？是下面这段： [self stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; 其实我也明白 Objective-C 这种长函数名的好处，就是能很清楚地了解当前的方法是干什么的。但是一些常用的方法，简单的方法名同样能表达清楚意思，并且更容易记住。长方法名的最大的问题是，代码写到一半得查文档，直接把思路打断了，所以我上周末花了一天时间把 Objective-C 的 NSString 类给封装了一下，把相应的方法调用都换成与 Java 类似的了。这样我每次用的时候就不用写那么长又记不住的方法名了。 主要封装后的方法定义如下： @interface NSString(Wrapper)- (unichar) charAt:(int)index;- (int) compareTo:(NSString*) anotherString;- (int) compareToIgnoreCase:(NSString*) str;- (BOOL) contains:(NSString*) str;- (BOOL) startsWith:(NSString*)prefix;- (BOOL) endsWith:(NSString*)suffix;- (BOOL) equals:(NSString*) anotherString;- (BOOL) equalsIgnoreCase:(NSString*) anotherString;- (int) indexOfChar:(unichar)ch;- (int) indexOfChar:(unichar)ch fromIndex:(int)index;- (int) indexOfString:(NSString*)str;- (int) indexOfString:(NSString*)str fromIndex:(int)index;- (int) lastIndexOfChar:(unichar)ch;- (int) lastIndexOfChar:(unichar)ch fromIndex:(int)index;- (int) lastIndexOfString:(NSString*)str;- (int) lastIndexOfString:(NSString*)str fromIndex:(int)index;- (NSString *) substringFromIndex:(int)beginIndex toIndex:(int)endIndex;- (NSString *) toLowerCase;- (NSString *) toUpperCase;- (NSString *) trim;- (NSString *) replaceAll:(NSString*)origin with:(NSString*)replacement;- (NSArray *) split:(NSString*) separator;@end 看着方法体，一下子感觉轻松了好多，以后再也不必每次写的时候查文档了。代码放到 github 上了，你可以用如下命令获得代码或者直接访问网址 https://github.com/tangqiaoboy/xcode_tool ： git clone git@github.com:tangqiaoboy/xcode_tool.gitcd xcode_tool/NSStringWrappeer 如果要把这个 Wrapper 加到现有工程中，只需要拷贝我的文件：NSStringWrapper.h 和 NSStringWrapper.m 到你自己的工程中即可。在使用的时候注意我修改了一点，我将查找不存在的返回值设置成了-1，这样和 java 语言保持一致，如果你想用 NSNotFound 作为查找不存在时的结果，请修改文件 NSStringWrapper.m 顶部的宏定义:JavaNotFound 即可，如下所示： // 如果不喜欢，可以将-1 改成 NSNotFound 即可#define JavaNotFound -1 Have fun!","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"象写程序一样写博客：搭建基于github的博客","slug":"setup-blog-based-on-github","date":"2012-02-10T11:55:00.000Z","updated":"2024-01-15T05:59:05.442Z","comments":true,"path":"2012/02/10/setup-blog-based-on-github/","permalink":"https://blog.devtang.com/2012/02/10/setup-blog-based-on-github/","excerpt":"2016.02.16 更新说明本博客已经由 octopress 迁移到了 Hexo，本文章的内容稍显陈旧。 对 Hexo 感兴趣的可以参见：《从 Octopress 迁移到 Hexo》。 前言github 真是无所不能。其 Pages 功能 支持上传 html，并且在页面中显示。于是有好事者做了一个基于 github 的博客管理工具：octopress，基本原理是用 git 来管理你的文章，然后最终发布到 github 上成为一个独立博客站点。由于 github 支持 CNAME 域名指向，所以如果有独立域名的话，可以基于这些做出一个专业的博客站点出来。 本博客就是完全基于此搭建起来的，在使用了 2 个月之后，我将原系统根据中国人的需求做了一些配置，去掉了 GFW 会挡住的 google font api，以及替换掉了速度超慢的国外的评论系统，也加上了分享到国内的微博的功能。现在把这些都总结出来，希望大家都可以方便地搭建基于 github 的博客来。","text":"2016.02.16 更新说明本博客已经由 octopress 迁移到了 Hexo，本文章的内容稍显陈旧。 对 Hexo 感兴趣的可以参见：《从 Octopress 迁移到 Hexo》。 前言github 真是无所不能。其 Pages 功能 支持上传 html，并且在页面中显示。于是有好事者做了一个基于 github 的博客管理工具：octopress，基本原理是用 git 来管理你的文章，然后最终发布到 github 上成为一个独立博客站点。由于 github 支持 CNAME 域名指向，所以如果有独立域名的话，可以基于这些做出一个专业的博客站点出来。 本博客就是完全基于此搭建起来的，在使用了 2 个月之后，我将原系统根据中国人的需求做了一些配置，去掉了 GFW 会挡住的 google font api，以及替换掉了速度超慢的国外的评论系统，也加上了分享到国内的微博的功能。现在把这些都总结出来，希望大家都可以方便地搭建基于 github 的博客来。 安装首先说说怎么安装相应的工具。其实这些内容在 http://octopress.org/docs/setup/ 上都有，我只是把它大概翻译了一下。 安装 rbenvbrew updatebrew install rbenvbrew install ruby-buildrbenv install 1.9.3-p0rbenv local 1.9.3-p0rbenv rehash 你有可能需要安装老版本的 GCC 编译器才能顺利安装 Ruby 1.9.3: brew tap homebrew/dupes brew install apple-gcc42 安装 Octopress首先从 github 上将源码 clone 下来： git clone git://github.com/imathis/octopress.git octopresscd octopress # If you use RVM, You&#x27;ll be asked if you trust the .rvmrc file (say yes).ruby --version # Should report Ruby 1.9.2 然后，ruby 的软件源 https://rubygems.org 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内淘宝的源： gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l 然后安装依赖: gem install bundlerrbenv rehash # If you use rbenv, rehash to be able to run the bundle commandbundle install 最后安装 Octopress rake install 配置安装好之后可以简单配置一下： 主要是修改文件：_config.yml ，这个配置文件都有相应的注释。主要就是改一些博客头，作者名之类的东西。注意最好把里面的 twitter 相关的信息全部删掉，否则由于 GFW 的原因，将会造成页面 load 很慢。 修改定制文件 /source/_includes/custom/head.html 把 google 的自定义字体去掉，原因同上。 设置 github 账号基于 github 的博客当然需要先注册 github 账号，Github 的账号注册地址是：https://github.com/signup/free 。申请好 github 账号后，建一个名为 username.github.io 的代码仓库。这里注意 username 必须是和你的账号名一致。 写博客方法然后就可以写博客啦～ 写博客主要是用以下几个命令，这里 有详细介绍： rake new_post[‘article name’] 生成博文框架，然后修改生成的文件即可 rake generate 生成静态文件 rake watch 检测文件变化，实时生成新内容 rake preview 在本机 4000 端口生成访问内容 rake deploy 发布文件 博文是采用 markdown 语法，另外增加了一些扩充的插件，markdown 的介绍文章网上可以搜到很多，比如 这个。 高级配置我主要介绍一下如何配置评论和分享到微博功能。步骤如下： 在 _config.yml 中增加一项： weibo_share: true 修改 source&#x2F;_includes&#x2F;post&#x2F;sharing.html ，增加： // 下面的大括号是全角的，如果复制，请自行改成半角｛% if site.weibo_share %｝ ｛% include post/weibo.html %｝｛% endif %｝ 增加文件：source&#x2F;_includes&#x2F;post&#x2F;weibo.html 访问 http://www.jiathis.com/ ，获取分享的代码 访问 http://uyan.cc/ ，获得评论的代码 将上面 2 步的代码都加入到 weibo.html 中即可 修改sass/base/_typography.scss，将其中的article blockquote的font-style由italic改为normal, 因为中文的引用文字用斜体显示其实并不好看。再将其中的ul, ol的margin-left: 1.3em;修改为margin-bottom: 0em;。 其它对于国内的用户来说，Github 因为服务器在国外，访问速度上不可避免有些慢。我在 2014 年 5 月尝试将博客同时放到 Github 和 GitCafe 上（GitCafe 提供博客服务，而 Github 作为备份服务器），使得国内访问速度非常理想，感兴趣的朋友可以参考这篇文章：《将博客从 GitHub 迁移到 GitCafe》 Tips####从 wordpress 迁移到 github这儿有一篇文章介绍了如何做迁移：http://blog.xupeng.me/2011/12/14/migrate-to-octopress/ 图片如果要在文章中上传图片，直接 copy 到 &#x2F;source&#x2F;images 目录下即可。在文章中可以直接引用。也可以选一些大的图床站点，例如 flickr 之类的放在那边。 域名如果你象我一样有自己的域名，可以将域名指向这个博客，具体步骤是： 在域名管理中，建立一个 CNAME 指向，将你的域名指向 yourname.github.io 建一个名为 CNAME 的文件在 source 目录下，然后将自己的域名输入进去。 将内容 push 到 github 后，第一次生效大概等 1 小时，之后你就可以用自己的域名访问了。 原理 Octopress 其实为你建立了 2 个分支，一个是 master 分支，用于存放生成的最终网页。另一个是 source 分支，用于存放最初的原始 markdown 文件。 平时写作和提交都在 source 分支下，当需要发布时，rake deploy 命令会将内容生成到 public 这个目录，然后将这个目录的内容当作 master 分支的内容同步到 github 上面。 参考这儿还有一些参考的文章： http://www.yangzhiping.com/tech/octopress.html http://blog.xupeng.me/2011/12/14/migrate-to-octopress/","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"}]},{"title":"斯坦福大学 iOS 开发公开课总结","slug":"mvc-in-ios-develop","date":"2012-02-05T04:58:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/05/mvc-in-ios-develop/","permalink":"https://blog.devtang.com/2012/02/05/mvc-in-ios-develop/","excerpt":"前言iPhone 开发相关的教程中最有名的，当数斯坦福大学发布的 “iPhone 开发公开课 “ 了。此公开课在以前叫做《iPhone 开发教程》，今年由于平板电脑的流行，所以也加入了 ipad 开发相关的课程。在 网易公开课 上，有 该教程 的 2010 年录象，并且前面 15 集带中文字幕文件，非常适合初学者学习。","text":"前言iPhone 开发相关的教程中最有名的，当数斯坦福大学发布的 “iPhone 开发公开课 “ 了。此公开课在以前叫做《iPhone 开发教程》，今年由于平板电脑的流行，所以也加入了 ipad 开发相关的课程。在 网易公开课 上，有 该教程 的 2010 年录象，并且前面 15 集带中文字幕文件，非常适合初学者学习。 在这里顺便说一下，网易公开课上的 28 集其实并不需要全部看完。真正的课程只有前面 12 集。后面的课程都是请一些业界的名人讲他们成功的 app 以及学生的作品展示，可看可不看。所以大家不要被 28 集这么多吓到。 由于近一年来 iOS5 以及 xcode4 的发布，苹果对原有的开发环境 xcode 以及开发语言 Objective-C 都有改进，所以原有的教程中很多内容不再适用了。例如新的 xcode4 将 Interface Builder 集成到 xcode 中，整个 IDE 布局和快捷键完全大变样，又比如苹果为 Objective-c 引用了 ARC 和 Storyboard，这些都使得 app 的编程方式大为不同。 值得高兴的是，斯坦福大学最近更新了该公开课的 2011 年秋季录象，免费下载地址是：http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=480479762，不过现在该公开课还没有翻译，只能看英文原版了。新的课程相比以前要短了许多，一共只有 9 课。我大概快速看了一遍，总结一些心得给大家。 iOS 的 MVC 模式MVC 模式算是客户端类程序使用的设计模式的标配了。iOS 对于 Model, View 和 Controller 之间的相互调用有它自己的规范和约定，在公开课的 第一课 中，就介绍了应该如何将 MVC 模式应用在 iOS 开发中。主要的内容就体现在如下这张图中 (图片来自该公开课第一课的 配套 pdf 的第 37 页)： 我下面详细介绍一下这幅图的意思。 首先图中绿色的箭头表示直接引用。直接引用直观来说，就是说需要包含引用类的申明头文件和类的实例变量。可以看到，只有 Controller 中，有对 Model 和 View 的直接引用。其中对 View 的直接引用体现为 IBOutlet。 然后我们看 View 是怎么向 Controller 通讯的。对于这个，iOS 中有 3 种常见的模式: 设置 View 对应的 Action Target。如设置 UIButton 的 Touch up inside 的 Action Target。 设置 View 的 delegate，如 UIAlertViewDelegate, UIActionSheetDelegate 等。 设置 View 的 data source, 如 UITableViewDataSource。通过这 3 种模式，View 达到了既能向 Controller 通讯，又不需要知道具体的 Controller 是谁是目的，这样就和 Controller 解耦了。 最后我们看 Model。Model 在图上有一个信号塔类似的图形，旁边写着 Notification &amp; KVO。这表明 Model 主要是通过 Notification 和 KVO 来和 Controller 通讯的。关于 Notification，我写了一个模版代码片段如下:（关于代码片段的管理，推荐大家看我写的另一篇文章：使用 Github 来管理 xcode4 中的代码片段 // 监听通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(&lt;#methodName#&gt;) name:kLoginNotification object:nil];// 取消监听[[NSNotificationCenter defaultCenter] removeObserver:self];// 发送通知NSDictionary * userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:200] forKey:@&quot;code&quot;];[[NSNotificationCenter defaultCenter] postNotificationName:&lt;#notification_name#&gt; object:self userInfo:userInfo]; 所以，对于初学者，要正确地使用 MVC 模式还是挺难的，回想我们以前做公司某产品 iPhone 版的时候，就有一些 Model 层直接依赖了 Controller 层，比如 Model 层更新数据失败了，直接调用 Controller 层显示出一个失败的提示界面。这样层次划分不清，造成我们做 ipad 版的时候很痛苦。最后我们做了代码重构，把 Model 的相应改变都用 Notification 来完成，使得在做 ipad 版开发时轻松了很多。 Convention About synthesize“Convention over configuration”（约定高于配置）成就了 Ruby On Rails，而 iOS 也有很多编程的约定。这些约定单独看没有什么好处，约定的最大好处就是，如果大家都遵守它，那么代码风格会趋于一致，你会很方便地读懂或修改别人的代码。 我们可以从第一课 PPT 的第 50 页看到如下的代码： 从图中可以看到，该课程推荐大家在使用 synthesize 关键字时，为 property 设置一个下划线前缀。我也看过一些 iPhone 的开源项目，比如 facebook 开源的 three20 ，它是遵守了这样的约定的。 其它的约定还包括： 以 new, copy, alloc 开头的方法，都应当由调用者来 release，而其它方法，都返回一个 autorelease 对象。 通常 iPhone 顶部的 bar 应该用 UINavigation 控件，而底部的 bar 应该用 UIToolbar 控件。 所有的 UI 操作都应该在主线程 (UI 线程) 进行。这个似乎不是约定，但是好多同学不知道，也写在这儿吧。 UIView刚开始对界面之间的跳转很不理解，后来发现其实很简单，就是一层一层叠起来的 View。从 View A 上点击一个按钮跳转到 View B，其实就是把 View B“盖” 在 View A 上面而已。而 “盖” 的方式有好多种，通常的方法有 2 种： 一 . 用 UINavigationController 把 View B push 进来。 [self.navigationController pushViewController:nextView animated:YES]; 二 . 用 presentModalViewController 方法把 View B 盖在上面。 [self presentModalViewController:nextView animated:YES]; 除此之外，其实还有一种山寨方法，即把 View A 和 View B 都用 addSubView 加到 AppDelegate 类的 self.window 上。然后就可以调用 bringSubviewToFront 把 View B 显示出来了，如下所示： // AppDelegate.m 类[self.window addSubview:viewB];[self.window addSubview:viewA];// 在需要时调用[self.window bringSubviewToFront:viewB]; 上面说的是界面之间的跳转。对于一个界面内，其控件的布局其实也是一个一个叠起来的，之所以说叠，是指如果 2 个控件如果有重叠部分，那么处于上面的那个控件会盖住下面的。 Nib FileNib 文件实际上内部格式是 XML，而它本身并不编译成任何二进制代码。所以你如果用 iFile 之类的软件在 iPhone 上查看一些安装好的软件的目录，可以看到很多的以 nib 结尾的文件，这些就是该软件的界面文件。虽然这些 XML 经过了一些压缩转换，但是我们还是可以看到一些信息，例如它使用了哪些系统控件等。 Nib 文件刚开始给我的感觉很神秘，后来发现它其实就是用于可视化的编辑 View 类用的。其中的 File’s Owner 一栏，用于表示这个 View 对应的 Controller 类。通常情况下，Controller 类会有一个名为 view 的变量，指向这个 view 的实例，我们也可以建立多个 IBOutlet 变量，指向这个 view 上的控件，以便做一些界面上的控制。 在 Interface Builder 上还有一个好处，是可以方便的将 View 的事件与 Controller 的 IBAction 绑定。只需要按住 Ctrl 键，从控件往 File’s Owner 一栏拖拽，即可看到可以绑定的方法列表。其实这些只是简化了我们的工作，如果完全抛开 Interface Builder，我们一样可以完成这些工作。我所知道业界的一些 iOS 开发部门，为了多人协作更加方便，更是强制不允许使用 Interface Builder，一切界面工作都在代码中完成。如果你用文本编辑器打开 Nib 文件看过，就能理解这样做是有道理的。因为如果 2 个同时编辑一个界面文件，那么冲突的可能性是 100%，而且，从 svn 结出的冲突信息上看，你根本无法修正它。下面的代码演示了如何不用 Interface Builder 来添加控件以及绑定 UI 事件。 // SampleViewController.m 的 viewDidLoad 方法片段// 添加 Table View 控件UITableView * tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, 320, 400)];[self.view addSubview:tableView];tableView.delegate = self;[tableView release];// 添加 Button 控件self.button = [[[UIButton alloc] initWithFrame:CGRectMake(0, 0, 200, 100)] autorelease];[self.view addSubview:self.button];// 绑定事件[self.button addTarget:self action:@selector(buttonPressed) forControlEvents:(UIControlEventTouchUpInside)]; 总结总体来讲，学习 iOS 开发还是比较容易的。我大概花了一个月时间学习 iPhone 开发，就可以边做边学了。 苹果的设计对于开发者来说是非常友好的，很多时候使用相应的控件就行了，都不用操心底层细节。不象 Android 开发，一会儿要考虑不同手机分辨率不一样了，一会儿又要考虑有些不是触摸屏了，一会儿又发现某款手机的 cpu 内存太弱了跑不起来，需要优化程序。另外，Objective-C 相对于 C++ 语言来说，要简单优雅得多，而且更加强大，所以做 iOS 的开发者很省心。 要说到不爽的地方，就是 iOS 开发相关的中文资料实在是太少了。要学习它，基本上需要查看苹果的官方英文文档以及 WWDC 大会视频，还有去 stackoverflow 上问问题。这对于英文不太好的同学这可能是一个障碍。不过反过来，习惯之后，通过这个锻炼了自己的英文水平，倒也是一大收获。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"使用 Git 来管理 Xcode 中的代码片段","slug":"use-git-to-manage-code-snippets","date":"2012-02-04T06:32:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/04/use-git-to-manage-code-snippets/","permalink":"https://blog.devtang.com/2012/02/04/use-git-to-manage-code-snippets/","excerpt":"代码片段介绍xcode4 引入了一个新 feature: code snippets，在整个界面的右下角，可以通过快捷键：cmd + ctrl + opt + 2 调出来。code snippets 是一些代码的模版，对于一些常见的编程模式，xcode 都将这些代码抽象成模版放到 code snippet 中，使用的时候，只需要键入快捷键，就可以把模版的内容填到代码中。","text":"代码片段介绍xcode4 引入了一个新 feature: code snippets，在整个界面的右下角，可以通过快捷键：cmd + ctrl + opt + 2 调出来。code snippets 是一些代码的模版，对于一些常见的编程模式，xcode 都将这些代码抽象成模版放到 code snippet 中，使用的时候，只需要键入快捷键，就可以把模版的内容填到代码中。 例如，在引入 GCD(Grand Central Dispatch) 后，当我们需要一个延时的操作时，只需要在 xcode 中键入：dispatch, 就可以看到 xcode 中弹出一个上下文菜单，第一项就是相应的代码片段。如下图所示： 定义自己的代码片段那么如何自定义 code snippet 呢，相当简单，当你觉得某段代码很有用，可以当作模版的时候，将其整块选中，拖动到 xcode 右下角的 code snippets 区域中即可。xcode 会自动帮你创建一个新的代码片段。之后你可以单击该代码片段，在弹出的界面中选择 edit，即可为此代码片段设置快捷键等信息。 如果有些地方你想让用户替换掉，可以用 &lt;#被替换的内容#&gt; 的格式。这样在代码片段被使用后，焦点会自动移到该处，你只需要连贯的键入替换后的内容即可。如下图所示： 关于 xcode 的一些代码片段，这里 有一些用户的总结心得。 使用 Git 管理代码片段在了解了 code snippet 之后，我在想能不能用 Git 来管理它，于是就研究了一下，发现它都存放于目录 ~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;UserData&#x2F;CodeSnippets 中。于是，我就将这个目录设置成一个 Git 的版本库，然后将自己整理的代码片段都放到 Github 上了。现在我有 2 台 mac 机器，一台笔记本，一台公司的 iMac，我常常在 2 台机器间切换着工作，由于将代码片段都放在 github 上，所以我在任何一端有更新，另一端都可以很方便的用 git pull 将更新拉到本地。前两天将公司机器升级到 lion，又重装了 lion 版的 xcode，简单设置一下，所有代码片段都回来了，非常方便。 我的代码片段所在的 github 地址是 https://github.com/tangqiaoboy/xcode_tool, 使用它非常方便，只需要如下 3 步即可： git clone https://github.com/tangqiaoboy/xcode_toolcd xcode_tool./setup_snippets.sh 大家也可以将我的 github 项目 fork 一份，改成自己的。这样可以方便地增加和管理自己的代码片段。 祝大家玩得开心。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"}]},{"title":"Git 的使用感受","slug":"talk-about-svn-and-git","date":"2012-02-03T13:08:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/03/talk-about-svn-and-git/","permalink":"https://blog.devtang.com/2012/02/03/talk-about-svn-and-git/","excerpt":"从开始工作到现在，在公司里面一直用 svn 来做版本管理。大约半年前听说了 Git，因为 Git 的光辉相当耀眼，作者是 Linus Torvalds，被大量的开源软件采用，如 jQuery, Perl, Qt, ROR, YUI, GNOME 等，所以决定学一学。比较庆幸的是，国内有一本较好的介绍 Git 的书：《Git 权威指南》。我大概花了一个月的周末时间来学习它。在这里总结一下使用 Git 的感受，主要是和 SVN 来做一些比较，以便突出 Git 的特点。","text":"从开始工作到现在，在公司里面一直用 svn 来做版本管理。大约半年前听说了 Git，因为 Git 的光辉相当耀眼，作者是 Linus Torvalds，被大量的开源软件采用，如 jQuery, Perl, Qt, ROR, YUI, GNOME 等，所以决定学一学。比较庆幸的是，国内有一本较好的介绍 Git 的书：《Git 权威指南》。我大概花了一个月的周末时间来学习它。在这里总结一下使用 Git 的感受，主要是和 SVN 来做一些比较，以便突出 Git 的特点。 学习成本首先我感觉 Git 的学习成本还是比较高的。svn 基本上不到 20 个命令就可以应付日常的工作了，而 Git 有上百个命令。我在学习 SVN 的时候，基本上没有看什么书，最多就是在网上随便看了一些贴子，就基本会使用 SVN 了。而我花在 Git 的学习时间算下来，至少有 1 周。 因为 Git 的学习成本较高，所以当一个会 svn 的同学刚刚接触 Git 的时候，如果简单地把 Git 当 SVN 用，就会感觉 Git 相当难用。我在公司就时常听到同事抱怨它。所以我认为，要想真正用好 Git，还是需要投入时间来学习它，否则是很难使用的。 Git 的内部结构Git 真正是一个面向程序员的工具，它的内部数据结构是一个有向无环图，并且，你必须理解它的内部数据结构后，才能掌握它。因为你的很多操作，都其实对应的是这个有向无环图的操作。比如: git commit 就是增加一个结点。 git commit –amend 就是改发一个结点。 git reset 就是修改 HEAD 指向的结点。 另外，Git 内部包括三个区域：工作区，暂存区和版本库。 git add 是将工作区的内容保存到暂存区 git checkout 是将暂存区的内容覆盖工作区 git commit 是将暂存区的内容保存到版本库 git reset 默认情况下是将版本库的内容覆盖工作区 git diff 也有三种情况，分别是比较工作区与暂存区，工作区与版本库，暂存区与版本库之间的差别 了解了 Git 的内部结构，对于这些 Git 的命令就更加理解了。 svn 的坑svn 在平常使用上基本没什么坑，平时通过svn pe svn:ignore . 设置好忽略的文件，以免误把不应该加入版本管理的文件加进来。 我唯一遇到的一次问题是这样的：我有一个目录要加入 svn 的版本库，但是目录里面的一些文件不想加入。如果直接输入 svn add 目录名，就会把目录下所有文件都加入到版本管理中。如果 cd 到那个目录里面配置 svn:ignore，又会因为当前目录还不在版本管理中，设置不了。最后找到的解决办法是在 svn add 的时候增加 –non-recursive 参数： svn add dirname --non-recursive或者是：$ svn add dirname --depth empty 还有就是对于一些不小心用 svn add 加入了版本管理，但实际上不应该加的目录。可以这么做： svn export spool spool-tmp (这里 export 可以将原目录中的 .svn 目录给清除掉)svn rm spoolsvn ci -m &#x27;Removing inadvertently added directory &quot;spool&quot;.&#x27;mv spool-tmp spoolsvn propset svn:ignore &#x27;spool&#x27; .svn ci -m &#x27;Ignoring a directory called &quot;spool&quot;.&#x27; Git 的坑 在 windows 下的文件的权限因为无法和 linux 上完全一致，所以用 Git 检出的文件权限可能显示为被更改。另外因为 windows 下的换行和 linux 上也不一样，协作开发时也容易出问题。所以在 windows 上使用 Git 的同学需要加上以下 2 行配置参数： git config --global core.filemode falsegit config --global core.autocrlf true第一句是忽略文件权限的改动。第二句是将文件 checkout 时自动把 LF 转成 CRLF，check in 时自动把 CRLF 转成 LF svn 的 svn revert filename 对应的其实是 git checkout -- filename, 而 git revert xxx 是基于 xxx 提交所做的改动，做一次反向提交，和 svn revert 完全不一样。 Git 的一些小技巧节省clone体积有些时候，我们只想简单学习一下项目代码，这个时候，用 git clone rep_address --depth 1 可以只 clone 每个文件最新的一个提交，这样速度会快很多。 强制推送一旦推送到远程仓库后，就不要用类似 git reset, git ci --amend, git rebase 等破坏性提交了，否则远程仓库会因为你的新推送不是 Fast Forward 而拒绝提交 (关于什么是 Fast Forward 要讲的太多了，自已看书吧)。如果实在不小心做了。在确定别人没有检出前，用 git push -f 可以强制推送到远程仓库中。如下图: 使用 git svn 在公司没有应用 git 前，你可以用 git svn 来做管理。 git svn 相关命令： git svn clone -r REV1:HEAD svn_addr local_addrgit svn dcommit 提交到 SVNgit svn fetch 从 svn up 信息git svn rebase 将从 svn up 过来的信息，rebase 成 git 提交git svn rebase --continue 冲突后继续 rebase 信息 用 git svn clone 的时候，带上 -r rev1:HEAD 参数，可以省去将 SVN 整个提交历史抓取下来的时间。 设置常用命令的别名 在用户的 home 目录下，有一个 .gitconfig 文件，里面可以配置一些别名，方便平时的 git 操作。特别是那些平日使用 SVN 的短命令习惯了的同学，配置一下别名后，使用 git 就会相当顺手了。我配置的别名如下。这里特别多说一句，有些人喜欢将 ci 设置成 commit -a，这样就不用 git add 来把需要提交的文件加入到暂存区了。在《Git 权威指南》中，作者极力反对这样做。因为 Git 本身在提交前有 add 这步，就是为了让提交者能够审视自己的提交文件，以防止错误的提交发生。 [alias] st = status -s ci = commit l = log --oneline --decorate -13 ll = log --oneline --decorate co = checkout br = branch rb = rebase dci = dcommit 删除不在 git 管理下的文件 如果你需要删除 Git 下没有加入到版本库中的文件，可以使用： git clean -nd 测试删除git clean -fd 真实删除 搭建自己的远程仓库搭建一个 Git 远程仓库相当简单，直接在一台带 SSH 的服务器上用 git init –bare dirname 即可。本地可以用 git remote 命令来设置多个远程分支。另外，第一次提交的时候，因为远程仓库中没有任何分支，需要用如下指令建立 master 分支： git remote add origin yourname@yourhost.com:~/path/repository_namegit remote add add2 yourname@yourhost.com:~/path/repository_namegit push origin mastergit push add2 master// 如果 git remote add 设置地址写错了，可以用 git remote set-url 更改：git remote set-url origin yourname@yourhost.com:~/path/repository_name 如何用 Git 将一个文件的历史提交恢复？上次遇到一个问题，我某次提交改动了很多文件，但是其中有一个是不应该改的。所以我需要把这次提交中关于那个文件的改动撤销。直接用 git checkout 命令可以检出某一个文件的历史版本，然后就可以将对这个文件的改动取消了。如下： git checkout CommitId fileName git ci -m &quot;revert a file modification&quot; 本地工作区还有未提交的内容时，不能 pull?可以先用 git stash 将内容暂存，然后再 pull，成功后再 git stash pop 将修改恢复。 提交的邮箱错了？有些时候，因为同时在 github 和公司内部做提交，所以用 2 个不同的邮箱。如果一个新工程 clone 下来，忘了用 git config 来设置提交用户名和邮箱，就有可能用错误的邮箱作为账号名提交。这个时候，如果你只是错了最近的一次提交而已，可以用如下命令来将最近的一次提交作者名和邮箱修改： git config user.email your-email@163.comgit config user.name your-namegit commit --amend --reset-author 如果等你发现的时候，已经错了很多提交了。可以用如下命令来一次性修改多个提交的用户名和邮箱： git filter-branch -f --env-filter &quot; GIT_AUTHOR_NAME=&#x27;Tang Qiao&#x27; GIT_AUTHOR_EMAIL=&#x27;tangqiao@fenbi.com&#x27; GIT_COMMITTER_NAME=&#x27;Tang Qiao&#x27; GIT_COMMITTER_EMAIL=&#x27;tangqiao@fenbi.com&#x27;&quot; HEAD 提交的时候自动去掉源码末尾的空格源码末尾的空格几乎都是无意义的，应该去掉的。大多数 review 系统，都会将源码末尾的空格标红。所以，我们何不在提交时让 git 自动帮我们去掉这些空格呢？这个可以通过设置 git 的 hook 来实现，具体方法如下： 用 vim 编辑一个名为 pre-commit 的文件： vim .git/hooks/pre-commit 输入如下代码，保存退出 vim #!/bin/shif git-rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1 ; then against=HEADelse # Initial commit: diff against an empty tree object against=4b825dc642cb6eb9a060e54bf8d69288fbee4904fi# Find files with trailing whitespacefor FILE in `exec git diff-index --check --cached $against -- | sed &#x27;/^[+-]/d&#x27; | sed -E &#x27;s/:[0-9]+:.*//&#x27; | uniq` ; do # Fix them! sed -i &#x27;&#x27; -E &#x27;s/[[:space:]]*$//&#x27; &quot;$FILE&quot; git add &quot;$FILE&quot;done 增加 pre-commit 的运行权根：chmod +x .git/hooks/pre-commit 让常用操作自动带颜色默认的 git diff, status, log 什么的都是不带颜色的，可以用如下命令让它们都带上颜色。另外还有一些有趣的命令，一并列在下面。 git config --global --add user.email &quot;email@163.com&quot;git config --global --add user.name &quot;your name&quot;git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status -sgit config --global alias.l log --oneline --decorate -12 git config --global color.diff autogit config --global color.status autogit config --global color.branch autogit config --global merge.tool kdiff3git config --global meregtool.kdiff3.path &quot;/usr/bin/kdiff3&quot; git config --global alias.visual &quot;!gitk&quot; 自动补全 git 命令 安装 bash-completion: brew install bash-completion 按要求把以下代码增加到 .bash_profile 文件中： if [ -f `brew --prefix`/etc/bash_completion ]; then . `brew --prefix`/etc/bash_completionfi 下载 bash-completion 对于 Git 的支持 cd /usr/local/etc/bash_completion.d/sudo curl -O https://raw.github.com/git/git/master/contrib/completion/git-completion.bash 一些 Git 的资料 Git Magic 很通俗的一本介绍 Git 的书，比较短小精炼。 Pro Git 全面介绍 Git 的书，非常详细。 《Git 权威指南》 中国人写的一本介绍 Git 的书，也非常通俗。我个人主要就是通过这本书来学习 Git 的。 Github 基于 Git 的开源网站。在 Github 的托管的项目相当多，著名的有：rails, jquery, node, homebrew, three20, jekyll, jquery-ui, backbone, coffee-script, tornado, redis, underscore, asi-http-request, django。","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"}]},{"title":"使用Objective-C的文档生成工具:appledoc","slug":"use-appledoc-to-generate-xcode-doc","date":"2012-02-01T12:37:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/02/01/use-appledoc-to-generate-xcode-doc/","permalink":"https://blog.devtang.com/2012/02/01/use-appledoc-to-generate-xcode-doc/","excerpt":"前言做项目的人多了，就需要文档了。今天开始尝试写一些项目文档。但是就源代码来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 语言本身就自带 javadoc 命令，可以从源码中抽取文档。今天抽空调研了一下 objective-c 语言的类似工具。","text":"前言做项目的人多了，就需要文档了。今天开始尝试写一些项目文档。但是就源代码来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 语言本身就自带 javadoc 命令，可以从源码中抽取文档。今天抽空调研了一下 objective-c 语言的类似工具。 从 stackoverflow 上找到三个比较 popular 的工具：doxygen, headdoc 和 appledoc 。它们分别的官方网址如下： docxygen http://www.stack.nl/~dimitri/doxygen/index.html headdoc http://developer.apple.com/opensource/tools/headerdoc.html appledoc http://gentlebytes.com/appledoc/ 介绍我把这 3 个工具都大概调研了一下，说一下我的感受。 docxygendocxygen 感觉是这 3 个工具中支持语言最多的，可以配置的地方也比较多。我大概看了一下文档，觉得还是比较复杂，而且默认生成的风格与苹果的风格不一致。就去看后面 2 个工具的介绍了。另外，它虽然是开源软件，但是没有将源码放到 github 上让我感觉这个工具的开发活跃度是不是不够。 headerdocheaderdoc 是 Xcode 自带的文档生成工具。在安装完 Xcode 后，就可以用命令行：headdoc2html + 源文件名 来生成对应的文档。我个人试用了一下，还是比较方便的，不过 headerdoc 的注释生成规则比较特别，只生成以 /\\*! \\*/ 的格式的注释。还有一个缺点是每个类文件对应一个注释文件，没有汇总的文件，这点感觉有点不爽。 appledocappledoc 是在 stackoverflow 上被大家推荐的一个注释工具。有几个原因造成我比较喜欢它： 它默认生成的文档风格和苹果的官方文档是一致的，而 doxygen 需要另外配置。 appledoc 就是用 objective-c 生成的，必要的时候调试和改动也比较方便。 可以生成 docset，并且集成到 Xcode 中。这一点是很赞的，相当于在源码中按住 option 再单击就可以调出相应方法的帮助。 appledoc 源码在 github 上，而 doxygen 在 svn 上。我个人比较偏激地认为比较活跃的开源项目都应该在 github 上。 相对于 headerdoc，它没有特殊的注释要求，可以用 /\\*\\* \\*/ 的格式，也可以兼容 /\\*! \\*/ 的格式的注释，并且生成的注释有汇总页面。 安装那么简单介绍一下如何安装 appledoc，安装非常简单，只需要 2 步： git clone git://github.com/tomaz/appledoc.gitcd appledocsudo sh install-appledoc.sh 使用使用 appledoc 时，只需要用如下命令即可： appledoc -o ./doc --project-name ynote --project-company youdao . appledoc 会扫描当前路径下的所有文件，然后生成好文档放到 doc 目录下。你也可以用 appledoc --help 查看所有可用的参数。 基本上使用起来还是比较方便的，详细的信息可以查看官方的文档：http://gentlebytes.com/appledoc/","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"用javascript协助导入图片","slug":"use-javascript-to-import-pictures","date":"2012-01-23T15:10:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/01/23/use-javascript-to-import-pictures/","permalink":"https://blog.devtang.com/2012/01/23/use-javascript-to-import-pictures/","excerpt":"需求先说说需求。春节回家见爸妈，老爸迷上了摄影。他把平时的照片都上传到了 成都图片网, 这个成都图片网专门有一个 “快拍成都” 的版块，用于大家将随手拍的生活中的图片分享上去。每天编辑还会选出一张最有特色的图片，刊登到《成都商报》上。","text":"需求先说说需求。春节回家见爸妈，老爸迷上了摄影。他把平时的照片都上传到了 成都图片网, 这个成都图片网专门有一个 “快拍成都” 的版块，用于大家将随手拍的生活中的图片分享上去。每天编辑还会选出一张最有特色的图片，刊登到《成都商报》上。 快拍成都版块的网址是：http://photo.chengdu.cn/diary.php，另外，这个成都图片网还带有一个 “ 拍客论坛 “，论坛的网址是：http://photo.chengdu.cn/bbs/。 老爸在兴奋地给我介绍完他的光辉成果之后 , 提出了他的需求：他希望在 “快拍成都” 发完图片后，能够自动将图片保存到他在 “ 拍客论坛 “ 上的 “个人相册” 中。 调研简单研究了一个这个网站。明显这个网站自带的论坛是改的别人的开源系统，而 “快拍成都” 这个功能由于需求比较特别，能看出来是另外开发的另一套系统。这 2 套系统仅仅是将用户个人认证功能合在一起。并没有实现图片从 “快拍成都” 导入到 “论坛相册” 的功能。所以说，只能自己想办法实现了。要么全部手工弄一遍，要么写程序来做。 简单尝试了一下手工 copy，发现完全不可行，主要是图片介绍的文字是用 css 来排版到一起的，如果单纯复制文字出来，文字的顺序会乱掉。所以只能编程搞了。 我们需要用编程实现的技术步骤很简单： 模拟登陆到快拍成都。 从个人页面中点击 “我的作品”，查看自己的作品列表。 将自己的作品列表中的每一个作品中，包括的所有图片及相对应的介绍文字都下载下来。 模拟登陆到 “ 拍客论坛 “中。 对于每一个作品，在论坛的相册中建立一个对应的相册，然后将对应的图片上传上去，并且配上对应的文字。 技术方案其实我最熟的语言是 Java，但是如果用 Java 来做这件事情的话，我需要： 了解登陆的 Form，模拟浏览器进行登陆过程，然后保存登陆成功后的 Cookie. 模拟各种网页请求，将对应的页面内容抓取过来。 解析 html 内容，用正则表达式匹配到图片的 url 和介绍文字的内容。然后把这些都保存下来。 了解拍客论坛这个 bbs 的相应 Form 的内容，模拟上传图片和介绍。 这些步骤比较麻烦，而且有些做得好的网站，为了防止模拟登陆，通常在登陆前会执行一段混淆的 javascript，把 Form 中的用户名和密码进行进一步的加工再 POST 到服务器上。考虑到这个网站是改的开源的 bbs，可能会有相应的功能。那这样的话我还需要看 js 的代码，了解它又做了哪些事，把对应的逻辑用 Java 实现了。 每种语言都有它擅长的地方，对于网页来说，最方便处理的当然是 Javascript 了。如果用 Javascript，上面的那些麻烦的步骤都可以省略掉了。于是最后，我写了 2 段 Javascript 来处理这个工作。 第一段 Javascript，取出相应的图片 url 和介绍文字，生成第二个 Javascript 代码 var ps = $(&#x27;.lazyload&#x27;);var ts = $(&#x27;h5&#x27;);for (var i = 0; i &lt; ps.length; ++i) &#123; console.log($(ps[i]).attr(&#x27;original&#x27;)); &#125;console.log($($(&#x27;h2&#x27;)[0]).text());console.log(&#x27;&#x27;);for (var i = 0; i &lt; ps.length; ++i) &#123; console.log(&#x27;document.getElementsByTagName(&quot;textarea&quot;)[&#x27; + i + &#x27;].value=&quot;\\\\&#x27;); console.log(&quot; 图片属性：&quot; + $(ts[i*2]).find(&#x27;p&#x27;).text() + &#x27;\\\\&#x27;); console.log(&quot; 图片描述：&quot; + $(ts[i*2+1]).find(&#x27;p&#x27;).text() + &#x27;&quot;;&#x27;);&#125; 第二段 Javascript 由第一段 Js 生成，用于在论坛相册中将对应图片的介绍文字填上。 有了上面的那段 JS，我导照片的步骤如下： 打开 “快拍成都” 的页面，找到需要导出的照片专题。 执行我上面提到的那段 js，它会将需要下载的图片列出来，并且生成另一段 js. 手工下载上面列出来的图片到本地。 在论坛的个人相册中，把这些图片选择上传上去，然后执行生成的另一段 js，图片介绍就会自动填上了。 本来上传图片这一步也应该自动完成的，但是我无法解决浏览器对于 js 的限制：浏览器不允许 js 帮用户选择本地文件。所以这一步只能用手动来完成。 导图片的工作最终在 js 脚本的协助下，花了 1 个半小时完成了。不过心里还是有点不爽，听 zyc 说可以用 nodejs 和 jsdom 来在命令行中模拟浏览器相关的功能，所以打算试试把这个工作用 nodejs 和 jsdom 来完成。正在研究中，完成后再写一篇总结的博客。","categories":[],"tags":[]},{"title":"我们必须自学","slug":"we-must-self-learning","date":"2012-01-20T15:53:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/01/20/we-must-self-learning/","permalink":"https://blog.devtang.com/2012/01/20/we-must-self-learning/","excerpt":"前两天看到一个文章，题名为 《所有的程序员都是自学成才》。当时没有什么特别的想法，只是觉得自己也确实是基本上靠自学来掌握新的知识的。但是今天在公车上没事好好想了一想，想明白了，原来对于程序员来说，只能自学才能成才。","text":"前两天看到一个文章，题名为 《所有的程序员都是自学成才》。当时没有什么特别的想法，只是觉得自己也确实是基本上靠自学来掌握新的知识的。但是今天在公车上没事好好想了一想，想明白了，原来对于程序员来说，只能自学才能成才。 这个道理似乎有点奇怪，因为我们从小都是由老师教授新知识的。我自己也实验过，掌握同样的高中课本上的知识，自己自学的速度通常比老师讲授的速度要慢一倍的时间。即一个知识点，如果你自己要看 2 小时的书才能理解的话，有好的老师给你讲解的话，只需要一个小时就够了。所以，我一直希望在学习各种东西的时候都能去听一些课程，因为我认为这样节省了我学习的时间。 但是这个道理在程序员这一行行不通，为什么这么说呢？原因有 2 点： 计算机编程相关的知识更新速度很快。同时，国内的 IT 类资料的翻译质量相当差，原创的优秀书籍也很少。所以，我们通常需要靠阅读英文才能掌握最新的资料。 计算机编程知识需要较多的专业知识积累和实践。 如果一个培训机构有一个老师，他强到能够通过自己做一些项目来积累很多专业知识和实践，并且不断地从国外资料上学习最新的技术。那么这个人在企业里面会比在国内的培训机构更有施展自己能力的空间。国内的培训机构因为受众面的原因，基本上还是培养那种没有自学能力，只能做低级技术活的代码民工，所以对老师的技术要求不会那么高，自然也不会给出很诱人的薪水。但是企业就不一样了，企业需要不停地利用新技术来增强自己的产品竞争力，所以对于 IT 企业来说，产品的竞争就是人才的竞争，所以给优秀的人能够开出很高的薪水。 所以，我们不能期望从 IT 类培训机构中学习到最新的技术，一切只能通过我们自学。当然，自学之后在同行之间相互交流，对于我们的技术成长也是很有用的。 所以，各位同行，别想有人能够教你，一切还是靠自己吧。","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[]},{"title":"2011年个人总结","slug":"2011-summary","date":"2012-01-01T10:47:00.000Z","updated":"2024-01-06T14:52:37.911Z","comments":true,"path":"2012/01/01/2011-summary/","permalink":"https://blog.devtang.com/2012/01/01/2011-summary/","excerpt":"2011 年的过去了，总结一下今年的成长和收获。 流水账2011 年是我完整工作的一年。不过这一年的工作也变动频繁。 首先是从 1 月份专门搞 uvs，把 uvs 升级成 ouvs。升级后增加了对于时间段搜索的支持。另一方面，周末在家做的 topcoder component 终于拿到了一次第一。这是一个做 IBM Symphony 插件的项目，因为之前在 IBM 实习一直做相关的东西，所以能够很快的做出来，那个东西 tricky 的东西很多，所以基本上没有人做。不过除我之外还有一个会做的，竞争就只是我和他之间了，不过最终我比他得分稍高一点，拿到了 800$ 的第一名奖金，另外 digital run 的排名还多拿了 100 多 $。一月份的时候把这个钱通过 wirelesstransfer 转到了我的工商银行账号，然后马上换成了人民币。第一次尝到拿美元，还是很开心的。","text":"2011 年的过去了，总结一下今年的成长和收获。 流水账2011 年是我完整工作的一年。不过这一年的工作也变动频繁。 首先是从 1 月份专门搞 uvs，把 uvs 升级成 ouvs。升级后增加了对于时间段搜索的支持。另一方面，周末在家做的 topcoder component 终于拿到了一次第一。这是一个做 IBM Symphony 插件的项目，因为之前在 IBM 实习一直做相关的东西，所以能够很快的做出来，那个东西 tricky 的东西很多，所以基本上没有人做。不过除我之外还有一个会做的，竞争就只是我和他之间了，不过最终我比他得分稍高一点，拿到了 800$ 的第一名奖金，另外 digital run 的排名还多拿了 100 多 $。一月份的时候把这个钱通过 wirelesstransfer 转到了我的工商银行账号，然后马上换成了人民币。第一次尝到拿美元，还是很开心的。 Topcoder 比赛结果，来源 3 月份，oxygen 离职去了知乎。其实我也明白微博的竞争似乎已经结束，某浪和某迅基本已经占位成功。在产品上没有新意，宣传上没有增加投入的情况下，要超过他们似乎是不可能的事。并且我也渐渐意识到微博本身的价值有些被过高估计，新浪的股票一路从 50 多涨到 120 多，现在又回归 50 多似乎说明了这一点。也是从 3 月份开始，我开始带实习生 tianye 了。这是我第一次带实习生，感觉自己很多细节上还是没有处理好，比起郭老大来说，有很多考虑不周的地方。不过至少我是尽力想做好这个 mentor 的。 也是从 3 月份开始，我开始跟着 perfectworks 做前端开发了。前端开发在春节就翻过一些书，有一些基本概念了。perfectworks 在前端开发这块很牛，也很希望跟着他多学习一些东西。因为前端的 tricky 很多，如果没有牛人带的话，成长会很慢。后来果然在他的指导下，进步很快，没多久就开始写前端代码了，后来因为转组，没有再做前端，但 js 相关的开发经验在后来给我带来了挺多优势，比如做笔记的一些功能的时候，就是内嵌 web 浏览器来完成的，这里面就涉及挺多的 js 开发。由于有前端开发的经验，这部分的开发工作在我转到做笔记开发之后都派上了用场。 5 月份做了一次组内的 talk，讲 java gc。这也是我们开始尝试把有道的技术分享的文化带到微博组。开始的分享都是大家先自己研究，然后做报告。做 java gc 的分享也让我好好学习了一下 java 的内存回收技术。后来面试的时候发现，真正研究过这块的人还真是少之又少。从 5 月份开始，我们也尝试进行用 scrum 的方式进行项目开发。每 2 周一个 sprint。后来回有道发现，在实施 scrum 开发实践方面，我们是贯彻的最彻底的。我们坚持了每天的站会，出牌方式的评估时间，严格按照 scrum 的要求来做项目计划和功能分解。每天会详细标明每个功能点的开发进度以及遇到的问题。后来了解到其他组的实践，都比我们山寨得多，比如有些组开发时间是由产品经理定的，有些组没有站会，有些组根本没有详细做功能分解，更别说每天更新 status 了。这一点也让我认识到微博团队是一个很优秀的团队。 6 月份，我经历了很大的变动 , 最终选择回到有道，在选组上，river 给了我们很多帮助，各组的 leader 的热情也让我们受宠若惊。一开始我是坚定想选择 infra 组，做搜索的底层开发的，因为这样我的工作也算是有延续的。但是后来了解到 ouvs 开发已经基本完毕，只剩下一些 bug fix 或者小修小改的事情，我就感觉没那么有热情了。加上 jwh 说云存储这边需要 iOS 开发的人。正好当时 xc 把他的 mac bookpro 转让给了我，让我也有机会去了解 iPhone 开发。其实从去年就觉得移动开发这块会是一个趋势，可能造就很多伟大的公司和产品。当时就买了 android 开发相关的书籍在看。所以自己觉得这正好是一个机会，可以转到移动开发这个领域。在决定之前，自己还是犹豫了好久，因为在后端做了一年多了，多少也积累了不少经验。转到移动开发，又是一个全新的开始，一切又需要重头做起。不过最终还是觉得应该乘年轻做自己喜欢做的事情，加上自己看好这个领域，所以就决定去云存储组做有道笔记的开发了。 7 月份初，微博的工作交接完毕，我专心开始学习 iOS 开发。其实公司给我的时间不多，差不多只有 2 周的时间学习，中间还要处理一些交接的遗留问题以及 iPhone 版 JavaScript 相关的 bug。对，我差不多刚进去就开始改 js 的 bug 了。那段时间是我最辛苦的一段时间，因为组内也没有对 iOS 开发特别熟的人，我只有自己学习，而公司内部的 iOS 交流气氛又不太好，各组的 iOS 开发同事交流不多。我基本上把周末和晚上的时间都用来学习 iOS 开发了。半个月之后，基本能够上手写代码了。之后做了 2 次关于 iPhone 开发的 talk, 拉 huangdx 做了一次 facebook320 的 Talk, 给测试的同事做了一次 iPhone 模拟器使用的 talk, 另外也组织建了一个 iOS 开发的泡泡群，拉上了网站部的同事来一起交流。基本上有一个交流的环境了，不过大家交流的习惯还不怎么强，所以群里面很多时候都比较冷清，这一点使我比较苦恼。 9 月初，完成了有道笔记手写和涂鸦功能的开发。中间也被拉去开发了有道词典的图片广告功能。9 月底开始思考如何做 iPad 版笔记。 10 月份开始做 iPad 版的开发，最终于 12 月初提交上线。上线后排名一路上升，最高达到了效率类第一名的位置。现在一直稳定在效率类前 5 名。 2011-12-20 的 app store 截图： 10 月份做了一个个人项目，图书馆借书系统的改造。把借书改成分布式的，每个人都要承担图书的保管任务，这样就不会丢书了。虽然只用了 3 天时间，但是能在工作时间做个人项目感觉还是挺爽的。 12 月份开始带第二个实习生 maojj 了。希望能把他带好。 主要工作总结起来，自己这一年主要的工作是： 1 月-3 月 微博搜索功能开发和维护 4 月-6 月 微博前端开发 7 月-12 月 有道笔记 iPhone,iPad 版开发 技术成长今年是自己技术语言扩张最快的一年，学习并掌握了： JavaScript、Objective-C 2 种新的开发语言。 对于 shell 脚本的掌握也有提升。 git 版本管理。基本可以用 git 来做代码管理了。 正在看 python 语言，打算进一步提高自己的脚本能力。 值得一提的是，由于 iPhone 开发的中文资料太少，今年接触和阅读了大量英文书和视频。在听完 stanford 的 iPhone 开发课程和苹果的 WWDC2011 视频后，英语的听力水平提高不少。iPhone 开发的各种问题，也基本只能在 stackoverflow.com 上找到解答，所以现在已经很习惯直接阅读英文资料了。 读书这一年，我也看了很多书，包括： 后端开发的各种书：《java 程序员职场全攻略》等 前端开发的各种书：《ppk 谈 JavaScript》, 《Professional Javascript for Web Developers》等 iPhone 开发的各种书：《iPhone3 开发基础教程》《iPhone 开发秘籍》、《iOS4 in Action》等 工作效率类的书：《Git 权威指南》，《鸟哥的 linux 私房菜》，《vim book》，《番茄工作法》等 传记类：《乔布斯传》，《编程人生》，《黑客与画家》，《软件随想录》 变化这一年感觉自己比较大的变化： 在买了 mac book 后，由于 mac book 下的游戏比较少，所以更加注重学习脚本和工具了。脚本能力有不少长进。 在做完图书馆个人项目后，更加强调执行力了。推动了公司内部 iOS 开发的交流。也更加注意通过写博客或 wiki 来总结知识。 感觉身体由于久坐更差了，脖子和肩膀，还有手腕都常常有疼痛现象。所以开始注意加强锻炼了。除了早上打五禽戏，晚上周三会去游泳。 个人 Milestone 2011-04-07 开始维护自己的原创博客 , 原本在 网易博客 上 ,2011-11-05 购买了个人域名 devtang.com, 12 月份将博客移动到 github 下，地址是: http://blog.devtang.com","categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"}],"tags":[{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"}]},{"title":"去掉Xcode源码末尾的空格","slug":"remove-tail-blankspace-in-xcode","date":"2011-12-10T09:08:00.000Z","updated":"2024-01-06T14:52:37.910Z","comments":true,"path":"2011/12/10/remove-tail-blankspace-in-xcode/","permalink":"https://blog.devtang.com/2011/12/10/remove-tail-blankspace-in-xcode/","excerpt":"","text":"在用 Xcode 开发的时候，很容易就在行末增加一些空格了。这些空格在上传到 review board 上后 , 就会被特别的颜色显示出来。因为一种好的编程风格是说 , 不应该在行末增加不必要的空格。如果是用 eclipse 写 java, 那么这种时候选中写好的代码，按 ctrl+shift+F 即可调整源码的风格 , 将尾部的空格去掉。可惜在 Xcode 中并没有提供相应的功能。 不过我们可以用命令行来达到这一效果 , 在工程目录下输入: find . -name &quot;*.[hm]&quot; | xargs sed -Ee &#x27;s/ +$//g&#x27; -i &quot;&quot; 这样 , 就可以把源码中行末多出来的空格去掉了 , 是不是很爽 ? 可以把这句加到执行 post-review 的脚本上，这样就可以做到自动去空格了。 顺便说一下，我打算把这些小脚本工具总结出来，放到 github 上，地址是 https://github.com/tangqiaoboy/xcode_tool，感兴趣的同学可以把它 clone 下来。 祝玩得开心～ 2013 年 6 月 22 日更新上文写于 2011 年末，在 2012 年在 WWDC 大会上，苹果推出了 Xcode4。从 Xcode4 开始，Xcode 会自动去掉源码末尾的空格。所以上面提到的脚本基本没用了。不过对于工程中的 html 或 js 文件，Xcode 的去末尾空格功能并没有打开，所以在某些时候才能有一些小用处。 另外，每次记得敲命令来去掉空格是一件很恶心的事情，最好是由程序自动完成。考虑到现在 git 已经很普及了，在这里介绍另一种在 git 仓库中创建钩子 (hook) 的方法来去掉所有提交文件的末尾空格，具体做法如下： 在工程目录的 .git/hooks/ 目录下，创建一个名为 pre-commit 的文件，输入如下内容 #!/bin/shif git-rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1 ; then against=HEADelse # Initial commit: diff against an empty tree object against=4b825dc642cb6eb9a060e54bf8d69288fbee4904fi# Find files with trailing whitespacefor FILE in `exec git diff-index --check --cached $against -- | sed &#x27;/^[+-]/d&#x27; | sed -E &#x27;s/:[0-9]+:.*//&#x27; | uniq` ; do # Fix them! sed -i &#x27;&#x27; -E &#x27;s/[[:space:]]*$//&#x27; &quot;$FILE&quot; git add &quot;$FILE&quot;done 然后用 chmod +x pre-commit 给该文件加上执行权限。这样，每次在 git 提交文件的时候，该脚本就会被自动执行并且将提交文件末尾的空格去掉。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"让UILabel的文字顶部对齐","slug":"set-uilabel-text-align-top","date":"2011-11-20T14:43:00.000Z","updated":"2024-01-06T14:52:37.910Z","comments":true,"path":"2011/11/20/set-uilabel-text-align-top/","permalink":"https://blog.devtang.com/2011/11/20/set-uilabel-text-align-top/","excerpt":"","text":"默认UILabel是垂直居中对齐的，如果你的UILabel高度有多行，当内容少的时候，会自动垂直居中。 如下图所示（图片来自stackoverflow)： 比较郁闷的是，UILabel并不提供设置其垂直对齐方式的选项。所以如果你想让你的文字顶部对齐，那么就需要自己想办法了。 stackoverflow.com 上提供了几种方法来达到顶部对齐的效果。 方法一在显示文字时，首先计算显示当前的文字需要多宽和多高，然后将对应的UILabel的大小改变成对应的宽度和高度。此方法的相示意图如下： 在显示文字时，首先计算显示当前的文字需要多宽和多高，然后将对应的UILabel的大小改变成对应的宽度和高度。此方法的相示意图如下： CGSize maximumSize = CGSizeMake(300, 9999);NSString *dateString = @&quot;The date today is January 1st, 1999&quot;;UIFont *dateFont = [UIFont fontWithName:@&quot;Helvetica&quot; size:14];CGSize dateStringSize = [dateString sizeWithFont:dateFont constrainedToSize:maximumSize lineBreakMode:self.dateLabel.lineBreakMode];CGRect dateFrame = CGRectMake(10, 10, 300, dateStringSize.height);self.dateLabel.frame = dateFrame; 方法二此方法更加简单粗暴，但是很有效。其方法是在文本后面加多一些\\n。需要注意的是，\\n后还得加至少一个空格，否则多余的\\n会被UILabel忽略。从这一点上看，UILabel似乎又过于“聪明”了。 该方法的示意图如下： 该方法的代码如下： for(int i=0; i&lt;newLinesToPad; i++) self.text = [self.text stringByAppendingString:@&quot;\\n &quot;]; 方法三最正统的方法，利用objective-c的category特性，修改UILabel的绘制代码。示例代码如下： // -- file: UILabel+VerticalAlign.h#pragma mark VerticalAlign@interface UILabel (VerticalAlign)- (void)alignTop;- (void)alignBottom;@end// -- file: UILabel+VerticalAlign.m@implementation UILabel (VerticalAlign)- (void)alignTop &#123; CGSize fontSize = [self.text sizeWithFont:self.font]; double finalHeight = fontSize.height * self.numberOfLines; double finalWidth = self.frame.size.width; //expected width of label CGSize theStringSize = [self.text sizeWithFont:self.font constrainedToSize:CGSizeMake(finalWidth, finalHeight) lineBreakMode:self.lineBreakMode]; int newLinesToPad = (finalHeight - theStringSize.height) / fontSize.height; for(int i=0; i&lt;newLinesToPad; i++) self.text = [self.text stringByAppendingString:@&quot;\\n &quot;];&#125;- (void)alignBottom &#123; CGSize fontSize = [self.text sizeWithFont:self.font]; double finalHeight = fontSize.height * self.numberOfLines; double finalWidth = self.frame.size.width; //expected width of label CGSize theStringSize = [self.text sizeWithFont:self.font constrainedToSize:CGSizeMake(finalWidth, finalHeight) lineBreakMode:self.lineBreakMode]; int newLinesToPad = (finalHeight - theStringSize.height) / fontSize.height; for(int i=0; i&lt;newLinesToPad; i++) self.text = [NSString stringWithFormat:@&quot; \\n%@&quot;,self.text];&#125;@end 我选了简单暴力的方法二，你呢？ 参考资料http://stackoverflow.com/questions/1054558/how-do-i-vertically-align-text-within-a-uilabel https://discussions.apple.com/thread/1759957?threadID=1759957","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]},{"title":"不要在init和dealloc函数中使用accessor","slug":"do-not-use-accessor-in-init-and-dealloc-method","date":"2011-08-10T09:32:00.000Z","updated":"2024-01-06T14:52:37.910Z","comments":true,"path":"2011/08/10/do-not-use-accessor-in-init-and-dealloc-method/","permalink":"https://blog.devtang.com/2011/08/10/do-not-use-accessor-in-init-and-dealloc-method/","excerpt":"","text":"Objective-C 2.0 增加了 dot syntax，用于简单地调用成员变量的 accessor。相当于 java 的 getter 和 setter。因为正常情况下，写一个 accessor 对于初学者来说，还是挺容易犯错的。比如有一个 NSString * 的成员变量叫 name。一个错误的写法是： -(void)setName:(NSString *)newName &#123; name = newName;&#125; Java 同学肯定想不通上面的代码有什么错吧？原因是 Objective-C 需要自己负责内存的释放。所以需要在改变 reference 之前，将原对象 release，对新的对象，也需要 retain 一下，代码就改成这样： -(void)setName:(NSString *)newName &#123; [name release]; name = [newName retain];&#125; 初学者可能以为这样就对了，其实还是有错，如果 newName 和 name 的指向的是同一个对象，并且这个对象 retain count 只有 1 的话。那么 name release 之后，这个对象就被回收掉了。所以应该改成： -(void)setName:(NSString *)newName &#123; if (name != newName) &#123; [name release]; name = [newName retain]; &#125;&#125; 这样才算是一个正确的 set 函数，Java 同学肯定被吓到了，虽然知道这么写，但这比 Java 麻烦多了。于是，Objective-C 允许程序员使用 @property + @synthesize 关键字来自动生成这些代码（注：Xcode 现在会默认自动添加 @synthesize 关键字）。于是 Objective-C 的程序员幸福了。大部分时候根本就不用写 getter 和 setter。 但是需要小心，Objective-C 的 accessor 不能在 init 和 dealloc 函数中使用！如果你在 dealloc 中这么写，就有问题： -(void)dealloc &#123; self.name = nil; [super dealloc]&#125; 苹果在它的开发者文档库中有一个专门讲 cocoa 的内存管理的文章：http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/MemoryMgmt.pdf 文章的第 16 页有一节题目是：Don’t Use Accessor Methods in Initializer Methods and dealloc 文章说：你唯一不应该用 Accessor 的地方是 init 函数和 delloc 函数。在 init 函数中，对于一个 _count 成员变量应该像下面这样赋值： -(id)init &#123; self = [super init]; if (self) &#123; _count = [[NSNumber alloc] initWithInteger:0]; &#125; return self;&#125; 对于一个带参数的 init 函数，你应该实现成下面这样： - (id)initWithCount:(NSNumber *)startingCount &#123; self = [super init]; if (self) &#123; _count = [startingCount copy]; &#125; return self;&#125; 对于在 dealloc 中，对应的写法应该是调 release: - (void)dealloc &#123; [_count release]; [super dealloc];&#125; 但是比较郁闷的是，文章最后没有说为什么不能！去 stackoverflow 上搜了一下，比较不靠谱的说法是这样少一次函数调用，更快。比较靠谱的说法是：在 init 和 dealloc 中，对象的存在与否还不确定，所以给对象发消息可能不会成功。 顺便说一下 , 当发现这个文章的时候，我们的代码中已经有了很多这样错误用法。虽然程序没有出现严重的内存问题，但是为了保险，还是打算一行一行改掉，后来我想，这个能不能用 vim 搞定呢？于是我进 vim，用 qa 启动宏录制，然后输入 :%s/self./[/g 再输入：%s/= nil/release]/g 再输入 q, 这样就可以用 @a 来启动刚刚录制的宏来做替换了。相当方便。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"}],"tags":[]}],"categories":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/categories/summary/"},{"name":"shell","slug":"shell","permalink":"https://blog.devtang.com/categories/shell/"},{"name":"iOS","slug":"iOS","permalink":"https://blog.devtang.com/categories/iOS/"},{"name":"mac","slug":"mac","permalink":"https://blog.devtang.com/categories/mac/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://blog.devtang.com/tags/summary/"},{"name":"cspj","slug":"cspj","permalink":"https://blog.devtang.com/tags/cspj/"},{"name":"anniversary","slug":"anniversary","permalink":"https://blog.devtang.com/tags/anniversary/"},{"name":"books","slug":"books","permalink":"https://blog.devtang.com/tags/books/"},{"name":"marketing","slug":"marketing","permalink":"https://blog.devtang.com/tags/marketing/"},{"name":"cooking","slug":"cooking","permalink":"https://blog.devtang.com/tags/cooking/"},{"name":"supply-chain","slug":"supply-chain","permalink":"https://blog.devtang.com/tags/supply-chain/"},{"name":"startup","slug":"startup","permalink":"https://blog.devtang.com/tags/startup/"},{"name":"PM","slug":"PM","permalink":"https://blog.devtang.com/tags/PM/"},{"name":"Git","slug":"Git","permalink":"https://blog.devtang.com/tags/Git/"},{"name":"writing","slug":"writing","permalink":"https://blog.devtang.com/tags/writing/"},{"name":"Interview","slug":"Interview","permalink":"https://blog.devtang.com/tags/Interview/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.devtang.com/tags/Swift/"},{"name":"投稿","slug":"投稿","permalink":"https://blog.devtang.com/tags/%E6%8A%95%E7%A8%BF/"},{"name":"blog","slug":"blog","permalink":"https://blog.devtang.com/tags/blog/"}]}